diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/backprop/Makefile gpu-rodinia_new/cuda/backprop/Makefile
--- gpu-rodinia/cuda/backprop/Makefile	2015-12-11 08:46:15.000000000 -0700
+++ gpu-rodinia_new/cuda/backprop/Makefile	2023-06-06 14:22:22.668705617 -0600
@@ -20,6 +20,7 @@
 	NVCC_FLAGS += -deviceemu
 endif
 
+NVCC_FLAGS += $(CUDA_FLAG)
 
 backprop: backprop.o facetrain.o imagenet.o backprop_cuda.o 
 	$(CC) $(CC_FLAGS) backprop.o facetrain.o imagenet.o backprop_cuda.o -o backprop -L$(CUDA_LIB_DIR) -lcuda -lcudart -lm
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/backprop/run gpu-rodinia_new/cuda/backprop/run
--- gpu-rodinia/cuda/backprop/run	2015-12-11 08:46:15.000000000 -0700
+++ gpu-rodinia_new/cuda/backprop/run	2023-06-06 14:22:22.672705541 -0600
@@ -1 +1,2 @@
-./backprop 65536
+./backprop 65536 
+#./backprop 2097152
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/bfs/bfs.cu gpu-rodinia_new/cuda/bfs/bfs.cu
--- gpu-rodinia/cuda/bfs/bfs.cu	2015-12-11 08:46:07.000000000 -0700
+++ gpu-rodinia_new/cuda/bfs/bfs.cu	2023-06-06 14:22:22.676705464 -0600
@@ -1,230 +1,301 @@
-/***********************************************************************************
-  Implementing Breadth first search on CUDA using algorithm given in HiPC'07
-  paper "Accelerating Large Graph Algorithms on the GPU using CUDA"
-
-  Copyright (c) 2008 International Institute of Information Technology - Hyderabad. 
-  All rights reserved.
-
-  Permission to use, copy, modify and distribute this software and its documentation for 
-  educational purpose is hereby granted without fee, provided that the above copyright 
-  notice and this permission notice appear in all copies of this software and that you do 
-  not sell the software.
-
-  THE SOFTWARE IS PROVIDED "AS IS" AND WITHOUT WARRANTY OF ANY KIND,EXPRESS, IMPLIED OR 
-  OTHERWISE.
-
-  Created by Pawan Harish.
- ************************************************************************************/
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#include <cuda.h>
-
-#define MAX_THREADS_PER_BLOCK 512
-
-int no_of_nodes;
-int edge_list_size;
-FILE *fp;
-
-//Structure to hold a node information
-struct Node
-{
-	int starting;
-	int no_of_edges;
-};
-
-#include "kernel.cu"
-#include "kernel2.cu"
-
-void BFSGraph(int argc, char** argv);
-
-////////////////////////////////////////////////////////////////////////////////
-// Main Program
-////////////////////////////////////////////////////////////////////////////////
-int main( int argc, char** argv) 
-{
-	no_of_nodes=0;
-	edge_list_size=0;
-	BFSGraph( argc, argv);
-}
-
-void Usage(int argc, char**argv){
-
-fprintf(stderr,"Usage: %s <input_file>\n", argv[0]);
-
-}
-////////////////////////////////////////////////////////////////////////////////
-//Apply BFS on a Graph using CUDA
-////////////////////////////////////////////////////////////////////////////////
-void BFSGraph( int argc, char** argv) 
-{
-
-    char *input_f;
-	if(argc!=2){
-	Usage(argc, argv);
-	exit(0);
-	}
-	
-	input_f = argv[1];
-	printf("Reading File\n");
-	//Read in Graph from a file
-	fp = fopen(input_f,"r");
-	if(!fp)
-	{
-		printf("Error Reading graph file\n");
-		return;
-	}
-
-	int source = 0;
-
-	fscanf(fp,"%d",&no_of_nodes);
-
-	int num_of_blocks = 1;
-	int num_of_threads_per_block = no_of_nodes;
-
-	//Make execution Parameters according to the number of nodes
-	//Distribute threads across multiple Blocks if necessary
-	if(no_of_nodes>MAX_THREADS_PER_BLOCK)
-	{
-		num_of_blocks = (int)ceil(no_of_nodes/(double)MAX_THREADS_PER_BLOCK); 
-		num_of_threads_per_block = MAX_THREADS_PER_BLOCK; 
-	}
-
-	// allocate host memory
-	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
-	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
-	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
-	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
-
-	int start, edgeno;   
-	// initalize the memory
-	for( unsigned int i = 0; i < no_of_nodes; i++) 
-	{
-		fscanf(fp,"%d %d",&start,&edgeno);
-		h_graph_nodes[i].starting = start;
-		h_graph_nodes[i].no_of_edges = edgeno;
-		h_graph_mask[i]=false;
-		h_updating_graph_mask[i]=false;
-		h_graph_visited[i]=false;
-	}
-
-	//read the source node from the file
-	fscanf(fp,"%d",&source);
-	source=0;
-
-	//set the source node as true in the mask
-	h_graph_mask[source]=true;
-	h_graph_visited[source]=true;
-
-	fscanf(fp,"%d",&edge_list_size);
-
-	int id,cost;
-	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
-	for(int i=0; i < edge_list_size ; i++)
-	{
-		fscanf(fp,"%d",&id);
-		fscanf(fp,"%d",&cost);
-		h_graph_edges[i] = id;
-	}
-
-	if(fp)
-		fclose(fp);    
-
-	printf("Read File\n");
-
-	//Copy the Node list to device memory
-	Node* d_graph_nodes;
-	cudaMalloc( (void**) &d_graph_nodes, sizeof(Node)*no_of_nodes) ;
-	cudaMemcpy( d_graph_nodes, h_graph_nodes, sizeof(Node)*no_of_nodes, cudaMemcpyHostToDevice) ;
-
-	//Copy the Edge List to device Memory
-	int* d_graph_edges;
-	cudaMalloc( (void**) &d_graph_edges, sizeof(int)*edge_list_size) ;
-	cudaMemcpy( d_graph_edges, h_graph_edges, sizeof(int)*edge_list_size, cudaMemcpyHostToDevice) ;
-
-	//Copy the Mask to device memory
-	bool* d_graph_mask;
-	cudaMalloc( (void**) &d_graph_mask, sizeof(bool)*no_of_nodes) ;
-	cudaMemcpy( d_graph_mask, h_graph_mask, sizeof(bool)*no_of_nodes, cudaMemcpyHostToDevice) ;
-
-	bool* d_updating_graph_mask;
-	cudaMalloc( (void**) &d_updating_graph_mask, sizeof(bool)*no_of_nodes) ;
-	cudaMemcpy( d_updating_graph_mask, h_updating_graph_mask, sizeof(bool)*no_of_nodes, cudaMemcpyHostToDevice) ;
-
-	//Copy the Visited nodes array to device memory
-	bool* d_graph_visited;
-	cudaMalloc( (void**) &d_graph_visited, sizeof(bool)*no_of_nodes) ;
-	cudaMemcpy( d_graph_visited, h_graph_visited, sizeof(bool)*no_of_nodes, cudaMemcpyHostToDevice) ;
-
-	// allocate mem for the result on host side
-	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
-	for(int i=0;i<no_of_nodes;i++)
-		h_cost[i]=-1;
-	h_cost[source]=0;
-	
-	// allocate device memory for result
-	int* d_cost;
-	cudaMalloc( (void**) &d_cost, sizeof(int)*no_of_nodes);
-	cudaMemcpy( d_cost, h_cost, sizeof(int)*no_of_nodes, cudaMemcpyHostToDevice) ;
-
-	//make a bool to check if the execution is over
-	bool *d_over;
-	cudaMalloc( (void**) &d_over, sizeof(bool));
-
-	printf("Copied Everything to GPU memory\n");
-
-	// setup execution parameters
-	dim3  grid( num_of_blocks, 1, 1);
-	dim3  threads( num_of_threads_per_block, 1, 1);
-
-	int k=0;
-	printf("Start traversing the tree\n");
-	bool stop;
-	//Call the Kernel untill all the elements of Frontier are not false
-	do
-	{
-		//if no thread changes this value then the loop stops
-		stop=false;
-		cudaMemcpy( d_over, &stop, sizeof(bool), cudaMemcpyHostToDevice) ;
-		Kernel<<< grid, threads, 0 >>>( d_graph_nodes, d_graph_edges, d_graph_mask, d_updating_graph_mask, d_graph_visited, d_cost, no_of_nodes);
-		// check if kernel execution generated and error
-		
-
-		Kernel2<<< grid, threads, 0 >>>( d_graph_mask, d_updating_graph_mask, d_graph_visited, d_over, no_of_nodes);
-		// check if kernel execution generated and error
-		
-
-		cudaMemcpy( &stop, d_over, sizeof(bool), cudaMemcpyDeviceToHost) ;
-		k++;
-	}
-	while(stop);
-
-
-	printf("Kernel Executed %d times\n",k);
-
-	// copy result from device to host
-	cudaMemcpy( h_cost, d_cost, sizeof(int)*no_of_nodes, cudaMemcpyDeviceToHost) ;
-
-	//Store the result into a file
-	FILE *fpo = fopen("result.txt","w");
-	for(int i=0;i<no_of_nodes;i++)
-		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
-	fclose(fpo);
-	printf("Result stored in result.txt\n");
-
-
-	// cleanup memory
-	free( h_graph_nodes);
-	free( h_graph_edges);
-	free( h_graph_mask);
-	free( h_updating_graph_mask);
-	free( h_graph_visited);
-	free( h_cost);
-	cudaFree(d_graph_nodes);
-	cudaFree(d_graph_edges);
-	cudaFree(d_graph_mask);
-	cudaFree(d_updating_graph_mask);
-	cudaFree(d_graph_visited);
-	cudaFree(d_cost);
-}
+/***********************************************************************************
+  Implementing Breadth first search on CUDA using algorithm given in HiPC'07
+  paper "Accelerating Large Graph Algorithms on the GPU using CUDA"
+
+  Copyright (c) 2008 International Institute of Information Technology - Hyderabad. 
+  All rights reserved.
+
+  Permission to use, copy, modify and distribute this software and its documentation for 
+  educational purpose is hereby granted without fee, provided that the above copyright 
+  notice and this permission notice appear in all copies of this software and that you do 
+  not sell the software.
+
+  THE SOFTWARE IS PROVIDED "AS IS" AND WITHOUT WARRANTY OF ANY KIND,EXPRESS, IMPLIED OR 
+  OTHERWISE.
+
+  Created by Pawan Harish.
+ ************************************************************************************/
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <cuda.h>
+
+#ifdef TIMING
+#include "timing.h"
+#endif
+
+#define MAX_THREADS_PER_BLOCK 512
+
+int no_of_nodes;
+int edge_list_size;
+FILE *fp;
+
+#ifdef TIMING
+struct timeval tv;
+struct timeval tv_total_start, tv_total_end;
+struct timeval tv_h2d_start, tv_h2d_end;
+struct timeval tv_d2h_start, tv_d2h_end;
+struct timeval tv_kernel_start, tv_kernel_end;
+struct timeval tv_mem_alloc_start, tv_mem_alloc_end;
+struct timeval tv_close_start, tv_close_end;
+float init_time = 0, mem_alloc_time = 0, h2d_time = 0, kernel_time = 0,
+      d2h_time = 0, close_time = 0, total_time = 0;
+#endif
+
+//Structure to hold a node information
+struct Node
+{
+	int starting;
+	int no_of_edges;
+};
+
+#include "kernel.cu"
+#include "kernel2.cu"
+
+void BFSGraph(int argc, char** argv);
+
+////////////////////////////////////////////////////////////////////////////////
+// Main Program
+////////////////////////////////////////////////////////////////////////////////
+int main( int argc, char** argv) 
+{
+	no_of_nodes=0;
+	edge_list_size=0;
+	BFSGraph( argc, argv);
+}
+
+void Usage(int argc, char**argv){
+
+fprintf(stderr,"Usage: %s <input_file>\n", argv[0]);
+
+}
+////////////////////////////////////////////////////////////////////////////////
+//Apply BFS on a Graph using CUDA
+////////////////////////////////////////////////////////////////////////////////
+void BFSGraph( int argc, char** argv) 
+{
+
+    char *input_f;
+	if(argc!=2){
+	Usage(argc, argv);
+	exit(0);
+	}
+
+	input_f = argv[1];
+	printf("Reading File\n");
+	//Read in Graph from a file
+	fp = fopen(input_f,"r");
+	if(!fp)
+	{
+		printf("Error Reading graph file\n");
+		return;
+	}
+
+	int source = 0;
+
+	fscanf(fp,"%d",&no_of_nodes);
+
+	int num_of_blocks = 1;
+	int num_of_threads_per_block = no_of_nodes;
+
+	//Make execution Parameters according to the number of nodes
+	//Distribute threads across multiple Blocks if necessary
+	if(no_of_nodes>MAX_THREADS_PER_BLOCK)
+	{
+		num_of_blocks = (int)ceil(no_of_nodes/(double)MAX_THREADS_PER_BLOCK); 
+		num_of_threads_per_block = MAX_THREADS_PER_BLOCK; 
+	}
+
+	// allocate host memory
+	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);
+	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);
+	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);
+
+	int start, edgeno;   
+	// initalize the memory
+	for( unsigned int i = 0; i < no_of_nodes; i++) 
+	{
+		fscanf(fp,"%d %d",&start,&edgeno);
+		h_graph_nodes[i].starting = start;
+		h_graph_nodes[i].no_of_edges = edgeno;
+		h_graph_mask[i]=false;
+		h_updating_graph_mask[i]=false;
+		h_graph_visited[i]=false;
+	}
+
+	//read the source node from the file
+	fscanf(fp,"%d",&source);
+	source=0;
+
+	//set the source node as true in the mask
+	h_graph_mask[source]=true;
+	h_graph_visited[source]=true;
+
+	fscanf(fp,"%d",&edge_list_size);
+
+	int id,cost;
+	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);
+	for(int i=0; i < edge_list_size ; i++)
+	{
+		fscanf(fp,"%d",&id);
+		fscanf(fp,"%d",&cost);
+		h_graph_edges[i] = id;
+	}
+
+	if(fp)
+		fclose(fp);    
+
+	printf("Read File\n");
+
+#ifdef  TIMING
+    gettimeofday(&tv_total_start, NULL);
+#endif
+	//Copy the Node list to device memory
+	Node* d_graph_nodes;
+	cudaMalloc( (void**) &d_graph_nodes, sizeof(Node)*no_of_nodes) ;
+	cudaMemcpy( d_graph_nodes, h_graph_nodes, sizeof(Node)*no_of_nodes, cudaMemcpyHostToDevice) ;
+
+	//Copy the Edge List to device Memory
+	int* d_graph_edges;
+	cudaMalloc( (void**) &d_graph_edges, sizeof(int)*edge_list_size) ;
+	cudaMemcpy( d_graph_edges, h_graph_edges, sizeof(int)*edge_list_size, cudaMemcpyHostToDevice) ;
+
+	//Copy the Mask to device memory
+	bool* d_graph_mask;
+	cudaMalloc( (void**) &d_graph_mask, sizeof(bool)*no_of_nodes) ;
+	cudaMemcpy( d_graph_mask, h_graph_mask, sizeof(bool)*no_of_nodes, cudaMemcpyHostToDevice) ;
+
+	bool* d_updating_graph_mask;
+	cudaMalloc( (void**) &d_updating_graph_mask, sizeof(bool)*no_of_nodes) ;
+	cudaMemcpy( d_updating_graph_mask, h_updating_graph_mask, sizeof(bool)*no_of_nodes, cudaMemcpyHostToDevice) ;
+
+	//Copy the Visited nodes array to device memory
+	bool* d_graph_visited;
+	cudaMalloc( (void**) &d_graph_visited, sizeof(bool)*no_of_nodes) ;
+	cudaMemcpy( d_graph_visited, h_graph_visited, sizeof(bool)*no_of_nodes, cudaMemcpyHostToDevice) ;
+
+	// allocate mem for the result on host side
+	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);
+	for(int i=0;i<no_of_nodes;i++)
+		h_cost[i]=-1;
+	h_cost[source]=0;
+	
+	// allocate device memory for result
+	int* d_cost;
+	cudaMalloc( (void**) &d_cost, sizeof(int)*no_of_nodes);
+	cudaMemcpy( d_cost, h_cost, sizeof(int)*no_of_nodes, cudaMemcpyHostToDevice) ;
+
+	//make a bool to check if the execution is over
+	bool *d_over;
+	cudaMalloc( (void**) &d_over, sizeof(bool));
+#ifdef  TIMING
+    gettimeofday(&tv_mem_alloc_end, NULL);
+    tvsub(&tv_mem_alloc_end, &tv_total_start, &tv);
+    h2d_time = tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
+	printf("Copied Everything to GPU memory\n");
+
+	// setup execution parameters
+	dim3  grid( num_of_blocks, 1, 1);
+	dim3  threads( num_of_threads_per_block, 1, 1);
+
+	int k=0;
+	printf("Start traversing the tree\n");
+	bool stop;
+	//Call the Kernel untill all the elements of Frontier are not false
+	do
+	{
+		//if no thread changes this value then the loop stops
+		stop=false;
+#ifdef  TIMING
+		gettimeofday(&tv_h2d_start, NULL);
+#endif
+		cudaMemcpy( d_over, &stop, sizeof(bool), cudaMemcpyHostToDevice) ;
+#ifdef  TIMING
+		gettimeofday(&tv_h2d_end, NULL);
+		tvsub(&tv_h2d_end, &tv_h2d_start, &tv);
+		h2d_time += tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
+		Kernel<<< grid, threads, 0 >>>( d_graph_nodes, d_graph_edges, d_graph_mask, d_updating_graph_mask, d_graph_visited, d_cost, no_of_nodes);
+		// check if kernel execution generated and error
+
+		Kernel2<<< grid, threads, 0 >>>( d_graph_mask, d_updating_graph_mask, d_graph_visited, d_over, no_of_nodes);
+		// check if kernel execution generated and error
+
+#ifdef  TIMING
+		cudaDeviceSynchronize();
+		gettimeofday(&tv_kernel_end, NULL);
+		tvsub(&tv_kernel_end, &tv_h2d_end, &tv);
+		kernel_time += tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
+		cudaMemcpy( &stop, d_over, sizeof(bool), cudaMemcpyDeviceToHost) ;
+#ifdef  TIMING
+		gettimeofday(&tv_d2h_end, NULL);
+		tvsub(&tv_d2h_end, &tv_kernel_end, &tv);
+		d2h_time += tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
+		k++;
+	}
+	while(stop);
+
+
+	printf("Kernel Executed %d times\n",k);
+
+	// copy result from device to host
+#ifdef  TIMING
+	gettimeofday(&tv_d2h_start, NULL);
+#endif
+	cudaMemcpy( h_cost, d_cost, sizeof(int)*no_of_nodes, cudaMemcpyDeviceToHost) ;
+#ifdef  TIMING
+	gettimeofday(&tv_d2h_end, NULL);
+	tvsub(&tv_d2h_end, &tv_d2h_start, &tv);
+	d2h_time += tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
+	//Store the result into a file
+	FILE *fpo = fopen("result.txt","w");
+	for(int i=0;i<no_of_nodes;i++)
+		fprintf(fpo,"%d) cost:%d\n",i,h_cost[i]);
+	fclose(fpo);
+	printf("Result stored in result.txt\n");
+
+
+	// cleanup memory
+	free( h_graph_nodes);
+	free( h_graph_edges);
+	free( h_graph_mask);
+	free( h_updating_graph_mask);
+	free( h_graph_visited);
+	free( h_cost);
+#ifdef  TIMING
+    gettimeofday(&tv_close_start, NULL);
+#endif
+	cudaFree(d_graph_nodes);
+	cudaFree(d_graph_edges);
+	cudaFree(d_graph_mask);
+	cudaFree(d_updating_graph_mask);
+	cudaFree(d_graph_visited);
+	cudaFree(d_cost);
+
+#ifdef  TIMING
+	gettimeofday(&tv_close_end, NULL);
+	tvsub(&tv_close_end, &tv_close_start, &tv);
+	close_time = tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+	tvsub(&tv_close_end, &tv_total_start, &tv);
+	total_time = tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+
+	printf("Init: %f\n", init_time);
+	printf("MemAlloc: %f\n", mem_alloc_time);
+	printf("HtoD: %f\n", h2d_time);
+	printf("Exec: %f\n", kernel_time);
+	printf("DtoH: %f\n", d2h_time);
+	printf("Close: %f\n", close_time);
+	printf("Total: %f\n", total_time);
+#endif
+}
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/bfs/Makefile gpu-rodinia_new/cuda/bfs/Makefile
--- gpu-rodinia/cuda/bfs/Makefile	2015-12-11 08:46:07.000000000 -0700
+++ gpu-rodinia_new/cuda/bfs/Makefile	2023-06-06 14:22:22.676705464 -0600
@@ -1,15 +1,19 @@
 include ../../common/make.config
 
-CC := $(CUDA_DIR)/bin/nvcc
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 
 INCLUDE := $(CUDA_DIR)/include
 
 SRC = bfs.cu
 
-EXE = bfs
+EXE = bfs.out
 
 release: $(SRC)
-	$(CC) $(SRC) -o $(EXE) -I$(INCLUDE) -L$(CUDA_LIB_DIR) 
+	$(CC) $(SRC) -o $(EXE) -I$(INCLUDE) -I../util -L$(CUDA_LIB_DIR) -DTIMING
+
+clang: $(SRC)
+	clang++ $(SRC) -o $(EXE) -I../util --cuda-gpu-arch=sm_20 \
+		-L/usr/local/cuda/lib64 -lcudart_static -ldl -lrt -pthread -DTIMING
 
 enum: $(SRC)
 	$(CC) -deviceemu $(SRC) -o $(EXE) -I$(INCLUDE) -L$(CUDA_LIB_DIR) 
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/bfs/run gpu-rodinia_new/cuda/bfs/run
--- gpu-rodinia/cuda/bfs/run	2015-12-11 08:46:07.000000000 -0700
+++ gpu-rodinia_new/cuda/bfs/run	2023-06-06 14:22:22.684705310 -0600
@@ -1 +1 @@
-./bfs ../../data/bfs/graph1MW_6.txt
+./bfs.out ../../data/bfs/graph65536.txt
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/b+tree/Makefile gpu-rodinia_new/cuda/b+tree/Makefile
--- gpu-rodinia/cuda/b+tree/Makefile	2015-12-11 08:46:16.000000000 -0700
+++ gpu-rodinia_new/cuda/b+tree/Makefile	2023-06-06 15:49:17.349759818 -0600
@@ -1,7 +1,8 @@
 include ../../common/make.config
 
 CUDA_LIB =	-lcuda -lcudart
-CUDA_FLAG = -arch sm_20
+#CUDA_FLAG = -arch sm_20
+#CUDA_FLAG = -arch sm_70
 
 # ====================================================================================================100
 #	END
@@ -179,7 +180,7 @@
 # ========================================================================================================================================================================================================200
 
 clean:
-	rm	*.o *.out \
+	rm -f	*.o *.out \
 		./kernel/*.o \
 		./util/timer/*.o \
 		./util/num/*.o \
Binary files gpu-rodinia/cuda/cfd/common/data/flower_gold.png and gpu-rodinia_new/cuda/cfd/common/data/flower_gold.png differ
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/data/flower.ppm gpu-rodinia_new/cuda/cfd/common/data/flower.ppm
--- gpu-rodinia/cuda/cfd/common/data/flower.ppm	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/data/flower.ppm	2023-06-06 17:20:53.972838493 -0600
@@ -0,0 +1,3530 @@
+P6
+# CREATOR: GIMP PNM Filter Version 1.1
+600 450
+255
+	
+
+!".-=.BZOe|H\tBSmK[|ReÖSgÄ\tÄXqkNiVTnSLeH7M8+@/0D;$94'9=2DN=RcXoXnyG^fJ^iOaoVfuerÇ_k{Yfvgták|åsÖìzçëPaW=P:=Q6?V:(;("2% #$0&#1$#/!%2!!)'+$ !##"' ).'.3,7A87E81?2". 						#&'*!
+
+
+
+
+),%# +->./@0):*6A1HQ@DP<9H11D0/E0/B./A+3A(3C(5E*4D)6B,.:&)4$)5'!.$+ %7),A0*?.1,'3'#-$&(-7.
+
+&:/1L;-F1#1$0:/AMC<F;BF8feSÇ{hwq[UR?;?.5C49P@>YJ>_NEfUBdS9^M4YH2RC-M>,H<-I=.IB/JA4L?3K;/G71L91N83U=4W?2Y>2V<4X<4[>3Z=1U;7Y>EcIQnR[tWWnQQdHPcETkN\uWTmMF_?IbDKhIMoNFkJ+O3.P8*E2&=-%:+,(:$7I/M`@AV5SgL=T:+='&7$#4"'7*"4(8NA8TE:UD""3!0J1$>%"#%9-B]J?aF2W8-P0)J+&C'+H,.L4/M52O;1N:4O>9VD<[L>^O?aQ=_N=\L9XF9UG6RD0J?&@5$94*?8-C6.E33I45K42J23K3.A-)<(,=+2C12C3*;++7+1=14B32C3,A.+@-'9+ 0##3(-?32F;5M?9QA3L9,=+#1"#-"3?5?KA=J@1<4/>76IC;RL?YP<VM7RK0KB2PDJj[Op_9ZI+C52J:8XC8ZA=`@;^>9W=7U=:X@JhPSoYRmZ_{oöëé®üë´†ïØ§î∞°ä¶ó~õáràsbv]cu]_qY[mW^o]cugpÖvã¢í†π¶¨ƒ¥¢π©áòé[kaCTJ?UI>YJ=ZH<WF-D2%:),A.-I30Q64Y:1Y65Y32T/+H,(A+.I66Q@>ZLEbPOhSRoSJgHDfCDgFDgF;\=:W9:T;=U?D[GOeYiyyãô¢áóßâöÆô©¬ü±«ú≠øâõ©uâîkàevÄ_mpYb]Y_QafR`fJ`gF`jERb>BV3CV6H[=N\BZdKTYBFE0JB-L@(\N3f]<WR2HO.=P26R95TB@_POk_LbVR\TW`[ant}èôuáïRev[mÅhuÜ[[eJFGQNEPQALP9;D)8A&>L+CS.:J%,9+9"4L2;Y=8V:.L0+E,2H10>-!.*5'(3%(3#)8%2H38N7'5$)4$& .%3"$5"#4!$6 !0.- 1$1 &3"+9*!/%3"$3 %7!&8"4C,'6+7!5C,8G23F22G4)@,'<)5M7/H2-F0):(1D1)A+%A*1I3":$%;$2H1'>$4!2/*0 21,**'6#&4#%6#&9%'9#'6#'4")4&"*!''*6<.-4$%./8%/3%-1#)-#'"$! # &!!)* )#-"%#!'$&!#$$,9($,!"%) .,=+,:)*"0#1 +(+"3#)%'  *"0! .*)0/D39P@$8,)" (39-%(! !%%& .!( " !! ' 	
+!*#3BH]rG]u"6Q$7U/AeDWx[pã`wÖQjg?ZK8Q;6N64G4;M=DXL?TK<PNDXYPgmiÄàDX_5IP=O]HYi]m}huÖbom{àÅéûzäóÉó†ëß•`th7J6?S8=Q8);+&6+"/&' -#!.$)&'!,%1#%1#($&&&%'(.$$,!&1#1=/1?.+8'"*	
+
+		!!$
+	
+,.)$'5&6D57E68C5AL<ER@8G2-C.+C-,?+.@*1@)5E+:L22D*0>',9%)6%'5('5(+;./A3-?/1!$
+
+",!0:/ 	$5-4J>-D4-)-9/BH<TVHb_Nb_LOP@4:,+7++=1&>0,H95QB8WG;\KBbSEdUBaRB^P?[O?ZQ<XL:TG2M>+F5+F3*G1*L40R:1T<3U<3W;1U9-T73W=<^EEfKSpTUoTPgKSgKShIYpSNgIAX;CZ=E\@MgJIjK;^@2V:9[B:WC,G4*A/,!4@R8M`D?R6AU<10,0 - 0&8NB6RC9TC!%0C08R95""-B3EaK<^C2U5)G+&C'&C'0L31O71Q:1Q<0M9/L:2O=0O?/P?2SB5TD7SD;VE?ZK?[L?YL<VI;RH;SF6N>0I6/E0/E.+A,'=(%;&0C00C03E53E5,=-)5)/;/3A21B2-B1-B1);-!1$.#'9-1E98PB9R?2I7*;+-!-!%1%7D:ERHDQH7G=0C=6ME=WNA[R;VO2MD1MA=\MLm\GfT1L=-E53S>CeLMpRGjJ;Y?0N68V>FdLMjTOlXb~pwìáÖüîá°ñä¢ïà£îÅúãyïpÜqcv`_qY\nXReQSfS`ufrâyÜùãñØúü∏•óÆûyäÄJZP7H>5I>1K>=YJNkY>VF+@14I8'@+&D,,N35Z;;^=2Q20L30I4-F3+F5-H9,I7HdNWuYGfG8Z97X96W87U97T8:R:9Q;CZHVj_sÖáú≠∑ö™∫è†¥ì£ºõ´¬ó®∏åû™äù§âú¢ÅîòwââdqhMXHIU?Q[@YdDZhEGV5:M-AT6IY<T^CekQ[]GFD/G?,E9#QE+e\=idDV[;AQ46P54T?=]NNj^Tkc]ieNY[UclÇî¢àõ¨buÜrÑòâñ¶nqx\[Yik`\`OLU@@L4+72A$DT0EV2=K1AS;3M28V:7X;.O2B_C:R:/@-,9(,8**7&-:),;(?U>*@+%2!$/!&'$2#&4#%4!$1$1&3!%3"$2!!.$1 *8'):(#4!&7$&7$ 23B-1@)&4+9"3E/8K75L82I5"7$(@*5N9+D.$7$,?+'@*&?)+D.'?)&<%+A*$:#.,/!2 ):'3D14E21?.0=,2?..;)(6%0.&5""/%$/!$!/5',3#+2"+2")-&*$(!% " # (&#!#+#1$!/" , '$*  &"%"#.9)"*#'". -;*.?-"0)!/'))""*(''&!"$)-+**=*?TA-B3-!& ".4(),%!!!!' -#+!#"#,'!*%"%!		
+
+#'-;DARd%6R,>b:MwG]Ñ\róg~ùfÄë\uz@YS+A4(:*-=0;L<H]JI`LI`PLdVOgZLc[8LK8KQDTcYh{qÄìoèpÄçzãìrÅàwâãïì|ñçiÅq/E05H2->+$4')9/(8.!1'+"$1' ," "!,$0"&4#(4&'4#%2!* -"/%0 *5%+4#(1 ,7&0=)1?(-9#"+
+
+	 ##*+&	
+	'-8*)4&1;0<H<=K<6I6-D0+B.)>++>*/>)0?(7I19M41E,0B,$5%"4&'9+.@00B20 
+	$'3)$0$
+
+%5*0F9*A1*
+	)#/<35A7:D9GMAWZODJ@!( (3?5'7,&:.*?0%<,+C3-H94NA:VH=YK?[M<[L:YJ6RC5QB/K</L:*J3&F.*J3.N72R;5U=4X>0T:*P70S;BdKTrZQjTIaGZsU]vVPiK9P4+?&9K3<P7E[D>ZA,L4+M41U;=aG=aG4T=9#0BU?<P7);%$3 -., 0#+2'6NA7SD;VE+#$5#:P;)A)-%(9N=MiPCbC3P2&<%)<(-E-8T;4R:-O71R=5VC4T?-M8-J6-J61N</J9&</(=.5M=5P?6RC6SA9VB9VB6S?.J4*B,(>)'<)'<)1F35J92I9/F60E6-=0)5)+7+/=.3D4/D5-B3*<.$6&"2%1#-D47P=5N;.E3(9)-,:++9*+;0GWMarh[lb8LA4J>:QI>XO>YR8SJ3OC1M?AbOOoZ;VE)D38UALnVW{_MrS>\B/K27U=DdLLlUIjU[xfpå}zîáóâÄóá}îÇ}îÄyë{oÇlas]\o[WjWMbQOfT^wdpât}ñÄá†äã§ëÉöäizp:IB0A92F=.H=@_PKk\>]N4J=+@1+@/-D0*G10P95R<3N;3L9.E5(?/&=-#>//L:HhQIkP9Z=3Q50J1/H26O:<T>?WA@UBCXIL`Wtáã´ΩÀß∏ î§ªéû∑àòØsÄëhvjzyjxd{ubyqSi\8M:4K1AU9J_@DX<.@&5G-CV:LY;\aAlkOc]GG?,@8%B7#J?)WP4faC[_>GT6<S7=]E?aPJia`zyvâèeuÇ[j}~é•âùµdyéexáiwÄciidibrzmcp_M`LCYD0C/&8":J/QaDQcIVnT6T87Y>:^B-R3=`B7T8/@-5B1+8'*8'&4#8I68N7':& +$"#)$/!&1 (1&-&.$/#0&3!(7$%6#%8$':&'8%%6# /%2 />))8!0':&6K85L83J6'<)6",E2&?*$<&.F0%>(%>()C*/G/*@+/E0'=(1%)$2!&7%%6$#4"-)6%%2!) .+$""&1#"%+04%.2#-1")-%)#'"%" ('##(/ 1!"2%!-!",!#)$$#"&-5&"("%)4&2@/%6# .#1  ,%!'( !%"$$%$"!!!#( , .!,)<).A.- '#%+/2+!#%*$"$"" %!(!%#%" +!"/%#0&".$ '/90FQI-82$-*&#	!#+4,C-;^Teë]rüg|ßlÇßrä§|ñ•uéíXqk:PC2D4;L<@S@CYBE]CBZB?WA7L91E9/AA;IRYfwvÇòxáö}çúÉîõ{çç`ojevnh~rC[ME\J1&*,"(8."2(('%2)&3)'$#"("0!.,'* -(5#/:)3<+2;(2;(2>(6B*7C+4@*$-		 % "(-',-(	
+	
+!)!)$.#3?38F75G7+@/&=+'<+'<)(9&$7!1D.;Q:6L5.D/!3# 2"&8(*=*%3$
+	"(2*)3+"		%0(6H:*?0'	
+(5,,<2(5,!,$/91ENI4;4+5-*7-!1&!1$%7'(=. 6)4'7*(C4,H9-I:/N>3RB7SD3O@2O=,I5(C0)D1+F3.I61N85U=4V=1T</R:3V>=]E?[DC]BZwXQlK6O21"4>P::L4I_H2K5(D-(F.+K30T86Z>:\C)I19 7O70H24! 1&7'.!.! 0#(0%7OB7SED\N%3&&3F2:P93+&(4(CXEMgLDaB0J- 1%6$,B-4M71Q:4V>;\G9ZG0M;*E2/J70M93N;2J:!6'/!,>0-B3(@0)D1,H2.L4,I3)E/(@*&;(':'+@/6M;7N>0H:/G92F:.@2*6*'1&-9+2C31C50E6-?/*<,&6)0"'<-2I72I5,A.$5%- 0A13E7:L@GYMXl`ksJ_P?UH;SF8RG>XO>YP9SJ4PB9VDMjVLgV:UDC`LOqYV}`LqR>\B1M42P6?_GEgOCeMVvadÅmoäwtçzvãxwävxãwuàrm~kap]YjXUfVQcUQhX_xelÖouèvvèytçzirVg_6GA4E=4I@.H=/MA6VI2RC2M>*A14I88O=3N=0L=0J=1H>+A5(>1&:.$;+-E7;XFEeP=]F-K3-I2%<* 7%$;)<S?J`KMcNL^NGZTyåíÆ¡œ¶∏Ãô´√ïßøáóÆboÇYgpVebPaWBWN>VI@WE6N6.G*3L.3K1*A' 21@+>L2SY=olM}tWodNOD2JC0LE2MF3MH2TT:RX<BP6=T:;[CCfRJkbXtw~ñ¢Çî®oÄösÑ¢nÅüARl->P.<EDOKXbWiug]n\MfP?[DAZE,B-CU;buYCZ=B\?4R68Z?7^A+R3+N.-J.->+.;*)6%,;():'BUA&<'):( + & $#*"",!)1")0 +/!'-"-!.#0&5"&9##9"+>*+<)#4"* /&5"(:$!4(=*8O;9Q;AYC3H5'<+(?-*C0(A+)A+7!%>(6P7F`G":$/E0'<)$7$ 1!*&"(+* - -(5$(6%(*2#"*(. 48)04%.2#)+%'!%"% # $&%$$/,.#1$$.#$ #%$"!#&#!'/<+,;($5"&5")7&#/!($%"*!$'&&#$&%&#!$"$&%) *  ,","- .)'$ &39/',%,1*',&!#*0,)/-"+*('(%$/'#0&'5(.:.,7)7C5P]S.>4'2,*&	
+		
+	
+.&J1=mJZãPeíG]ÜNeÖuè†|òúyîèhÉtF_J>V>@W=AX>>U98O36M32H1-?/+:3/<DDQbjwäkzçyâôãú§|èâxà{o|jXeQAO>0  0# ( 0&'8.,!#+"(5,(8-"2%) "*+#&"-'2"$, ('-,3#09$4@(4@(.:"(4 &/#,$"*+%$' -3)',%
+
+
+	!% (08-5@22@1+>+-B1&;*&;*&;*6"'?)>WA/G1$9&1!"3#):(%3"$%'3)'3)&
+
+	+7-,:-!		#.&+;0&6+$(%-63 *"$/'0@5.>3"2%&8*-?3%7+*%9-*@4+C6&>1.J<6UF0O@,G8&>0%;.(>2+A51G;4L>/J72O9/O71S;3V>3W=2V:0Q67U9C`B?Y<1H.-'9#@R:<S7E^A)A)#=$$<$&@'(F,-N3/Q6-O4-O45V;8V>6R<0I4&=)0%7)1%1(7MA9SFAYK%?P=.A+0+'.<-G]HIcHF_A*C&1*?.0E2.G21N8;[D<\G3P>"9)$9*.F60K:3P>5P?*?0*#/#%1%+'8(,B-,D,(@*'=('<)(;('<))@,1J73N=/G:0H;2F:0B4,8,'/")4&4@24E52D4.@0+=-+=/%7)"4&,A2.C0,A.'9)!3%/A55I=DYJK`OSjXYp^LeRLeROhSB]J9SF=WL>YP;UJ8PC>VHH`P=XG@]IIkSNuZJnR@^D<Y=:[>FiKJkPGgOQoU[w^a{bhÄhmÅhqÉkrÑlsÇmn{ikxgjtibnd[h_Zl`cxghÄjhÄhe}g]tbSi\H\SEYP3G>F[RF`S,H:,J>6UFA`N@]IC`L9VD1PA7RI@VSEYW>QM.B9*@3*B2*E66QB=XG*E4&?,3J87M@2J<+C3@WCPfOOeNK`MI^U}íó©øÕé£∏ç°πöÆ∆î¶æê§uÇígrxT^]IVOBRE;L9=Q65L//F*)<&0--:(>F/]]C~sUâz[{mSZR;KI4IH4GF4DE5DK;HUDBWD=YC=]F>aM@aXGegxíüÇò∞qÅ¢uÖ©^lë<Ii6BZ=IUO[YJXKWeVM`L@\C7U;6R;1J4>R7fy]D\<;V55T58[=6Z>,O1,K,.G**9$'4"#0,;(;Q:2H1-(6'&0%'"&.#%/&&0%#-"%- (0#$,"-$1 %4!'8%(;%'=&)<(,=+(9&/++"4#6 *B,9R<8P8>V>4J5.C2*A/2K8/H5+D/,'>*GaH-G.5*?,%;& 5"!4!#4"#1 (%4!*9&"1'6#+:'#2))$0"(&&(0!.5%26'/3$,0!(,&(#%!$"!"$"!%$!%/*+"0##/%%$(#"$'4".=( 1 1*9&'4"'2$(0%!)#!#$"$$$' (&  $% %"'!!(!"+&'2.&1-%0,"-'*!(&#$5=23:2.5.$ #""&%)-,#'(:>?:>?066,46$-,(3-$/'!-#(4&/=,5D15F62B5*:0%2+		
+	
+		
+
+*%RANÇZoú`xû]tîh~ï|ìõF_[?VL:QA7M89P6=T8AX;BY<9P4.E+-@,(8+,866BPXdzbqÜ]nÄÇî†ÜòömsTcNQ]E@J2%!,("$( !1');/&%$1('7,(8+ -#%#'"
+%"*,4'%- $ "%+2"3<)+7!#/%1)2,5"-6%,4%"*%/2'.4(!'
+	
+#%,%##)'/$2=/1=/*;+3E5+@1'<-'>.$;)$=(8Q<)@, 3 !2"&7%%4!'#(!*1)(2)(	!,$-:0&4''%"#.((#&1)#.&(*:/0B4#3&$4'/A5-?3!3'/A5.?5+?4+C68RE6UF+G8 8*2'*;35F@7JDLaZE]P0H80I4+G15R>3S>.P77X;>\@2O31N05R67O7!7"!4 9L8<T:1K0$<$(@**@)!9!9 !=$!?%*K0/Q61S:3S;6S=4P:)E/!8$.E3/C7';0,B68PC8TE=XG+'GYC- .,+1B0KcKIcFG^B&:!%8%+=/*A1.G4.K58U?3N;!8( 0% 0%'=00K<5QB8TE2J:"4&".$#-$')7*.A.+A,)>+)>+/B/(=*(=**A-(@00K<0H;1I<4J=7G:3>0)1$*0$.9+4B35G71D1+@--B3(=.$6*%7)+=-/A12D62D80D95I=BWFJaMRiUSjVJcNOhSXpZKdN;SC9QC>XMBYQ=RK:OH9PF/I<9UFEdRHnUFjPA_G=Y@FgHLoOPsSHiLIgKNkMWpS\sWew]l|bn}fo|htÅoyÑv{ÖzvÄwjumbofdvhaveWn\LcSE[OCXQ;PIH]V:OF=UHF`S6PC9UG>]MFgRKnXHkUEfSCaUHc^ShkXkoQcc@SOF^Q@XJ/G:.F91I;"9)/  5$*A11H84K;@WCUlRQhLQgRK_T}íï•ª…jîuâ¢öÆ«ö¨ƒèü∏Åê•wÄèmv}]ghHSK:G6I[C8L13G.'8&-$2#/:*AE4b]G~nT}jLxiLe^DFH2=E0=D4<G9CPFH\PC[M8SB0M97VD8UP?[_sçúsà£l†sÖ´pÇ™uÖ©n}öHXhL[^>OEK]OG]H4P7+I/0N67S<G^BH]>LaB@Y93P2<]@7Y>/Q6+H,)@&(7",.8J4;Q:(>)->.'3'!-!'(%0"#-"'1&'1&%0"%- "* +&3"(9&0C/+>(':&+<*(9'*=) 3.)."8#,E/=W>8P6:Q77M8:O<;R@:Q?D]JAZE&;(?U@=U=#;# 6!&;("8#5 1"3!&4#%3"+:'-*.=*.%* -'4#"-#+'-,3#-1"-1".0"+/ '+#%! "( %$+#&%#'%%*!/*-!/""/%$.&" '+'%'!,.;'%4)!2,;&.'(.$)/%',%#%& "%&"(!'##!&""&%%*&*0,5@:AMI9CB6@?+56!+*'"$$"!.8->H=181#*0,<B>267-12>BCVZ[OSV59:+/08>>?DG&/.+41%0()''5$.<+*;)+;.+8/%2)
+				
+
+
+	
+
+	
+
+		
+53DpiÆoâ¨sé©màôsäíFYU !#/#*8'6H2@T9;O40D),?),=+'4*&456CTSc|cuçrÖñ~íô{êãM_O+8$*3"##-$+!('*"/$&8,$	%'4*(8-)6,+!(*4+%
+	#% %(!.1(*-$" %(&,",4'"-)"( $*,4%0;*0<(4@*-9% )
+	
+
+'-)(2*! '/$&'3%,:+->..@2.C4+@1)>/(=,&=+,A.%8% 1#1 &4#!.* ",! *!
+			
+		
+
+		
+*"-:0)9,'#)4,.;1*6,)* "2'$6*(:,#4"$5%.@44H=1G:1E92C9*>56MC=YM9UF"=."8++<27C?JYVP`_cxs>YJ+F3)@,(?-Sk[D\L+D/1K2<T:5N10M10N22P8,H2&?,%<*+B.*A-$;)$;''?)%='%=')A+'?'*D++G0.J30I3/H2-I2-I2(D-*C.3K;7OA8SD;WH9ZG9YD#:&,?+AP;-+ , ,9J7MeKKeH@W;#5 ,&3)5K>:UD/K50I4,A2#3(*$,%&:16NA5TD:YI3R@4L</A5)6,(5+2B70E4,C1)@0'>.,A2'>.)@0+B2-C73K>1H>3K>2H;7G:6A3,2&+/!*0$/:,3D43H5/F2/F62I9-?3%5*,<//?24D96G=6J?CWKF[JJ`KOgQMeODYHJ\LLaNKaLJ_L>UC=SGAVOCXS@VS;QO>TQ>XOA]ODgSEhPB_I@^FFiKMuSJrOFkIEdDFcEOhK[oT_oUes\gt`o|jÄç|íüéö¶òíûê}âgtk`qgWkbG\S>UO>RSI\`Ma`EYWBYO<TG@ZM?[L@_MBeOFlSJrXGmV@bQ1OEB[X^sxat{cv|VklLc[;SF'=1+A41G:4K;?TAK^J?R?4G4,A.6L5SjM[sS^rYNcTxçê¢∏∆hxëxà¢ûØ…ó®¬èüπÄé®Äå§}àöoyÉGQS6A9>L=5H20C- 1!+.<-9D6FJ<ebQveQo[BÅmRulONR;=J8?QABXKD\O>VI:RE6N@*B24L?2GHJairáöpÑùáúªüµ⁄í´‘ì¨‘í©…^räGYc9LJMcWD[I8Q<<XB>ZC8T;1J-5M-WlM@Y94Q59Z?5W>0P8,F-'=&7J4-?) 3BXA+A,1&7'/=0)7()(#."-(4&.9+#. $,*!.'5$-@,1D.*=)1$5#$5#"5!!40-132K5?XB3I22E/6I5DZED[G@WC:S>5N82J2:R:1G0"5!#8%&;($9&2-(,*8'(7$#4! 1$2!*'&*"-&/(/*.+/!*. ,0"/3$04%(,!!*1)&-&%,$ '&!))()++ ,&2$*"/%$1()! ! #*!-()(5#-:(,&&5");%-##)*0&*-$!!$$' !%'%#!( 1818>>INQ4:8;F@Vf\Wh^O^YO[Y<DG19;$*(&#"!%-5(7?4(/( ' 8B:>GB7=;GMMKQQ:?B>DD399IOKagc/53)2/-61%/'&&)*!+ %/& &"%!					
+	
+	
+					$&AHZ~vé≤wì´tíùjÜâ\ro*
+	
+
+,$5"#5*<&*;)&4'(" +12AT`pâtÜöuãòtååbwn&7%&!!-# ,"%##&%5*&!,$(5+.>3(8- -#%1'"
+	%&!()#01))*"#$),%).')0((2) *!$* !
+*6"+9 -;"3?)-9%&."
+,6.)3+%0")7&&4#&7%%7');++@1,A2)>/'<-%7'"4$&4#&4#(6%'5$#0!.&$
+
+	&)9.)9,,
+!+#,8.+9,".$%".$*8+(8+(9)#4""3!*<08L@9OB0F9,@7-B;=XO=[O7RC$;+"4(%2)6A=com]mjK`W.I8*C.'<)#8'4F:5G9':'+>(3E-/C*-G.0L31O71Q<2M<.I8,D4*B2%<,$9*$9(%8%%8%&9%%8"%8"!7"5 5 349"*F/6R<>YF7TB/L:+J8,M:2R=7P;=P<9H3)6""-#."0CVBMgLKeH7K2!0 .!5E:BZL>[I1L90G5,>2 0&#/+(720E>8RG7VG7XG5VC5R@6L?2F:5I>4H<1H8/G7/G9/G90F9.D7,B5-C71H>3J@/F<3K>2F:5E8:E736+(*(,+3&2@13E52I70H85K>4F:+;0.;16C9;K@EUKJ[QQcWL^NFYFH^IG]HJ[IYjZ\o\PcPPcOG\I=ND=PJDXVJ^_J^_H\]AUSD^UFgVFgTDdODdMDhLEmKBlF>g?@bAFcELeH[oV]oW_nYdq`uÉtåùç£¥¢¨ø¨¢≥£éõëo|sZidRb_EUTBTTK\cWjqdw{OecH_Y@ZO<XJ<[K>aM>dMBhOBiN@cK5VC-KAG__`t}^p~j~áVkn7LG!7+ 2&+=1,B52I96L7<O9=N;=L73B-6H.PeFbwXhzbPbTkÄÉ¢∏∆åû¥óß¡õ¨∆ë°ªï£æÑí≠|ä•Ñì™~ãú]jr;EF3>6.?/'8&* $/'/;19C8NSLmi^gWH]H3|kQ|rWRZCCVCD\L?[L6RD0L>=WJD\O7OB<SKBWZ\p{wâùyç¶ê•ƒã£≈\xüâ•Ãë´Œxê™RevEX^Pe`=SG;RBHaLA]F4Q5,E(2J*]rQ1I)-G,8V>3T91O5/G/*='2E//F,5M33I2(;'0('3%2@1/=,"/,,&3!,9'(5#(3#&1!'5$(9&0F1,B-(;'/"3!):'%8"(;%):'(9&':'%:'4M7AZD*@+':&3D16I51D0,B-*@+'?'/G/-C,#4! 1$7$'<)!6#!4! 1% -*7&,-"3!%3"#/! +)#.%.'.+/ '+&*"&$('+*. %)!# !"(07/$.%%"&$&)(%(()&2$#/##,#0&!.$%"!&$! #$%&*+8&$/"!.=*-?)!0"$'#)#&"$""$#$ .5-ele]cciqs?HEJWNi{oVh\\kdJVTV^a=BF%++$ %!!%,4)5=2.5.'.'1;3-7/=FAR[X\bbLRR066$**FOJS\W+4/,50,50!+#&() ) +2*ELE!&"	
+	
+		
+	
+
+!'8=Lcbwäsåìe~[uj9MA +%6&'8&+#,4ARm~êzéôräåkÇzF\O' $1'* & '4+('&6+-?3-B3 2$,!"				##!%&!/0*/0(()!+,$/2+.5-.8/'1(&,"#&"*'3&4 ,$0$/)2!/8'1:)/5'$!+#0<2#0&$2#):(2E16I3.D-&<'$9&-?/2D4*?.&8( 0#$2#,:)-;*/=,+<*$2! . -'!
+
+$)7**<,#5%. (!.$&3))6,".")$+# '#+ ",!*0=,#0)):*;M=4K;)A3%<23LF@_W=]R.F8."!"+41Zfb\pg8P@(A,,D.+>+.!/"+9*)7&.=*,9%'6!(;'+C-0I43P:4Q=3S>2O=,G6!7**"$+'5$(5#)8#!0!/!/+/2'?)6O9?\FB_I<YG.K9.K9-H5*A//B/:I4/<(&1 $/*9&J`IPjOIaG,>(!2.C2>VH?^N9XH4PA:RD;RH7NF5LF7PJ8SL9WO:ZM9[K9YJ9XI:VH:TG7SE7SE6QB6QB4O@3N?4L>2J<0H;0G=2LA2LC1H@5JA2D8.</5=069.--!+++/!2=/6D53H92I96L?8LA7H>8E;FTGRbUWg\Uf\Yj`UbXIWJGXEGYCWhUj{ipÅoYjXPaOHZL8H><LIGYY[mofxzj||fywavoSocIhXIhVHjRHjOBgE>g?=f>=`?BaBOiPYoX^q[^o\gxh}èÅî©ö£∫®¶ø¨†∑•âùëm}sUa]HRQ:BD9CELY_bszuäèc{}SkkKfaCbZ?cU@eT?bN>_JCcKAaI@]I=XOPhjcvÖ^qÇgyáQbi/@:*:/"2%&6)*<0.C4.C00C//<(4@*;C,BL3L[>VfKN`J-A6Ldfáü´óÆ¿ü≥Àú≠…î£¿ö®√êû∏~åßÖì≠ãúÆÄëõS\a4=<*4+%/&!*%'0-,523<7MQPXUPQE9Q@.j[DplSQ]G?TA;VE8WG8WG7VGA]OFbVA\SD_ZUnrjÇéwç¢rÜ°uà¶oÉ§vé≤ô≥÷é¶ Çô∏pÅõTeuJ\`9LFBVJ9P<2O30M.'@"8M.^qQ-@",C)8R95S79S6BU9-=#/C(:Q76N4%;$'8%!.-6%EN=*5$0?,.?,%6#.*9$.@(5G/4C.0?,):',?+3K5+C-(>)%7!&5 (7"%7$6 #4!#4"':& 6!4M7AZD&<'+<)*8'*8'0>-)7&#2(:$':$0--%8$':'"5"0 #1"%&2$"/( .%3$$"-)4#)4#+4#(/*.'+%' #  &%'*.1&,2&.6+'1(#-%  '*)$$#") , (%*!/" .! *!  -(5$$$3B-*9$'4"&#)/%*-&&(#!# ##(CLI+41,6-blaqzudmh@MDbrgfxlI[O[ha7B>;CE7?A$*(!"! !',6+,3,*1*292;B:U_VV`XSYW@FF9??!! &$(1,'0+-82+60#.&#-$%/&#-$##*"9@8				
+		
+
+	
+	#",69HO@RR8MF.@4$
+#'2,'2*+!#	 '.<G_pxtàâkÇz]sf2D4#!+!(6)$0$% %0("/% -$(:./D5(:,- &
+
+	#"/0(/0(,/&+.',3+.:0)5+'/$"(""&$/!$/($$!)!*'$-/7(06*.1("' !( *6*2C3/B/1G20F/2H1/E.0F1.A.,?,6I62E2(:*.!!/"$0"*6(0>/.?-&7% 1-*$
+	
+
+
+
+
+
+
+$5?4+<,$6&#5%*:-+;.-;.#1$$ ( (5@0"-(&4#3E5+B2%=0&@7:XP?`W9YL1$!@MFYob4M:*B,-C./@0 .0<.'2$*7&-:)!.!."3#1!$9(/F24P:6S?5TB5QB/G:.#"(&2$7B19E1 -(3#+6((4&#4$22 8"-F02N82M:2M<3N=4L<(?/':'/B,+:%%0!.,=*QgPOiNB\A'=&/D1<WD<[K;[L<\M?^OC_SEaUA_U@^V>]U=\T;\Q;]O8ZJ8XI8XI9XH8WG7VF6UE7TB6Q@6QB2M>0H:-E7/G:/I>3MD3MD/I@3K>1E9,=-2=/5;/,, **.0#6<.9E74D73G;5K>;OFBSI>KAXfYbreYk]Yj`^oe^kaQ_RFTCI[E^pZoÄmwàvj{k]m`L\R;JEDTQRddi{}|ééíêÄìètâÇg~tUqcPm[PpYJmOCgC<b=?e@?`AA_COhRVlWZp[`s`moîÖé•ïó∞ùò≥†í≠ö~ïÖhznUb[ENI:@@8=@W`emzÇfyIacE_^IhcBf\?eX;_S;[LB_MFaNF_JE]M@YS[pumÄëctàj|äSei9HA0>1*6('5&-;./@04I6@S?:G3;D/BJ2FN6FP74@*(5#.$,?CdzÖì™∫ú≤…ûØÀï§¡õ©ƒû¨∆àñ∞áóÆè¢≥Öó£^io>FH395)0)-31;DCHQPPYXRXXNPMLH?TL?`[H^aLJ[I:RB5PA2N?/L:/L:3O@6RD9TKD^[TnofÅäzî•ê¶æù≤œ¶Ω›´≈ÊßƒÊù∑⁄ö≤‘ó¨Àn~ó?L\>LOJYR);++C).I*%<4I*\mM4D'&:!5M34Q39T5I\>6F)7K/;T7)A'#: &5 '2!;?06:+)2!(5#,=*/B.);%3E/4H--A&)8#!0/2H30G3.F0"8!/,+,)&0/B.18T;=W>+>*(7$$1 )6%/;-(5$*%2 *9$!3$3 #2&7$':'#4$!/ &4%'3%.4&)/!!)%0 &.!%'2"8C2/<*(3"&/")#"#% (&" $%- !+ $.#1;2 ' +!!-!'!%#"&&$&'* ,)#&3"!.+3B-#2%2!%!& (-&.3/+0,.3-%,% %*-9-itn:C>#-$BLAq{pbnbQ_PpÅq`peBOF/:4-84@HJ6>@(.,#)%#" "%,6+2<4+5-181BIABLC8B9/51&,,#))##'-+*30*510;7,71#.&4>54>5(2*### 
+
+
+	
+	
+
+		
+	
+	
+
+
+#-%)!%%!///?>@QKEYMI^M=P=,#$"+!&4'$0$"""/&"2' 	$'4*)9,/" , 	
+$%+,&),%#("",$*:/&6+&-% % "$.#!'*!(+ ! %(!*/(.6+1=/7H62H3.F.(@($9&%8%)<)/@00A11B0;N:-@,/""/%%1%,8,-;..?/,=+#4",*+&
+				
+	
+	 %3=22>0!-,$2%-;.)7**"*(3%+8'*($2#2D4(<0&=3/HB?]UAaV2NB*%0(6K<'>*"7$#5%$2#!-!(3%($0$#1$*,- '(,=-6K:8Q>6SA8WG5UF0O@-E7';/#3&%3"LYE4A-(&1#-5**5'%6&%8%0+/!3##8'1H63K;0K:3K;8O=2J4,?) . .5H2UmSJgI;Y=1O59V@:[F:\K=_O>`R?_R?_R=_Q>`R<^P<^P;]O9[M7YI8YH6WD4UB3R@4Q?1N</L80I4-F1/H5.G4+A4&>0-E8.H=1KB1KB.H=3N?0H8.C05C25=..0%,, 56(;?0;C66D71C73G;6JA:KA<LAYi\_tcPgWUl\_te_p`TbSAR@I\H\pWj}gnÅmiylhwpfrpUdaK[Zdvvtàá~îíÜúôâ¢úÑõìxçÑf~qd|lgÖm\~]JlG>a@@aBEcGKgPSjVVkXZp[bxcoÑq|ìÄóÉÄóÉÅöÖ~óÇrãx]tbSeUJXK=G?8><KPTJQW8GJ6LJ8VN9]Q;aT8^Q;ZR@[TGaTMcVH\QBUOBTTarztÑîkzçl|ãVhl>OG:K;8E48C27B21?.4G4:O<7I39G0AK3;E--6#&/"-$0&+68L]eé£¥†¥Ã¢≥œû≠Ãô®≈•µœö©¿ãú∞é°∞}ëöQ_bDNM<F>EOGW`[dokmyunzvbqncokV\XLQJQ\NM^NI_R=WJ8SD0H8'@-/F4/F6,B5.C:2IC:PNI`f]wÑÜ°∂û∏”ûπ◊ûºﬁùæ·°øÂ¢æ„¢∫‹ÜôπQ]w;BT08;'2*%6$&:!$8+?#VfI2B'13G.4N18S49Q1?W7=V6.G)(A$(<#,9%/8')/!$(&'4# 1-@*.E+ 721-"0*=*3K50I32K5.D-($%'4/G-&@%4N31I/'9#)6$,7)%0".;*2?.(3#&3!#2'9##4!'8%'8%#4"#1" .(5#6?,MK<@=.0."''/1&.4(*5%BO=0?,"1* +$/!+7),9((5$)"(!-#&1#6A3.6+%-"#-"!+ ##&'&''**&$)+%$",7'(+8'1@-"/$/!#*"! #'(-1259:489'-+#)%&&* &2?.jvhEQE*4+/9.^kZ`o\dv`[lYBNB*5/,52BJL`ehBGJ*32&/,&!#" +6B4DQG5B9%.)&,(;B:3:2,20-33!''#!KTQMVS4>?1==+54'!$.&*1)'1)$#%!(! 
+	
+	
+
+
+
+			
+
+
+&"(40.:6,;6*94+81/$-):(&4#
+
+$) %
+		( #3( " *!)*$0&!+"	
+	! #$'(8.*:/#-$%##(%	 
++,&)*" 
+	"' 4@29J83I4,D.&<')<)):**;+,=--;,->,/B.*=)(6'(5+2>40<2+7++9*+<,->.(6'"0!"0$1  (
+	
+	*,)%*$#*" +)"-)3(-9-&2&'!$%1#3@/$1 !/,:+,</';0/F<8SL@^V<ZN+C6,<1 *!""/%5J9(?+#8'.')*&%"#)(+!*(4(5E85J;4L>7SD8XI8ZJ7VF3N?(=.*;)RdN+:%)&&.#+6((6'(9''5$+(-!1$0E63K;1I9/F65L:=T@;Q<*;)"5"=U=RlQCbC>_B=_D:^D8[C9\H=^M=^M?`O=^M=_N:\K;\K<]L8YH6WF5TD3R@.N9,I5*C0%>+)E/0I4-E-,D,/D1-D2,B5-E7-H9+E8/I>1K@1K@4NA-H71H47J76C215'44(:;-;?06>/0>/,>00D83G<3G<7I=FXJRiYKdQQhVZq_VgUQbO?R<BV=I`DQhLTgSVfYgtmuÅhwtWjhlÄ~yèåyèå~óìà£úä§õÜùìxêÉ|ïÇ~öÉsísTvU@aDEcIPlU_xcbyg^sb[p]cydlÑntåvpÜqnÑopàrmÖoc|f^wa\t\TgTIVLDOKS]_SadG[Z=XS:[P8\P6ZP9ZSHbaOecPe`ReaUedSabLY_co{p}êrím}åPbf>QK9K=5C2<G7>F76A10A13E51B/2A,0<(*3 $,'/ 08)/7,,54:DMÇï§®Ω“™ª◊£¥–õ¨»©π“§µ…î•µ}ëö[nr=MLERKNZPeoffphitnn{tnyqÅ~wáÑbqnHWRH\SG^TJdYGcWC^O7O?<SAF]ICXG9N=2G8:PD;PK=UWKeruë¶â£æmà¶wï∑ä®Œè¨‘ç´—î∞’êß…vÖ§CNb+4;%0*'5&!4$8!8K`A7J,(:"1H.6P35R3:U6;T4.F&.E(/C(/A)5B.*3"&,#) &) .#6")?(*A'(<# 2.'8(:P;1K22L35O6:R8-$&4#*=)(>')A''A$(@&*=')8#+8&#/!))6%5B1;F6.;*-$5")<&2E/(9' 1%3$%2!.:&MTBTRCDA2A?257*/2')1"'5$6G4):'#4!-;*5C22@1+9*#4"#4"#1 + .!/ '()!+ )4&-8(+3&.6+)1&&.#'!)"**!.+'()(&'+*($ !%"*'*7%"/& %1#$0"+ *!'.&$(*%',(598U[[kqqGMM7==*00 &"( !+#* $+N[J>K:LVK3=22?.?L:>M80=+",#&/*OXWJRT]bhCHN"*,%.+(#"&$.#0<.FTGMZP3<7'-))0(/6.LSL<B>+1-#,'T]X[f`=II4@@)32# !(!)0)$+$"$"#%,$	
+	
+
+
+
+
+
+"$4*,<1,9/%2))!!
+$+9,'"&2(
+%!+""",$'1)( 
+ &+8/,<2".$' *!,"-	 &) #&		#.&6F9/D3*=*,=+/=./=.3D22C3/@0+<,$7$(;((6'&4'0<22>4-9-(4&):*+<,-?/-?/(9')8%&1!!)			
++0, ((3%,7)'2$&  % '&!-!/=.(6%,&2$&4'.D87RI9XR=\T6RF)A4-#'%2)7I=4M:/H3#:(1! 2$ 0#$4'!1$.!,)'(#0&#0&"0#&4'(8+);/0F98WG:\K8ZJ:YI6Q@:Q??VB%:'#1"&+&2$)7('5$'2$'1&#-"+!1&/D51I90I6*<,&8(,?,4I69N;1I3>ZA@^B:[>:]?;^@:^B9[B:\C7W@4T=2R;1Q:/O8-M6/L66Q>0I6,D43N?4O>.G2(=*#4",%;&0H0,B+(>'+>+(=,*B4.I:-J8*G52N@1K@4NE5OD/J;7P=7L95C29=/89+>@3;?15@21B2+@/)@0.D71E:3E95G;;OC@WGJcNMfPL_IG[@=Q59N/:O0@T8GYCO`Panem|wizt_tmqàÄxíáuåÑvçÖÖûòã¶üã¶ùÖ°ìÜ£ëá§éuï}ZzbFcMNiViÖo{îxè}i~m\s_^v`ijkÅjgzdat^_u^`x^YvZYvZZwYOiPH^Q\smtåélàãXvtAb[7[Q8YR<VUD\`Vjq`szVhlK]_iv|oyÇdnzhqÇtïvÇòm}åFY`<PN9NE9K?9G::D9<D94@62?5.</$2#%0"%- +3&28,5;/-3)*.-,5:oÅç•ºŒ®º’ü≥Œù± ßπœñ©∏nÇãMbc7LG5F<@NAT`Tcmb_i`[e\]jc]nh_onqÑÇíê\qlDZWG`ZId[Ok_MhY=XE@\FIeOF_J>UA@XBMdRPg]\vw~ö¶ìØƒé£¿Vjç^vúì¨’ó∞ŸãßœìØ÷ë´Œà†ºcxâ9LP8LC1F7$<&": +F'Ga>Ga>5N10J-3R23R24O0,C&/?"5C))7"/%.!'#&)/#'-!,(&-!2#6 #9" 6!*B,6P7/L0-J.,I+@[<6!!#+):(&9#)A''?%':&%3"&4#*8'*;)%6$+7)1>-6C21>-%3"/&9%/E.)<)&7%,:)(5$'2!LUDFJ;=D49A25B15F61F33J6,D.#9"&9%%6$!/,+!2 "5"!2/0./%3$"0!** +"-%/$&-%-2+-3)(.$%+ (!/ .$$) +!#'*(*+*&1#/:,!,%2!,;( .))(& *"(/(,1+,1+BIBQ[S2;6NWRiskQ[SFLJ+1/(#!+# *!(##$/!)5'Q]OCOA$.#%0"8C5.8-$+$FLJclkhpsOS^4;E)+%0, *"!"#-$",$(2)5A5GSGALD)2-!+".8-<F;4>38B9%/&XdZUbY2A:1@;)40'$!  " &AI<
+
+
+
+
+
+",71,9/-"	
+	#/%,8,
+	
+
+				%/'	$) $
+&/*'2*&"
+	$ )4.,<2&3))%1%#. '		*-$$'
+	!3>64F:+@1->..?/(6'0>/6G72C3*;+(9)&9&)<)(9)(6'0>15C60<.)5',:+/@0,>.0C02E1/@-,;('4#*#)!#($&+%,1*&,"%$)%*/))0('1&***8).<+!/*)6,,C98VN;\U:YQ-I;1%&+$%0*(5,4F:CZH2N8,H2'>,*<,+=-*:-*:-)9,"4&#5'&4'&3)%5*/?4*7-$1'%1'".$,"#3(-C64PA:YI:YI=ZH>[I8S@2K60E4.@0*;+*8)(6'*6(*0&'-#*1)&2(/$,@4.G4.E1,=+,:)#4"$7$0H2?XBA^B:X<6T84U82S82S81O50L5(A++D.,H1+G.&D*'E+(D-0I46M93J88SD=UE,A."3! +)&5 4G1/C*!7 2!8&*B40K<*E2*G35QB3MB6ME5LB3N?:S@7L91?.5<,79+:</7=/7D38I70E2'<+*>2/C72F:1E9,@40G7<SA<T>>U;>U9:O09N/8K->P6N]HXfW`mdapiXmfVmejÜzuëÉuçÄoÜ|vêáÖ†ôä•úàßòà§ïÇüçwîÄa~jTo^_ziyîÅä£éÜùâpÖr[q\\r[_v\au\YmTRfMRfMRhQQkRPlUQmVJeT?ZQJgcOonLnmEhd:]W6VQ9VTH\cZkuhxÖl|â^owYjrsÅä}ãñÇéúäú|àûsÇópÄêOak<OS:NM<OK:KC=HB=G?=FA=H@.91&2(+5,2<18@339-17+,/&',(*24\mtòÆªßæ–¶º—•ºŒì©∑Ymv1EF,A<.B7,>07E6NZL`k]`h[MWLGTKAPKCUU`tuyéèbxv@YVJe`Kf_QmaLgX?ZG:V?@\EB[EA[BC]BA[BC^OUrnzò†ñµ«¢∫÷ë® Çö¿ù∂ﬁ°∫‚ï±ÿëØ”ëÆŒ~òØLcq4JH3I=:Q?$<&!; /J+@[:C^;.H+ =/N.0O//J+,@$2<#NR;27!$,$*!  &$"$&"#+/$<&9R<-I0/L0)C('A$@[:0I+'9!%4!!2 1!4 $:#0H0+C+ 3 ,0#6#':' 1%3$/<+4A/1>,(6%!/"5!(;'&9%(9''5$$1 -8(AL<>F7<G7:H76I63H50G3*C-%='%=%(>'$7#%6$$5#%6$%8%"5"!2 .,0"3!(9'%3"+,+'3'$0$ '#(!(+"*-$&, !)"0!,:+ , #'#''"$))#0.;*(5$0?,+:'.('1&8?73:3&,()/+/40<A;8B:GQIGQI0:25?62<3/83%.)!*%",$!+"!+"%""%#/!&2$!+ (/'08-$,!;E=`idirokptY]h/3>()(3- *" '(2*'-)'-)180<D96@8&0()  *"-GRD9C8'3'\j]4D72D80@6'2,%   $ %8@3
+		
+	
+
+
+	
+
+
+
+
+$ ' 
+		
+.:."."
+
+
+#&! *" 
+$(5,(5+&
+	
+
+$ %0*.>4+=1#3(#1$'$"
++.%/2'$ 3>63C8.@4-B30A12C3;I</=0/?2):*%6&&9&(>'(>)):(*;+0A14E51?0*8))7(2C3/@0+>+0C/0C/.?,+<**9&*7&#-4-
+'''576384).'/9.1?.(9&"3! 1/@.'5&')9/+E<9XP;\S7WL.H;(>2.'(72+<4/C8E\JD]H5Q:(A,#8'&8()7(&4%!-&4%$5%%7');-(:,%:+&;,&6+'4*'4*%1'#-$!+"#.&.>35K>7RA>[I=\J9ZE4T=0P8/M5/H3.C0$2##. .1(03,-0')0('3)-?3-D2,D.):'+:%-:&)8#1D.AY??\>5R4.H-(B)%>(.F05K61D0(6%#1 .C0.G1&B)+I/0N6*G17S=7R?8SD?WI,>.' (&-.:&/A)3I2.F.&?)'@+.F6.F6)@0*A14O@2LA6ME5LB0H:0G50C0,;(39+57*35*28*:G5<M:.A.!3#!3%+=10D81G:.D8*>2+=/0B2;Q<@X>=T7=Q5=L5FS?TaP_k_^kbRc[I`XLg^`|pnä{káxdpd~srçÑÇûíÑ†îÄöçzïÜsé}c~m[vgiÑuÅûåà•ëÑùásãs_sZThMUiMThLNbFI]BJ]GL_LN`RMaVXlj^vv`y}SqsHhe=`Z9ZS8WR<TVJ]d]mzm}å{ãösÉíhzÑqÉçÖô§è•∞ñ©∑ê°±Äè¢rÅîÑî§xÖïP^iDSZPbdRecQ__V`_[fbU^Y4>6=G>EODEQCCN@<G939/)/%),%-4-<KHh|}â¢©ú∑¿â§≠Zqw1ED*;5(:.);-*:-/=.FQA_hW_jYMXH=JA?NKRcjpÇåqÖéWlq>WSE`YLjbLj^HdU=YCA[@@Z=6N46P59S60L35U@Mnc`ÑÇ|°™úº—£¿ﬁ†æ‡°ø„°ø„õπ›í±–â§øVk~&9@)<81C5;N;4$:#+B&6O1?X8,C)'?%-K/0O01K./?$=?)XS?RM721(,$  &!)& %("/D14M70J1*D+!9!8;V32M*-D'0G+4N53O63O6+G.(B)+C+2I58O;6M;-D2':'&9&3D25C25B0/<*/<+&4# 1&9%$7#$5""0*.:,0<.&1#!- ."3!%8%#9$"5!4/F,4K1+A*)<(%8$#6"#6##6#/*0!2 -#1  .+!.,&4'*%""&) %+! +%3$'5&",#& %"!#$""$$'+!/.=*(7$,*;F8JRG>E=$*&!'%&*).3/7<8284AF@OTNHOH.80<F>)3+#-%"-%",$(/(&*)!  $ *!2<1?I@)3*(*5']i[mymouquy|qt}05; )(.80 *!$-7/7@;8>>*./.0/9>:/51$+$#*# ' '%/$6@5'3'=K<$5%-?1.@4$/'&(/(&+%!&!!'
+
+	
+	
+
+
+	
+			
+
+
+			%+'/;/
+
+
+
+	 *"",$		"/&*:0#.& ! +%0=60A7(8- ,"%$)"(+$"#(!39-25*&) 
+#($8B:5B8.>30B6/A5/?28H;AND4B5+<,$5%):(%8$+>((;%,=+/@.2E24G40A1->,):(3D20A/&7%)<&':$$7#'8%,=*.<+%1%''-7.##%687051!( '2$@O<.?,#1 %3"+9(1?0!/"+<23NE<\Q:ZO/K?1I;/C8!2*'82+@76N@HdN=YB3L6 5"!2"$0"&1#'2"$/!)6%(9'/B/-?/)>/7O?+B2$6*'7,(8-'4*)5+*4+&0(,8..@20G78SB7VD:ZE7YA3U</Q6-K1*C-&7%#. %-".4*06*08+)7*0B2,C/+C-,?+%4!&3!/<*0A.4J5,D.&>(%8$ 3 "7$;P=;L:%4!5@0(5$3D1)?*'?'+G.4Q;8U?7T>/J78TEAYK-?1%$%,/8%0=)+>*3K53L7/H3.G4(@0&;,.B66NA1K@8OG6MC0G7,A0.?-.;)48*46),/$/5'?L:CTA,=+.*&8*.B61G:2H<.D7(:.(8+4G4@V?D]@E\@HWBO\K]g\htjeriJ[S9PF:VJIhY]|lcÄn\yg]uhg~ttéÉ{ïäuèÑuèÇqå}hÉrc{mmày|òâ~õá}ñÄoám`tYQdHQaDM^>H[?GYAM^KWhX[kaiyxsÜåsäífÅàSruGgd<]V8UP<VSObhiyÜuÖîâô©ãõ´wáî~ëòâú£Éö¢Çò£ã°Øè¢±Üï®}åüèüØì£≥Äéõl}ÖxãèvààvÜÖhwt]hdP[U;E=>H?AK@?K=>H=8B708-(0%-3'-7,+8/2C=I_]XrqC\Y/EB,=7(8-&6)(9),</)7*@L>YdTan\R^PERIM[\fvÉuÜñtáïPdk=SQ>XOJh`LlaNj\GbONhOJcF9Q7+C++E*)E,*G1AbQRwoYÄvö®à´øìµ–û¿‹û¿‹î≥œç≠ƒiÜò5KV/AE5D?,:-+9*!2 *;()<&-A&9M21C+%8")F*1P13M0,>$DH1JH3TR;GI3/8%+6&$' *(##")!) #(=T@0I30F1 6!-18S01M'%>8!;"">%*F/-F0%;$#9"+C-8Q;;T?8O;-C."5!'8%0?,/<*-:(-:(/<*$2!$5"*;():'+*+9*+9*+ .#4"%6#"3 0"3  1'>$7N4(>'/11!4 ,?,):($2#0.,$2!2>0$0"--"0#%"(%($'#)!) *#1"!/" *!).().'*/($)#!#%'%#"'*-*9&'6#,+?K=HRG6=5#)%,20@DEAEFNRQDIERTOAF@*0,(1,#-%%/'$/'".$5?6NUN8=9(,+&*+"((!'#/91JQI%/&(4@2fsarnu|tuyxbej/48!*'.80!( )0)9B=<EDLQU25:-.2021(-)+2+&-&$+$!(!'!+"!-!-0 +=--?/'4*",#;@9FKD!#%			
+
+
+
+
+
+			
+
+
+	.91!-!	
+( #-$!#)6-*7.!!!,&.;44A8,9/#*"',%(+$.4*/7(7?06>/#)#*#(/(2<3,9/3C80@5(8-4D:5B97C9;G9BP?*;((;(!2 !2(7$.=*/=,3D28K84G4/B//B.4E22C0->+4F02D.*;(&7$'8&->..?/+<,&4%)5)'%(***352',&%/$9G65C2 -$/+8&4B1'7,/E9:UL<ZN6RC(@0,A26J>3D<-B9,F9A^L9V@9U>+>* -#+#)),!&, &.,9((;'7J6,>.)>/8P@(@0#7+(:.$8,$8,(:.-?3+=1.@4.@2)>/)>/*A13J85Q;2R:2T93T71O3.D-):')7&,9(0?,5F38K53K3/G1-F03K5&;( .!!-#*7..;4$/)#.("-'#0'4F8;P=&7%.6H25G16H0&:!%;$,D,1M7:WA9VB4Q?9UFBZL,</&!%(,.5%+6%+$2%/D5/G7-F3%>+#8)/E85OD2MD7QH7MA-?3%3$/<+1:)15'24'+- -3%9D4:H7+9('*%5((?/-E52J<0H:,@4);-(8+3E5@VAI_HM^LXfWbnblxnmzpEWK-C6/J9<XIKjXXteZuf]rii~wqà~vêÖsçÄråoã|eÅra{npä}yîÖtè~rätkÇh_qWQaDM\=MZ<IW>LYEZfXkxn{äÖÜòòÇñùpâêZw{Hhg=]Z;XT=VSPefgzÄrÑéÅî£úØæåû¨j{ÉsÖágy{RdhYkupÇêàó™í¢≤åú¨áò™àô©àúß{èñnÅÖl}\mgKZSDTJ<LA3@61=3,6-(2'*1)(0%&.#-8*/<++9(&4'%5*&7-(9/&:/-A5/A5$6*#3&-=0.;1(5+7E8Zh[iwh_lbUd__lreták{íyåùEYb4HG6MGB`VLlaNl`Pl^Un[SkU@WC+A,(@()A)'@*.K7Fj\PunX{hçñwõ´Ö™ΩâÆ¡á´ªÇß∞Xy~C]^4HG(40&0()0(&1#*8'0A.,;&*9$'6!,>&,E(2O01P06Q2:J03=%1=%8F/8K54J5&9&%6$"0!/ %3$%3&)5++!) 6H<5N;4K7-@-('/4M-1L+ 4$,,"3#.)8%.=($6 )<&,D,-G./G-.E+)<&/>)2?-0;*3@./<*%2!$1 ,:)+9*!+"+!4D7.@0(;(&9%)<("3 ,"/!/-1<O9*='),"5!,?)-@**;)"3!*-,#1 -;,(6) ,  , &#*+#&' &% ((#1"+#$)#,1+6;5461(+$#$ +$%&)* *&3"%2!(%BND=G>&0' )$>GDW_a/47Y]\EJD,.)).(+5-$/'%0(%0(!-##/#DNCDLA;B:LRNJOR49=&+.&,*',(")!) *6(UcLp~guÄrx~zW\_).1"+&.:0 *!DNFU^]MUXMT\IMV47<(,-*1*4;3+0*%*$#*#( '(*%3$-?/,>.)6,!+"%*#16/# ' &
+
+
+
+
+	
+								
+	
+	& 1=3
+ 	
+
+!( $)#-80 +#!'"%0*.;23@72=5(/'.4*25,4:.3;,-6% (  %%,%)3*5A72?5&6+*:/4A87D;MYMWdS=L9'8%*;)0$0"+6&-:)/<+0A/9J:5F6->,.?,->+0A/,=*,>(4C.1@-,9(*6('5&*;+.?//@.-;,!!775DDD;;;461%*##*"(2' ,,9(*5%('4#*8)'9-7OB9UI:VH/G7$9*&6)0@59JB'<30K:>^G4R:/H2#1 $,$*&) ,/$&))1$/:*.<+5F4&6)-?31H8&>0&:.(<0"9)%<,%:+*>2-C6+A4-?1&8*1#0"#5'&=+%A+,J23Q7=Z>BZ@2E/+<),=*-@,1G0;Q:8P83M41J40I3/F4-A5->8.<<3>B>GNBKP*46-<7>RF4I8-+:'7I34H/8J08L3&9#-C.-F02N80K8.I8:VG@XH0B4!-"((,.5%=H8#-" -#-?3.E5/H5/H5#:*0F:5OF2LC:TI5K?&6).;)2;*15'46),.!,0"19*1>-#0%+)9,(=.*B2.F62J:3J:.C4'7*%7)-B/;P=K]M\n^_p`ctdbtdF[J+B.-I32O;6SA@[LRj]h|s}ëàÑôê~ñâsçÄqå}màu`{h_zkjÖvpã|lÖrijey`\lRN]@KX<KX<KWAS`Nhth}äÄè†òî®¶Éõùe~ÇKii=]\9WW=WXMbej|ÄráYgpfxÑ†≤¿åö•WdlR]aIWXIX]O`j^n}ãú¨ö™∫âõ©rÑíkäwãíuäçWklHXU8G@6C:2B7(8+!.$'3)&2(&0''.&#)%-"0<.+9():((6'&4%"0!#1")7(.?/-=0!1$"2'+;01>4#0&0@5Yi^m}rdtj`nnlyÅmzçl{ítÖï;NU.A?0E<=YMLlaPndPkbWobUk^8L@'<-$9&#9$"8#";(.M=Ij_QtnEiiEhnWyÇ_Åä_ÇÜ]Å_Äy`~vUofG[R:J@7C9(4(.<-LZI)6%)6$1>,:I2/F*1N/4S35T45L02D,5D/1C--C./G1/G1-C.1G2;P=BWDFXHEWI>PD7K?AXH2K88Q<'8& ."/"1'@#0I+1')6%&3" -+5D-;J33E-&:!"9&>$3K18O37I/6E.1>*,9',9%.;)+6&&2$.<-&4'&2(.</4F60E20F1(>):M76G4+8''2"+(+8G2,>&0&8"4G12E/-@*#4!'%"0!!/!/%3&$0$)&%'*!()!"#&$& .!-"#(!',&05/794-0)#((3%&'+!#0& -#*()"."".$!,$*4+*4+)!OZV^fh+35*0,*/)&+%!&  *"$/''2*%1'+$0"1<.08+EMBkrjbkjZ_b>CF288/51/6/'.&&1#3A*aoXrzkryqBHH'0/$/'-9/.8/Xa\glodioY`hjnwINT'--/6/?F>181%*& &"!'##-%#/%"."(6',?,,?,#3&* $!&$ '")0)!'#!				
+	
+	
+	
+			
+
+		
+
+		
+		
+
+#*#&	
+	%,$$/',7/!	!#(" ",$)4,&3*1>55B91;008+-3'+.#$* &		3:31=3&3)*:-/=05A5OZL_lZET?,=*(9'+<,$2#.8-/7**5%0=,/;-6D7:H;.</-;,.<-2C3/@0#1 5B1&1!,4'08+"*",!'5(.<-.<-% %
+#5<57<8.3-(-'!( ")!&0%"."*6(7E4%3")5' .!+?4:RE:VG6QB&8**%%/'>MF4J=A]F7U91M4$<&"0"-$,#),2&'-!)/#*0&*1)%/&( )6-0B6*>2*>2)=1%<,*A/+@/+@1-C6*@3*<0(8-$4).#,!/!/"9%,D.3K5<O95D/,;(.=*,=++@--B/-E/.H//I0-I2/J7/J;2IC4GNDVbyãóÄíú3FJ9PJ8PC/D30>-0=+0?*1C+8J20D+%8",B--F00I3,E2.F69TE>YH4K7(9&$-$+*2#DQ@8H;*?01F7/D3,C10G5)=11F=7NF3JB:QG7M@5H50B,7I13@,3:*79,--!-/"06(-8('",+<,+@/)@.*A/-F31H60G5*?.'<+,A0/D3=RAOfRUqZZx^UqXD`G7Q81K2/K43L96L?QeZxåÉï´üë©õÇöäräzkÜshÑm`|e_xeflgÄmd{gdwa^pVUeJIW=HU;LX@N[GWeTkyjÉìÜíßòñÆ°~ïèXro=[Y8VV8TXH_gas}vÉåor{KNW]ep¶∞∫Öâï;=IAAKMQ\kuÅyâñÇï£î™∑ó≠∫áõ¶váè`qxj|~cuuO_^3?=$/)(2*(4*,"(#/%+7+3?3+3(%+!$,!+5*.:,.<--9++7) ,&2$8E4+9*&4'"0#"/%&3)*7."/&.>4Vf\hxn^mfjuwsÄàxÑîxÖñqä8GLAPIH\P9TEHfZRphWrmràÖxãâTdc<MG(<0#8'$6&!3#/3N?Km_Mqe0MH+EB-GD)G?+I=6WFKl[Wyh\}jXweHaN.C25G7IWJ&2&)4&6C1@O:/C*/I,;Y76T29R4+?&%3"!-$4''9)(?+4M7>ZC7S<5Q;:UB7P=<TDDaO5R>4P:0I34J51B/,:+&52J0%9 (:"+:% ."16G%G\;C[;@Y;<S7'9!1%7*<".>$-=#(7"$3)8%'6#*7&1=/7H88J:;K>9K;7M80F/*;("3 (9&0A.+8''4#&1 %0%14B+.@&1E)7K/4H-(:$#2+'&".  .-(&&%(+ *-"#&#&%%'*%3$:E708-16/&+%160.3,%",!",!&(&2&)5)!-!"-"-'<F;0:1 *"1=3)5+$.&R[VX^\/85%.)#,'"($!'##.&%2)%2("0##1$'3%)5''2"2=/NXMLWOLWQIRO3<70947A9181*4)*5%HSBksdai^395%.))6,3A4KUMflhjnqhkp]ajHLU16<)///90@J?>D@(.,%#!'%%.)*4+)5'%3"*@)+A,#3&!.$!+"'&$##*##,'
+		
+
+
+	
+
+		
+	
+
+	
+								
+)0(	
+
+*5-)4.#&##-$(4*)''4-5B92>2!,  !			")"(4*0=3+8.),6+R]MIUA1>*(6%!2"/=.9E9JRE<D7,7)*5'+7+,8,<H>5A5,8,-;.5E85F6*8);G9&1#& *!&4%,:+*6( *$$ %%'.'181,3+%$"*%/$)5'3A0+9( .!"2'1E:>VI8SB-E5$2%%,$#% !(!3C9CZJFcG4Q3,D, 3#/!'/$+3(*2'-5*&.#'.&'1)(.*-612?82A:1B8/C80D8'>.%<**?,)>+)>-(?/&</'9+$6(!1$ 0#*!2"+>+-B/,A.)<)$3 (5#/<+7D34E3,?,+=-)>+)?*)A+-F11L;3OC5ON5KXUg{âûØÖù©@Y]5OL0J?(>1);-0A1)6H24G1+A*5 +C-,D,)B,-D2*A16Q@>YF;T>1D.$/$+'2"0>-8M<1H62G61F32G41F5-C73H?:QI5LD<SI8PB2G49L6<P77F/3:*57*--!*,,2$&.#"+!2"&8('<+'<+&=+)@.0G53H74I82G6/F42I7;T?BcFIlLGhI>_@=\=9X95R66R;<REbxlç•óü∑©ô±°ÅöámÜqe~heb^x[^v\_w_[s]YoXZnUZmQQaFIW=ES9IW@Q`M_m\qnÄëã¢éè®ïwéÑMfb9UV7SWC[gbuÉzåö|ÜícalROXZ^i§´µyyÖ<:GDBObfrÉëûãü™áü´Ñü®ÖùßÉö†ÑïúsÉÉ_olVgaAPK'#% $-("-%* (!-#&4'5A5+3(&.#$.#)5)-;.,:+2@1AN=!-"/)7&*8'&2$&2&#/%#/%&3*!.%2?6QaW]mcYhcfqsvÄâ|àñÇéúhu}<JJZj]cvc6N>B^PPnfSplÄïòõ¨≥m|ÅIYYAUL9N?2G6+=-*5#7VDWxeGcU&@3)A40H;(@0#>+?*&G20V=HkSWw`NgRWlYI[K+'3%8E3CR=8J4,E(FdB:Z59V8-E-"3#- '7*9K=G\I=V@9R<EaJ<YC2R=1N:4T?>^I3S>-I3&=)$:%'8&+"#6"3I2*>%%7#35D'GX4Mb;@Z5A\;FaB5M3*<&$3!0 /"1#2%4$3 /)!/5C4=N>L^NGZG?R??R>8K7&4#'!2 (9'(6%*7%"-"+.8 7D*4G+4H,.A%&8+&&$&++!/*% ('-!+/!$(  ('$%*#1 +9(0<.3>08?7 %',&(/'%,$(2'%1%(%!,!-!+(3%)4$&.!,4)(/''9E;#/%*6,FPHLUP2;6$/)'2*"-%&1)$1(%2($2%"0#$2#%1##/!!-"-",!#/%(3-)2/)2/'2,1<67=94;4.6+3;0NVIAI>-7.#/%0>/IWHblcflhfhgmqtsx~TXa16<%.-'1(:D9JTL,2.$**"(($*('1)*6*)7&/B,.A+(9)(5+"-%&(%#(%/&'3)
+				
+
+
+						
+
+
+					
+	
+	
+
+	
+	
+
+		
+
+
+		!'-#
+"$.;2)6,('''3'*6*+)#3@73C6)  "#
+*6,3?3(4( (;F83>.1<,0<.*6(9G8NZLU`PHPA1<.(4(*4).:.9G:;I<'3''5&1B29L9.?-6D36B4&$+# *&2$*8),:+%$ (! " !&";@:492$)""%!&*2'(4(-9+"0!*'7,7OA;VG5N;'<+!-!$+;0NeQC`D7Q4#4!& "+0*/90+8.0A73G>7HB:MG6JA3G>5JA3H?5K?&=-*A-/E0.A-)<)%7'!6''<+1H42G4*=)/)<)1G2.E1.E1#5%%#. )4&6A3>K:=L96D3,=+->,(:*'=0.E;6OLBYaPbxarå{ç£Äñ§>W\5ON5NJ6MG6KD.B7&;,5J71F34L6+C-.F0+C-(@*)>-5#7P=B[H=V@3I4'4 !,$1 ,=+3H52I50E2-B/2E26K:4L>6PE7PJ4MG=WN8PC-B11B/7J49H34;+68****,,0" ($$( ,"2%);-);-'9+%7)(:*-B17L;5L83L73L73L69U<=\=:\;7Z99^<9^<8[;;\?IdQgÇqâ¶îó¥†è¨ñ|òÅfÄg\uX]wTYsNWqNTmOThOPdKPdITgKObBJ[;HW:M[BTfPctapÅnxãwÅôÉÄôÜjÑyF_\9RYF]ki~ëÑñ™ë¢¥ÇãúfesQO\Y]h£™¥kkuNNXVZen{ÑxèópçìfÉãeÇàhÉäuçëÄìósÉÇ]mcVf[;H>"/&"-'#.(#.&#/% -#!/"&2&,8,*2'%/$(6'*;++9*)7(7F3AP=(,);%8J4+9('3'%/&#-%#.($/)9D<N[R]mbbskbpqràzÉîàóXfiGVO[nZ\r[4K9;SFMhaOlhrãè¢∂ΩrÄâ7FK:OH=UG@YF<T>+>*#9$)E/AaJWxe;ZH-H92H;&:.+=/+B0)B-(F.#D)1R7IgMc}dBZB-@,(9&1@-5B0@O<6L5HgGBfB7X;;YA1H6>SDPeTF[J1C3*(4I6@[HAaL@aNEfS3TA0O=&=-#5'&7'%3&&#"3!3F0)=$&9?P0J[7DX3?W3C^?C`D=W>*B*%8$#4!--!2!2(9&)8%*("3!/@.*;)<J9FUBGVC?P>BPA&2()*8)&7%':'3D16B,AK2CM2;H,0C');!$3!.+'% &*)!.) +(0!)/!#)! '&#$#/!2@/):(,:)-9+$ !&#*"#*"'1()3*'%( *!+ *!,&.!19,5=2%,$#-$)2>40<2KUL+5-!.%!1&#3()9.%5*$2%$2%$0$"."!+ )",!.9+3=21:5098058+35'10(21/537=97=94:62920:1,6+&4%<N8\nXdoacjbikfeihqvzU\b8?E'/1*4+6A3LVK5?7IOO=BE%),"(&",#'5$6E01C-+9*(4* *"%()!+#!-#1=3)7*
+	
+
+
+
+
+	
+		
+	
+
+		
+
+					
+		
+
+	
+
+	
+
+			
+
+
+
+	-3)#!%%2(-=0(4("!+ (2'*%+6.7G<(6)"'  ##$&% %$-4-3=4 *&-%/9.19,>I;8D81=1=K<M[JGRA?H75@2+6(+5*>I;:F8;H7)5'!.-;*8I71B/.=*>K:$,!"$%(!%$0$,:+-9+'1&!!!*,)CE@*-&#% .5-/9.&2&,$4)%9-7RC7TB0I6#8''3'""'1(;P?MiR:W;0H. .'$!#/838H>:NC;RH7QH1K@0G=,C92I?6MC6MC1I;"9'%='+A*(:$$3 &7',>./F26O94L4"8!#6"-@,4L62K6.E3"7&*)",!'3%2?.>K:?L:>M:<J;,</*;3*<<=RWcyÜdvéduèrÑúuàôAX`7OQ9NO8NK:OJ6KB5K>4K;1J71J5*B,,D..F.(@*$;'5#5N;>YF;T?-E/&7$#2+:'3D1/D10F1>T?.D/1F36M;3N?8TH8QK6OI<WP5OB2I74J5;Q:7I35<,68*,, -/"-1#!)'&(#/!&6),>0*<.%7)$4'/"1!(=*0G3/H22K6.J4.H/-G,,I+0O/3V54Y76[9;^>EfK]}frî|}üÜ}ûÉsëua{^VpMXsJYtIVqHPhFM`DM]CN`FReGOc@O`>M^>ScFZlTexbmÄloÖpuçwnát[rj<TTD\hd{ç~î´ë•ΩïßΩåô¨twäOPbTZhòû™aeqX_i]jrcx}_{RqvIflHcjRkrpáçÇïôpÉÅcsiJXK*7-&3)$/'$/''2*$0&%3&$2%&2&+7+*4))5),=-+<,+9*)7&+:'(7$()7&2F-,@''8&%3&#-$!+##.()4.CLGR]W\ib`olerxsãÄàõÄâòWefRcYat`ZpYCXG7MAE_VPmicÇóÆ∂n~ç(9C,@A-D<1I;8O;2E14G3=U?7U=FhPNqY>[G2K8 0#"0#(6')<).F..H/)E,0L5,F-+C+6N6/E.3E/(7$.<+9L88U79\;3V8=_FOlXHaN2I7+''-.@0";(4Q=DeR:[H6WD8UC9QC3G;+;.#3&$1'#3&-@--C,*=''; 0C%)<.C"9R22O3A]D2K5%='!6#2#1 #1 "0. .)7&,-'8&0,6D3?L;LYHQ_PO]P7B:3>60<0!/ "3#0A.;I29E-5B&3B%-?%$6  - + +#. *$')*"/$1 '2"*2#&.! ($""$  *<J9+<*$5#/=,,6+&#*"*1)",#&0'+5,(' *$'((3>06A3,4)%/$'+!"0#,:-+7-%1'$1',!#5))9,%5(!/"!-!*(!+"$.%%/&=G<T^UZ`\Y__UZ]CHL-57:DCBKHAGE<@?6<:1;3-9/+7+)8%AU<VhPQ^Mowl^e]`g`enm\df?GJ'0/&-&08-DOAFPG6<:@EH<@C"(( *"#/!6C1/<*(4(&2( *" *")!*" +#%2(2@3%5(
+	
+
+					
+
+					
+
+		
+
+
+
+
+			
+
+		
+
+		
+	
+
+		
+
+
+	
+
+	8@5)!!/""0!&1#%$%!7B:4@4*2'*0& #"#**",+&&'!%*# #*#291#+ .4*>F;4A7+;01B2:H75@0@H9MUF9A208+X`QR[H<E2/8''$,,7'4A/,9'>K:7?2-0'%$+*&('"$#()!'-#'1&.:.2<1!+*(%$"886!",3+,6+()6,+?30H:7VD5TB4O</D3* (&0(/=0HdMDbH2L1!7"&4'%/& *"( (5.9JB=TJ7SG1LC3OC1M?1K>0J=6PC5OB7RC+D1%=',E()@$*)6%/@.-B/)B-0I3/G/$:%(;(-@-1H4/F2-F3'>,"4$"3# 1!$5%-;,2@1<J9YhUIWH/<23???LTpÇéwäõQf{_qâtÜûtÜö\pyK`cAUVATRL]W?SJ9MA3K;1L;+F3)B,/I0/I.2L1.G18"2O=;XF7S=)A+#9$*='3G.2E/.=**;(:P;?W?4M71M72O=7VG:UN7RK<WP2N@1L9:S=?Y@8K54;+89++- ,0"*1!$- +"/(%3$);+&;*(=.(:,*<,*<,'8()<)+@--E/5Q;4P:,A.-@*+?&,C'.H+/N.1T36Y89^=EjKRtY\~caÇebÅa[vUTpHVsEYvFXsHWpITdIN\CO]DVeHQb>Tf@TeAXiG_rVey`dzed{gb{hYqcI][DY^`{Üzï¶~ôÆë©¡°∑ŒüØ∆ãë©NRkJPft|èVbpSdlRglOhlD`c>Z^C\cOep_uÉ{éúäûß}ëí`qk4D9'4+'2*&3*)5+&2(#/#)7*):*'5(-;.,9/0>1/@0,=+-;*,9((5$!.(+>*.F,'?%':'%3&!-#( #.()40LVUXbc_hmhr{}ÜóÉã†Äã°Ñê†ftw`qidvfYn[RdXAULBYQOjeYvtqäëctàDSh9GT5DI+;8,>23E50C0/E03M42S8CgKGiN6T<+%",!'3%,?+.D-(=*<Q>&9&2,D*6P57O5#9".*=*5O4;Z;6Y9?bDpíyqéx8Q< 5$($5%6D5*;+(?-5P=B_K9YD0P;;ZH=YJC^OAZG2I5'<+&=)&?)-E-%;$%8"%7! 22E/(>'?[B<X?,D."7$!4  3,+$2!($#1 0'8&%3$#"0#5C6,8,<H:N\KYgVNZN:D;(2)) ,#1 />+.@*$6 ,>&,?)!4 *!,"*)1$(3#$1 +++"/'2!$/(#!"%%($ $%0 '6#!2*;)):(-)(!+ ",!'1&((2'07/&+%"&) )5)-9+%3&"0#," -#,- !/" .!!1$"2'&6+%5* ,")%&( ,""-%$/'$/'.:0LVM_f_bhfHNN7?ADNMGPMQZUEKG,2.+5--9-):*,?+AU<6I36D3>J>@L@FRHW`]\ed.44&,*',().'>F;Q[PQWSRXX8>>"+( )$'1((2'!-#$/'3>6*3.!*% )$)#!,$#0&"2%'9+	
+				
+
+
+
+				
+
+
+
+	
+							
+	
+	
+
+7A6$%,%#-$) "+7-:F:*5'+1%+.%&'00(33+00(#$ $)#6=6'.&-4,8@56@55B8%7+,=-9G8>I9PVH[aSBK:4=,[dSiq\>F/)0""$!*&1 7B2@K;MPEFF>>;4ROHSPGLLBAD;,2(0:/?G<89196140-0,)+&#% .)&;74:63:9421,'("',%3;0'!+"*7-/E84O>7VD2R=6R<AVE%3&".$$0$->.KgP3O6 6!$&$1*0@66G?;OF:QG5QE3QE4PD3MB/I<)D5,F9:TG5QC;VE,E20H0/H+,C&#21@-0C/.D/#<&*C-(@*4$9&)>-%<((?++B02I7<N>;M=?QA@RB@QA3D40A/RcSBOE2>:@IRirÅåõÆXj~EWoZjÉzä£Åí¶àú•îïdwu]pjgxp]ocK`Q8O=6Q@3P<3O81K2/I.0J17S<5R>8UC9VD4P:*C-,D.0F10D++=%/<*0=+5F47J65J72K66Q@>ZL:UN8SL<WN0L>-J6;W@>X?7I35<,9:,*,)-)2!#.#0-;*%3$%6$ 5" 5"&;*(=,+=--?/'7*&7'):(0E25Q;8T>6M92E12D.9K3)A'/L./N/3T53V64W78[=AbCKjKMlJOjGRnE\yI`~Lb}P_xP[kNTbIS_GWdHXhDXjDYjFZkI]pT[rXXpZUn[NfVEZQASUXjtf}ãYtÖkÜõñ∞«∞»‡Æ¬€ò°æW\zNTtYc~Q`uL_nDZe?V^>U]DZe\r}uãòzè†âûØì©¥sàãBUQ(91'4-'4+(5+(4(",!'2$/;-.<-(6)*:-0@31A4/@02@/3B/+8&!-')&9%+C)/G-1D1#3&#/%!,&%1/+68S^bp{Åãó£õ¶∏û™¿çô±Ñê®ñ£¥Çêôfvu[lbUgYTe[M^VBWPMd^UolWpuM_s^nán}êIWb6DE(707I;/B/.A-+A*)E,.O2@cEBcF,B-"0$0"+8'->+2H1)>+ShW"3#.3*B(5O4(@&"5!"8#5M54Q51O39Z=;]BQrW8T>/F4#5%(:*):*'9)1J5B^H@\F4Q;'D.,I59TE6Q@;T?B[E9U>2N72N5-G.#;%%;&*=*)<)&;(.E1LhQA]F'<)$7$!4 0%3"%2!*#($2!)<(*=)($'7*7G:+!2>2BP?IXEDQ@=I;.6+)1&%-"*"0!+<*+>+%8$'=(!4!)'#+-5&)4$!.+$0"%1#"/(5#"-$%&'*()) $!.-1*=*!2 -$0"!,#. !+ '/9.6@7271%+'!(! *! , !/" .!,+!," .!,+- "2%"2%'4+ -$#$#$(!,$&1+&1+%2+%0(&1)7A9djf?ECGPM<EB=FC6?:286)/+)3+/;1*;+-@-;Q:,?+'8(2@3CTDTbU_jbAJE"+&.40051-2+:E7[eZV`X8A>%.-"+("+&2;6!+#%0(:E?>IC'2, +%&1+%2+/$!1&(:,*<.	
+
+
+		
+
+
+	
+			
+
+	
+
+	
+
+
+
+
+		&+$,7''!& &.#( ' )2>0+6()/#03*34,66,88.55)--#  (*%7<607/8B9=G>4B52B51A4/"$0$5@2AG9IM<IM<@G55A-:F2U_G=E..3#'!'*5'4?/KQC=?2SQEa_R_^LUVD;?103(ILA\^Q][OZVK\XOXTKTPGSNHTOIYTN\XOZXLRTFGN>5@23>0,2&&,"'.&&3)/E88SB5R>+H2;T?8M:0A1+(CQ@;N: 3 +'.?99NE6PE6PE7QF5QE1K>,B6&:/2'1&/G:9SF5QB8SB$;)"7$$:#*A'0G+5L0,C)-E-":"(>)%;&+&;*+@/-D0*B,&;("4$(9)+;..@21C37L;9N=4I:K\RAMK:CLOVhàêßàóÆhxëp{ôxÉüÉé™Ñì¶}êóxéåuåÇzêÉsàyj|lqÑpJ`K9P<7P;<XB8T=2K50I3;VC?\J8UC7T@5S;-I2-F0,B-+:'*7%:E5FNAAK@6@53?14D7:PD@ZQ:SM9RL>XM0K</K5?XB?U>7F18<-=>0-/"*. '0!0&7$1D0)<)"5"!4!#6"'=(,B-+@/+=/ 0%* &2&/@0/H37T>7P;6M95K6/E.'?'+E,0L30L30M11P11P02Q18U6?Z9A\9Kg?WwH_McÄRazRYnOQaFTbHZgK^lK]mI^mL[kNUiNOgOHaKB]J>VI<PNHY``r~_rÉ0F[mÉõü∑—∑œÈ∑ÀÊ†≠œt|°`hèZcäP]HWvFVoETkFUlRcwnÉñã•∂è™ªë≠πéßÆMbe*=;%60&7-(8-(4*#-"%- /7(0;+-:)*;+/A11C30A1/=,.<+7H5(9& ,&+&9#'?%&>$':'"2%"-% ,*'585CLrÉçñ¶µõ¨¿ö¨¬ùØ«ò™¬ï•æ†∞«ù≠ºqÄá^nm]nfXi_SdZL]WL_[UlfH`b/ESZoÑè§∑{éúJY\>MH6H:)<)%6#-?)$7!6(G(DcCMjK4M/2E/.@*(<#*B(0L5SlW$9(-),-C,4L2/G-+E*1I/-E+.D-2J20N46W<6T<-I3*A-)>+&;(/F2CaI@^F;WA0I4/H2,C/4%$9**?,3M43Q50Q42N5/H2%='#9$&9&%:),C1IeODdL>\D$9&):((9&(7$$1 &"'*$5")?()?(-)-?16H:*,8*9H5>P8>M8MZFR]LEM@4:0*0&&0%$0$*=*&;(%8%"3!('$,&1!&1! ++7)*6('3%". +))!+  (#+ ("*!+ ",!! !(!/ ,"5"!4!%3"!-$ (''/9.?I@?IA<F>'1) *")  , ".""0#* ,!+!)&(!1$"0#"-%*"'%%&( #.&(5.,92.=6)81'3/*5/0;3>H@T^V>D@X^ZY_].23?EE*0.$.&%3&&9&'=(*=*'7*)6,,</8H;@MC-80*"9E;;E<,6+7D3NZLS_U2=7+416?>%+)(1.%0*6C:LYP2?6"-'!.'(8.*<0*>25J;6K<(=.
+	
+
+
+	
+
+
+
+
+
+
+
+			
+	
+	  ##" #(-&"*# &, *0$#&"#*"#+  " '  %-"+3&-3'03*67/::0<9055)//#**""#3950:27A8:D;1=31?2:H;)7*&()1&28*8<-=A0:A/3?+3?):D,;C+49#*-"!%"*$,5=.?F6]_Q^_O]`KJM:15'BE:Y[N`aShfYfbV[WK]YMZVJ\XL_[Pa]Ra_R]`ORZEAM93@.-:)@F8CI=4<1%3&0G58S@2K6#:&,A.2E24G4%6$1@-AP=*;)) -$5B;?NI=PJ6MC4NA2G>(>23($!*!%2)):06KB8RE8TE0K8'>,3 1 6.G*@Y<-E+'>$+A**@+2G4"7$%:)&;(7O9,B-#6#*&*-0 1!3#(9/DSP@JSNWh}á†°¨ ¶µ“©∏◊©¥‘ö•√íû∏ê†∞pÉâSjdd{qvårÑvnmpÇl_q[BUA7L95L8;R>9Q;6O:<WD7T@1N:7U=5S9/L0(@*%8$*7%'2!>F7U]PMUJCK@7B40>14I@?YP=VP<UO>XK1L;8T>A[B=S>7F3<@1?@213&&,&1!!2'<)4K7*?,#6"%6#(9&1D0/E0-B/,A2+<2"2($2%5F6'>*3O86O:1J55M70H0-C,*@).E17N:4M72L3/L00M/3M06Q29R2@\6Ji?WwH`}Q_yRVnNNaETbI\iO`mOdqSetW`pVReOG_I=VA6Q@3J@EYX]nv`rÄSfw0EXvä£§π‘π—Îª–ÌßµÿÑê∏o{•nz§lz°o}†vÉ£{Ü§r}ôTb}HZrezèvê°}ó§uåí3GH%86&71&:/+=/+9, +#+17)08)0;+.?-1D1/A1.?-,:)(6%&7$#4"-;*(*2!7 %;$':'$4'#0'#/-.@DrÑêùÆæÖñ™l~ñ{è®öÆ«•π“ùÆ»ö¨ƒ¢≥«àò•gvy\liYjb`qicqqP`_VjhG\_%8FWi}}í•ò™∏p~ÅBOH-=0--#2"3  3%?"7T5HfD-H')@&+?&';"!9/M5NkU&;*.'4#(6%$7!)A'2L1.H-+C)6L59L8&<'!;"-K17U=6R;+D/+B.1H4>WBB`H9YA.K55Q:6P74L61D1*<,1":$/M13R31M4-G.)A)$:#4$;'B]JGgPGgO2P8 5""0!/!.' !,,'9#&<%0F/*;(%+@//D5++-<'1@)/?%4B)CQ:Q\KRZMIOE8@5,6+#1"%7'#5%"3#))3((3%%0"$/!'2$1<.(4&%1#!-!/"* , %1%&.!#+&!,!+ ",!%#"". (.2-$%%&#-%,6.9C;CMEXbZ)3+!+# *!* %1%*6*!.$," -# ,"+!!-# -#+!",$"+&'"&!&!( ( #0'+811@9:KA7H>1@;.;4$1(.:0AMCFPGYc[Z`\$**JPP*00#,'!.$#3&&9&*<,-:0,90)9.*:--:0,9/'4*+8..:0(4(+8'6D3LYO9D<AJGFON$**%.+5@8=JA8E<$1*!,&"/&(8-2D68M>6K<1C5'9+
+	
+				
+
+
+						
+
+							"$$"$$ '%1#-8(/:)+4##)%!( "#-$'%"*,':=68;2893780>>4;;186*+)(( $%  )&7D=3@72?5,6-",! *<D9$ ##+ -5*/7*39+07'/;'0>'/;#3=$6;$(- " ""%%+)1$1<.:E5DK;HO?IP@7>.17)IOCWYLZ\NabT[\LTUERPATQBWTEWSG_`PbeRYcKFT;7F/,;(6A1DJ<9?1.6)1?0;WA;W@-C.$3 ,9(/=,0C/4G1=Q88K5@S?=RA<QB;QE<QH;PG7I=.>3*5-%/'!(!%*92<QJ5OD=YJ+F3-B/-B/?TA7!-C,-D*-@*0C-*@++A,;R>'>*$7$!4!7O9,B-"0* ++6%0?*+:',(!*'1:ANYkäò≤ö´«ë§ƒÅîµäöºó¶«õ™«¨º”úØΩnÇÉI^WK\VhwpuÇ{mzpgvc]lWRaNO^KN]JHYFJ]I@XB9R=3O83Q98V:6U5,G($8(7"0=)(5!0<(BM<MZI>K:9F51B25M@>YP<WP:UL>YJ5P=?[D?Y@8N9=L9BI9>B3-1#'/ $1 0(=,6M9.C0(;''8%"3 $5"*=*0E2.E32H;5I=I[K8K8'<)-B/3J60G31I30F/+>()<&*=*1F57N<6O<5N;2K56N46O14M-5P-;Y5IgASqKYtQSlLMaFVeN_mVerXiv\hv]cr]QgRBYE:Q=2J:6KBQeddw}ewÉ[ozG]kuäüú≤ ∂ŒË∂ÀÍ§¥ÿäó¡Ñëªáîæèü√ö®À¢±–®∂”†Æ…âó≤alàEQk?NcAQ`>MT+;;%52&7/';/*?0;L<,:)-8(.6',5$2=,6G40C0,=-.?//=,0=,:H76D3,:)+0-2#6"(:*'7*&3)%4/ATXÖô§tÉñS_wLWsaoåùÆ ®º◊ô™∆ê™Öó≠ö¨∫ÇìöXhh\jjn||ÄãëYfnN_fi{Ö\iy]hzam}tÅäiusDQG&4%'6#$2!)7&&7%#6".E+4K/+C) 7&8"'9#%7!2,I3GdP"7&,)8%1C-';"6M32J0%=#)A+4L6-B/%:'!9#)A+>WBB[F9P<-B/8O=@YF=ZF0P92R;;[C>\BA[B@VA4I6)>+&=)&?),F+'A&(A$*C&,E(6N47S:JjS:\DGiP,H1-)!.)'')*(7$*<&"5(;%5G1/+@-(=,)$1 /<*-;$-9!,9,<"1@)@M9LWFMXHDOA5?4,8,+;.(8+#/#1;0&0%&0%*2'.6)08+'2""/ -+( .%1##/##/!"/$1 +(# ((.#4!&5""/#. "*)!2;82<;6?<DMH@G@%+' *"$.% ,"#/#!-!",!#-")3*1=3#.&!,$&1))3+292:@<4=:%.+'#)#* *7-2?5/?49K=>PB:KA6F<"2'2B74D7?OBZfZLVM5>;;DC*43-84"-'#0'*:-4D76C:5B;+;1(8.*7-*7-%5*&3)%1'%1'#/!-9+HTH=I??EA<B@)2/9D>ANE8E<%0*$/)(3-%2))7*0A13A21?2-=2)9.							
+
+
+
+
+
+
+
+
+
+											
+
+
+
+
+		
+
+
+
+
+
+
+"#!!")5+)!+# *")5+/=.,:)%4!&&%&'1(#-%$$% ;<7BC=AB<;<488.77-:8,0-$%%$%%(&+$"%+).;4.=6)6-)!!#(!+0*6=5-7,.8-*5'.9)0=+.<%*8.:"3=$)1# $!&*&, )1")4$0;+*5%+3$.6',4',4'4:.6<.:>/?C4=?1?A3AB2A?0DB3CD6CF5@H3;I0<K4/A+)6$2:+7>.CI;?J:DUCIcJ7Q81@+*6"9A23>.(:$1E,4K/<S7DZEBWD>UC;RB5I=0B64B58B7270:=6DE?9:4/2+160,7/4E==TL5QE<YG-I32H30F1>V@0H2-E-)?(0C-0!4 )>+2K6%>)%:)%:'9Q;-E/"0)*5$7B1/:)$/##%*08?Ocoáâö∂äüæxè±Vjç~ë≤°±“©Ω÷∏Õﬁä°ßezsNbWJYRlyrìûö{Ü~hveds^cp^n{itÅokzg[lYDWC9Q9:T;:T;6P34O0+D&*<$.=(2A,'6!/<(>K78G40A.3D23H7:TG@^T>\T:XL<WF=YCA]D8R9-B/=K:EM>@F828**2##0 1!(=,7N:1H4'=(#4!.-'8&0E2/F20G76M==TB6K8*=**=*-B//E01I3/G/':$!3#4""4$-B37OA;SF;SC9R<;T79R42K+2K-:U6FaBOjKMfINbIWfQanZht\lzao}fhzdSiTBYE7N:0G76L@Qfa]qri~Éi}ÑQgrlÅîó≠ƒ≥»„±ƒ‚£±÷êû√èõ¡ì°ƒ°∞—¨ªÿ¥ƒﬁΩÕÁ∫ „Ææ◊ü´≈Åå¢ZfvFPZ6AG)77*94):0);/-?14E52@1/:,)1"+3$0;*4C0->,+<,/@06D34A00=,$1 + .,=+%6$&9&,?,,>.'9+(5+$3.0CG>P^Xg|ÖìÆêõªíüø©∫ÿ™æŸú´»Åë™k}ëâù®é¢£_rp`ppvÑáò•ÆyÖëO_néû≠¨∑…îúØo{ãP]eISR5A7#/!(5$-:)0>-(9''8%.A+4K1,D*!9#9" 323'G/DdM/, 37J4,?)8L31D.2E/0F10E2+@-+B.+B./F2JaMg~jMbOG\I]tbYr_E`M?\F9YB3S;1O7$='43 '>*&=)'@*1K21J--F(,E'+E(<V9LjN:\C2V<HhP+G0&9&%1##0,(+"1$3+='$6 #5"42D.0C-/D1#8%,&4#)8%+8$.:$0<$/=$,:!-;$5A-<G6ITDFQC9E9/?2/?2-=0/=0+7-'1(/4-17-+3&%0""/!//"3#%3$ .$0"*8)(6%(6%+%# '&&--;*(6%'2$$.%*&<FGFQU6@B@IFDJF.40%,%)!%/&%1%#/#(2'2<15?4-9/"-%%0(<F>4;4DJF=C?W`]8A@&1-*$!,$)6,2?5.>3/?23E77G:0@5$1'1A62B5/?27C75?6W`[9B?&1-5@<'2.#.(.;2IYOKVNITN/<5%2+#0'#0&+8..;1%1'".$ , 7C5JVJGQH173064<EBALF=JA-80'2,3>81>5(5++7)9E74@21=13@6-:1		
+
+
+
+
+
+	
+			
+
+
+
+
+
+
+
+
+	
+
+
+		
+		 &%&#-%#/%((%1%!-!$ $/''4**8+/"%7'*<,, #) $%/''1)#-.)>?9EF@CD<AA7>;2:7.30'++#)*"),#$* 16/5?6-:0,"!#% 7<57C7/=.(6)(9)):(*;()8#)7 0=#-7#+!(!(")*0"4=,0;*&1 !,"-&1#%-"&,")/%,4%-6%-3%26(6:,46)24'57,37)-3%3>-9F24C.0=+9A2<@2;?1:@29D4ETA?R<2D,5A+5=(<C31:)+8$-A&-F(2K-5H27H59H55C21=/1<.6>1;A5=@7>A8EG<IK@FI>BJ=7G<;SF:UL5UH4U@3Q9.D-'=&<U?>ZC2J20F/2E1$5# 1!)>-2K8!<)&=-,C3;TA5L:)7&.;*1>- + ($)"!$'-3?X`u|ä•âö∏äûøÇñπÜòº¢µ’¨¡ﬁ®¡’°º≈b}xOfTL_KL\OvÉzèúï}äÅkyhcr_fxbvátÄé}_m\L[HAP;5G/1E,/B,.B).B)-A(,=*.?,->+):'->+2C01B/+>+*?.3J::VH?_T<ZR;YM?ZI?[D9V:3M4*?,9J:ITFCN>1<,)4$%0 "0(;(;R>4K7%:'0 .!/ ,:)4E24G3-B1.E51H8-B1'9)/A1=R?AWB;S=6N8-@,*;($5#0  2$,B67QF8RE>WD>V>AX;;P14H,3J.9P6CZ@E]ELbKVgT`m[eq[ky`oÅih~gXnYH`J9Q;2I5<QBMcWWnf`{vYsrG`e`uÜïßøØ¿⁄¨ªÿù™ ëúºëöπïü∫ù©¡©µÀµ¬’∫…‹πÀﬂ≥»€∞∆‘•∑√Éêò]hl@KM-<9,;4&6+-;.-;.+7+,6++1'(.$,2&*2#)4$)7&,=-/@05C25B1:G61<,$/'4#->..@0,>.,>.-?1);-'4+"1.(6?<K^äö≥°≤Œ®∏Ÿ©π⁄™Ω›™Ω€õ™«ï•ºuáïlÉjÅ{Vkd^qozâé®∂¡¢Øøàï®ò§∫ó£ªèû≥°≥¡ÖòüU`b5@<(4*)5'+7),:)%6&(9'.A+:Q5B_A9X83P2/L.+H*$A#+L/A_E2.!7">T?)<)->,7F36E24E33F30E40I64P:,H29U?VoZOaQFYFàüãiÇlJfO1M6)B-*C0/F4+B0,A0-B/0I36R97U;DaE-G*-G**D'$>#B`FB`F3S;1Q9DdL.J3"5"*+))#0"1+=''9#+&5"-/<*.=*2H3#9$"3 '8&(9))7&.9(2;(09$.7"-6!,5"(5#0?,8F5=N<5F4/A1BWHEYM?OE6A938205/'1($0$". !/ %6$"3!%3$(4&&4%&4#!0%4!'#$#&%%'*8)'5&$2%(5,,-KX`kyÑ8EN7?ADJH>D@*1*"'!*/))1&'2$0;-AM?4@4!-#*"(1,HNJ062U\U,50Xa^7B>(1.!,(!,& +##/%'3)'3)*6*-9-+7-,8.,7/,8.%1'$+#181JSN:C>%/'MWO7=9)2-#/+9HABME;F>1<6 +%'(,8.1=1/;/2<10<.7C5@L>NXO9?=066@IH5@<)4.%0(1<61<4*7-%1%/:*AI:=H:3?33@6.;1
+	
+
+
+			
+
+	
+
+
+
+
+
+
+
+
+	
+		
+		
+
+$%$$0:12>2"0!(($2% , #% ,"#0&,'-!0D80D8.$ 0&5B9)6-%1'$!&&0((  "#23-<=7HH@MMCJG>HE<==3<<235*)/%/7,@H;3?10>1!()$3817A69G8/?2&8(+>+2E2(7$(7".<#-9!*3'.%,#"))2!+4#!,)(!+ # #+ )4&(%+!#+ %0"6C22?.#0#. (+ *-"-0%,2&,7'.;*,;(1>*:F0;D/<C35>-/:)2A,-D()B%*>%3B-3@.4?/9A27?04:,7=1=C7EK?KOAHL>HN@FQA;PA7SD5SG9YJ-O7.L2.F.0H02N5;W>/G/5K4;N:2C1!2"-B19R?6Q@>VH<TF=XG<TD7I9<M=0@3$1' +#$-*,525?A;GU}å£ê°ΩåüøáõºÉó∏ç†¡°∂”¢º”ú∏ƒwìîMi[E]ED[?DWCxây|åsÑtgxe_q[ViS`s__m\O]LBO=3@,4C,+:#%7!&8")<&&9#$:%#8%$9&$9&&;*&;*(;(*<,)>/.F9;WKCaW=[S?[O?ZI6R;6P55O4,A.8J:SaRMYK/<+)6%,7&%2 )<)>S@5L8%<*.*,8*.<+2C06I5-B/'<-/D5.C4*?05J9H^I\t\B[E2K5,B-+>*+<*):*&6) 4(-D:6PC?WGC[EJaEK`AAT8<N4:L4;N8?U@I\IRcQYhU^lUbqZfzaayaZt[OkREbFA]DOhSVo\NiZKg[E_\@Y^`uÜí§∫´ª‘ßµœõß¡îû∑êñ¨èñ©ìö™ü©µ™∂¬±øÃ™∫ ¢µ∆û∂¬£∫¿ïß©sÅÅM\Y3B=(5+#1$.:.:D919.,2(,/((+"),!(."+3$.;*,=-->..<-.<-8C5:E72=-*7&#1"/ 1!$5%'8((8+(5,#11)7Bhwå•∂–¶π◊´ø‡°µ÷¶πŸ£¥“ì¢øñ¶Ωas}H\[A[PGaTQgdâú†¨æ»Æøœ•¥…òßæbnàFUjtÜîú≠∑åôüWcc2?6*8+'5&)7&'8&->+.A+:S64Q2-O./N/1P13R24S32S46U6/I0+C+.H/8Q;#:&/"5".?-/B/M`M:O>1H6+D1(A..G2H_K\q^ZmZmÉnUmWHbI:S=-D0)@.&=+)>-"7&%<(0L36T:DbF0M17%=#)C(1M4GeK6T<&D,;YA<ZB3L6(=*(" %#0!00?*,'$2! -)4$(5$.A-&<%%6#!2 '8(0 +6&09()0/3"-1 )0 &1 &5"'8%3D15F4?R?ezi_vf[maP]S:A:)0)&0'%1%%1%#1"'5&(6')5'++$2! 1"3!)&&%#)"#)$2%&3)$3.#27AR\k|å@P]*599BAAGC;@<13002-(-&'/$(3%)5'".  , 0:18B:395,2.LRN'0+KTQ;FB$-*#.*#.($/'!-#'(!+"$.%)3*1812922920701816=63<7)3+'1(5<46;5JPL'10'2.2=7OYQ5>9(#( $.&#-$%1'.8-/;//;//;-4@2JVJGPK2;:0:;/98'2.-:39D>-:1$1'(6)1<.;F8:E76B60=3/<2
+
+	
+
+	
+	
+	
+
+			
+				
+			
+	
+	!$#"(2)%1%+$0$!-!(6'".  !#" ,"(5+* !%6,6J?0F:3'(<12C9&6+%
+	$.%%/&",$"')  &'!;:5BB:LLBKK?II=LL@GI<;?1*0$?G:1=17C7'3)-/*9>7:@43>.7C51B2.A./B/$2!$3 )6"*6 *3 &-$( !$,#+"-"-!+ '&",!)3(%	!( "/;/1=1!!#)")!##. /:*4A/2?- +$$**5%+=',@'';"(:$)6$'2",4'/7*0;-0;-2=/1<,5=.2:+5=.8F7<TD8WE4SC6UC)G/-I0.J1-I0,H/2L3,?)CU?9L6=P<*=)-B/:RB3N?5PA;VG<XI=YJ?ZK<WH=UH8PC8MD:MG>QM<PQ>P^äú≤ó¨«ç§√âùæç†¡öØÃû∂Œé´ªlâèHcZB[F?X:AZ:BY<]tX[oVWkRRfJQeJTfPN_LHVEQ^M>I9/<*;J3?N7*<&,?)4K11I/.F0'?)$;'#:(!8( 7'#7+#5)#7,,A8=WNB]T@[TC]R<WD0L3-J,0J-,F-8N9QbRN\M/<++6%2;*%0):(=R?6M;!6',*- .-@,6L54J5,A0.@45G;3H9;R>GaFKeH6S7-G./H2,D.0C0->,!2" 2"';/3I<;SCAZELdJXpPWlKReGL^DCU?@Q?DUEM^NRcQTcNUdMXlSWoURqRNqPKoKLpLRsTEfK:WC6RF8PPG]hrÖñó©ø•µŒû≠ƒõ¶∏ô¢±ëô§çîûëïûóû§°™Ø†©≤âí£n{éyåõÅó¢Äïòk}NbY/?4-9+4?/;H7CN@.6)+1%),#)*",.#,/$,2$+6&+9*.>1/=0,:-2<3?I>LXJHTF4?/%2!$1 *8',:))7**7.$236HTî¶º´øÿ™ø‹™æﬂ°¥’Øø‡†ØŒë†Ωî•πFZa1JF/K=A]OQjfï≠Ø™æ«û±¿≠¬’´Ω”ëùµYaxFO`kuÅíüßUed3G<2D6&7'(6%"3!1C-0D+9P41K.$A##="&@%(E'-J+0O/0O03R34U83V8=_D:ZC4Q;+G1.G2.G1,C/+=/(8+0@34D7);+F[Hezgat`N_L;M79O8A[BIbLD]H<U@5N9&=))B,1O5CaE7Q8$:#/2)C*EaH=W>.G13MfP8Q;7!0C/*;)%'2$(+4A-%$!.!.#+.9)+<)&9%"3!+(6%"0+.9)+1#15&13%+/!#+(!.(7$,=*8I6=P=;P=DWDJ[KP\PEQE?K?8D8+7-*4+-7,*4)'1&%"."$2#.!2 +%'##! , #") -#&3,&444EMFWg^sÑEXg1@E4@@?ECDIE;=:*,) "#!))(&2$FQCPZOBHD.42*00$**8A>?HE,73%0,%0(&3)%2()$#+!'1)%*$*/)-2,/6/181/6/)2-%.)#*#")").'8=7:@@,222868>:'-)!(!&,(062)/+(##.&$1($1''5(-9+AM?P\RHSO6AC0;=-990?<;HA-<5*:00@68E;:G=7C9/;1(5+*7.			
+
+
+	
+
+
+		
+
+
+
+			
+				 
+
+#')() ,'#/#$0"+9(+8'$&"&0'"-%&,=35M?,G87*4I@4J>1% %/6/&-&#"('3)'3))" ,"$% 45/>?7GI>IK>PQCIK=FJ;9?1+3&4>34@44@4%/$ $)# % #*#+2+$+#292?F>?G:1<,1=/1B2+<*+<*(6%!/#0#0&/'%%+#+&.!&1#!+ +%1%)5'$/!$")"%%1'4@6"#% +0) .9+,9(+9(,8*-3)'2"(7$*<&+='+:'$1 *#-"1=1:F88F7:H76C23@//;-.>18SB6UC5TB5R<2L32L16R94P71M6-F0+>*0A./B.<O;6I5+@-8O=7O?,D4)A1,D47O?5PA7RC:RE:RE:QG;RH7PJ2KH;RZtãõì¨¬ì≠∆í™∆°π’©¬ÿö¥≈oåîEcaC^MIcHA[8A[6?Y6C]:F^>BZ:I^=ShIOaIFWDBP?BP?8F72@/2D.;N8+>*2H1>X=<Y=9U<7S<4P92M:1L;-H9+C6'=1%:1-D:@ZQC^UAZTD^S9R?)C*)C()C&-E-7O9J_LK^K5D1.;)3<+*5$'8&7I94I:"4&!1$'7*%6&*=*.D/3K57O94I81C74H<:Q?C_HIhHDcA8W72Q22O3'A(3/)<(&9& 2$4%5L<9R=F`EZsUhÄ^kÄadv\[mWO`NEVFHYIN\KO\JN]HN`HKcIHgHHkJLrKRxQLpL<]@0M9/I@:OT^qÜò¨ù≠ƒö™√êú¥çô©íú®êò£èñ†ìó†îò°îõ£äêúel?G^FUh]o}at{ZllIVO2<1DJ<NRC6>/,4')/#(+ %(,.#03(.1&'/ (3%*8+.>12@3'4*&2(=I?WeVYgVN[I>K7=L7BQ<9H54B1,9/"21@T_†∑…¨ƒ‹™¬ﬁ§ª⁄™øﬁ∂…ÁùÆ»ó©¡ÖòßAY[;VO:VG5QCQlgïØ∞ô∞∏Zp~°∂…∂»ﬁ≤¿⁄ö§ΩyïZaqXbl/=@(913E7+<,!/$3 ):',>&+?&1I/$<$2/49$>!*G)0O03T75X:5Y=4X>5W>3S;:X@:X@5Q;1H60E6-=0*<.3H70G33J66L7TcNTaM2D./E0/G10I35Q:?[D;T>0L3=[A9U<'=('#/?XB>ZA5M7 6!8"PiS0F1*$7#0C/-9+&**!,$/"#) -'(3#'8%(9&-(*8'%3")%0"*2#'-13&,0" &) -+:'*;(.?,2C0*;)!2 +<*>L=KYJM[LGUH6B80:1)3*,4)-4,(/'&2(!/", .+&$%%( "$/'#/+$30?NQJ[eFYhQfwRhsQceETO>ICDMHCIE051 %!#&)&1!>F7MUH8?8GMKJNO,22)2/BMI5@<(3/$1(!.$"0#, ,  *!",$$*&$)%+-*162/4.070.40*0,%.)'0+.5.*/(AF?cig=CA/85&1+ *"!+#7A98A<,52'2.-:3!0) 0&#0&(6';I:P^QZg^XdbJYV8HE5F@4E=;LB=ND;LB6F<1>4-:0+8.,9//<2
+
+
+
+
+		
+
+
+	
+				
+
+
+
+	
+	
+
+
+
+
+
+			! &("/(6'!/ #1""0!)5'-9+*7&%2!''!"/&2I95P?/I<,F;8RG4J>+!"(/;/5C64D7&6)*"&".$(5+$4)"2',.);>7=@7DF;KK?HJ<KO@19*0:/:F:;E:3;.17++.%!"% '(2)/;10>12?54D7:K93D2.?/&7'$5%0>/0>-&3"$1!.+4!"+)#+!'#)'-#(0%'3''5(*8)+7))4&%+!'*!),%(-&#-$#/%&2(*6*6B6,6+ !&)" %#2:/+3(.6+-8(!.8F5'3%!14+!+9(9L62E1.A--#2@3!2"7J7-@-*;),</,A26SA5VA5VA2O95M52H1=V@6R;7R?;SC9P>-B1&8*0A1EXE4G46L79N;&;* 2"&7%BSA7H6*;+3A44D93E94J=4KA0IC6NNG`eqçòñ≥¡®≈◊™«Ÿö∑≈{ò†MijC_SGcLMhIIc<Gb9Hb;E_8C[7E]9Ka;Ka=EX<?Q;5F44F63H94K;6M94L6-D00H28U99X99Z=7Z<7Y@7YA7XE8YH8WG7VF4PB5QCC_SB^RD^UG_R5L:&<'(;%,?)*@).F.LdNZr\BU?->+*7%&3"&4%):*)7*$4'%7'&;*(?-)B/)@,1J57P;6O<3I<1H89V@>_DEiEAg>9]75Y33U2-L,+E(-E++B(&<%$9&"7&+B0/H3;T>RlQjÉesämuâpoÇnbubSdTLYHPYHV_LT`JTaMM`JA[@?^?FhCImGEgF6T:.F63HCK^euÜñó®ºù≠∆çò¥uö}Öúàê£ëò™óúØôúØóôÆóú∞ìô±Üå¶w}ómuåRZoHQ`KRZGIFNKBMG;A=144*),!)+ &)),!/2'39-08+,9():*'7*+=11A6%2('1?2N_OReQI[CCU;DY:FZ>@T98J4/=."3+=RWçß¥´»⁄ß√Ÿ•¡Ÿ≥Õ‰¥Õ„ú≥≈ò≠æd{É;TP:VH1N<(D5<WPì≠ÆÜö£5HWê•∏™æ÷∞¡€£≥Õó£ªÜé£w}çPWa.680;3.<-&5"-- .!24J5%;&**-052J0.H-%B&,J03T9:\C6X=5W<6X=6X?6X?9[C>_J=ZF:WC<YC.J4)B-,B-BT>wÑpS^M1>,-@,/G1)C*%A(,H/:V=6O9(?+.?/(- 2I9EaK3O8+>+./G1G`J+A,((>'2H12E11B0!2"+$!$#%!-$%"3!'8%))+:'+9( +!,*2##+)0 *1!%-(3#-<)):'&7$#4!(9'&4%'(". 3?1@N=CQ@0>/<H<@JA4;3/6/*1*")")! *! , !-!&$$!'%"-%",+'24-;>K\cGYcG[fQepPejPe^K_SF[LN`TL\R?LC-80)!",#)!)&.!)/#17+(0%?F?KQM=CA'2.@KG2=9'2.$1(!.$#1$!/"%1'#-%$*((,-015/02LPOGLHDIE6<8+1/'0-.729C;'1(FPGZe]Xe\@PF,=3)9.-=2BRHAPI1B<->83D<,=3'8.&6+'7*1?07E6@N?K[NTfXLaRE\LCWKBVJ8L@3G;5B84B51?22@33A27E6
+
+	
+	
+
+		
+										
+%()-!/""0#)5)/;-$1 '#!% 2$*A12J=2L?7SG:TG0D9&!'+&6)-=0,</&3)(+- "2''7,$1' /4->A:CE:DD8NPBFL>*5'8D:=I?:B5?C5?A668-35**-$!& '")!",#!-#&4',:-0>/5F44E3->.$5%"3#+9*.<+ .%4!'4"0;*$/(5##0%%+!(3%/;-*8)&4%0;-)1$*0&14+/5+-3)&.#$.#*4)3=24?117+77-74-43.12,/0(14)/5+8@3:B7*2''1&,7'&2@/;H708))/#
+!5F4=P<9L89J:!/")7*,.C2)>-(&#9,6UC2U?6VA0L6.D/+>*9O:6M90H88PB<SC9N?1C5-?1>P@EXDCV@@S=&7%'5$,9%FS?>M8-<'6G5DUE@UDCZJ>VH2LA3LH4NKC_`hÑáÄù£uêóUns7OO.E?8O?KeLJeDPiBMf?Ga:@Z5<T2=U1>T.BX4AT84F0/B/0E60F90H:2K80I40G3.G1.J11O33T75X:5W<7Y@6WB5VC7XE:[J;ZJ;ZKA_SB]TD`TC]P?VB;Q<=P<;N:-C,2L3LhO]w^AW@1D.,=*(9&'8&$5%#1$ 0#!2""7&#:($=*)@..G48Q>7RA2H;1I91N:9YA;^=9]76Z46[25Y34V15R34O03L/2J04L48Q;9R=7S<9R<HbGc|^rãmxèuwçxpÖrdwdZgVXcS^gVajYZgUN_LAVC=W>>[=@_?:X<1M76J?>QOduäö™†Øƒú™ƒÑè≠jsêuöäï´ú§ª™≤…≤π”∑æÿ∫ƒﬂ∏¡ﬁµæ€±∏‘°®¬Üå¢bgzPP\WOMgZR`PCPB781),)")+ *-".1&28*5=0/;-*;+&8(&8*-?30B6&6+(&4'2C3BUA?S:;O3CX9IaAH_B>R9.?,#5)$87d}Çôµ¿§¡œÆ…⁄≤Õﬁ™ƒ—ö≤ºvçì6OL.H=3N=.I6)F4)D;Öüú~ñöNdqôÆ¡¢∂œ¨¿€•∂‘ù¨…†¨∆ù£π|Çí?CL-31!-!)('(!/3F3.A-"0-(+17M62J015 9#+G0)G-%A*/K45R<8XA:^D=aG9]C8ZA8X@;YA<XA5O66L5ewaÖíÄ=J83B/1D0/G/-G.2N52K5 7#&8((6)(6)7L=KcS:UB-D0"3!0AZD>WA.A.,6L5<R;%8$4E34E5%3&&" (&$". ()'8&"3!%+'6#-;*(4&&0%,7).6',4%-6%,7&,9'*;($7#0+$2!.:,",!&'"-+8'/>+%3"7E6KWKQ[RJQJ8?8&-&&0((2*&0'$.%$+#"'  %!$ #$+'4+(676ELUfnqÇåhzÜI]fMbgEYX3I=3J8KbPaxhRh[K_SIYN/<2#1$"."(%-"(.$%+!$,!3:2;B;3<7'2,+81(3-%0*$1(-:0+8.&3)'3)%.)267MNRRSX@DG489MQPW]YPVT286'0--614?9(3+=I?T_WS`W=ND3D:0B67I=<LB<KD5F>4E=4E=1B:->6-=3+;0*8++9*1?05C4@QAG\KBYG=RC:O@5J;7L;7G:5C6.>1->.0A/;L:	
+
+	
+		
+	
+					
+
+
+			
+	 ''!%#/#&# 		"(%9-2J<2N@5QB7RC(>1' )'4*)9.%5(!1$+) -#+8.*6,) !$01+>>4JJ>LNA08-)5+<I@>H?EG<JH;DB6DD8<<213(,/&).'(-&&+%%*$).'5;1AG;?G82=-$2#,</,=-+=-(:*!6#$7#&7$)6$%2!*8')$%0"-:),9($0"%0")/!#)'*),#-0'*-$$* )/#,2&36+25*47,::077-66,44*52)66*<>36<.9A4BM?-8*(3#+6&&3!+8&=J8=J6'2"  *6C20>-$0"%1%.>1,>.)>--D4(1$+C56UE3TC9VB'@-$7$(9'5H57I92G8:QA8O=3J83H72G68M:UkVUhR=O9#23@,9E-@N4H\@9R4=W<<XA<XA;VC:UD2L?3MD5OF0G=*?6%820**('# *".<-PgMMfFJb@AV57N1:Q4<S67O/9Q-<Q06H.-?)2E2/D5,@4-C6+C3-F3/F2+C-*C-*D+(D+*H,+L13T9;YA>[E:ZE;\I9XI;YMB`X@^TEaU>YHFbKTnUSkSBZB2N5?]CHeIA[@0F/0C-3J04K1<R;7L91C3$6("0##4$(;($9&$6((=.4L<9TC5K>,B5(>1+D1.H/1N02Q12T13U06V14S34Q23P16S55R67U97U93Q53M4D\Baz\rãkvçqvåurärjÇlbwdducfrdfrdeqeYi\G[O@WG>WB=VA9R?:RDL\Y^mpçòõ®πß≥À§ØÀú•ƒó†ø©≤œ∑√›øÕÁƒ‘Ì«◊Ò«ÿÚ≈÷¬”ÌΩŒËºÃÂ∂≈⁄Ø∫Ã£©πäàì{mmh`}cVfOA?2*0+%,,$,/$-0%-5(,8,(6)'5('8(*<..@22D6(:,*+!/ )7&5F39M4=Q6CZ>F_B=T:+>*$5%"6+;PKRkh\vwgÄáä£™oáãQfg6KF.D8*C.,H13O6.K5!<-Lf]cÄ~màèßæ–£∑–¥≈„¨º›°±“•¥”£±Àò£∑\dq)14&/*!-!*%"(/B/3F2%6$(6%!/(*,B-4L4#9"2 30F1/" 5"-K32S84U:4U:7U;9W=9Z=5V7<Y;E_Bf~d[nX7E46D30E23K53K5(>)):()7((8-7I=LeRA]G3H7%7'$5#.A-D]G6O9#6#-8N70C-!/+2@19J:-;.)(%$%1#$1 $2!)7&'5$$)-%6$%3$"."(0%'/"$,$1-<'(;%&9%*(( .2@1#/#%%&)#0$3 *8'&2$6@5DNCMWLO[MMYM<G?/:2'1)&-&!& #% %(!+.'$$%1'6G?[mqbv_rÄcvÑWiw;MW6JK<OK5G;/A19P>BYG>UEAVG8M>*<.0B43C6+;.,:-)5)*4)(2'*4))3*)3*%1'*7-,9/(5++8.+8.&3)&3).93KQO[_bWX]UX]>AF:>A9??>GD=FC/85+41:C>6?:+412;8=FC<GC-:3&6,,<1BOEKTOHNJ4?9=JCAMI5A?.:6-:3*7-&3)0=3:G=/<54A8:J=6H8/?2+<,.A.2E26H8/@01B23D47H6:M9	
+			
+		
+	
+			
+
+
+		
+
+						 ') 
+#!-##$!
+	
+
+
+& 4(*B4,H93O@4O@$8,!(!.$/"!1$#3&!/"($2%,:-,8.$0& *""' '*!:<1KM@=@5)3*1<4;G=AI>TTHPNAJH;B@4::068-35*01)*+%+,'12-:;6KHASQE==1IM?&2$*;+1C3)>+#8%"7$&;((;('5$,9(#4$('!,(3%0=,.;*,%&$$(!% !$!$$'#&&)$'&)*-"13(55)55)22&42&86*;;/:>039+8C3CN>4?/,7&,9'+6%7D2@O:/<*	$0"/<+2>2%-;.6H80C0&;*+B2*B4!7*'B34SC4UD6Q>&-):(+<*BTD+@1=RC8O=2I50E2,A.2G4BXCH[EM_G,;$<J1@O2AR2=R39R43P21M43L6/H3,C32J=3K>9QD*?01C37H8". %%%*6(7M65N17K01C)+=#6H.7K0<S6:R21H+)=$0C/5H52G8*>2&</(?/,E2&?*";%'A(/I04P75Q8)F*%A(-E/3J69R=>YH>YJ?[OBbW?_TBaR=ZFB^GLhOMeMGaH>\B?]A<X?3K3+>(.A+4H/3I28N98M:6K:'9+*8)-;,4E3,?,&6)$6*/G7<TD7OA$:-2'(=.+C-,F-,I-,K,3R09X64S14R04Q25R32Q21P11P1/L01K0D\B_z[sånuéqräplÑlfÄge|hg|korsÄvp}thxnTe[BVK@TI@VJ@WMH]XWiirÅàåú©ûØ¡™π–≠ª÷≥æ‹ø Í≈”ÀŸÙÕﬁ¯Œﬂ˘«€ˆ¬÷Ò∫ŒÈ≥«‚∞¡›±¡€µ≈‹∑ƒ◊¥ªÀØ≠∏§ïòêxtàmbqYMG816/)0/*,2(-5(+6($2#/%5(,=--?/,A00E4);+)''3'$2#1B00A.2E/<S9AZ=<U8/B,&9%(:*.B60H;+E<-C@`vs\sm&;2!5)"7$)A).H-*G+/K2'C-%@1?\Wmäé¨∆’•ª”∞√·±ƒ‰¢µ’¶π◊©∫‘¨ª–~äò-6;'0- *!*$'*%6$3F3,*8'+<)+-#6"@V?;Q:+<).=*0A.',D,(E)*D)"<# 8 $>%+E,+H,0M/:W9KeHf~f_p^M[L>P@6H8/@.%3"#0(4&8J<?VFEaK8Q;+<*$2!4E3E[F?XB+D.0"5"7M6$7#( * ,*8)6D71=1&0'",#&0%.:,*8'+:''5$3@/"-(,$5"(6'&0%#+ !))$3 ,?)$:#-** -,0>/*6(##"(#1 !0,;(+#-"(2'1<.@L>MYKGSIFQINZPDNE7<6.1*,/(17-"'  *!+",<9-AH8N\4I\K`slêM_kHZ^9LH/@6/A5.B7+A5,@7(<1"4( 2$;M?>PB4F8/?2'3)#/% , #-"$,!#+*8),9/(5+*8+&4'#0&.91MVQV\\Z^aRVYMQT>CF[`cEJMAJIHQN-63,52gpk[d_2864:8AJG5>;'2,#0'8E;^iagkjeih173QZU]hd@KG0;70;5&1) ,"CPFN[R?LE-:3&6,%2($0$#1"'8(,>.4F80B43C67H8:M:9L9				
+	
+
+	
+	
+
+									
+
+
+
+
+
+ !! !
+%!-#'"	
+		! ," 0#%<,/G75M=4K;1#$!-#(+$0$+ ,%1%/<2/<3'4*#/%,2(GJA.4(4</&2(5A75?4>D8FH;SSGMMAII=??5>>4>>455+/.)('"850<94QJDF?5KD:TUG08)"01D11G2+A,':&(:*'9)%6&)7($2!"1%0-8'5B..;'"/(&! &(/#)  !!$&&#!$#%&(')--#22(13(35*25*08)7B24?..9(0;*6>/5B0>M8<M:#/!	$2%*:-4D7>NA*<.<Q@)>+%:)'>./E8(@2.I:3RB9XF-J6*C-;Q:@S=*;(@S@.C0<SA1F5%:)%7'(9)'8&+<)7J4WkP?R4@Q1DX5<O/4H,1E*(<#!4!/+/$5F<4J>7OA$9(':'0C/.?,$1!.%3$.@09P<,D.):'2A,4B+3C)7I/=Q6.G*'?%)?*5H5;M=2G6-B3(?/.E3/H3&?)0L35S76T85Q8-G.*@)':$-<).<+.<+7H88O?>YJDdUBdT?^L6S?7S=<XAE]GIbLIfJ;X<4N5)?**;(1@-4C0,=+%6&)9,4D7(9)3D2<M:0A/*;++;.*<.4K;<TD:RB$<,0$0G75Q:8V<8V:,K,4S3Cb@?]97R/4O.2M,2M.2L/3M01K04L2?Y>TqSdÅcmÖkiÅge}c^v^azelÉstà}{åÑÖíâÅéÖhwpN]XHWREURDZWMbc^qwpÇåÄñ£î´ª™º“µ≈ﬂºÀË√“ÒÀ⁄˜Õﬁ˙…⁄¯¬”Òπ»ÁÆºŸ•∞Œ°¨ £ÆÃ®≥—Æπ’≤æ‘π¿“ºæ ±®≠ìÉÉàvràyrja\D?;5613810<0'5&!/ -%6&.@0);+,A01F5)>-+$"0#)7(6G5/@-1D.<S9D]?B[=3J0+>(.A.4I81H60I60F97K??TE&;*#6# 3#6"+C+.H-+H*-J.&B,&D8Qoo©≈”≠«ﬁ≠≈ﬂµ Á§π÷§π‘™æ÷Æ¡“Çéö%/1'" *$$)+*8)&7'*0':$3*-@V?+B(&8"7H5->+'$5#+A**A'&9#%,"")!4 #: .E+AX>QfS{çTaW?I@<D9:B58?/AL;?TAF_J=T@2H3/=,1?.K^KBXC9R<!:$0.D/7M8"5"%!+ )& */:,3=2/9.,6+)5'-;*.=*"0.<+,:)%4!+:'*9&+6('/"$,!!,#/!+<*':& 3,,*.;*,:).<-3A2'! (&4#!0,:)*$.#%-"$,!$,!/:,7E6XiYZk[FTEHSEFL@AG;<B6'/$%/')",+BVaczåcyêjÄòmïIZj`qyFXZ4GC6IE>RSASWL[`0>?#/++8.8I9<N>&6)* )! *!)$,,2&"$#/! -#%2(&6+(8-)6,<G?OXSU[Y^gfENKAJGV\ZbhfZ^_AFI8>>.42062CIGV\X/51EKGt}x6?:)2-,50LVN]c_ptuX\_177BKHXc[LWO.93-61&0(1;0YeYTbUHXN?PH&6,*"( ) %2(-=22B80@6/?44D78J<8J:	
+	
+
+
+
+
+				
+				
+
+	
+
+					
+
+
+
+"# #"% ##+!%	
+	
+	 %,4)(2'+&8*,C32I9-B3$!" ' '!$(++!.%+8/0@6)9.)5+*6*7C5EQC)5)1=38@5>D8;=2HH<Y[NMMALLBJG>LJ>@>2:7.;60>93D=7?6/F=4UOCSTF6<.,*;)0C/0A.,=*(:*(:,$4'$5%(7$(5!)6"1?(-:&'"$&% "&- ( ! "  !$&(+ ,/$,2$/:*,7&.9(4=,7@/6A04C.:K89G6/=./;/,:-3D4 2"*<.G\MOfTAZG%<(-D2 7'#;+)A31M>6UC:YG0M95N99O:7J4-@,0C09N;9P<1F34# 1!)7(,:)+:'&8"5G/=P4':.A#&6 /+:'$3 +!,%!.$:KA4J>9OB3".2&9#+>*:M9BWF:QA1J74K9+<*+8&:H1<J37I17N42J2,E/0G3CXEEWG.C2*A/.G41J71J58R9@\C5R6%B&&@''=((;'*;(2?.2=-/:*1=/1C5<TDHiXFgT;[F.J42N86O:2I59Q;@ZA7Q8-E/'=(,;(0=+6C19F5*8+&4'9I<EVFQdPNaK5H40C03E52G60H83N;8S@,G4%<,4M:7W?:\A:[>5V78Z9EgDBb;;Y31O-3N-1L-2M.4M03K14L2:R8E_DSmR\t\_u^`va]r_czhkÅtxåÉÅïåãõëãõëÉíãtÉ~kzw[kjQef]rwk~ÖpÇétäóÜù≠†µ ¥»·ø”ÓƒÿÛ»Ÿı«ÿÙºÕÎ≠æ‹£∞–ûß∆†¶∆≠∂’±∫€∞ª€≤¿›∏ƒﬁ∫≈€º¬“Ø≠∫ëäíu}ÉzÑÇÖnnlIKF8?7+9, 1!!2 %6$#6#*?,)>/-D42I7+@/- $+)7(9J84G33F09P6AZ<D]@4K10C/-B13H70I43L75L8/D1%:'"7$2/#6"4$<$'A&,F)/I05($>=õπƒ∂“Á≥Œ„∫“Í∂Ã‰≠√ÿ®ΩŒç°¨GV[*646B8)!$#(-+!2$;!#: 1!4 .D- 3 2.?,&5"'5$.<-.<+,=+(;%*A'+B&&8 +($*(.$&&)8#)91C+<R=xä|dogIPIHKDZ]Tfl^]jXI_J?VBCYD@Q>DRA>L;1D0:P;4L6#;%!7"2H3.C0%8%('"*#+ (.",4)*1)+5-,50*5-/;/,:+&4#,:),;(+:%(6&2'.#* ( -*;)*=)%8$1 -"- -$1 .:,-;,9G6$0"" '#/!$5" 1,=*+",!%-"(.$&)*8),=+$5#!/-8(5;-4:,08)(2'!-#*#$44h|ámÉògôsà£evêO`t6GQ,;>&97J\\cvzpÉäÄéóMX^*327A93A49G8.;1+!( (!+ '/$,/$*-")". %$1')9.3C80=3JUMOXS_hcS^Z=HDGRLXa\W]YZ^][_`8>>.42:@<HNL:@>)/+TZV[d_2;6*4,<F>Äá\b^hloadi.37&/.2;6HRJ/83*3.(2*=G<7A6=I=9I>=MC2B8)4,#-4-&0'5B99F?0<8-:1-=31A63C8	
+
+	
+						
+
+
+							
+
+
+
+
+ $$' #)"(!'"&$#&69006*%)%5*,@4/C7(5+!$$&+!-!)&)"&7//C:&:.%:+CZH.C2)$+#39/BE:AC8II=RRFUUIII?MMCQOCLJ>EA5IB8KB9A8/E<3[UIOPBHL=3>. -"0*8'/<++9(*;)+<,&8(/+)7 3A*)7 ##" 	"!'
+
+	
+
+
+	%,4%5>-&.0;*.9(3?+1='0<&.=(0A.5H4,?,*=*4I6.F0)A+.C0;R@EaKEbL'B/,E2,D4)D3+G81P@6UC;ZH0M;.I85L<5J9/D5/D38O=:Q=9P<-B/.C23D4.;*%2!%2 5D1CR?'6#!,(%( , , .! 0#+=1:NC7MA8NB';/#8)&;,)@./F23L72I70I64K97N:5F3'6!-:&9H35H23K33L6-I26M9QgR6I6*?,,E21L91M79U>;U<+E,$:%3!4!#6#!4!$5#'5$'4#(4&+9*(:,9P@HeQBbK8Q<.F04L63K5-@-(;(.D/0H2.C0)<)-<)1>,<I7CP><J;4E5K]M[p]YqYPhNKaJKaL<S?4M82O;4Q;;YA7U=6R<7T>6V>7Y>9\<<a??e>@f?<`:5W43R02O03P14Q28R54N33J04J38N9>T?G\IOaQUgYYk_csim~vwäÑÇñçäûìè£òã°ïãüñàõó{ççtáãÜôüû¨µõ©∂Éï£zçûè•ºßøŸπ—Î¬◊Ú €˜Œﬁ¯«◊Òµ≈ﬂ≠∏÷™≥“ÆπŸ∏≈ÂøÃÓπ»È∑«Ëª Èª…‰∏¬€≠± ïï≠{îrpÖqwÉq{|`g`9C81=/!2"#4"=P<6K81H41H81H81I9(?/#3&)* '5(6I6<O98L38L1BY=I`FEVC6H8-A5.F8.I80K87R?3K;'>.4%4#!6#$9&!4!1"5-D*1G0&8,#!Äû¶Æœﬁµ“‚∫’ÊßæŒê¶≥sáêCWX*943@6L]M*$$%"#*$2!.#: #:%<"*A' 3+--$1 %3"&7$*='(>',E(FaB1L+3J-%7%2 7?019*'/ !,)2>F.5?&3E/ctdÉçÑ=D=685?D>DPBIZG?U@>T?Q`MKZG:H73D2(;%8N70C/.(>'3I4,?,'5$'2"*0$,2&(.",/$-3)+1-)214;A;DI6A=-:0*8)%3"%2 /;%3;#,2(,"(+)8!-@*)<&"5! 1-#/!!,&!,!.0A.1B0)5'&2$#4" 3&9%.A-"0!)/7*HPE+3(&1#&2$&4#$2#"/.6'-4$+2"/7('1&!-#+"#32hálÜóe}ïwå©WkÜVg{)7@+,!1.QfakÅi~h{aor)13:@<?G<0;-0<2%0( *"%",#'.&)/%)/# +". !$1'*:-+8.3?5KUMW^W[e]CNJ7C?5B;4?9DJFV\Xage:@>+41ENKaggPTU(.,397:C>.80/6.KSHÜåÇmrlZ[_VY`/4:HPS*32-63*3.-7/2<30:1)3*;E<2=5#0'*7-0=3)!1814;3JTLBKH.95#.*-821<6/<5
+			
+	
+
+			
+
+
+
+" ##$"!!
+'""%69025*"(!!2*):0/?5+!&#/#%1%%3&*( 0&&5.,@73I=4J=3K;7P=/F4$)"<?6AB:HH>II=PPDPPDPPDSTFNL?MJ;SM?OE;ZRGYQFRPCGK<9B10;+%2!!-(4&8C5)4&(6',=-&7%0'5/;%#1"
+$*
+		
+									(0#3;,"* DL=(3"-9%-9#+9",9')8%,=*.A+-C,D\D+C)%=%"8#-C.5N85Q;3O97P=3N=7RA6RC4SA=ZH7TB2M<3K;1H81F7/D50E44I69O:6L73H50E2*=*&4#'4#*7&7C5ESD>L=;F88@32<1,8,/=01A43E74F:5I><PG8MD;RH1E:3G;3H93H71H4/F2,C1(?-'>,6K85H41D.+='%7!*='0H2.G1-I38Q;@XB=S>+B.3L9/J70L6.G1!;"$<$/B/&7'#4$ 3 "5""5"&7%0A/.?/->.,>.8M<@\E8V>2K53K57O95K61D1-@-1F31H4*?,&9&)8%2?-;H6>K9=K:<M=J_NLcOE]G;S;<R;<R=3J:0H8/G9.I81M72N7/K43Q90P8.O4.Q14X46_77`64Z31S00O/1N/4N14N16P37O58N79O:;N:<O<?R?EUHLYPVb^bnlkwwsÅÅxàÖ~íâÖôéâüìè§õç†úÇîîÜôù§µΩπ«“π«‘¶∂≈àô´{ê•í´¡¨≈€Ω”Î∆⁄Û–·˚–·˚œﬂ¯ŒŸı«“Ó¬–Ì√“Òƒ‘ıΩ–ÒπÃÌºœ¿—Ô¿ŒÎ∫≈„™∞–êì¥`dÅXarcnt_iaLWFBP9.>$(8*<"'>$$<$)?*/F22K8-D2(9)"0#!/"(8+1D14J59L69L69O8J_L_qcCUI5K?2J=+F51L91N:5R>5M=+C3*A/-D0.E1'<)#4"!2 %8",?+#0&Slqñ≥ª¢∫ƒ|íù?RY0BF*<</@:+;0/@.I\H#6 ,$&"/'6#+,"9&=!%<""6!40+-"0#4!(;%%;$!9.G*4O02K+2K-,C'(:$-:()5!(1$+16"LN8@E.6B,9H5ÖëÖwÅyY^ZGMIDPD=N>4E39J8?N;@O<5F42E17N47K22E/(;%.D-3I2<M:>K9DM<EK=KQCGMAEH=7<5-63$-2âïçñ•<EN'13+'!-#*)2!27#48!?C(;D'3A'/A',@'"8!"5" 1+ , +$(* /:K8,=+%6$ 1"5!"5!,?+"3!#1 (3#4?12=/*5'"-$0"%3$". (0!%."+/:*&2$#/#&2($3.L_cf|âsäúmÉöYnÉQbr"/5'%*#CWNWleSjdK_]Zhh,52382IOE?E98B96@8#*##)%$.&(2)*2''/""-". ($0&+9,.</?IAAKCU\UJTL6B>6E@ANGQ\V1:59?;OUQ6?:-61OXUgmmIOO)//BKH1:5/914;3OWLntjlqmehmPU[.39CKNLQT399(1,,6.1;31;3)!%&$/'#0&.</*4+$+#CJC;A=OXW('.764=<5?>.87						
+	
+	
+
+
+								
+		
+
+  ! !!$ ( 	
+
+
+%*#270/4-!  *+'33+75+81(4*%* $4)!3' 1'%6,';0-C7,B60F9/E8+B2#:*#8)$9(-?/#1$&!+0);<6AB:FF:UUIWUITUGYZJMN<OL=VPBUK?^VKKG;<=/7>..6'/7(&1!++6(7?4+3($2%(9)&5".=&-;"$0 
+
+
+		
+$!'
+
+
+
+
+				
+		
+	
+
+
+	"*4?/%-"
+CK> .9)/<((5!("-,9%6H02F-5L2.F,+B()<&9K55K4*B,(?+-D21I91L;7TB;XF?ZG3L96K:1F36I64G38K79L64G1-@*$7#,?,6I69L91B0(9'+7)7E8EUJGWJGUDAO>AR@;P=8O;8O=5M=6L?7K@>RI<QJ9PH0D96H:=N>@Q?0A. 312 5"2H3.F.8P6>V<-E++>(0F11I31J43J69P<;T?1J73K;/G7#:(%:')?*2H30B2);+#5%#6#)>+*@+%;&)>+,>.,>..@08M::S=1M6/K58Q<6N67O7,B-+@-2K80I6)@,&9&*;(1@-0=+0=,0>-1B05G75G73E54F6.@0(:.)83)85*88.=8,=3(=.0G59R=6R<0N6,I-0O/3W31W.3X/3U02Q/0J-1I16L5=P:8N78N9;S=?U@F\GObNSaTWb^muwÄâéÅäëwÄáuÄÑuÑwà~yçÇïâÉîéÄêèâö°ßπ√øœﬁøœﬂµ«’°≥¡ëüÉñ•ôÆø©ø‘πœÁ∆€ˆœ„¸‘Ê˛⁄Èˇ◊Ê˝–ﬁ¯À⁄˜∆÷˜ø“ÛªœÚ¿‘˜√÷˜≈ÿ¯∆÷˜¡ŒÓ±∫Ÿèñ≤ZbwT]f]i_drX\lGXi?IZ00@3D 3G$-B!0G*3M41J5-@-!2""2%,>0>S@2G4*=**=*,C3=UGtâÄUlb4L?.F6%<(/H22N7)G/-J41N8.K5+G0+D.6M9:O>5G7+@-0C0#--GVYFTW,7;#+-"+(#0'1A4"3#8K7=S<"6.+'-'9#1#: '@#!;  8.,,.. 1#6"#6")?(!9!(@&'?%'>"'>"*C&.G*,E(,@%2@)2;&(,58%FE18:%4<%4@,YgXÜìâåñéflhNUN180,4)*6(4B12E1-C,4L29P46J/8L35I0.E+8L3M\ER`IV_LOXEFO>AI::@4)3+&20-<C°±¡üÆ≈<C_)/G"(6#(.+11& & '%..<#1C)-A&(;%"5! 1/%%!-)%) 6D30A..-0"3!->+7H61@-0?,!.(5$)4&+5*/9.0<.$2#!-"/$5#):($2#&2&)1&$.%-95cuwuåíayÉYmx7HO-*$!"/&&:.@TH@QG1>5*1*28.EI;NTF@H==D<&,("(&$-(&1)'1(!+ ". -9+3?3%1%+9,8F9NXPIPIKPL4=86E>6G?*92CNHIRO*0.DMJ0962<4OYQ[aa>DD$**GPM4?9/:25>99?;LRNW]]bjmPW]/6<GOR@FF%+)+4/*5--7/'0+"+&!*%#!*%!.$+9,0<0,6-#,)#,+-25 %(AIKAIK0:<+57						
+					
+
+						
+
+
+
+	
+	!"!"
+	
+
+ +$
+
+$&-&.40,2.(1.(236ACWbfXdd%1-,7/%/$#-"'3'&6+,>2.B71E<1E</E9.D7)?2'>.%<,"7&0!'& .)( *!!(!/4-@C:DF;PPDTUGRSCNQ>LO<MK<URCXPCRL>?=046(6:,+1#+3$)1"('1&270+2*)6,&7'*7#1?("0'(.$							
+	
+	
+		
+
+ .9)(5$
+&,"5;1	'2$1>,#0(7F/9M2/F*)B%.E+/C*8J44G1*=),?,#8%&=++D19VBDaK7P:1G0<O9<N8?Q;GYCHWB@O:4F0,>(&7$%6#'8%1B/0C/*;)*8)$4'5I=AVG)7&%4!*=)(>))?**A-5#!7*0D9DXO:QK<SK(<17I;IWFZgV@N=)*#6#/D1.E1.F00H0.H/,D,-C./E05M7,C/,C/1H61J7/J94L<.F6/F60G5-B//D3);-"4&#5%(;(+@--C.-E/-B/,>.+=-.A.9O:;T>2N73L76O90H0*A'&<'-D04M81J5(=*$7$'8%/>+3A0+9(%3"#1"):*.@2,>0/A52B80?<0;?8BKLU^U^cEQQ,;4+=/0E25L8/H2*B(+F'-L*0T.5Z19^58W51K.1G2BUBUhRPcM?U@<R=AW@PcM\mZesfr|{éóú©≥º±ª≈óü™àèzÜÑtÑzmÅusá{|çÖÅëéé†§ß∏¬∫ ⁄ΩÃﬂ∫ ⁄∞¿œõ´∏Åëûâö™ë¶πù≤Õ∂ÀË∆⁄ıÕﬁ¯’Â¸ÿËˇ’ÂˇÕﬁ˙≈ÿ¯¡’¯ø”ˆø”ˆ√◊˙∆⁄˚…‹¸»€˘√“Ô≠ª’yÑöIQ\Zd[iv\iyRexJ`qEIZ.AQ*L^8QgA:R04N31J4+>+'8&"4$'9)=R?CYD/B/&;**A1+C6KbXH^R3J:,C/)?*.F08Q;1M6'E-&C-/M54P9/H2#<&--)>+4F6$! "" $#!&""' 2<1(6% 3E[D3J02-+0&7$#6 .B).E+#<9":"2+(*-!4!$:%&<' 8"$:#(>'-A(.=&#55";-F)1H+2D*3A(+42:%>A,(-;E-8E15H5dvhîüóu~y8=9,1+/6.*'8&*@+5M5C[A7N2/C(+?&-A(,@',@'1@)3A*3?+0;*,7)'1( ' &#$25=NX´æœë°∫\gÖSZwAG_+1A+/8,22#'"//A)-A(':$2"5"0 .$"(!,$"##1 :K8$7!,=+$2!/.?-5F45F38G4,;('4#&)0(2<3.:.#1"-#4$+>+%8% .('&$$3,7KI6LJ';:#32"/&&# #DVF?OB#/##+ )/#9=/IOAHNB9@8(.*+41$/+'2*'3)#/#!-!(4(,6+(4(*6*<H<V`WGNG4958A<7G=:KA-:1%0*NWR6?<*51,733>6T^V]cc;@C&/,<GA1<44?7OXSageZ``INQX`cPW]08;08;%.-+41-61*4,*4,'0+&!$ &&&,*)#'4*2@31=1LWQ:CB %( (*"*-(/$+
+	
+		
+
+
+
+
+
+				
+
+"!! 
+
+
+
+
+" ,(#
+! !% ( '# &"&/,-76BQNEURVign}Ägux>JJ>IC+7+#1"/"&8*(:.'9-):0(:.&:.%9-%7+"4&/".-%"$(#/%'3)0:1;>5GI>LNARTF;B059(@C2RSCTQBRPABC5=?1BD615'.4&#+((!( '1((6)&7%3@,/;%".&
++1'					
+#%/$%1#*##:@4(."+3&1>,+	&8 >U8>Y81J,'@#,B+'=(,B-2E1$5#*&9&6M9@^DA`A4M0?S7K^B9I.2@)8D07D23@.-<)-<')8%)8%&5"-<)/@-(9&2E1.C0.E3CXG2@1(5$$1$1"/(7$"0!+-A6CXO=TN>UM%9-1B2)7(#1"*;+"4$!3#$6&+B0-D2*?.(=*'<)&;()>+4K76M9&=+#8)*?0.F61L=1I;5M?5PA5PA2J:)@0%7+/""3#):()<)':'(=*)>+,>./A1.C0<R=@YC7Q86N84J50C-"5':'3J65N91J4'=(%6#%6#,=*/@-%6$+++;.2D8.B60D;3CB6EJIUcmyâçôßàïûalr5A?8E;.?-)<)(>'+B((A#*H&0R-7]6:`99[83P26N8LaN_u^dwaOaKDV@FU@Q`Mbo^myoÄãç°Æ∂º ’¬–€µ¡Õ¢¨µï°üÖïãpÇvsá{ìáÑòèì££¶µº¥¡“∏ƒ⁄ª«›∂√÷¶≥ƒàï¶rÇípÄóÑï≥¢≤”∏»È¬— Ÿˆ—‡˝Ã›˚ƒ◊˜æ–Ùø”ˆø—ıæ–Ùº–ÛΩ—Ù¿‘ıƒŸˆ≈€Ûµ ﬂ|ãûEOYU\U[dOPaAOc>L]9@U.:N)=S-G_;;U25O40H2+>+&7%&7'%8%.D-9Q70F/&>(+B0(?/!3'%7)2E27J41D.1G2+C-2J44L6#;%#;%-E/2L37Q8/H2!9#4 5G7$!# %*2'3>0,0JbJ/B,'*$2!):( 1!2$5"026!9!2.++ /#4!'=( 8""8#)<(&5"-9%&2+)1%<"+B&0G*2I,0D(4G+6D+#14F.3I2,C/RgVùØ£ëûïakc<C<1<4(8+&;($:%41H.1H.(?%%9 *='&8""3 !0-"0!$1'$/+() (+"+2&4?Ugu¶∑…rÉó[jcrázä°`oÇ9?M27;",$ -2D.-A((;%,-!2 /+"!&& $)+='2E/->+0A//&7'0B21D11B/0?,%0" ")0(3=2&4%,+<*+>+&7%'%""%)/#"4($4*!.$'&,<J;2>0",!"*"*+1#AH8NTF:@4,6.;FB0<8&3,$0&+ , '$.#%1%*6(,8,GOD6;4CJB4>56F;:L@?KA *";E=FPH(3/)404?7Yd^]fe7<?(1.1<60<2>J@S\WfljaefbfichlOV\07=KUW'13-65,504;3/6.4>64=8)2/8<?VZ]"+(&1)0>1BPCZf\/91-3/RXXS[^KT[EKW06D
+	
+				
+		
+ !$!!
+
+
+
+&&*("#'!-#!-#",!'"& #!'0-WfcdwsYlfSfb[jmfsyZdfP[W,8,-,("*!1&#3&$4'$4'$4',*"0!"3#!/"!&( '$1'*6,.8/=C9DH:DH917)4;+18(@D5LN@PRDLPAAH8>B329)'/ "-#. ($0$$0"%3$'6#6B,-9!(1#*		%! 	#$ '#-$!+ AG;"
+4<17D26E0-:)+8&,;&,>$3L,JeDHaC/H+(@((@(%;&,?+!/$1 /@-<R;GdF0M.1E)6I-IY<0@%'3#.'2"#0%4!+:')6",9%$3 (7$-?)':$(;%.A-1F5AVE<M=5B11<+)5!.7$.9()6%#1$/C8AXN;ULA[P1E94E55C64B5/A3.@2-?1,A2.E3,C1'<-'9+&8(%:)/D19P<1F3(=,*?00D80H81I91G:8PB6PC7SE9SF7OB.B7%7+'9+(9)'8(&9&'<)*?,/A11C36L7F\EIaI:R:3I28K50?*/(;(6M96O9/H2)<('8%(9&+<*.?-#4$' +%1=;6EB4GC6HH8GN?MZlyåó§∑¨π °Øºrà/:<0=33A0)<(+>(3G.)@#(C$-L*3W3:`;>`=@_@G_IPcOas[l|baoVNZBLXBWcOcn`p{sàñóßµæøœ‹≈’‰√—ﬁª»–©∑∑í°öwá}uá{ìàÜôìí¢¢•≤∫≥ªŒ∞∫”Øπ‘Æ∑‘§∞ éö≤uÅô^láuÑ•†Æ—¥√‰ª Î¡–Ò¡œÚæŒÚ∫ÃªÕÛæ–ÙæŒπ…Îµ»È¥…Ë∂ÀË∫–Ë∫”Á£∫ j|àFQUT[SLUD9K3NbGCW;/D%(=(@1K(4O.3M2-E--@,'8&&7'):(&<%(@&-E+)A),C/.C2$6&!2);#2D,.A+)<(2"5"/B/,=*&7$"5!1&<%1G29O:6L76I6*#  %!):B5#. (!7"KcK*=)%,-9+)"/$3 "1!/0!4 5 / .*)!/&9%'=(7!'<)(9''2",3#'. )%!.*<& 7-F&A[83M*6O/5L/5L/3K10J/(D+NjSì™òyé~ãÅ`lb?LC/<2$6&-04G1':$0&9#&7$!/!.(**!)511>DPZfCKX,5F9IYÑï©éù≤;G]+</?EXiâö™xÇå2<>+8.1B//B,(;%,'*&7%.&&"&$!$"$#2/>))8%-;*-0 -?/1D1*;)+9()4&#+ #(!%'"."#1 /@.(9'"0)'#+ )+ 1!&7%$5#%3$*')5''3%&2$$0")'!)$,9B1JQADL=4@6=JC9F?'4- -# , $0&'%",!*6*'2$'/$<B8)1&,8,6H:9K==G>+2*%/&JTK7A9'2*3@7P[US\[2:<'2./:24@6GQFX_XglhVZYX\]\aeGOR1;=U_a+56.95+2+:A907//91>IAP[WQTY<?D177,50/=04B35A5 *!U^Y^gdFNPELRZ`lLR`
+		
+	
+
+	
+
+
+				 !" #						
+
+
+")'$#!+ #-"!+"$	%# )&!''2=9arlRg`DUOHWTKVXfotelr\ed9C8)#$%/$#-"$.#%1%*6*/;/+9*"3##4"0 -  ,"&!,$,#$4*&3)'3'6<0:>047,;A53;.,7)4<-7B29F55B05B03@,/>)0?*'6#-0>-*9&$1.<%5A)/9 -5)1")  
+
+.4(""
+
+HKB5?44A/:I48E1;K18K/5J+1I)4M/E]CH`F1K0+E*'?'%8$->K:+8$K]EC\?";"4.=&+=%*<&)7&". $',:))8%'4 *9$*;(,?+&9#8K5!0'&7':O>9N;+A,&5 &4'3+7#)6%#1$-A6AXN9TK?[O2H;1F71C5/A30B6,@4,A2-B3/F4)@.(:,$6(%7')>+:P;>T?3D2&7'-B31H82K8+B.0B25G96L@8OE8RG:TI9SJ0G=&:.!3%0 0 #8%-D04I63I4=Q8LcGMfI5N1+=%@O:.=(-*?,7N:7P:+C+&7$&7$'8&*;++;.)6/ (+")303B8?O>JV:HU:EWMZmÜí®®∑Ã≥ƒ÷£µ√yáí2@C%5+&9&':&&<%1E**A$'@"(F$0R/7[7=a=@_?AU<GU>bjRrx\puWagK]eMdmZjret}xçòú©∂ø∑«◊æœﬂ√”‚¡“‹≤¿√í°ûuÑ}o~wyâÜÄêêäôûù©µ∞∂Ã´∞Õß´Œ£´–ü®œï¢≈èôΩàí∂èõ¡ßµ⁄ª Î¿œ∫»Î∞æÂ´∏‚ÆΩÊ≤ƒÍ∑…Ìπ…Íµ∆‰≤√ﬂØ√€´¡÷®øœú≥¡ÄîùKZ]ITNP[M@M;/B/F]IKbN$<&#;!,E(4N16P3-G,&<%&9%(9'*8'+<*&9&%;&&<%'=&+B.2I55M52J0)=!%7%7!"3!!1$("/$1 &3"$2!+'(!0*;(-@,6I57H6%1#!)!$.6'.6'%&2E1CYB(9&&/:*"*%&.&1 $/!./ 1,"-!)&#4"(=*7!(>))<) -*2#,2$%, ''.(1-<'&::O.5M)D\8;U05P-3Q-0O//N..O04U89Z==YBMdPrÑv]i_0:1)3**0>-.?,0"3!'8%-'",!'% &%(37R`m≠∫ÕÅã§7C[tÇúó•ø_fÇ*.G"5"0,6@;JQcru4GC4K9/E0-@,%4!&'*&4%$2!))' *+3(-3)%!!,+6&&1!#. )5'!-!/#4$+>+->,'4#!)*0&+3(#+ &&*8'):((5$$/(. #) ** 1!(9''8&$3 -:)$,#+  ,/=.". #/!)5'%1%(((3%-8(AJ9NYIBND=JA:J@%5+-" 0#/;1,6-%/&%-"%/$'/$*/('/$",!.<-:O@4F8-7.&+$#BM?FQC.9+4B5N[RQZY.76'2,.;19E9NXM\dY_d]af`UYXUZ]CKM3=<EQO0<8.91-5*8>4;B;0:2<I@N[T[`c*/2(,+&-&/;/4@4+!+4/KTQ>GFOUU`ei]aj\`k	
+	
+#$"# ! !				
+
+		(%$#		*&$/+$.-6B@;NLEXTSd^gvq^hiowz}ÑäéóñGQF#. &$/7,$* $.#*6(.(9)+$+!) #$/)&6,&6+"0#'36+=?4AD9BH<5=0*2#%0 .;*4B18G45F37F11C-&5".-<)'4 *8!8D.,60:".8 ,6*3"
+
+
+%39-$,
+
+				
+,-(BC;#9A4+8&0>'7E,;K06I+6K,2I,-D(+C):R:JdI6P50J1+A,'8(9G8(5!;M54H/.B)*9$$3 "1!/'+2@/+:'!0*9&,?+(;'1+=',9'%"-?/<U@1K2/C*-<%'5%1"-&2&0A7CXO:ULB^R-C6*<,+;.)9,'9-(:.+?30G53J8!6#$6&+=-)>-3H5=S>J]IJXG'8(2G63J84K72G40A1&6)+?32H<4L?5OD8TH7QF2H;"7(1#$6&%<*.E14K71G26M1PgJLdD0G*+:#:G3(7$-/D3:Q=7P:)A)):'*8'(8++;0/;79CE,2@16JEIbTZrZeyUbuP\tamÖêü∂≠º—±¬‘°≥¡uÜê9HK#4*2$7$&9#5I0/C(%< *C%.K,5W49]7:X6;K0V[DrqUz\|]xwYrv]mu`muhvzêôû®≤æ±æ—∂≈⁄øŒ·øœ‹≥¿∆åööqÄ{sÇ}|åã}åèÅéóñ¢∞©Ø≈®≠À¢¶Ãù§–ù•”£Æ€¶≤⁄™∂‹µ¡ÁΩ Ì√–ÚΩ ÏØª·¶≤‹£Æ€™∑„ÆΩÊÆ¿‰≤≈Êµ∆‰±¬‹¶∏Œï®πÑó•pÉäOac6C<=I=AN=3A0(:,4J=E]M.G4,C/*B,6P71K2*B*&<% 3):(*;),=+)<),?,&9%3&;(1I38R7A[>J_@5H,-<) .(6)&4''"+"/%2!$1 "-!.$3 &7$$7#+>*#4"#1 "-'2"4A/"-%$>Q;9P6&5 (5#*2# &%(%('*'-"("*,- +&&"/,?,"8#*@+/B.-;*#0)1$'- ()2!.2#,3!)8!3E+6I++?,?0D!2H$0H$1L+1O-.P/0R11R32S49U<XpZzà{VbV2>2/;->K:)7& .(6'$0"$%&!$*&$**!(.$.:çú±™∫‘ì°æhvìö©∆{Ü§6<\&*G%%="%6(0=4AI>PR9NI,C3'<)$2# ,&%$". $2!*)(!+ '1&%+!%'#+ "*)1$0:/)3(+"0//@.,=+)%"*$,-5(2:/&1#.<+(6%+6((0#*0"$* ,&4%(6%%6$0+$/*2#%+&.<+-;*%0"#. $.#)3*#-%( &2& ,4?/NZLMYO:G>7D;%2(- )9,8F9.:.&0'&!$)"'/$!,.?/:O@1C5(/'.1( &*2#;C4/:*3A2R`SV_Z.74(3+0=3<H<PZOY_U]cY]b\\a]FJK;DC3>:<IB1>5.:0-5*<B8CJC7@;4?9LWSPXZ',/%)(*1*.8-4@4;G=-7/3<7@IF[aajnqY\a]`g" 
+	
+
+		
+		
+!$! 		
+		
+	"!+ &!%2!'4#'$+<4->62B?4DD7FM[jorÉ}jyrUa_nzzìû†Çéå@L@&2$$0$('!	'.''#&4'"")!#	
+
+	
+ )4,'7,#0& AA7IG;PQCNO?GH8<?.,2$(0!3@/=K:0=,%3"*+ -%24@*6?*$-09&,8$+7!*6"')/#-3'
+=<7@@447&;B05>+)59G.9G.6F,4D)6I-8O3/G-.D-'?'3M4G`J:V?8Q<3H7(:*(9'0A.,?+(;'%4!#0$" ((4(2@1"3#(+>+*?,2.(2>*)5!"*;)@YC*F-/F,6J1(7 #.!'+3(2?5DUKAXND\O'9+(6%.9+,7)&2((8-@TH5L:4I8"5""3!<O<,D.@XB3F3UfTL]M0B22I73L70E4,>.'8(&7'+=-"7&-B33J:2O=7TB4O>2J:%<,%<,+B2.G42K6-E/8P6LcFDY80C%-;$1>,%3$0 5L::S>3K5+A,+<*+9*(5,/;94?EFM]Y_ut{ïÑéßÜï¨Åí¶xâùsÇôÄé®ï§ª©∏Õ¨ΩœùØΩpÅã;KK->4%6$ 1$5",>();%(:"'>$(C$2P.8X3=W4LW7gfHynP~oPÅtTÄy\y|as{fqylzÅzêòõ§¨π®≥…´∑—µ¡Ÿ∫«ÿ¨π¡ÜîîqÄ}rÇrÇÇn}ÇzÑéïû≠¶Æ√®ØÀ§©œù§–üß÷´∂„∑≈Ï¿ŒÒ«÷ıÃŸ˘≈“Úµø‚¢ß—òú…†©‘´∏‚©∏·ßπﬂ¨æ‚≠¿‡ü∞ÃÉì¨jwäNZf>IK1<6+7+0<./<+'5$$4'(:.2G8+@1(=,)>-2G4-D0*B,'?)&;(,?,+>++>+*?,,?+(;(#6#':'0E25O6:T7J_@AQ6$1"."3?34@2#/!!/(6%'6#%4!"/%3""00A/'8&)<))<)+>*,@'8L3*<&)8#%4!#5BY=4M0'9#0=+ ("%"#!" ! " !!* -& $*;(':&,B-5H4(9',9'5@/)4$*#.4<-'0'3!33G,(: '5&006@A"AF&5D'/C'0I,,I+-J+/N.-L,2O1C[EoÑqcxeReRcq`2>0.:.+5, ' #'#>HG[aaNSW5=HGRd°±Àö´…ö™Àâö∏û≠ÃÉê≤v~¢`fäQTwTWvNVmP[mIW`4CF0?8#0&'''# !,'4#,**&%$!)'/"'&.# ())*"0"3!$5#'8&-!- ,!,#. 2=/8E42?.&1!"*)/%$*  (#. *7&)4$"/+ -*3"5<,&/ +5D//>++6('-#$)""'!%+'!'#",#"."*6(AM?R^T<H>2<4$0&!/"->.4B3+9*#-" '#*"#$$,!!-/@06K</?2'.&+.%/1&04&.2$(0!2?.IVERZO180)5+3@6FRHFPGFLBSVMWYTX]YBFG/55/:4.;22=56@79>78=6JQJPVR5>=@HJ).1156&(%,1+'3'2@1:H9[gYmyoW`[?HGchkhlmijl  		
+				
+			
+% ,!-!)!- +&&')6-+;1/?51B8/C8.C<6HH:INAMYÖíöqÄ{@PE9F?KWSáìërx6D7'5&(6)+! , 
+	# ".$(#")"$1($1(891HH<LM?WXH[\LSVEBH:4</+7)+7))5'(4&#0 -"/)6"0<(-6#)1")1"'3'3(4 !,	
+17+				
+63.EE;GH8JM8GL67?'/9!<H06D+2@).=&,>&3F07M60F/,D,$<&*C.B^H:V@E\J5J91!&7%-+- .#$ *$2%.>1.>1)(:*-?/"7$1)&-:&/=&,&7$3K5-G.+,>(&5"'(+ *0&(3+FVLBWNCYM$4''"*&.!'4*EWK9P@7N<?TACYD/B/AWBAYCBZD+=-UfVAVE1H44M8(A,"7&'9),>.0C03F2+/+=-0G34P:0L62K62I7-D20G53L91J51J44L45L05H*.>!/<(*8' 0#$6(:Q?9R=.E1,B-+<**8),719CD[cnàë¢ö•ªû≠ƒö™¡åù±xâôsÑîvÖöÖî´ñ¢∏¢Ø¬©π…ö™∑n}Ñ9IH1C7-@-%8$$6 #2&5"*;((;%)B%0K,7U3@X4P[9^^<h[;hX7raCzqTwz_vjr}owÄ{çïòû•µ¢©≈†©»®≥—∞ª—§Æ∏Öëël{vduocsresvzÑçô†∞©Ø≈´≤Œ•≠—•Æ◊Æ∂‰ª«Ò¿Œı≈’ˆÃ€˙Œ›˙«’Ú≥º›ïò¡îó¬õ£ ®¥⁄´∫·õ≠”ô≠“§∏ŸéüΩXfÄ<DY,4?098,6-$0""0$2!"3!%7)'<-)>/ 5&-1!#5%%:'*?,.D//D1+@-*?,,B-/E0-@,3D1/@.(9)+>+2K52J0/A'+9"$1 $0$)'3'>L=9J85F4&4#- -&#,-;*"3#,2"8!0G-+B( 2."3 (;%HaD4M0,=**!!  ( -),'8%-@,+A*4G10A/&3"(3"7B1'4")$//:)$/#0*>%+B&'9(6/7"35c_DUT81;"+;!%9 "9(?#,E(-H)-J+1N2A[B_w_f|gnmJVH?KA.80"'#!'%,73tÄ~ÜêëzÉàÄäñzáöèûª{ã¨yå¨í•√©∫ÿ©∏Ÿº…Ïæ»Ï∑º‰∂ª·Ø∫ÿ©µœgtá1=K,5<4<>#"!$%$)"!)+8'"1)((%'%%%%-"'%&' ,$5##4!(9'/ .+('$.9)5@05=0#+ %"'  (!,"-"-'+*7%/8'5>-%.%12A,/<*,4'$%*$2735:6'-)( $0&,8,9E9MYMJVL.80%/&(4(-;..<-&4'!+" ' #(" %$!) ,->.3E5/?2$,!%(,.#35(02%%+/:)2?.?G:.6)(4(9E9WaX>E=AD;VWOZ[UHJE>@?/530;51>52>4/90=B;05.LQJbhd>FH/7:%*-#$$&##(!(2'5C4<J9FTE\h^kvpU^[QZWlponso!#"
+!1<B(37
+
+
+
+
+			
+	
+			&)!#*") ) *6,,<1+?31H81H8.E51G;3FB.=D3?KtÅä}ãéwÑ{(4((2*3=5isjCOC?K?*8+)9..#%	!'#$!(5+
+
+
+$ "($
+	$-($/)!-4,AG=CI=JPBP[JLYHGSE;I<6D7-;.%3$%3")8%(7"*9$+8$,7&.6'39-4:,3<)%1&2%0"		
+		#&&,"			
+
+/,%KG<LH<JI7IK6LP7IO56?$/9 9C+5A+7C/1>*)8#$5"2E1*B*$<& 7#!8$0L64P:2I5>S@CXE%8%*!.!0*'-$5#+=-+=--B3#8)#5%-?/!4!.+&(..>$.=&+='%8$ 3 -%" +#CRKBWNBXL-=2#  .!9N?8Q>,E28Q<NhONfNAWB@XBAXD4K9);-AVG7P;7P:6O91#8))>/2G6*?,+>*.(#0*9&(;'&9%&<',A.0G33K54M72K50L5-F1,D,,>$0@&1B/(9'1#-B3;R@6M9+@-.A-.?-+9*9?;V[^Ñçî†Æª¢µ∆ì®ªí°nÄå`ovYfncpÄuÇìçï™û¶π¢Æºñ£¨grv8GD3E70F1+A*';"(9&)8%%6#&9#&=#*C&2P.@Z7M\;SY7XR2[M0cU:haElpWr~jsszÜÇãñúò°≤ù¶≈û¶ £´œ•Ø ô£ØÄãçgvoYi_Yf_gsqÖéïü¶∂´±«¨≥œ©≤”∞∫ﬁº»Ó√—ˆ¬–Û¿œ≈÷Ù…ÿı∆÷Ôª«·ß≠Õìó∫õ£«£∞”®∂ŸûÆ“ãüƒë•»î§≈Vd39Q06B7@?*6,+&4#1?.':'5L:3K;*B20G5!8$2-+2"7$*?.,A..A.1D01D./B,0B,*9&2>0 ..E15M7#4")+)7*1?2)9,+>+8K8>Q>.?-'3%$/!%)%3$->.-+14G1/*(--C.HbG0H0(6' (!#$!"-.&,,$!$) .$5"0F1,D,(@(1G0.A+*7&+3$+2")2!++:%&3!+8&&.+?$'>!-D'*<"#/19"CG.5;!-;$-<' /+ -!0%9 (A$,E(.F,MeK[qZ\o\nor~rblcU_VNXPZg^pÅyÖïíÑìñÄëõÜï®Éì¨âòµÉî∞ê§ø∏ÕË∫ŒÈ∏«Êû´ŒhqöYeçXhäwà¶o|úHQn/3N=>R43;000!# "% #'*$$++!, +%&!,#/!+( *'!2 (;'$7$#4"$1 )*7&+7) (%%- 19.0:/)3(&-%"' !)"-*"/%2!'4#,9''4", -&3"&1#$&,"Z_Yfmfipi-4-) !-#)5+4B5DPDT`V-7/*4,,8./;1(3+%/'#("""$*-&!& &!/".@01C3.?/$,!$'),#02'02%(. ,7'-8(-5(%- )4&GSE_g\@F<WXPlldUUM]\Wlnk=C?/<3-=33?53:2?D>271:@6^e^QY\5<D+06"%$(' %'1&AM?@N?GUH9D>HQN]hbcmekumdkd$$#"##,5HV_>PT1@=/:4,6.#"
+
+
+	
+	
+	
+	
+	
+			
+	*"!+"%1' .!%7)/D52I97O?4K;)?2 4)"21".:am{~âè\fePZO!,#,3+JUG-9+,:-&6)%7)#3() !(!*4,
+*5/#.&
+	#*#$+$
+!/:42=54>59C8=E8<G9<J9;I::H;:F:9D68D66B4.<+.=*.=((7".;'+6&2:-9?3:@29A,$-$0(3"$/ 
+
+	
+
+/2) & 
+		
+96/JF:NK:LI6JI4LN8JP6BK04=".8 3<'2;(6?.8E4"0#(3K3)C*2I56"$;' 7#!6%:O<UkVGZF(7$+:'2D.0B,/B..A--@-'<))>+,A0"7&-?/$7$+()*('6!3E-3E-*<&$5"!/ % 
+
+7F?BYO>VI,>2$8J<7N<6!.E12I5XpZMeOIaKSjVPgU.E3%9--B34P:8T=+D.3+@1+?3:O>&;($7#%4! - +"/'6#(9&':&(>)*B,*B*.H/2K5,E0*A-/D12D,4C,1B/+=-);-6K<:Q?3J6-@,-@,+<*,:-@FBZbdàìôì§¨Åï†`vÅL_f:IN8DD<FGFS[_kwÜòóûÆüß¥èò°\ej2>:1C50F1.E+,C)+<)*;)'8%%8$%;$(A$-J+;V5DY8IT4PP4QM2SM3TR9ZbKer`lyptÇÇáëõìõ∞ù¶«ß∞◊ß±’£¨…èò©|Öåfrn[h__jds}|éóû•¨ºØ∂…Æ¥Œ´±—≤Ω›¬œÒ»’˜¿ÕÔµ¬‚∑≈‚øÕÁ«”Èø ﬁ±∑œ°¶√ü®«´∂÷∞æ€®∑÷èü¿Ñó∏ê£√Åë´DLa3;F1;:+8.)7*,=+3D1(=*4O<?\J-H76Q@.E1%;&/$0A/#6#0 #8%.C04G13F04F.);%7F3#. %:)4K9.?/'("0#,:-/@0+>+'=(9N;>Q>->.*#-""%-0A1 3 (*@)0G-0''->V@8R9,D," !#&'"%& ()!01)%()"3!0F1.H/(D+-G..D-->+%0 +1#*1!"+ -:I4:I4*<&)&8 &=!%< -D(%9#2-;$0<$-9!*9$$5"$3)6"'2!&-&9#(?%#: 0F/7J6K^Kvàxâöäñ§óï¢òzá~`pfhysl}oÇÜÄí†åõ∞áñ≠Öì≠è†∫âù∂ó≠ƒ¡◊Ó¿—ÎÉí±/=b+:aÖôºÆ¬„•∑€íü¬v|†`aEDT:9?...')$  #""*"/%2!"-!,() *&1# , *!-!-  1)<)':'.++3A01?0&1# (!'#-"&0%(/'!)"*)5'*6((5$%2!,;( / -,	$6;4/6/*/)!( #-$+#1$.?/=N>AO@*6*2>42?55B8.;1+6.&0($+#,4)-5*(* "3#-?/3D4+9*(0#&) %('*)+,0",4%.9)+3&%- %0"7B4PVH^bTTTJEB9[YM^^TTVQ7=9,<2/?43?51;2AF@1604:0V]U\dfJQW9<C%(-(*)',&%,$7A6>J<UaUNWR=FA;G=UaWZd[DNE!$%#$%)(5+)51!*/-:B?PZDW]5HD2A:!.%* %!$"	
+	
+	
+
+
+
+				 *!'3),9/);-1H89R?6M;,A2+ "#.0.8Dt~àISR[bZDJ<'.
+)3(-9-'5("2%*<."4&%7)!1&$()5+( "0;3	
+
+#%/&!+"
+	'.'*4+'1)%/&,6-3=28@3<D7AI<BJ=FLBKQEMQCLRDCN>1>,/>+2A,*9$,9%2?.5@09D6>F7?F4.6!/8#%1)5!,7&)"
+				"%39-%
+
+	 B@4GE6KJ6JI4GF1DF0BF/=B+5=%19",5 &/"*"*5A31?0
+=U=+E*3K3#9$#6#*,(:*>V@G_G9L6!4%7!*<&&7$(9&'8%(9&)<()<).A.':'"0$1#0($$&4#-;*%6#,=*,:)'&6,=UH?WI0E6
+8O?4K9/-.?/%6&=O?OdSOfTPgUSlY0G5';/2I9:UB4P:*C-&=).C4,A22G6&9&"3 $5")7&%3"!/#1 *;),?,5L81J5-F01K2/G14!#4")8%*9$)8#+:'(9'+@/9P>:O<0F10C//@-+9(+9,:E?Yeejy~hz~J\`8HH,;8#0)$/'4?9<HFQ\`r|Üéñ£ô°¨åìù\ci,65+;0/B/0H.1I/0F/-@,':'(;''?'+E(,I*5R3;V7<P5?M4CM4BJ2DL4IUASaT_kit~áÅäõâìÆû®À≥øÂ≥¿„™µ”ãì™wåhpsenmktqâäïûß≠¥ƒ∫¡‘º¿Ÿ≥∏’∏æﬁ¬ÕÌ∆–Ûø»ÈØ∏’Øµœ∏æ‘º√’º¡‘≠Æ¬®™¡•™«´µ–∫≈€¥¿÷íû∂vÜ†{ìØ|ë¨dtÑER[0<</<5,:-->,2E13J62O;EdR6UEB_M,E0$:%%FWD1!4!#8%-B/0F/5G1-?)#4!4B1!#8).E35J9-"*$2#):*):()<('=(7L9;R>.C2-;,*&"0-;,(9',2J0E_B0I,/+0JbL3M4':$" !$% ),%*-&&)"$)"+$7$,D.&B)'D(,F++A*&5"$,*0"'0)!0%6#7M6.F,!8-D(&:!,&=#,C));#'9#&9#,?++>*/B,4H/.@(.;''" /+>(,?)&9%"5"5G7dyhl~ntÜvÅìáqÇzYec[ijZiprÇèë†≥íû∂ã•iuè~ç§Éï´D[m±À‹æ‘È¥»·Äê±àõº™¡·∑–Ô•Ωﬂ´¬‰Ææ‡ò£¡DI_BDQ158#"($/*7&#/!!/ *& +'1&'/$ (%+!*:/*<0'7*.?/+<*!/(,#4$%6&&4')!) "." , &0%",!(&!-%2!3@/+8''6#%4!"/*
+),%).'(+$$",#"0!-@,7M67M65K69L9GXHJ]J@UB9N;:L<7H81B23D20A/%6&&8((:*+=-3A2,7)*-",.#(*&(-1#.2#-4$2:+,2(%-"%0"08)59*8:,9:,GH:vwgfhZSXQ(1,*;1/A52?59C:FKE271-3)T[Sbhd]ccNOT/04*** )+&).'08->F;BLDKUM=G<ITF_gZai\ #!#$+$4) /*%+!/:0BNCW^9ML;OF*:/=K>3?1 #"	
+	
+
+				"$ *")!*:/:NB6M=$=*0$"(*@JSLW[3=5FN?*1! !!+ ".$)*.@4!6'$9*$9*!3'"2'* +6.+6.		
+
+
+
+
+		&'3) 
+
+)1&39/@C8MPEWZOfh]eeYdeW^aPDK94@,5D1.?,+:%%2 ,7'8C39D4:E5=F3/8#5>)&/#,-6#)4#'
+9<1&)	
+
+..&=;/CB0EG2DH1@D->B+?C,<A+08#(/&-$-	*=K<!/ !2 8N75M34L4-C.!2 )"0##4$-C.1G0+A*-(,#'& /*;(/@.(9)!#*&$!*)7&$2!+,#<REAYK5J9&G^L+('	#OaSEZK>UEE\L1H8*A18P@=XE.G2)@,)>+'<+$6&(:*"3# 1"3!'8&->,0A/0A/%7',A0:Q?6O:2J2/G/(>)/,2?+,:#,:#,;&#4!/D3;R>8K8-@,.@*.@*'8%*8+5B;JXXM\_=LO0>>1=;%1-+60+60-823?=HSWeoyÉåõñû´çìükox9AC+60):*1G05M35M53K3/G10H0/I.0M11N04Q57P:7N:9J:<J;:F8:E7=I?GQP^iové~ÜùÑç¨§±‘æÃÒ¬—Ú¥¬ﬂëõ¥~ÖóqxÇnsysx|Ñãìô°Æ¥ªÕ∆Ã‚ÀœË∆ Â¿≈„¿…Í¿…Íª¡„≤∑‘Ø± ∞≥∆¥∑»∑∫…∂∑…≠Æ¬¢¶ø§™¬≥∫Ã∞∑«éïß]h|\nÜbwådvÇ]lq4C@.>4*;+*;).A-4K73P<JiW=]NNm]0I42!-=L9"3 $5# 3 )@,.D/4G1);%!2 1'%'9+(=.6K:&8(#,%3",=*&7$':&+A,9R=8Q<0C04B10?,*9&"0+<)33L/,F)5N1.A+"5!%='D]G3K3&7$'/"#& !#$&)"*-&'*#&/&>()C*%B&&@%'?%#4!)#+)1"*,&5"+>*)A)8#>*C&';" 350F/'=&1.F0*?,':&+<)#5-,*  -#4!*=) 3 0+@/mÇqmÉnh}jlÇubuqlz}dqzoéÆΩ–ö©¿ò§æ≠π”myìP\vZiÄ/@ràñ≠ƒ‘ÖúÆí®¿ó¨«ò≤Õ™≈‚©ƒ·¶¡ﬁßø€¨Ω◊LTg8>J27:%! "*2'/:,2=/%1#(, .*!-#. $+#(($1'5G;5I=7I;0A1*;)&4#$2##1""3#:J=5B8$%1'&2("."&2&(2'",!&2$#/!+ -&3",9(!/,9'#0#+"$&+$)0('/$",!(4('8(2E/9P62J28P8NaMJ]JBXCCYD?U@7M86I60C/+>*&9%&9&);+&;(+>+0>1(2'*-"..$-/$,.!,0!/3$04%9?1,2((0%#. -5&15&(*,-9:*?B/NRC]cY#.&);/-A54A77A99@9KPJ270HMFbibbgc?@B446---$$":<9)+&+0)4;3.5.(2*-7.LVKZbUbj]!"$%&, )&(1 1A8N\H`jD\^CXS1C76G7+7)! 
+	
+
+		
+ "!! (+=1*?05#1"*!&#2-@PM3B=%1%"-(()5'*	"0B6'<- 5&#8)/C7.#!"2?5"	
+					(#-% 
+	"23+??5JJ>^^RghZijZY\IJM8DM8:I4*;(+<)%2 )1"FN?BK::G57F32A,1=)!*!!'-6%0;+/:*
+%(34,	
+11'=;,?>*FE0AE.=B+:B+:?)<A+3<'&/"',#0,:)1B0,?+-@,'=&.F.)@,3H5*=*%8%!1$&7'"3!/*;(+$%"%4A0&2$	
+!)%!"."+%&4%!-!";LBF\O6M;/$5%'
+	aobPbT>PBEWK>SD2M:A]G6O96N8+@-*?,%6&,$5%- ., .&7%/B/2G4$9(.E3;T?<V=5K4*='"3 %4!$1<J10=#>L29I/&8"4K7:O<4E30?*5G//C*(;'):*2B8<KF>NM2BA1??1==-8:.9=0;?2=A4?EGQ[Yeuu}êêó©íò¶z~âMRX#(+ +%+<*5M3=Z<>]=5V71R31P11O31M44M8<PDJYTJVV>GL:AG;BJ>EMNT`jqÉ~ÑöÑâßáê±¨ª‹«◊¯œﬁ˚ΩÀÊ®≤Àìõ∞âèü{~ç{}åêë££®ºª¡◊“ÿÓÿﬁÙ”◊»ÃÈ¡«È¿∆Ë¿∆Ëπæ€∑π“¥µ…Ø≤√∂π ª¿”∑ºœ£®º•ßºß™πü°Æ{yáON^<CUO]jUdiM]Z4E=.>11B0,=*,;(+>+-F3LiW=\MTpb1J70
+	%1#.<+%3"#1"/$;'.F00F1&<'1!2 ()+9,!3%-D21F5")&5"%6# 1+!2'?);S=;N82D,3A*6D-,;&(;%.F,,D**(>'0H.*D'7Q63M2.D-"3 (0#),# &'!!"#$"%"' (%8$(B'&C')C('?%%8"($#.%0 --:(2A,,>(52*G('B#'=&2#9",D,(B)+D.4K7-B/&5" +& !) ,#1 -$7#"5!*@+1H4|î~fzaH[EaujtÜÜàñ°î°≤∫À›…€Ò±øŸ•≥Œ∫ ‰øÕÍ|Ç§>Cc+3J0=Nè£ÆOgqsèõé©∫ç¶∫ê©øïØ∆ô≥ •æ‘zçû5BK+57:@>493&(#%*#19.(3%(%%(!/ -".  ,* )()7*-B30E6@RD/A1':'!4!,:)4B1$2#,:-%1'#"/%"0#&4'&4'".") ,$1 ". +$0"!.+)6$0;*,4%&)" "%.),8.0>13D44F6.@2&8(%8% 3&9%,?+9L8=P<>O=DUC<J93A04C00?,/@-*;(%6$!2 $7$.A.-;.#-"'*+-",.!.0"/1#/3$-1#5;/9A6(2)#-".6)*0$'++- 13%89+79+:=2!+ ,</1C55B9?IA:A:MRK8;4:?8OVNLSL&*)DFE(*)574@B=>C<#*#FMFPWPHNJ3<9)2//6.;A7 #&&(-!0.5FPK^oQhxVnz[tyMca8LC!1$$ "#"    
+		!"%"');-#8)*,#0&$1'&6,(9/,=3'9-"0!,*!,(4&( '7-&8, 5&5%0D8$4)	(4*$0&					) "		,,$==3IG;[\NghX]`M\aKEN95D/+>*,=*$1 17)IM>HO=AM9<K67H51>,)!!+3$,7'4?.+6&%+!!"%:;3 !::.BC3A@,HH0DF.>B+>F/5=(27#/3"(0!$/!"+6($1 #1 -'=('=&!7 -C.-B1(=,-@-+>+.0 -+$5#(""%/:*
+
+##+ !'!+'3' *+9,!.$ !*:/FXJ5J9$ &:H;GYK<N@_qeRgX@\FA]F":$0C0-B1+=-.0 %3$,!/ )"/%8%,A.(=,4K98Q;;S;.A++:%"1 -*8!7E,0>$AP38H.+>(9P<8M:0?,.=(@T;4K1*=)+=-/?43B;1@=0<<7BD;FL<FO9CM7AK4>J5<L<CUJRgjráéï®ïú¨Öãó]aj+.5&/.+8.=S>GdHBaB9W;4R8/M3.J3/H38NAXhewÖà}áênvÉY`pY^qciynsÜ|ÅïÖã£çíØö£¬∂≈‰ Ÿˆ—ﬂ˘øÀ„µ¿÷©±∆´≤≈•™Ω£¶π¶®ΩÆ≤Àø≈›‘‹Ò‡Ê¸ﬂ‰˙”◊Ú…ŒÓ√…Î»ÕÌ»ÕÍ√≈ﬁªΩ“≥µ ∂ªœπ¿”≥∫Õ¨±«¨±≈®´ºõù¨trÄPN\;=L,5>.<<8IA.@4->.1B04B18E4)7&#8)C^OGcUOk]8SB-D00$5#!2"0 #4$* 8".F01I3*B,5 !4 &"0!+9,%4#6K8!2"-"4..#0&)&9%:L6FU>IU?*8!.=(':$4L2!8&,'>$,F)>X;+E(%8"#&03,()#'("'(""#"#%('(6%)?(#="(B')A'%9 - )%*+&1 -8'#0-,!9)F'%B$#;#(>).F.+E,+G08T>1H4,?, +$!%1# .,):'&9%1G01I3qâqEY>DWA\qh{èê£≥¿¿œ‚ø–‰∏ ‚ºÃÊ±ø‹´∏ÿπƒ‰¿∆Ínrï9=X19L->H!9=1JOrçîñ¨πëßµã°ØÑö®Wkv&9@'56)%*1*FKD*/(#(!"*$ "(--"0&2$'%)- $6(8M>);-0B2%:'%8%&7$.<+-9+& '$1'(6)%3&,"."-9+4@2!.!-)". **#.:E5(3#.6+-7/(3-<KDDTI=O?;M=3E5*<."2%/%0/$5#5D1AN=;H7,7)3>06C21@-1@-2A.2@/):((;(/B/+9*$/!$*(,(*(*+-*,(+ *0&<F;/;/$.#,6+%+,/$-/".0#89+46(/3%"-/@06H:8E<@JB-4-JOH>C<6;4FME8?7&+%LQM!#"JLK685>C=#)%5>9OXSV_\9AC%-/#)'$ ##$',"$75EYbLbpNeuYp~ZszC[_3GF /* %%"#"$"$!" 
+	
+
+ * (8-#3(('9)0C0&8(0")/$!/ #/!!+ %$#*""/():03'-!$8,-?3-9/	&
+
+			#$77/CE8SUGPTCJS@:G3.?,.A-,:)%0 8>0JM<RUBKS<@L8<K89J8/=.*)1&5=00;+-8(*5%*5%"--5&<@2?A424' ",-%BB6:;+FG5GI3HJ2DG,;?(;>)7?*5<*#%"&,6-		 
+
+$0"):(/D1/E0-@,&9&('%8%+>+'8&0 /0%6$.&!!%0"!,
+'#. %! &-9+$0$
+  .!/=0 -#9D6!,&!)9J:0A1$'((0@35G;5I>eymMdTEaJ/K2./-?1'<+0 #5%%6&(9)):*!/  ,$5%#8'*?.1F54K7/B.*7#'3#.'#0*8!-;";K11C+1D.;R>3J6+<)6H2AX<9R5'=&)<)+;./<56@ACJRV]giq~r{ävêryãafyeg|npálná{òèî®òü±çï¢qxÇQU^4<?7D=LaRPgUCZH>SD:O@4I:/E81E<CVRwâã†±∏≠ªƒ®¥¿£¨ª£™∫¢®∏¢®∏•™ΩßÆ¡©±»Æ∏—æ ‰«”Ì»“Î∫¬Ÿ≥πœ∂Ω–Ω∆◊¬À‹¡»€æƒ⁄æƒﬁ≈ÃÊ’›Ú‚Í˝ÁÓˇ‹‚¯Õ‘ÒÃ“Ú“Ÿı”ŸÛŒ“Îƒ»·∫¿ÿ∂º÷∂º÷¥∫‘≥∫‘µΩ‘∞∏œ§´æèîßqtÖHK\07A!-).>3,=-,=-1B2=K<2=/'"<QHJfXJiY3P<.J31K2.F.(?+&;(,A.#9$"8#-E/2J2.F.42,"3#*8+"'0A/3D1!30D+';",("/)&%'6?.?H5*6".;'(:$9P62$$-4H/6O2,E(. -.(560()#"##& &$1 5G1(>'&>$(?%)=$$2&/'.!'( -+4#+4#!,,2)A'(E''D(-F0,C/*B,$=(1L96Q>2G4)7&"* "-(3%&-->+$7#+>(-C,BXA[rXZp[Ujcî®©¡“⁄ØºÃzâûzà¢¡—ÎøÃÏîú¿tzû¶±—Ω»Êâê¨GOd-9E"16!35+=?ASWL[`FUZ-;>!//*(& ''<D98?7'.&",#",#($%(-#1 !/*(#/#"0#,'4*- ,2G4-@-(;( 1'5$-9+) %1'-:0!.$*(4(6B4/;-*6(,8*(2'( , (4(&0%#-"/=05E8@RDEYM>TG?UHCXI9K;8F7*6*%1'".$ ,"$'8( 1!.6A1MUFLRF/2+.5-7C51?.,:)/=,0>-->,(;'.A-/@.*8'&1!'-&*')*,)+*+#'-#1=1:H;*6*,6+(.$.0%02%//#/0"35'+/ )4$2C37I;9D<7A9)0)292.5.07/8?7&-%+1'QVO;@<GKJ'+,,01+1/%.++41,65)+,47#(,"%"#$(-#%86CW^McnWo{TlxMcn<SY;NTDVX(40#%$$$#%%$%$$!%)6,%5(,?,':'/*+!.$(4( , '*5-%+$.?5 4(!5));/-?3"2'	
+!
+	!
+
+$!
+			
+	
+ !/2)8<.>D6<G73B/*;(2C0(6%&1!EI:NO?XZETWBFN93?+;I8:H95A5",! &.#5=008))2!.9(,7&)2!+2":>/=?1<>1+-"/1$GH8EG2CE/AC+@D)<@'36!*.)0IM?
+%/:2CME-7/
+) '*-%8%"3!(!1$1!4!"3!,&4#-&9&#4""0!!-!(#)1$"- + &&4#1?0$  .!/=0)0A/<K8'!-!&$'&#+5*1?2&6)/@62F;L`U@WG?XB'?)!3#"2%/A3'9+#5%&8((9).@0,=-#4$&+ 2$!6'&8(*?.-B/#4!'3'0$-$/2=,(5!'64F.1D.5K47O9-B/.A-<R;?Y>>X=*@),?,,<18D@alpåñ†ü©µ¶≤¬´∂»¨∑…Ø∑ ≠≥…¨±«Æ∞…£•æôõ¥õ†¥ù¢µïù™ÉåïlpyFNPBNJUf\Xi_O`XZid\khHWR6GA7GFN`b{åì°≤∫∂«—π ‘ª«”æ»‘æ∆”æƒ“Ω√”∫¡—∫¬’πƒÿΩ»ﬁΩ«‡∏æ÷Æ≥…Æ∞≈∂ªŒ¬ ›»”Â ’Á…‘Ë«—ÍÀ’Ó÷·ı‚Í˝ÁÓˇ·Ë˚“Ÿı—ÿı€„˙›Â˙⁄‡¯—◊Ò≈ÃËø∆‚ª¬ﬁ∫¡›∑¿›∂¬‹∂¿€≤º’®∞«êó™fi|=AL3>:2@30>/-;*/?2/=0 7MAJfZKjZ.K7#?(+E,.H/-F0*C-+C-,B+*@)1G03K3-E-!7 !7"&9&1B2+9* *)7&);# 42I-8O5(;',($/!)$!' )%2 8I6<O9*<&$-',AS=.E)*A'$5"#$%34.-.("%&.!6E2.A+(>''=&*A''9!5C,09$*.$**#0,5$*2#!.$5#*@).H-*D)(B))>+$9(3"3!?ZG4M:/D1$2!)  #(-9+ , 0->+$5"/ 1/"4/@.O_UØªπ}áâù¶ØtÄêzÜú√”Ì¬—ù• bjèëû¿≠ªÿµæ€Öê§VclCSS0?<(72'33))&%&#)!* %&(&0%>F;-7.#-$') ) &$!-!.!/)*6(,8*#1$)*+-4G4(;(!2 -*$.#& *!(4*+8/#0&1=16B6+7+%1%#/#'3'&0%*6*&4'<J=7E8FTGM_QCZJF^NBZJ>VF8O?1C5.<-&0%&-%&+$(/''1(+,:+&4%#. 4<-QWIeh];<7&(#0:1<J=+9*"0'5$'8&':&.A-0A.0?,-8',4%,/$')')/1&./)+0)&2&7E8/=0.:.+0)/0(13(11%11%-/!#*/:*2D46H:4@66=6DKCLSK>C<4;37>6 (19,MSIHMGEIH+/07;<9??6<<)21#+-9AD9AD7<@+.3  $&+2,0DCQfiYqu[rxFZcL`iK_jYmtK^\-#!$&'&%'''&'&""! !		
+ #&(*:-,>.*&%* '3)#-$
+( +8/'7,.B6%:+$6(,!#.;2"
+
+
+	(-'&#*"#
+	
+
+"'1&4B5->,.=*8G4(5$)1"HJ<VTESR>ZYELO:?G2:A1/:,:F:8F9)5)",!19.8;0<>18<-18(*3",5$+2"26'57)<>0?@0GF2DC.BD,@D+<B(16*.!%IOC	#-%-80	%0(?OE5F<&
+
+
+.*=*.A.(:*$6&$7#$5"*)+8' .#4"0$2# .!(4(#  %-"-8*4@2,#(0# +&3"->,/"#"/$1C5#:(5L8&9&%		&%6$/@.*;)%3$"'7-+<24E;);-;M=+>+$6(*<.0B2&7'&7'(9)*8'+<**<,#5%.!/"&;,0E61!"4$':'->+,9%#/+4!0<(NZF&3"1'8%.D-:P95H4)<((=*C[E=Y@<XA+B.*<0/@:CSStáçï©≤§∏√¶π«©ºÀÆ¡“µ∆ÿΩ ›ø ﬁæƒ⁄∞∂Ã¶´¡§©Ω¶¨ºû¶±êô†|ÅÖYbaLXTXgbbppmxzáíñäìöpy~R]_HWZPbfoÄàéü©£¥æ±¬Ã¥¬Õ∂√Ã∫¬Õª√Œºƒœ∫ƒŒπ¬—∑¿—∑ø‘¥º—±∂ ¨Ø¬≠Øƒ≥µ ª¡◊¬ ﬂƒœ„≈—Á∆’Ï»◊Ó‘‡ˆﬂÍ¸ËÔˇ‡Á˙“Ÿı”⁄ˆﬁÊ˚‚Í˝ﬂÁ¸ÿ‡˜Õ‘∆ÕÍæ«‰º«„∫≈„µ√‡∂¡ﬂµ¿‹±Ω◊®∞«êï®dku?GI7B:2@1(9'+=/.@2+"%:)4O>FfYGgZ+F7.)<)2E13K52K5-G,+C)'?%0H.2J0/G-"8!$7#':'0A1%3$ +$3 %7!!5"95M56N6$:%)(4&/:,!! "+EVC4G1*<$FP85?'#0@R<.D-%;$&<%, !!"-.&-5&2?--?)-@*#9$%;$)@&4K.6I-/=$&/'."-#0*5%$0"+<,4I60H0/I.)A'#6"+$"0E4:S@;T?'<+(9'#1 -*''5&*8'(&&7$->+#1 '&+(&QSEddXYVO°°°xá¢Ææ¬“ÎΩ–µ≈È£≥◊´ª›§≥‘ô§¿íü∞FX\L_YMaXIZP0;7&# $&)(&&8B7;E:)3( '$&$""$#0(6%,:)'5$&2$*+&4'(>O=(6'*$&%'1(2<4&0(+!(5+*8+#1$!-##/%(2),6+-9--=0<N>D[ITkYUn[LeRG_O@WG8L@+;0*6*-5*,2(692:;5/2+.4*)1&%1#/=.*8)#+&, BJ;]cWYZU**(#*#5A7?M<.?,#1"!/ ':'+>*,:),7'19*-3'*-"),#()!*+%+.'+0)$.%'4*0B6.>3*4,(-'+.%-/$/1$-1#&.<+2E25G76B8,3+%$&) .4*&.#!)4</@H=;B;SYU/329=<W][286&,,BHHSX[PTWHIK>?A !  %$", 1+)=;?SRBUY&9@CUaJ`nWmxNfh8MH&(%! %%(&&('#&%%&%%%$$			
+''3'"0#+&&6).!+ , '+!.8/ '# ' ")"",$#0'(8-+=/0E6(=.!3%)!1;3			
+	/4. '
+ '		 "	*6,/?4%6&+9(;H6(5$'2"KN=LM;XWC^]ITVAGJ7+-*. +6(4@4<H<3=2.4*36+@@4CC7BF86<./5'/5'48)69(@A/DF1CE/DF.DF.@D-8=&',!EK?#'3)*5-
+$6*9MA=ND /("*8+4E5/D1)>++>+*;)"3!)$ +,7'"/%6$*'*-;.)&!&-8*1?0 -& +#02@/*;)($"##""'9+1H6%<*7N:$7$
+
+".<-0C/$:#2+/%-=3.>4 0%HTH4B5$6(0B41C3"3#(6',:)/=,*;()<)%7'/"#5'6K<1F7% 1%6#(9&.=()8!'5:H1HV?*9$+:'(9&1D.;N8->++<),B-D]G9W?8T>*@3.?93ADCRYas}tàìuãòvåö{ê°Üõ¨úÆ¬∞ø“ø ‹ºƒ◊∑æ—≥∏Ã∂ªŒ¥º…®±∫ö£®àêíhqnQ]YcomuÉÜäóü¢¨∂£´∂îù¶~áédqw^mrm{Ñåö£ûØ∑•∂Ω£≤πú©±†©≤§´µ¢´¥§¨∑®∞ª¨µƒÆ∂ÀØ∑Ã∞∑…µ∫Õ∑∫Õµ∑Ã¥∂Õ≤∑Õ≥πœµΩ‘µ¡€Ω…„Ãÿ›Ë¸ÊÔˇ·Ë˚”⁄Ù”⁄ˆﬂÁ¸·È¸ﬂÁ˙⁄‚˘Õ‘«ŒÎ¬ÀÍø Ë∫»Â∏∆„∏≈Â∂ƒ·∑¬ﬁ∂¿Ÿ§¨øÄàìKUW8C=1?0->,-?/1F52D45G7)@,1L9HjZHhY+C5+(9'(9&"8#(@(-G,1K./H+2K-7N12I-%9 1+(:*$2#-+-!3!53'?'2J06N6%:'.'5$,9( ( ( (&-K^J):'+:#DN6R\DCR;:M7-@*3%;$%8"'4#-5(! &3!*<$.B)*A'45 /F,.E).B&%7".(3"+8&4B15B1/=.0B20F1/I.+E*,D,!4 "."#/%%5*J_P9QA:S@*?.*<,2E2-@-*=*-@-3F31D01B00C/1D0.?,#/!()&2$#.%,CB.MJ7KE7ììãkps©µ¡ªÕ„ø‘Ò≠¡‰®∫‡©ªﬂ£≤”yá°N[kBTV?RLCWNGXP)40 &"%!%( *#! &0%:F:;C8&-%!"#!-+9(+9(&4#,9(.:,,:-*8+!/ *8')% ,")5+)3*6@75?62<3 ,"!/"- ,, 0%(6)6D7O_R_qaTiXF]IHaLJcN;R@2G6%7+*7--7.!&'*#9:256.34,:;38;2(0#%1#1?.-;,'/$&,"19*T\Ojke<=8!&" *";I:DUB8F7%6&+>+&7%'4#%- $*"(!$$* (+$$)"$)#$+$$+$* *<07I=-:3'0+")!'-#-0%+1#&/=,,>.3E56B48@16=+:B-/6&%+!)-5("-*2'3:3CHD>BA6<:5;7)2-CLIU[[U[[GKLBBBDDD
+!!"#$**##!"'2N_o8M`Uo~TozG_a1()%!!"#&)&(+())')),+*)
+'2@1->,%5(%+'5($2#-!'3'5C60>1-9/-80+5-,6.*5-,9/.>3-?1+@/(=,.
+
+)0)#*#		
+/83#$%	%'"
+%'-=2)9. (6)6D5%3$&1!?F4PS@NP;LN9JL7@A/45'::.,.#8;2@C8?E9>D88>2>@3BD7DF9@B5>@3?@2A?0ED0JI4HJ2<?$BF+?C*38"(,
+ #;A39D3'4"*:-"2%&2&$0$.)>-:Q?7N>.E53J:0G3,D.-E/,B-'8&*!!#&. -%6$-),+;.%3&!)%0"'&%,:)*;)- 
+%&$),"4$.C0/G18N9#1 *&0%(.@0"8#57! 5" 5$$8,0A7/<3".$NUM>H=+;.0B2+=- 1!)7&'6#1@+0?**;(#4" .'7*9K=-B3"+<*"3 !2%8"/C*1C)4F,/A))8#%4#25G13B-:G5?N;7M8>WA9W?5P?.?7AOPQ[eXap[duXdtRbqRcsWhzgxåÑì™®≥…æ∆€øƒ◊º¡‘ƒ ⁄≈ÀŸ∫¬Õ™≥∫ö•©åñóp|x[gcfur}åèû≠¥Øª«Æ∫∆´≥æö£¨~áår}ÅÄéëí¢¢õ≠≠úÆÆï¢®áëöÖåñÜäñáâñçëùîö¶ó†Øô°∏õ¶º±πÃæ≈◊¡∆ŸΩæ“≤≥«•£πùõ±öö≤õüº™±Œ¿ Â“ﬁÙ‡Ì˛ﬂÎ˚’›Ù’‹ˆ‹‰˘›Â˙‹‚¯⁄‡¯“Ÿı«ŒÎ≈ÀÎ¡ Î¿ÀÈª…ÊΩ Íª…ÊΩÀÊ¿Ã‰≥æ–åò§JX[3B;->.*=*'<)2G44I61F3 7%+F3HgUGfT,G4"9%/B.-@,)(*C&*E&(A#4L,;P18L0*>%%8"4$9&1!. ./0#7#6 ':$!9!1K24P9(A+-%8$!4 ':&,?+/E.7O7I_H ."-4=(CO7EY@/F,+>($7!%9 &8 '6! -%&!)%2 ,>(&=#AZ=.G*%8"#5#5#5,>&.@(.=(-<)<M;BSAIVEHUD9J85K6/I.*D),D,1G28J:>PB=SF@XJC[N4L>4I:3H7/F20G3-C.*@)*@)*@))<((;'2E1+<) ,",!$0"'3%-:)'2!?D09<'89)mpeR[Xçú°∑Ã›¬⁄ÙÆ¡‚¶∏‹´æﬂ´º⁄í°∏O\lGV[EUUGUU9EE.8:#,+%!#"$% !) $0$)5)?F>-2+ ""$ %$%1%&4%'5$'5$%3""0!)5)(6)'5&)7((4((2'/90-7.*4+*6,.:0&4'#/# .*/'<)<U@E^IG`KJaMH]JK^K=P</B.,=+*8)%1#+!%/&291#(!.1*:=2<?403*(.$+3&.;*2@/,:+(0%'-#)/#EK?dg^[^W,.+# , 2C1>Q>+>*)<)%6$$.##)"%#& %$+#!+"",$!*%"+&)!(0$0D85F>)81#.(#-%'/$!)).:,(8+0C0;I2BO1ES/HT0-7%#+%$,180685,.-*.-+1-1;3ITLLWQQ\VFLH?D@EECBA?#" ! "'''"(0EUdMbuSm~_{á[w{?VN(%"!!$&++/3 1/1/23 3 1.(
+	  $' , ."3#.!*%5(BSA/=,-9+(4(8F70>/$1#!6%+=- . 
+	
+		
+
+/:4 -&!+#$
+	%'"	+!*:--=0)3C8,</'5&"/-4$<@/>B1?B/BC3>?/=;.?=10-$OOENNBQSEFJ<CG9CE8CC7==1=:1=:1B@3GD3KH5KJ5BD,AE,=A(59"%( "$&##**"$&9@0DQ=0B,*=*1!)7(0>-4B16I68M:*C.!:'(A,,E/+D.)A+5 ' )/#&%3""3#!/ #&6)*:-& %*$0"(6'+<,)
+
+
+	
+!(()$"0C08P86N6;N:8I7)6%&);+(>).D/.D/-B/+@/-B3-?3.;2!+#MRL:A9,:+0C0&9&&9&%6#-%4,;&&5 '6#%3$'7*7I;&;*):*#4"$5#/03G.-?%);!%7!0*9$)8#%4$1LYG8G48N9>WA;WA7OA8FFhr{ëö©õ§µñû±áè¢nzä_l}`oÇnzêíúµ∑ø÷ƒ ‡≈ ﬁ«Õ›Œ‘‚…—‹¥Ωƒ¢´∞ó°£àíër~zbnjdrr~çí•≥º≥øÀ¥æ ∞∏√§´±éñòÖèéâïëèûôó¶°ì¢ùäññÅàéÇÖéÉÉèÑÇèÖÖëåêõêóßÜé•áë™©¥ ƒÃﬂ…–‚∆…‹∑∏Ã¢ü¥êã°èä°ëë≠£¶≈∏¡ﬁÕŸÒ◊Á˜ﬁÎ¸’‡ˆÿ‡˜€„¯Ÿ·ˆ◊›ıÿﬁ¯◊ﬁ˙Œ’Ú«ÃÏ≈ÀÌ¿ÀÎº…ÈΩ ÏΩ Í¿ŒÈ¿œ‰∏≈÷ëü®K]]2C;.@0':&%:'0E21F3'<)0/H5GgRKkV+G1":$%;$!4!4"8!+D''B#'@ 9Q/E[7=R1)=$/B.6K80G5-B1'<+%8%!7" 8 %=%'=&*@)":".H/4R:2P80I32K57O90H2)A)5'A&C[C' !,1@+=T:/F,4F.0?(1A'(8&8  2+:%7F17F33E/(;%!9AZ=!:"5%4!&5",;(1C-(:"*<&*;(5F4@Q?HUCP_LOaK@V?.H-.H--E-3I4BWDOfTHcTA[NCZR0E>"6-!2(3$ 7#%='$:#5"8!)/7J6(9&%&&#/!4B1#06?,2:%)0[cV;E=BRRü∑¡¬›πŒÎ®ª€©ΩÿØ¡ŸhwäHVcHU^?LR)48%04;DI2:<$*&#%')&* !-#)&.8/<C;&+%""'".")7()7&)8%#1 -*$&,+ *&2(!-#!-#!-#$1'#1$&4%/=,3F38M:KcMKdNB^G;T?5J70C0/=,'4"$1)4$+3$'/"%-""*)/%/4-"+.'/2'.1&14+17-+3&+8'3A00>/-5**0&&,"25*Y\Qmpg@@>')(% .!(9'':&%8%(9'$0$%,$"' $)" %) ))!("& $)!+ )=17KB1B<%1-!,&#-%#-$,6+&2&*:-2C0>N3?O+>M$AP)*4$AJ7%.4</OTMOQN243$*((#.8/KWMBME@KC:D;ELD?D>EGB#"!"$*'&"&("3;G]kWqÄa|áeÅÇWsg,(()*+.3 23 "7$34#8%113 310$ 		
+ .!&8($6&,>.ObO'8&!/ /;-5B12?.%1%'(5,#3&0@3  
+	&%
+,71)6/$.%#
+	+2+%1''5&,=+*8)!7G:#5%'8()"'-48*9=.68*BC512$;;/WWKVWGZ[KZ[IUVFRPARNBLH=?;20,#84)GA3IF3FE1@B-=@+.1'(*(66*55)((//%13%29'ET=7J4+>*2E29G67E41?.-;**;("5!#8%*?,#;%%;&(>)"5"+"""59+"/+9**8) 1!&8(1C3!2"#  !,%2!+8''5&"0#* 		
+		
+'(%&4%?P>?U>E\B<R;9O:.?-
+ #1$%7'$7$$7$&7%/&8*-?3*:0&JQJ.5-!/ /B.':&*=)#5*!0!.))6%'5$%6&2G6+@/%7' 2"1$5#,#2'6(7 )8#(5!1>*-:&!.%2!7C5#1"<O;<S??VD9MDIV^ãó•ØøŒ∏ ÿ¥ƒ‘®µ∆ò•∂éô´ï†¥®≥«Ω≈⁄«œ‰Ã“ËÀ”ËÕ÷ÁÕ◊„¡ —•≠∞ò†¢êôòÜèér}yfpo`kmåï£ØΩ≤º»¥∫∆≤∂ø¶¨¨ïüóåòåâïâàîààîàÑêÜÉåáÖããâäèàáèáÑçáÑçâåïçì°Åâ†vÄõ¶∞…∆—ÁÃ‘È…–„ø¬’™®Ωîë¶íé•ûû∏´ØÃµø⁄≈—ÈœﬁÒŸÊ˘€Ê˙⁄Â˘ﬁÊ˚⁄‚˜‘⁄Ù‘Ÿˆ◊ﬁ˙◊ﬁ˙Õ”Ûƒ Ïø…ÏΩ«Îº…ÏΩ ÏæÃÁæÕ‚≤¬œÜòúL`^0F:,>."5!"5"1D10C04!..G2GgPDfM">'6&<%&:!'>$": +C)&?"#<9S0C\4>V2-A( 3  4(%;.-E5/J75Q;8V>9Z?2S82P85S;.J13O65Q:0L5,H2-H5-F31$!4 0H0=S>##(7J72J4+A*.@(FT;RaD5D''7$8-F(6O2+B()<&%;$$<$AYA'?'.?-)7&$3 ):'7I30B,->+):'5F38I6BQ<FX@I]B7P3,F)1I/G]FAT@BUBYn]FaRMg\G[YXjj1?@#//)"$6(+>*&9#$7!"5!/'=(3I2#6"')+"0!4E3"0/:)09(<G7MWL ,".)Jbf¢Ω»æÿÈ°∫Œò≠æmÄèJ\jSdnO]hKX`GTZ9DH5?A=FE$*&'&2$ ,"."+,- +&".":D907/$+#&$.#.:.8D82@1/@.&7$$5"(6%-("%$&+0=3*7-(5,!.%,# .!0>/?R>:R<9R<:Q=/D1,?,&7%(4&8@3.4&+1#*0"+1#.6',4'*0$&, (+ )/#-3))/%.1&.1&*-$&,"%-"'3%3A0/<+5=0+1'$'%(HL>mpe]][111$&%#)%&2&#4$%8%3F30A1&4'#-$$+# ' ")"( &%%%'(!2(7K@5I@(74!-)!,&'1))3*#/#);-2E1<J1<I-&3*7+!+HP8&.-3%?D=EJD/40&,("+&(2)HOG1811;27C7:H9@L@LVK""!&3 4*##!%(,@IWnv_w{b{wJeV+/!4!$9&4!10442365 8"6"035  3/  		#/%*:-.@0*<,-$6&$". 8E3CP>"- *%-"$
+
+",7/)6,%
+			"'2>4%/'*7.*7.)!* #-$ 
++7-(6)$5%+9('!1<40B4!3#'7*"
+"%$')+ ;=0CC7HH<TUGYZJ]^L]\HZYEb_N[XISOCJF;@=463*95)><-=;,47&*-!23%JH;CE7-/!*,79,8:,29'DR;0D+&9#.-+ + +-:("1'5$0A//B/*=*!4! 1 .+"* & #()!?C5#*$/0;-2>0.<-/@01C3/+'$ +#. + $#-%$	")*&#(4&4E3>Q;9P65L22H18K7+<,"!1$ 2",+,0$,>2+;0!,$LSL)0((3D1+>*(;%1'"0*#0)6%'5$(9',>.(=,);-(8+*;+(9' . /6E.:J0.=&0?(9H19H11>,+8''3%,<Q><S??UI;NLkwÉ•±¡ªÃ‹∫Õ‹∑»⁄∞ø“©¥»Æ∂Àª√ÿ«œ‰Œ÷È—ŸÓÃ‘ÎÀ÷ÍÕŸÈ≈œŸÆ∏∫ö£¢ñüöîùòäïèzÖÅlvuhsw~áñò†≥•™Ω™Æ∫™≠≤ù¢ûêõçàîÄÇãxzÅqpvjv~sÉäÇçíéèêíéåëçàéàÖåààêäéöÅÜúxô§Æ««“ËÃ◊ÎÃ‘Á∆Õ‡∑∫Õ°üµùõ≥ß©¬∞¥œ≥∫÷π≈›≈—Áœ‹Ôÿ‰˙€Ê˙›Ë¸ﬁÊ˚Ÿﬂ˘’€ı÷›˜ÿﬂ˘÷›˘Œ‘Ù¡…Ìº∆Èª≈Ë∫≈„º»‡π∆◊£±∫pÇÇ9NG0F9)>+&9%(;(.A.1D14!/6"?_G9Z?(D+!9%9 *>%$;!%=#-E-(@&85O,?Z1B[46J1/A12C96KB:UF:WE?\H=]F0R96X=9YB0N6">''A(!:$6!7$5N;?VD6M;,?,1D0-C,<O;*#1".A.=T@/G14,>(CS9L\ACS8(: #:'B#,I*)C(/E.-C.(>)@ZA2J47H65C21B0/B..A+,>((9&'8%2C0(;%9K33G,7P24O0-G*5M3OfLPcMK^JOfTOi\D^U\nnn|6?FBKP3=<.;1%6#.#4!134J53I4%8$- -+'0A/#6"%22?-;I8)7*%2(/>7)>?QjonÖì[rÄI_jMajH[bSdlVdmKX`ESVP\\Q[\?JF-7/%1%$2#$2# .!"0!$2#$2##/!**$0$)3(3=47C79E97E80>1'5&0-+9(!/ .)#!/")$2% .!0@3/?42?6!.% -$"/%&4%$5#!6##8%&9&#4"%3"&2$'-#(+"),!.0#02%,0"+1#08++1%,/$*-"),!'-#$* '-!-0%'*!&,"(0%*5'7D36C14<-58-+,$ !15'^aVmnh@@>&') $# *!$0""3#'8&4E55E8+9,(4($.%'.&%,%&'#%$&+".@45I>0A;"1.!-)"-'$.&".",>.0C02?+3?)%1+7!'-7CL1#+)/!(/(.403<95>;,71(2*.408><094(4*0>1?M@GUF!"!!"+3G+7L-!3$"('/B@8KE&:.0-2!!8$(A,#<&236  9#6 4554 8"7!32!4  .
+
+ %!!+!(5+)9.-=0$5% 0#"2% 1!,&"/.;'GS? ("$/:2",#
+	
+
+	
+	
+	!) 5A76C9,<1(8+'7* .!"."3=2#$ %,%$.%$.& ,")&4'(6'+9*+'):J?$6* 2$(8-"	%&@B7GI<OQCUXGX[H_aLbdO]\J[YJWUFSQDGG;BB844*#%!#" +/!46):<.9@.5<*4;+,0!/1#+/ EQ=-<%,;&,%'$"(&/ ++6&$0"'5&(6'(9)*;)*;(#0(0!!''*),!JQA"+%-.6)%- 1<./=.0A/ .#1"$$#&&!(!$+# )()*&(.<+8L3>U93J.;O6:M7(9&3A2- ! 0#0"*)+ 1A6.;1%1'KPI+3( ,=L9-<)!0-%$2!-)'4#'5$(6%*;)&7'$2%"0#!/""3#'6#+=%EY=F[<BV:CW;DX<AS96E00=+/>+*=)8P:8Q>=RML^béö¶≥øœºÃ‹ª ›µƒŸØª”Æµ—∂Ω◊¬…„…‘ÍÕÿÓ√œÂæ ‚…÷È…◊‰∞Ω√êôñâìäñ¢îû¨ùñ¶ôÜñå{äáxÉâÉäùëïÆöö≤û†Øúù¢èîçáé|Çärx|ekmXeeYz{säèàìòíìïîëèêìèêêéëçéìçèõÇï{ò™≤… “Áœ◊ÏÃ‘ÁÀ”Ê¡»€∞µÀ´≠∆∞¥œµ∫◊Øµœ¥ª’π√‹ƒ–Ê ÷Ó—›Û÷„ˆ‹Á˚ﬂÁ¸‹‚¯◊›ıŸﬂ˜€„˙◊ﬁ¯Õ÷Û∆œÏ∆ÕÈƒÃ„ª«’£∞∏~åèSb_.?5.C2(>)+A,(?++B./F24!+)?]C8W8%?"#<+?&*>%&<',B-0H2/G//F*9Q1D]5Ha:BV;DVFEVLBWNC]PA]N=ZF<XB)E.)C*#<'!9#(@*&<',')-(:*8M:?W?5M5*B*<R;/B.0F17Q84N5,B-'1D0=P:9M43G..@*!5$= -G*:T9AYA=P<4J5A[B,E/*=*)<)$7$"5!200$5"1G2&<%/F,*C&,F)/L..H-8R7JbH^u[awbMdTQk`BYSjzzlw{BIQBIOQ[\&3,$2#-<)++-<R=3I4'8%,("-@-(>'<P5-A&+>*0B25E8'80<NPUhoI[gUgs.?FSeiL]dO`g[jqTch(66)517C?0=4*7-)7*$4'/"'!2"%3$%3"$1 #0!.!-$.#%/$&2&(6)'3' ,  ,  .$0"*6()&('"0#- $4)/"%5(#3&7E8)7*+%1%%/$&0% +". ". $0"(4&)4&&.##)#)*-"*-"(."&.!-5(-5(/5),/$-0'!$*0$(."%('*!(0%'2"7D0@L8/6&,.#/0(34,47,RVHeh_Y[V.0/#'&#*"'1& *& , +9,0B23D2>J<&.#$)"%'"##!& '')#3&4F:6G?'63"., +' *"(4(.?/0A1$/"* )*3"'0<&DN5&/*4)"-)2=?4BE1==-971<8=GFGNT5<B#-,#0),9/1A4 !#!+-A%+@!!3)""&"%(%&+18%%A+'C, 9$38"#<&#;% 8 65246 7!5  3)!(#&1+'2*$1'-#"#+!.!)),,%0 (
+	'$)5+
+
+			
+
+
+  & -#)9,4D7->.&7',- ?J<#+ 		
+(  ,"!/"+!-!(%,:-8H;, -"*7- 	()!8:-EG9NQ@UXE[^K\^IZYGYXFUSDNOAJJ>@B7,.#(+")/%)/#6<09?118(+7#/;%.7"07%-1##*CO;0>'0?*!.%"+%.#+"-%0"#/!,:+0>-*9&'4"1:),2$%)+/ T[I%,#)-3'$/7*1?06G5#1 )! "!""
+"".",,()!-%5A34C0.@*1C-4F0/@-+#1 2@1/;/(, 2$.! 0#/$/?4*:-(4(GOB-5(*3A0#2!.)) .#1"$"/,(6%0>-+#""-4E27K2=U5E];C[;BZ:;R65I0)8#'4"%4!)<(/F20H;1EFZkuù´∏º…ŸæŒﬁΩÃ·∑√€≠∑“≠≤–∂ªÿ¡»‚∆—Á¬Œ‰¨ª–∂≈⁄≈’Â∫»”åóõjtlwpäñÄò¶èó¶ìéúçäñíçòûìö≠ñö≥ôô±ñï•êëïÇÖ|}Äkx{`nlSfdOsqdâäÇòõîöüôòöïñóíïîíóïñóñõòò¢êë£íî´≤∏Œ “Á —‰»–„…—Ê√À‡πøŸµ∫◊∑ºŸ∏Ω⁄Æ¥ŒØµÕ≠µÃØ∑Œ∏√ŸøÀ·«”Èÿ„˜„Î˛‚Í˝‡Á˙ﬂÂ˚ﬁÊ˘ﬁÊ˘€„˙’›Ú“ŸÏ∆Œ€´≤∫zÑÜXdb=LE.@2+A,(>)*B*,E/,E02I5!6#)'8U97T6$>!'>"/A);L9H[HAVC3H5;Q<AU<AV7D]5G`9UiNj{k^oeDWQ/D;'=0$;+ 7#$:#5.2$:#/B.'8&"0!+-0,?+-E+>V<E\B7M60F/ 8;X<,I-(@(!7"8K76L72H3,?+&7$2D.%<"*C&1K0;U<8K7-@,@X@(@("7$#6#)?*'=(':&&7$$5" 1,B-*B*#;!7Q6/L.+J+2L1>X;>W9]u[Zs^Qi[OhbSghKZ_ju{nu\`iT\_'0-%1%$1 ''+AXD5J7$5#*) %8$-E+<S7+B&6I34F6#5)#4.dsvXiqXfq[ir:INSbeP_bCUWPbdSee1@= /*.'#3)'7*(8++ ),, ., , ,#0!.!+ )&*) , +* , ". (%$'(+.#- ) . .#/!#/!(4('/$)0(#+ !)$,!)$,(0#*2'(0%"*$* '*!(."$,)1$.6)-3'36-/2))*$(."%+%(!&)"&.#'2"3@,/;%)-*,!*+%,-'/2'@C8_eYioeDIE$*&)3*(4() &( "/%+=-3D26B4$,!%(! "! % # %!( '(-;.1A7.=8#/-#.*( %1%+<,->.(4('1&'($&/09$1<,5@:?MNbqxET[+68'33#//itxr|à4<I&09#.0!0+$4*"  !$"'./)( 1-,+#$)+)/ 7% 9&&B,+G1&B,:$6 !:$$<$$<$ 82222332$  		"%$%&6)!3# 2"/''($ "!-!$4'!/"
+	
+
+##-7.,8.)5)+!"0#3A2-;,)+8D8 *
+	 '5E:&6)&%-9-  	35*KM?QTAUWBY[E\[GZYGXWEVTEIJ<<>125*17+4<-4?.5@/6C/2@)1?(.<%0<(,4%#2>(;I02A*!. &!*$-!,"-#.%&3"0=+)6$(3"4=,5<*29':B-BG304#04&6:,4:.0;-1B27I9#4"!/!.)"$*/1&+-"*,!&'* .-)"(4&". 
+	",!)5',-!-$0$'3'-;.);-!6%1!1!%7)+=/*:-%3$:G6*7& /,;($2!'5$(6',#1$'5(!/"(4&#0'2"*(&"" , '8%8L3;R57O/2J*,@$';"&8"#0)6%!.-.@4/B>4BMlyä©∂«¿Õﬁ¡—·øÃﬂ∏¬€≤π’Ø¥—∫¿⁄√À‚¬Õ·¥ø”≠∫Õπ ⁄πÀŸî¢´WccLTIbgSz~eäêtãï|ÜëÄãîëô¢©¢©ª¢®æúû≥ìí†åãê~~vnm[fdMb\DjeQÉÑvòõêü§ùú°õôõñòôìõöñõöòùú°û°™£¶∑≠≤∆∫¬◊¡Ã‡¬ ›¬ ﬂ¬ ·æ≈ﬂ∫ø›π¿›∫¡ﬁµºÿ∞∂–Æ¥ ¨±≈®≠¡¨≥∆≥ª–ª≈ﬁ ’ÎŸ‰¯·Ì˝‰Ì˛„Ï˚„Í˙‚Î˙·Í˘›ÁÛ”ŸÂΩ¡ ìóö`fdGRL7G<+>+-C,)?(,D,5M7)A+.E1$9&.!82K..I*(@&1D.IXEKYHFXH?R?4G4FYEDX?9M1@Y1Ib;bv[evfuÇyo{wMXR%0()7*=N<4F.>R7!4 3!7 (>)/B/!2" .!'3%-;*-?)+?$CW;=O5+?&-D*2J04Q5.K-5N19P4=Q8;L9EVD-;*,:)3B-#5(?#1J-6N41G2)<(>T=%;$1 3%='+C-*@+!4!$5##4"':&1G252J2/M1.L0.H+C\>6Q0D^A@[HGbY=UWnÄäáï¢~äòiq~êî†uxÅ288$.%%1#((*F_L5J7#6# ,''($7!'>$-A(1D.*;)/" /(CSRRcjNahR`iHW^RahOacFYW1D@1D@.A=*96"1,%4-(9/);-"4$/"#3&,*!-!)+,$0" -!+ %1%&+ .!*+ ,  .!!/" .+(,-"!1& .!,*+",!$/!#/!'3%"."&2&&2&$.##+%+%("%#)#+ %-"$,!-3),/$+1%'-!/5)%(*-$*-$()# &%*#&)"%(!(.$,4%9E1&2(."*-$)*$%& #&'-#PXIcn^UaW3?58F9.>3*:0(70,;41>5/=02>0,4)!!$!"!$#$!#!&  ''*.;23B;+73)%#(+<,):*$0$)5))#$+4#'/ %8FG\jsq}âNXb5=@*24(35uÑãn{ã:GZ1>N,:C%36-*&#$$#"! "&+--(*',-'*11/4"#<)";&%A++G1*G1&C-!=&7 7 8 72-.242.
+
+
+
+
+$!3C6'9),>. 1!'5&#/! , $"$+,,>.,
+"+7-(5+ .!"0!!/ %!-!#$"!		!+#7D:'$(*4)  +-"BD6MP;UWA_^J`_K^[J\ZKUSFLM?@B54:,5<,2;**5$/<*-:&1>*1?(7D04A01>-.;'+:#3B+"1*"*$,%.%. ++,%0 '&3!-:(*5$1:)3<)3:(<A-:?)CH49>*<@1:@26>12@12G65L:!3#((3#*2%36+AC6:</79,	 & + ,, ,) $-9+9E71;0,
+	
++2! 2"0 #8)*<."4&$5%/=,+:'%4!):(.0 -,$2%+9,#1$+9*,9(#.#)#"*/>+;O64H-1I)@U6)=!);%%3" -,7'/;--;.1@9.>>=IWÉé¢¥¡‘¡Œ·øŒ·º»ﬁ∑æ⁄¥π÷∂º÷√…·«œ‚æ ⁄®≥≈≠ΩÃ∑…’ó™±Yhk4?;<B4NR;^^BnmOx{`}ÄoÜäâ†ß±Æµ≈´≤ƒ•¶∏ôô•ìíóÅÄ{mjY^YCZT:tpWíïÄû•ïû§òòõíñôíñóèúôîõöñöôûü¢´¨≤¬ª¬’Ω≈⁄∫¬◊ºƒ◊¡»€¿∆ﬁ∑Ω◊µ∫ÿ∑Ω›πøﬂ¥ªÿ±∑œ∞µ…´Æø´¨æ©¨Ω∞≤«ØµÕª√⁄…‘Ë◊‚Ù·Ì˝ÊÔ˛ÂÓ˝ÂÔ˚‡Íˆ”›ÈΩ¡Õòõ§klpKQM>KB/A3+>*+B(.D-0F/4J5)?*+@-'<)$7#.B)&=!$;*='(9&!.'3%&7'2E25H4)<&%;$-D'<V/C]6XoSgzgQaW\gahqlISJGSEo~k7I1@R8&8" 3 3$7#(9&,:)))/>)"43F*=P4&6/1:R81K0,F)'>"-A&/C*(9&*8)#/!(5$+8&%4)=$/G-3K1)?*,?+=P:)=$"5!':&":"&>(,A.(;('5$*8'"3!3F35 +C-.K/,I-!97N2@Y;6S7FbTB\YczÇÉï£î£∂°¨¿êô™àêùÇÜèAFI!,$$0$!/ (.E^K2G4$7$"0!) -!3"6';"-?)"3 &"'$aps4GNN`jVdmAPWQbiBTX-==)<8-@<.A=4DA>OIIZR0B6*?0%7' 0#() ,"(4($0$!-!!-!!-!-",!(4("."*%3&- **+ .! . 1!"2%!1$ 0%.#"0# ,  ,  * (!)%0"'3%$2#"0#%3&&2&&.##)$'#&&) "(#*"!( &,"*-$-0%*-",/&'*!%(#&$%"' #% %(!%+!)/#;C4$,)/#-0'&)"&)"#)"*=J9JXGIWHIYLM_OJ_PCWL=QF<PE<NB8F92>04>3' #!$"#!"#%""'!"'!&!+ &3)2B81>7%#(*:-&7')&2&%"#.2:-%'10SbiZhsr~äFPZDKQ8BD?LRrÄã]j}JVl>K\2@K'4:"01('&%%%$$%'+-/0310%"+++46!4 8#$=((A+(A+)E.)I2(H1%E-"@(8!4330.001-
+    
+
+
+% 5E8/!2" .%1#%0 ,4'*/%7). ' 		#-%(4(*&% &&	%,$&##)%1% 
+	')$#&*. AD3JM:UVDYZH^\M^\M\ZMSQDKK?DF98:-7;-15',2$"($,$/+8&:K8>Q=1B/!38J2#2('$&)&)!-%1#+'6#(7")4#.7&59*59(9<+=@-WZE16 3:(5@01?0-B36Q@4O>-)/7*,2&04&=?1@B413&
+	"**&)7B4*5')$)" %&#/#$2%!
+
+&$6&"7$0!3%"4&!3#"4$(9'/,$5#-('8(0 &7'):*#4$):**8''2"	!$#" -&3!'6!,;$.A%EZ;/C'*;(%3$((4&1?.5E81B<,;>[gsü™ºº…‹øŒ·æ ‚∏¬›∂ªŸπæ€¬»‡…—‰≈—·≤æÃôß≤ûØπõÆ¥gy{2A>*4+18&FH0UP3^W:g`FmgYzz|¢§∞≤∏∆™∞æ®ßµüù®öôûéçâz{keeK`_@xyYãísëôÅèñÑéíÑëìàòòéúôíùöïöòõù†©≠¥ƒø«‹ø«‹∏æ‘∫¡‘√»‹¡∆⁄∏º’≥∑‘∏Ω›¥∫⁄≤∑’±µŒ∞±≈≠¨º™©∑ß•≥±∞¿∞±≈¥∂ÕΩ√ŸÃ‘È’‡Ù‹Á˘ﬁÍ˙·Ì˝’·ÒµΩ–Üàù]^pBGM7@?4D:,>.+>(/C*(;%4G1.A-,&9&3F3$7#%8"(<#':$->+ ."&*1D1-C.2J2.H//I,5S/;Y38S4D\D4I:IYNÑëá[g[DRA[lYK_F9M4$7#!4 0.=*#01<+$1,;&<N4+@!5I-/C'6E.*9$.:R:3K3*@)&-,=*$5#'$)5B0%4!);%.F..F.4G18J48J2)=$$:%!7""8#&<'%:'0A/(4&"."*8)'<)5M7.K//I. 3-(>'C\IMhaYrvõ±æí•∂éù∞sÄìzäöó•≤{Öé;GG)6-$2%!/ &&;(JaM/D1-0"3!$6 %9 %9 &8"-*%$$TfjUgqTfrXisN\eIZa>MT7DJ7EH>NN;NLO_^H[U&:/'<-+=--(,)'3),6+'2$"- ,". !-"."(4(*6,!-#%3&'5(*++!/ "0!!/ "0#"0# 0#!1$$2%"0##/#&0%#!')4&&2$*8)&4'*&0'+2*(-&%(!$'$'$'%#*"&,"),#+,$()!(+"),%%*#%*#%(!!$$#(!"!$%+%+.4(06*'-#'-#)1$#04B19J85F64F62G4D[GOgWOjYQl[Vq^KbN6K8/A1&4''#"%!$ ""$#($$#*- 2B55B9( %)&4'.! .!$2%#((6)*7.+68N[c]kvuÜêkyÑBOXUbhP]ehtÇYdv8@U6>QO\edqw4AG(37)*)%$&+244334756!5(&' .15 8"!:$";%&?)-G.-F0+G0(H0'I0(J1*K0+G0'C,%>($=' 6!013 1#0$*!$
+
+
+
+			#'0+%0( +# *"!4D7.0 ". 5@0?G8:B3'$$.%$0"-. /"#! "*(#!!#-"'/$%-"'-#*-$'*#+,&"#
+
+$) % 		382(.$(. 9;-BE4GH8NO?TRCZXI^ZNTPDQOCQOCEG:;=235*/2'#&%+2=-/>+0C/;Q<G\IAT@BV=.@*0>-+&(*)) ,"."&2$/>+'4".7&.5%/3$46(89):=*[_H27!-6#.;*.@0.F63O@9QA).9+5;/.1&48*BD6>@2 )4&&2&
+		#. 3@/!'"0#'5&'3%-3)+.'"(+3(2>2->.-@- 3 .,/!2""3!'%#5%)- (8+1!%6&*;+&8((:*,:+-9+ & $* !,#.!,'30<&9G.9M1/C('8&!/ #"0!0A15G;2C=7FI~åó¨π…æÀ‹æÀﬁ∫∆‹∂¿Ÿ∏Ω⁄ƒ ‰À”Ê…’„æ»‘ú©≤vÖåkz}^pp=MJ(5,#. ,5"AE.ON0XS5XP;\TItrwüû¨´≠∫¶®µ¶§Ø§°™§¢ßûùõâä|rt\fjGovLr}Ss[wÄex}iÉÖxïïç°ûï°ûôöòõííû§´Ωø«‹¡…ﬁº√÷æ√÷∆Àﬁ∆Àﬁº¡◊µπ‘¥∑÷±∂÷Ø¥“≤¥Õ≤≥«Æ≠Ω´©∂∞Æª∂¥¬∏∑«∑∏Ã∫ø’√…ﬂ…‘ÍÀ÷Íœ⁄ÏÕ⁄ÎæÀﬁìû¥cgÇHJa4:H*383B=0B6*=),@'"59L8/B/04G4FYF 3 0.?,+<)&7%- "-1D0!9!(B)&B)#@$+J(7V45R36R98Q>2G8hzlEVFIZHH[Gbu_$:##9$1G2AT@N_Lcp^5A-;H4<K43G+3K+,@$"6&5 !2/G1:S=4J5!4 #"($5%%3$"0!*6(-;*(6%)<(/G/)A)0C-;M78J4+='$7#$7$#6#$7$%6$/=,.:,",! *'5(-B/>WA.K/)C(1.)A+OgWE_\î≠≤nÑëè¢≥åù±2AT*;KHXefu|m{{'4+%3&!/./G1E]G2E2!4!1B01B/1E,';"%9 -%#-$"))YkoXjtWiuWhrQ_hL[bRafKX`IV\KY\.--=:#4,2&)>-&8($))!-!"."#/!". !,)+". $0$+7++7+ .!&4'%3& .!)(+!/"$2%&2&$2%.!!1$- ++#-" %!&%/$!-.:,1=/#-"&0%)3*,3+&+$#(!$'#&!&%*#)/%+.%)*"'( %(!%(!&)"'*#(+$"% #(!%(!&) %(!&,"3;.5=0.6)0;-4A01@-0A/-@-(:*(=,,A.)>+'>.-E51J78Q<;R>=R?.C20B4-;.*6*/7,'/$&+$%*$160"!#*'7*6C9&3*'* '5(* .!#1$*8+6F9@RFVgaapw\jwfvÖxàïWhrDU][lsj{Éjzä@Lb-8N6>S?KWcpyEOY*4=&'')05#:";:8789:9 ;$=!8!/$$/!#0#6"":$#=$%A('C*,I-,H/*H.&G,)J/,M2,M0-K1+I/(F,)G+(B' 84!3&3!*3")0 +/!),!#&
+			
+
+
+$0&,=-+>+*;+((3E5#6#'8('(0!6>/(0!!)&.#1<.%- !/""%%*6,*8+&7'&4%)((( %( +%- &.!(0#+3&(.$*-$-0)#& !&#		
+
+
+*/)6;428*(/02$=?1MN@HI9OP@SR@^[LYVGYUIYWJQSEEI;<?4*0$"(-5(,9(,&7$/B./E06L7<R;4J30E2)>+$7$%7'&6)+8.+8.)7*%1'".".:,*(. -1#02%68*8;*<?,YaI;E,+7#-;*%:)9QA3K;1F7$1 /7(06(&,6:+?B18;*!),6+"		
+ *0=,&3"#1$%3$'5&%!)1&!)")2C1)<(!2".- 1!-$+&7'*&6)*:-.*<,%8%$6&!3#(6'%1#'2$)1"19*08)/8',5$)0 ")5>):F02D.-@,(9).#1 ,=-1C5.B75HDCUWzãì©π∆∫«◊Ω €ºƒŸΩ≈⁄∆Õ‡Œ’ÁÕŸÁƒ—⁄´µæÇçìGSS?KG-:3'4+%3&*&1 9C+JS4NT8LM;YVQ~Ü£°Ø≤±øÆ¨π®•∞¨¶∞≤≠¥Æ¨≠òòé}imsMisA`m8]k:cmHdiRkm`äâÑ¢¢ö¶•°üö†âáîïöÆ∫¬Ÿ∆Œ„¬…‹ƒ«ÿ Õﬁ Õﬁ≈»€æ¿Ÿ∏ºŸ±∂÷Æ≥—µπ“≥∏À≤¥√´™∏µ≥¿Ωª»æΩÀΩøŒ¿√÷ƒ…›ƒ ‡ƒÃ·…—‰»”Âª«›û™¬èô¥Ñã•Y`s3;H4?C6E@*:-'8%/@-2E12G4/F2H`JpÖr-"-):*$5##4!!3%7!&=#.E+ 62'A(!>"*I*-L,2Q25S92P82N86K:=O?CVCTgTI\I!4!*B,OhR`zaräräùá<K61>*(7 +B%1H+3 202:V?5Q:)<)))($0$%3&$4')9,,>0'9)(:*+@-/G/(@&':$6H2?N9.=*!/ !-!". '3%)4$)4$*7&$0"". .*C-4P7-K/#@$"9#: F`GHcPTmièß´3>qÑìãûØrÉïGWgZhsVejAQP)6-"0#/41J4C\F,?,1B08G40B,)=$$8"5!&)!"-'.>=btxYlsI[eL]eSaj?LR?MPJW]LZ]9GG&!(,!#5%+=-!2"%#1" .*+"0!) , &&&2&&4'+9,'5(#1"(6'(6'!/ %$),"!.$'4*)6,#3(%2( ,"%$!"")!$+#%%- .6'-5(-8*-7,)3((2)&-%"("%!&$)"&,")/%+.#'*!'("$%&'!&'!%& "#"' %(!"#! %%-"'2$&2$&2$%3"&7%':'5H5(=,4I8DVH*8+%(&6)(9)->.5F6#4$+<,+@-/D12C11?02>2*4+*1*%!,* .!0@6,<2)!%/&0<0"."'3%8F7GYI;R@AYK|ìç}èôevÜl}èk~çdxÉi}Ñuäè~íôÖòßçü≥|å•]máJXr?Ka;CV'.>*- 3 $7##9"#<'B#%@<;::;<< >#>&=!#2$"*%0 %3"&7$(>')C*,F++H,+H,)G+'H-)J-*K.,M0+L/+L/*H,+I-,F+,C)(:$(5!(3",3#*1!-1",0"/2',/('*# !
+
+
+(!2 ):($5#(8+);-3E5+')#$,(0!:@2#)%+@F8 (+!-!		%$ + .!%6&-;,1=/3=2)4& +"!,'&1#+3&)1$)1$(0#(."*-"(+"#)$ 
+
+	#*"!(!	3:37?49@059(')')((99-IJ<MN>[YJ_]N`\PdbUVXJAE7;?16<028,19,-:)0=,1@-*;(*=*+@-+>*(;'':',A.2G4/D3*<0.#&#(+ ,.#/1$.0"/4 YbG:G+1?(->+'>,BZJ5L<*<,(3#-3%/5'%+15'13%/1#%-"$
+$&2$,:).;*%" '5(0 %6&*
++%6##4" 1*. ,"!2 &7%- &4'(8+-/.!3##4$(8+)+!, +#+%.$+#*$+6>);G36G50B2$6&.'8&2D4.@2$5+0C=CVTfy}ê£™≠ª»Ω…◊…“„œ÷Ê“€Í’ﬂÎ…÷ﬂØºƒãîôT^_1<6(4*(4* .!$2#-,.<%@P5GU<KQEprqôô°≤≤æº∫«∏∂√∂∞ºπ≥Ω¡æ«øΩ¿´¨ßÉÜuntRluHan8\i4doG_eKVXM}|x†üö™©•¶§ßèçòèîß∑Ω” “Â«Œ‡»À‹Õ–ﬂ–”‚Ãœ‡ƒ∆›∫ªŸ≤µ÷∞µ’πøŸæ√◊≥∂≈©®∂∞Æªº∫«¡¡Õ¬ƒ—¬ƒ”« ›«Ã‡»œ‚ “ÂÕ’Ë¡Ã‡´∂Ãî†∏ù©¡ù®æhqÇ;EO7EF,=3'9)/B/(;'1F3/F29Q;CXE 1!,L^P:L<'<)'=&(;%$;!(A$-E+'=&#;%.H/-I0)G+&D(5;"*F/5Q;,C1AVEK]M\n^N_O%7'2I5Zs]b~ga{b\r]1B/(7");#4K/"9*'/.E19U?6O:0 +++! -#$4'-B31H66M=9P>@WE8O;/I0@X>0D+:L6?N;BP?/9.",#'#+)4#)5!'4"#1 -/.J1.L0/M1*G+&>$"9=U=)@.Rg`^rq'*Uir~î°Ñó¶åú´xÜëUfmGYY)51"/%,-4P9?[D0C0/@-'9#*<$$8!7 .$!$!.'+:7]oo\np);=UdiVdg2=?4@@/==.=:+'(*  1!(;(,?,-'+9*!2"--#1",)- "0#'5(&4'+9,&4%"0!,:)+9(+### ,"%2($0&#0&)6,'4*#/%'% %,$&-%&%!'(. *2#2=/2>0&2(&0'%-"%+!!( !( '-#(.$*-"),!)*"$%%&$%&'!#$ % "!&) , +*,!2 5F4AVCDVFTbS<F=$ !",$%1'*(+$5%&=)'?)/*+%%/$/;-,.!,<2.>4%0(4>5>J>7C5=I;EVF5J7+D1B\Oc|yìûyåùrÉïoÅèoÇâlÄÅh|{{êëí©±ÅñßoÉúqÅ¢è∞|â©?He")C%8$&<%&<'$<$&?"(C$(F$$D @!A?<=A?"B#A#;+$"*#+!)*"1&9%)?(+C+,D*'D(%C'$E(*H,*I*)J++J+*G++E*$:%(&* (%+)/!/3%-1#03(47,06,.1&'*"%			"-!3#%:)(=*1-$2#*8)*"(;>3*,!9;.CD4,0)(
+%		
++7+'3'(#!+ ,)". ",!&1#)1")1"$,-5&6:,37)14))/#% 
+#*"#-$*/)2<19D6:>/47&&(:;3BB8KL>Z[M`^Q[\Ngi\SWIFJ<@F89?18@1*2#!,&3!-;*,:+"0!"/-8(!-*"3#,=-,>0%5($$&(,/4 ZcD4B!-;"$5"1H6?XE?VD+"%+-"%'
+#)
+&4''8&.=*-)5'&&-;,+>+(;'!/ "*7&0A.*;(.)(!2 (9'&4%-,'*"0"3#(9)'7**)"
+	"!' &!(,8$>K97I9-B1!6%%8%0B2,>.(8++;0.?58KEL`^j}Åãô¢ß≥ø«—€‘ﬁË”ﬂÎ«’‡¨π¬Üëódln094.8/'&4'&4'(6')7&++8&9J7DUCZc^èîóØ¥∫ΩøÀøøÀøΩ ¡æ…∆√Ã …—… œ∏∫πêìäknYsyWt{QszNtzVhlUSPI{wvüûöÆ≠©Ø≠Æ°¢ß°§≥º¡‘Õ‘Á —‰Ãœ‚–”‰“’‰Œ‘‰…À‚æø€≤µ÷µ∏Ÿæ√‡√»ﬁπ∫Ã¨´π©ß¥∂¥¡¬¬Œ¬ƒ–≈«‘∆»◊≈ ›∆Õﬂ ”‰œÿÈ»œﬂßÆ¿}ÖöÜí®ê°≥ë¢≤es~<KN8LC<SC:O<$9&.D/3I4,?+#6#/-?/6K:%<(&>(%=% 61&?"*B(,D,(@('?'-G.*G+(D+.,&=).G43L9>UEQeZtÖ{yã}'9)7I;OdSJaOH_M5G94E5,=*1C-1C+/-+)A+7P;:S>&=+ 0#,!3%,A2@XHIdSGdPKhRRo[SpZGcM3O8,F--E+%<";O6.?-:H9WaVJQI06,,4%CQ:AQ7,;&.)!6#4P7-N/'F'0M1$;!*)%&3)*:0+"H_Yuçëwãñãù©^p|^r{Äìô4BC&2.+*;U<=Y@&9%!2';"'; #: %;$/E.)<(!/ '")!0)EVNIZT%4-MXT>GB")".80;F@ -$''+*(;')<(%-4E5/A31A4,$2%"0##1$$2%'5&"3#$4',</)7(,'5&-9+!-!%#"&!-#)3(+"0#%2(%1'!+" *(!#+ %+!!'"*!'"("(/7(5@2,8*#/##-"#-")  *!&+$&) )+ )+ &'%&#&%(!-.(,-'"  #%$(*&2$0A.7H5WdRdl_,.-',""0#- -"9%$;''$ !# -&*:06H<4F:1C7-?3(8-".$*4)4A0CP>:H78I7-B/+B2?TM]ruÜôßsÑî_o~Q`gCSPGYMK]OH^Rvåââ†®GXr<OpWjã_qï8Dj%L(@((@(+C+)C((C$)G#(H#$G"E C!A@A C!D$D'E!9)&$"  (.24687:95(
+!%(,/$-3',2$-1#*. ),!$'
+	.$9&+@-.C0/B//A1/@0&7'( +08+.1&59*EH7/3"*#")1$4<-$,
+
+	
+
+%,%0:1",##.$1 &0%$.#",!'2$$,'#$-0%58-5;-$,  &&'(( '$	" '(2)181.5-4?1/:*8<-+-"$
+55+NNBXXL^`S^bTbfXU[MQWIDJ<CK<4<-+6&0;+&1#",!$,!'08+!,"'&4',:-2?5+7-%	
+$,U`>6D!*8!):(7N<0I6@WE&		
+		&,"!)$5%&7%,:)*'5(#1$/@09L85H4$5#$2#(4()3*%,$% -;*:K88K5):' .$/%6$(&$!/.;**9&)7&(9)*:--'
+!% ('4#?P>6H:*?0#6#.A.+=-0 $4'.>31C50D89MDFYWM\awÜçØ∫¿ÃŸ·»÷ﬂ®∑æzáçdoqIRO.8/2=/"+$5%(9&3E/5D/0?,1A4GWMs}©≥µµº¬≠±∫¥∂¬¬¬Œ »”ÃÀ”« ”√∆ÕπΩæü§û{}p}jÑájâåmâåq|}krojàÑÉ°†û≠¨™±±Ø∞±≥≤¥¿ƒ«ÿ–’ËŒ’ËÕ“Â‘◊Ë”ŸÁ“ÿÊœ—Ê≈«‡πº€Ω¿ﬂƒ ‰∆Àﬂø¡Œ±Ø∫¶§ØÆ¨∑∏∏¬¿√Ã««”«…÷∆…⁄»œ·Ã”Â–◊ÁÕ”ﬂ§®¥bhxYbsnÄéÉó¢çû®Yhk=QH<QB:O>#8%'=(1G0-@*%8"3 &;*5N;;T?7P:4N5/G/.F.1I/-G,'?%!9'?%2L11N2.H/$:%#6#'<)!8$)B/?WIatnqÇ|Uf\);-ASG_qe>UE=TDTfZ:L@-@-<M:&5"+**=)*C-:V@9P>#8)1A4AQFL`TRiYLdT?ZI2O;,I3&C-)F0)G/(D--E-#9"!87J4'5$'5(7C9Q[PKSF>G6;I20B(-?'*"(@*5R6.M.< 5O4$7!&&! (23J:dzwráä~ìòFZaqàêê§´JY\&2.%3&%8$>X?A[B+"5!'>$#:#9"!7"0C/:M9;L:2C3%3$+1%$6*#3&)7*,4)(.$%"*+7-)('#.(;' 1"%3&'7*%5($6&'9)*;+)7('5("0#"0!-"2%,</,:+,%3$.:,$0$'#"%'(($2%%3&%1'%1' , *"#) &%#+ "!$#&+1%3;,-8*(4&()#-$!+"%*#'*#,-%*,!()!%&"%&)"()!23+ !"! " " !# #&%!+ -;*7F1N\EzÉrSSQ+,.#!("+!#1$'7*"4$"9%!8$&'"/&.;46E@<MG;OF8LA5I=.@4#5)/$!-!*5'7D29H34B1+=-(=,9OCh|}tÜêÄì§arÑ:JY5BH4?9@K=FQ@BP?K_TwåçÜò¨~í≠yé≠rÜßYhè2?i(D+&B)+E*)C&(F$)I")L$&I&I&I%H$G C"G$I'J *E" 4( 		 %&$$') "*2%/5',0"%)$'$%#$!""#"# ':&(;'#6#$6&+=--B1,A.+@-,?,*;),9(+6%/8%*3 1>-),(5$'2!#.!'
+
+
+'1;3
+	!)$/!'2"&.#&-%.8/#-$#"(.$-5("*$03*:8,62';4,;7.84+))!
+
+	&0'?K?,:-",7)3@/'2!8>004&
+560JLAQUG^dVV_Ngp_HSB?J9:E45@/+6&%"#&&) #+/;-$0" *",8.0>1/?2+;0)
++3R`=&5 +9,;PA,C36K<$"$* $,!%,,.". '$&6)*<,&<'$7#(9&/@.0B43E75E83D40B26I50C-1D.7I3,;(#%%"'&4#.<+.=*+9(%6$,=-$7$/A+-
+
+ & +-;.9K=4F:#5'!/+9(#1")"2%/?21C3.C2,@4:KC=MLCRUèö†Ω –∞ø∆vÑá?KK2=91=3&1#+6&)"%4!6K,ZrPFZ>,?++;1Wfcî††≥æ¿•Æ≥ìó†®™∂∆»‘œœŸ Õ‘ºø»™Øµ®≠∞•©®ñïëáÑ{êéÅòôâõõèóóçóìêùôò¶•£™®©ØØØµ∂∏∑∫¡ƒ»‘—÷Èœ÷È–’Ë‘⁄Í‘⁄Ë’€È‘◊ËÕœ‰¬∆·ƒ…Ê…Œ‰…Ã›¿¿ ±∞µ£°¶¶£™≠¨≤µµΩπº≈∏º»±∑«≥∫Ã∆Õ›œ◊‰…Ã’°†®XXbFJUFT]g|Åè¢¶ÇïìIXQ9I<'8($7#!7 ,C)7P3;T7&>('@+1J7/K51J40J1+E,+E,+G.*G+/I,7Q49S6/L.1N01N20H0,D,-C.%;&%<*<RFmÅÄuáâARL,=3TfZdxl@XHQl[`vi(<0)9,.</&4'*'=(+E,1M6RnXezkM_QFXJBTH9K?/A5%7+&8*)>-,A.1)A+.G1)B,/E0&9%+>*3D2- !.$-:0BPCFRDHSC9F2*9"-A&5'2J05O4+E* 8 4J5$5#!" ++ /&8"-@,4E;gzvcyv8PPá†•ñ´∞IYY2?8/@0(;%>V<F`E"8#(>)&=##: $:%1!2 &4#,:+/=. 1!-?//D3'<+"3!&3"(."!''+,"'*%'$2!):(*#*  -#- !2 6I30B,7F1&4#&'".""0!.?/(6)- %3$0>/-9+(4(&$%%$&#1$'5('5((4(". )#"%"$%" #"%"%/5)+6&)4&"* %")! '#(!#&//'&&$%$%"#))!?@8#$ % %$! '% &#/#-;*AP9jvbwzqAC>-3/0;30=3/?2-?/"7$$<&*B,'<+.B68LA:NE7KB1E<-A6)=2'8.'7-$4)'5(%1#8C3+8$/>)0>-,>0*>3ZnlmârÑòl~ñgwêKXkBJU?A@;8/97*CE7HUDOcXyéë~ñ¢yé£uâ¢xåßpÉ°&D*"@$)F*+H)-M(.Q),O%*O$*M#(K!%I#H"G#H#H'J )D#-
+	
+							
+	 ##! %# ""'/ 06(15')-$&)+ )+ )*"'( #$
+!+9*):( 1"$-"7&"7&%:'%8%$5##4"#1 #.%0 1>-+ .!/+!%+3(+3(*1))3*%/&%1'3?5)  #*")1&+6(*5''.&5<5JUO& %!!)!)'-!35*><0?9-JB7MG;IE9DB668-#&
+	'3'6D5)5'*7&-:(!,39+47,
+$' BE:NVGDM<@I8>J6<H4?K7/:* +%+!-.( !6B4&4%	
+%2(0@3.@22B7,9/'
+8A,O^=-%(5+:NB5K>&8,!&"		& %1%%3$/-! !/"*<,,?,&9%,02!//14!"5"&9%+='+<)%4!! ! *)7(.<+&5""1%3",=+':'%7!'6!#0"!$,%1#:J=5J;3E7#4$ -'4"'4#-*):*1C3(=,'8(1A6<KD;JGvÑÖ°Ø∞çõúLXX/83",#!+  +"-!.).5M+ZtMH`@':$4A8yÉÇ†™´•Ø±åìõÑàì∞¥øÃŒ⁄—‘›√∆Õü¢´{~áåëî¶™´®®®ïîííëçûùô£¢û§£ü¶•°ß¶§´™®¨´©ÆÆÆ∑∑πªº¡√∆œŒ‘‚”⁄Ï÷›Ì◊ﬁÓ◊ﬂÏŸﬂÌ⁄›Ó“◊ÍÕ”ÈÀ”ËÃ”„ƒ»—≥±¥¢ùö†óò£öùß¢®™©±´´µ™Æ∫≤∏»π¿“∫∆÷¬À⁄πΩ»îîûTT^>BK5BJGZ^våäâûôoÄvCSF#4$&9%&<%(A$>W95O2.F.2I54K7-D0&>(+A,,B-,D,.F0/G/0H.0I,1J,/H*/I,.H+-G*+C)+C)+C++B.6L?Pdbh|{M]Z0A9<LB?SG-E5NfV7N>$6($4',:- 0#(=*6S71O38T=Yp\ô™öguh1?21?2"0#*$0$#/!0=,4C0*9&5F3.C0%:'4G43D26G7.<-+!%1'%2(=K>+9*:H73A0&5"*>%,C'#:3L/3K1#;#!6#,?,(6'## -'6#(:$&:!)=$)-4L?9SJxëé|íê@QK-=2$6&33M4F`G+C-0H2&>&#;#'?)'=('8&!/%2!!/%!4!4I6:O<2E1*9&#+#'!-)',6+'('5$*8)$#')- .?,@S=6H0.=('#1"2C3,8,#/#$2#4B32>0&2$(%$&&!-#$2%%5("0#%3&&4'($"' !'%!!'#&"#"%)/%.4($*#&!$!& '!&&'%%"#&'!*+#34, !#&%,$$!%(5#IVB{Ås^aV7<61;3)6,%7)&8(!6#%='1I38M<4H<.D8-C7)=2)=2+<2(9/$4*#0&.#!/"-6E26E0.@*->,*?03I=}ìë~ëürÑök|òsÉùmxåPT`HBF<1-=0(@:.?F68H;Znlxêî{èöwäôzçûÉñß(F*$B&,I+-L*/R*/T).S*+R&*O$&K'L!%J&K &M 'N!(M"%> 
+				$$$#$   ! $(0#28*,0")-)-*,!)+ ''(($%'')!/  .!!1$%7)/*(&*+& (&2&+,-/)&+&2$+7+,8,5A5<H<-9-9C:>E=?G<?I>*6*:F88D6-9-&1+CMLKUV6@?(#!)"*)/#24':8+?;/JD8WQCTSACF59;-26(25*#)08+/:**5$*5$*29)),!				
+/2)@F:LSCHO=KR@V]K=F5$,.6+470%&!9E9(6)	
+		
+"-%,9//?2/?2+9*'&/%1N]>-&4#*<0.D7:PD%#%!	&(6)'8():*!/ "&2&,=-*;+(6% .%3"'8%"5!$5"/-*+(--"$$!"$2%%6$+:'(7$(7$(9'(9'*- /"0!.&&3"*;+=RA8O=/B.9K51@),;$(5!%4!$2!):*/A1'9)*8)*6*1?2>ND_pj|çáitnYc[;A7!'%+(0!3@.,9''(';AY7B[;2F-Q[Póõö´±±û£ßÉáêçëù¥∏ƒŒ–‹—‘›ææ»ÅÅçLLXnqv£ß®≥∑∂•ß¶èëêõõõ¶¶¶®®¶™´¶Æ≠©ØÆ™ØÆ™ØÆ¨µµµπ∏Ωæøƒ«À÷–ÿ„◊·Î⁄‰Óÿ‚Ó◊ﬂÏ◊ﬂÏ—⁄ÈÀŸÊÀŸ‰»”Ÿ∏ºΩ§ùïöåÉùäÑ§ïí•úü¶£™®¶±´≠∫∑æŒø ‹¿œ‚øŒ·º≈‘£´∏Öìdlw?LT3EGTjgjÑ{^xk=UE(=,(;'$;!&?"1J-3L/4J30C/,?++<*.?-<J98F58G43A05D17F16E.7G-8J05I-0G*0I+/H+-F)-E+.F.0G5<TGh}vM^XFSLKVNmzp?TEH]LI\IM^LN\KTeSLdLBaBTvS7Y8>X=ReQrnt|mrxjoughn`]cU]aSSWIOVFFO>;H6AO>5F6/A1EUH@NAIUK9E;&0'*6,,8,9G:#4$):*CTD2C1&9#*A'-F)3M0.E+5%:'CUE-=0 .!*)!24#;!+E(4M0.F,5N81J7BXLBXL0D8+B2,E2,H24P9;W@=YC2N7#=$'A(:V=IcJNfL^rY>M8(5#)( 1$7$2E1:K8*7&$,+ + (3%('8&"0!)!- , &4'2C3QdPEVC.<+!+2C3/;-". #/#2>2,8,#/#)&%'$&#0&'4*,"+!,9/)"&!#"($' #$#&*-&,/('*#&' #"(!)&!!$/0(%(!"% !" #")!!&"#&($.#(" $%3;,dkYyÄp<?8/4.2>4-?1!3#3 &<'-@-%5( 0% 2&&8,$5+!1' -$) )$$)20F1<R=.D/)?*)@,6N>Éúñä°©i~ëqÖûpÄöjpÜ^]kWLRSCCG51E:4DD:BLD:HHEWYWikN`d8EK,9?(F,(F*,K,,N+1W.,U)/V*.U),S&*Q$(O##J&M!'Q#(R$*O$3									#'''%" !""##  &(0!,2$)/!,/$.2$24'22&+-"()!"%
+'&+;.$ # *!+ !& .!- ,","'&+-!/ !/ ,##"(*%".$'2,$./R]aCLQ,54  ($*-1#44(A?3MI=ZWHZ\GPS>BE4;>-:>/8<.06*"(""' ;>5CI=:E5/:)%0!**3" 
+
+	
+
+ !47.UYK\`OPTCNRA)0 4:.7:145-,-'$5A5-;.				*,:+2@/3B/1>*+7!*M\=,<#4!0B4*@37K?$ (%
+
+
+%&4'):*(9)!/ -7,-;,-;,'5&'3%0=,*9&(7$!0" %+!/ (#*) "%3&)+9(*7%*9&*8'->,0*(,/0'8&>Q>;R>7N:);%<K4CV:5H,.<#,:#/>)->++>+'8&&2$#.-8*3?1ASGI[OQ_Rcn`-3%#)*0",5$2=,*5$ ';I(DR/JS8uvhÆ´¶πππ¨≠≤öú®£•≤ø¡Œ–“ﬁ——€ææ∆Ä~âBAI]^`ïóî≤∑≥®≠©ãçåñóô§¶••ß§°£û¶ß°´¨§¨≠ßÆØ™≥¥Ø∏∏∂∑π∏∫Ω¬√»Œ ”⁄Œ◊‡À”ﬁ…—ﬁ “ﬂ√ÕŸ¥¬Õ∞ø∆™≥∏ùüúìã~ìÉtñÑz°èã®ü¢Ø¨µÆ¨π•ß∂™±√±º“≥¡€∑«‡ºÀ‡∏≈ÿØ∫Ãìú´Q^g.=@3GE>UM;UH-H7%<('=&+C)-F)-D(,C)4G1BS@HWDIWFYeW^j\UaS^iYdo_do_^kYS`LL[DJZ@DV<9M26J/3J.1H..E+.D-0F1=OAWh^RaZdqjnysjwmK`OBXCPcMViSWjTOgM>];Ae?@e<3U0GaD\pWbq\`m[bkZbkZco[mvcqxhmqbryis~mm|ievdRdTK]M}çÄëûîåòéhtjblaWaV7C5*8)&9&*?,5H52E1$7!%<"&?"+E(,D*9Q9KdOWn\4I81C3/@0/B/:P;/G/!; /I,3N/2M.2L1=U?E\JE\LBYGAZGD_LC^KFbLIeOEaK)E.#<&+C-8Q;2K51H.0D+%7! /*-+<*-1(9&%3", .,*5%#+!)"0'8&- .(4&,8*<J;cq`RcQ3A0'#8F92@1"."* 4?70:2'('&%#&"/%$1') (%2("/%) ## # &#& #(-)AFB465,.-$% #&!'&% ("(%(!$!$"%"$&  ' !&!&#$",!",!!"!  &FO:lt_ccY/0*$+##/#!2"#6#*=**;)- +#1$-:0'7,#3)("& ."3!*=*/G16N85M7+C-&;(*A-+B0tãÅàù†uáïuÜòrí\_nPMXXMSM??J::]SQJKFENIAOO-??"53+('%+)+I1*H.,K,-Q-0Y//Z,/Y+/V).U(+R%'N""K$M!)S%+U'+P'' 	 
+							
+**('&%'$$$" !) +$,!+1%04&68+77+11%')	%5B8#$)"7=1'2",:)!2 #5'"2%$".$!.$'**#!'!		'!'$.%,50'(ITZLV_BKRDMR;CE$$% &$%33)LJ>WXHRU@NQ<SU@UTBLM;HK8CG6=D48A08@1@F8BJ;>K9@M;+6%"+"* $% )($! *+%<>3IM>UYH48):</IK>==3::0991('"%(!&0%6B62>2  %&!)*%-.(+,&'*#"(%- *5%0=)4B)9F,5D%N_;.A!,6H8.C2/A1!+ ""%(+ #)'#!'!'	",#)7(+<,'5&$+).8-&2$)7()5'%("-(5$)6% 
+%"0!*8''%+!!&3)+!#%*-;*'5$0A.(;'1)(-0 (=,CZF=T@0F1.'5=M2EX8=L-2A$0@&6E0*;(%4!%0 *1!28*+3$/=,:K9CTBIWF6A0+4#(/4;+4=**/"'
+<3OE"ZP,f[;ä}j∞¶ú¡ºπ∫πæ±±ª∂µ√≈ƒ“œœ€ÕÕ’¡¿≈ùõûTPOQQI|~söùíö†ñëìéöúô£®§°¶†ëñèÑá~ëîâ£¶õ©≠ü≤¥ß∂∏≠¥µØØ∞´Æ∞Ø¥µ∫πº≈πΩ»πøÀø≈”¥∫»ù•≤áêôzÅártquqexhéÑz†óí™•©±±ª±≥¿•®ªçë™zùxÇ¶Üî∑†ØÃ±¡⁄µƒŸô¶∑[gu7DJ.<<*;3(>1'>,-E/:R84M0*C%+?&*;(/@.=K:BP?FSBJXKO]PP^QR^PT_QN[JGVCL]JK^HDV@CR=?N;<K6;M76G41B//>)0=+7B4=G>@KER_X?NG8J>6O::T;3K1)C&1N02T12X/;d89^50R-8U6LfIJdI>V<7M6?U>C[AOfLFUB:G5@O<DUBF\GBZD<T>PgSsàwk}oqÅtÅèÄ}äy_jZNYH4C.2H17Q85M34K16J1+?&(?#*C&)F(7U9FgLLlTSpZPlVKdOHaK>WA)C*$<"*C&%?"1K./G-:R:<S?:S@<WD9TA6O:5L83J6.E1(@*#;%#9$ 3  1!//!2 !4 $:%/G1>V@@VA-@,+-&3"'5$ 1,?)Q`K#0'("0!'5&+*8)DUEK\JhucZeT8D6+$9F<3A4"/%6A=ckm7==!'%#$('%'.#.##&)(4("." #"%%$+41ZbdGLR47>,-1(*'#& &# ($$""$"!& !  % %!( %!+ '1&#+ #!-6%V[GsqbXTH30'%(#/!$5##4",=+ .)*$0&+8.)9.&8* 5$&;(.D/,D,*D+.G1.G1,E0%<(0 %6$2C35E:CROkyz{âåbkpXW\KFJnimUQRKEGTRS>DB6B@>QODXV:QK-B=/,'$0I4.J3,J.1U13\21\.1[-/Y+1X+.U(%N"'P$'R%+V(,W))K&   						
+
+
+
+
+	(+*)&''&$"$%#  !''2$.4(24'13&22&00$++!"#!( 5C6 #'*!MQC.7$%4!"5"!3#%5(%&0',8."0#+ , %""(25,/2+',%"!8=@FNPBKH8C=2=7*66CMVKWcT`lmzÉIRW&*+! !)1& (!$'*!02%CE7FK7/4 =<*[ZFZYEVXBTXAPU?IN8EM6FM;FR>IVDLYG.9('/  + (*/(/2+./)./)12,/0*/0*0/*21,22*00(02'35(IK=@B5LL@VTHLJ>KI=GG=::0+.%2=/5A35A58?7<?8;<7=<8?>:FGA>?7DD<FF>EE=CD<=C719*(5!-;"6C'1@!H\7,A +2E25H5):(+6(%+!$),#+.#.4&&. )$"*"
+	&+$$'-9+/=.-!/ #1""0!*!0;-+)6%&2$$  (+5*$.#"%(%3$-;*#%".$!.$))*7-$')5'*8)#1 +<)/B,$7!$5#'8(#5%4#4K9@WC;S=$:%-"/,<!AR2CT27F%0?"0>%)6"+8&'0/6&15&(/%2 8G2=L5BQ:HQ<JO9QQ9IE*GD%KB#UB"bJ(iP'qY)yb0h<èz[Æüä¬π≤ƒ¬√¿ø«¡¡ÕÕÕŸŒŒÿ …Œ»«≈∏±©à~rg\Ji^J}ubäÉsíéÉ†ùî§•ùü¢óáâ|ei[im^~Ösôûä¶´ó≠∞ü¨¨†ß§ùùôòùòû™ß∞ßß±∞≤æ∫æ ≤∂¬óù©ryÉUZ^MQPUWLddX~~tõúó≠∞µ≤∏ƒµºÃ±∑Õù£ΩgmçQZÅnz†óß»¨ΩŸ©π“ô®ΩÄçùYfo/8='3/%5+2D43K5B\CIfH5O2(>'&7%-;,4B32C32C3.>1-=27G:=K<1?0&4#!2 DZEE]E4J31B/+<*.=*5C2.<-.;*+8&8A0LRFbg`u~yQ^WEVN)?2/K58V<2O1/L-0R/+Q(4^0:d65W2,K))H(0O0;\=<]><Z>9V:8U9;S93F2+>*-C,4N51M42N58R94L63J8UlZRdTbscn|kyÜtjwc9H1!8(B'>V<F^DDX?6J1:L41E,*B(-J.3T79[@0Q62R:)G/%A*+D.#;%'=&+A*3J0,C)$:#*@+#:(5# 9&%>+&;(/+,#9$$:#01/!(:,6G7?R?FYFAWB:S=0I3-C.5H4-;*(5$2?.-<)&9#,C)&:!'!!5C4*8)'5(7E6\m[^mZQZGAH819,)3*$.&!*%(#$% '!&:G>6D7'U`bõ§´EIR*-4%*-%"("( ((.#* !++!$#$"'"#IRWJS\07?69>457,.)!&$%#!  #%(!""#*"$+#*4)*6()5'$.# '"$!!!'CG6_`PdaRJF;64(/3%"-!.)6%#(!-!/"!1$.@0.E32K61I19S:-G.#=$";%(A+'@-"7&+'#1""0#) ,71@JBCE@ed`>:7fff^`_DEG;?@:DE@NNEWW,@>3HC;NH>MH2>:5G74J57O59X66_52`12^-1],1[+/Y)*T&*U(+Y*-[,-W)"A 
+     
+
++,'
+
+
+
+)--)+**(	
+$()'! !,&2$,4'39+48*-/"**--#-.&),#.6+&0%()6,3A2-*! -1#TXGBJ5 ,*8''8(,:-"!")!/901?2-;,,:+$/!%9;.>@313((+")+(-149@HKT]KVZGUUBUO*=;RahYgt[kzaoz?JP/79AGG:>=*/(08+1=/$0""*17-)/#(. &,CD6\[I[YD\X?][BUU9UU9SV;KP9=F1.9(1>-+6&,7)-9+&2$1=/6A3-5*17-69067/77/85.;8196-99/8:/57,44*MMCNL@[WK\XLSQDRRFEE;47,6A32>04>3<D9@C:BC=ED?CC;JJ@JJ@QNEMJAJJ@HJ?@F8)4$.:&0<&.;!(7(8/$2!->.2E22+'))1&%-"%- &1!$/(% 05.!)#!(2'&2$0>/2C34G4/B/"5" 11?.')5'!,%!"(2' ,-;,-&4%"0!! *!!-!("/%#0&,$))7*'8(&7'%3$*8'5G1,;&%4!-!3#*?.?XE;T?0F11-"/#14D)9J*9H',;+83?)(4 (11:).5%'0"-<H2PY>HO0DI+DA"D4\ErX%|]&Ñ`&åf(èl*îv.ô}4ó~<öÖP¨úx¿π©«∆¬…»ŒÕÕ’““⁄œŒ” ∆≈ √ªæ≥üùåpÑjGqS/uR6ÅaJåucñÜwìå|åÜvvs`WVBKN;Z_Ipx`Öäsçê{ñîáöíèêÖâëÜéúïùöòù¶ß¨∂π¿∑ªƒÆ≤ªìòûehmHMPDJFJSNitpíûû≠∑¿≤æÃ∏≈ÿ¬Œ‰∫∆‹¶≤ÃíùΩì†¬¶µ‘≠ºŸ¢≤Ãú´¬ó§∑|ÖñDJV16<*30+;01F5/K4<ZBDbJ5M7&9&,=-8I98O=4M:/F63'4%:L<=P<,?+04J5>[?:W;.F.'?)1F3,?,/=.)5'!.;F8U[Qaf__hcJWPNbY-E7+H43Q92Q2,K)0T.-S*9`39^3,J(+E()F(,M.8[;8[:6X75R4.F,+A*2H13M42P4.O0-N14P73K5.6$KbR?VF3H75F6>L;FUB@O:&9# 78P6RjPK^HBS@UbPKVF4?.0?*/F,,F))F(5R6,F-.F0:O<&;(/B.9L8:K8!20$6&%7)&8*!3% 2"$5#+&.$:%#;#5!/H38T>;WA4M7.D/*@+#6#1-)$5%*8)'5$-;*2C0)<&(?%,@'#5&5"(6%^l[7H67H8IZJTaO@I6WXF20!+.#)1&+7-0<2.91.;2ANEHXN(709HA9I? /([iló°´W]k26B,09"*-('%"' -#&$)$%(0%%"%!;FB3<A4=DOX_%+-14*./-/.$)#&'&!$)"$"") (!-*8'+9( *"!!#!  !$15'TXJceWZXKPL@KE9+),/$'/"%(3"ETAAT@BXC>V@:S=0L30J14N5/H2,":$#;%%<*"7&,/" 0#)7*(5+0:146+86*NL@:;3X]W?HC5>;4>=1??8HGM[\6AC4@@.:6'2.'2,=I;9H5<P7?];:c74b33a01_.1],.Z)+T(.Y,.^,.\-0W++   			
+			!"	 .!1 -,-++#
+$((*)&#"%%6&>O?4B10=,/:*(0!,0",.#)*"(+"4<1=I=.</-=0,=-*8'( ($(+- X[HPUA.7$5@/,:)1=/)1&-3)"%4:0+5*$0"3A0/=,)28*AB4@A39;.:;3553CDH]dnOYeN[dSeiBVT.B@HV_KXhdtÉZjw>IOBJL@EH:@>07/(3%-9+4@2+6()1$&.!!'$!77+QO@]XD`\C_[@WV8QR3GJ->C,/8#-8',7''2$.9+1<.0=,0>-.<+4A05@26<09;0??5@=4A>5A>5??3;=0;;177/==3WUIYUIfcT\ZMWXJRRFAD96>12>0;F8?J<=H:AI<HNBIOCGK=JN@MPEKNCMQCDJ<5@08E3.:&3?)6B*;I/;K./->+->..?-2C10>/&2$&&$ +*7&$1 ""#&"#),%&,"#'  "*$/!-8*,8*-;*,=+,=*,=*-;*&3")5'*1<.08+##+ (4&#1  .%3$ , ! *#/#'+(8-"2%"2%*8+%3&!1$'7*)7*(6'-<),;&(5#4A0#4$6K:=T@8P:(:$- '%(+-7778?@MO*EI$JM.7; 26-0/2!!%#,08![^?db<FATHsZ"Üg&ïu*û{*£},§~+®Ö1ßâ1¶ç3ßë>¶ìN¨ükº∑ö »ºœŒÃ–––œŒÃ…ƒæøµ©º∞ö≤§°è_ñ{Fäf2ÉV,ÇV1É_?ÉdH|bIr\DkW<[M2HD)BE*RY:flPtv`ÉÅråÑÅá|ÇãâçÉãÅÄîñìÆ≥∂∏Ω¡∑º¬©Æ¥âåëY^bEOPCOOXhhÅìó°≤º™ªÀµ≈‹ƒ‘Î≈÷ÍæÕ‰¨∑”†≠Õ™∏’ÆΩ⁄¢∞Õõ©√õ™¡íù±x}êIMY4<?+81+@1,E0.K5?\FHaK?VB0B20E66O<2M:7O?5L</D57L;>V@5M7(;(,B-7T8<[<3O61J44K7.C0&4%,8*". :E7hndX^Tah`LYOEYMA\K,I52R:,J.-L,-O,0U,8[16V/+F%)C&2Q17Y85[65Y53R2/J+#: %;$,F+-L-,O/,O/-N1/K2'<)((:QA\td0I6.@0#4"+%3"'6##4!$7!+A*9L8M^Ldq`_jZQWI:E4.@(-F)+E(/L.2L3/G17J7.@0;M=:L<5C2.#4"*<,+<,"2%&6)#4$ .+(!6##;%2J2;T>4P9,J2'E-$>%5-(+,%*)"3!+<)+='%9 (<#*='+<)*9&.<+>L;>L;EVDDUC3>-DH7WTAKE5:6*02%'/ +7)2@3/"j|neym*;3?PJIXQFURoxÜåöil}Z]nOUa?FN*25('"!&%&#&''/"#)#)&-% +#BNJ=FK09BQZa2;B:AGBGK@DG288!'#"%$!# ()&$2!'8%&4#'1& %"$#% #"  %$QYLioaIK==;.\VFGD3>@25<,5>-=I5HZDJ]G;Q<3K5.F0)B,(A+-F0+B.#:&$;'&=)-B1&8*"2'#0&'5(,:-.;11;035(:;-?A3=C5DNC@MD<KD>OI9LF:MI=KK1==2><5@<#.* +%BJ;?K7>P6C^=<c76d34d40`00^/,Z+-X+/]/0`.1\.0T.    
+
+
+	
+
+		* 2"1 /.//+
+'*()/-(%*,?,7M8<R=8K8):(#. (."'*!$* (0%5A5?QA7L;-@-'8&&3!%.#' "PQ?[]H6;'5<*1<+5@0+3&)/#&)17+%- (3#0;+0=,5@09B1?A3?@2==1@@6:;6PQSLP[W^ndp|n}Ñ?QQ8HH5CNO\lcsÇYjtKVZKUVHPRAGE?F?5?4/;/,:+0=,+6&#)')44*@>2EC6IF7OL;WVATT:MP5BH,3;#,418(-5&08+08-6>17=/4;+1<+0=++8&4A06>/6:,:</??3>>2??3??3@@4=?4;=268-PPDYZLhfYZ[M[\N\\PKM@4:,4A0?M<@S@?R>AT@DUBAR?AO>?M>CQDGUHIWH<M;<M;TeR=O97F/4D*=M0J^;*?1E,/@-/>+;H7+6(,6+2=/)5' .$2! .&&!$+1%?B7MODLOD:@4-5*"!#+ 28,AD9DG<AE7>B4=A37?0.9),7''4#%1#&2$.:,.:,+8'.;*"-*$/()6%)6%#. #&*$"&4',>0'9+.#$.#'7*!/"$2# 1$3 ))$2%BTD?R>/A+'1.0608)>(F-M0V=cNfV#f\)]V(IE)&94 &*),UP0uj=ud,Åj&ìz&ôÄ#°é(§ë*¶é*£â(®ê0§ç-£ë/®ô<•ûF©§`∂±á≈¿™Õ…ΩœÀ¿∆ΩÆ∂™î´õz™ôm•ô]§óQ°ëFúÜ=ót2îg.é[,äU-ÑN*{I(wK(lK(WG%FBJN+\aAnqVÄ~oäÖÇäÄàäÄã}v}jieÇÖ|ü•°©≤±±πº≥∏æ†£™ty}QY[FRRO^arÉäî¶≤©∫Ã≥√⁄æŒÁ√”Í¬“È≥¡‹°ØÃß¥‘≠ºŸ¶¥—ù´∆ú™≈ù´≈ï†∂ajy09@(21%7+,C1+D/-I3@]GKhRA\I-E5+B21H6:Q?:O>/D5%:)6M;.E1)<)"8#)C*6S78U91K2*@+.'1&(4&;G9^fWZcRHPA3@/.@0IbO6S=7U;IeL0J/(E':W86U30O--J+9X6PsKFk@1V-0R//J+%>!&=#/G-0O0-P/,O.,O/.L0&@'"3!%3$%5()@0Ro[6S?+@/*8'#$$&*!2 (;(AVCÇïÇqÇp]jXGT@8K5*B*+E*+H,0M1AZDEWG<L?HZLM_QOaQ^t_jÄibxa,?,$5%+9,%3$!/$5" 6!":"&>&.H/.F.+C-%='3001!4':$,?+-+,$7#+=''9!'9!"40 .$2!+9(7D3AN<CP>CP<:C2Y]LÇl\UBTI7TL9HJ5XaLZiV4G3KcMaxfH\QZmgiztuÅÅÜâíkiw=9J21A^drks~NU_',0"'%$$"#$##+"*"*)1"1<.7C9?KG=HL<GMU`f]gpWakLV`PY`@HK%$!'#"'! %  !''-&4##1 *%/$'$ #"$$ ""$&'FTER`O<G7[bPjmX\`GX]FDL5CM5@N7?Q9=P:6H8.@2&8*!3%#5'$9(&;*%:'%<*)>/9K?*)+'3''3'$2%%1%)1$+1#.6'.9+1?0:J=?SG:PC8PB=SG?SH<MC6G?->6"1,%4/GN>CL98G0?X8<c76f63e43e43b4/]/0]20^0.^,1\.$C#  	
+
+	/ 2"3"4#3!2!/)
+%&)-0 2.'+7!+C-6M9@RB6D5)5)+5*(2'*4)0>16H8=R?6I6 1%2.7$,2$,0!MN<^`K=@+*2-8'5B1)4$)08)4<-%08)!))1"9B17>.>@2=>0@@4AA7?@;FJM<BP7@Q[ivrÄâ+9<2@CKWcguÇbrWen?JLHRQV`_EPL6@80://;/(4&)4$-5&-0%<>3EC7IG;KG;IG:IG8EF4CE/;?(19!+3+2 18(19*6>/.6)17+37(37(29)3<+0;*4?.2:+28*:</77+55)66*::0<<2;=2<>3<>3BD9YYMdeWhi[b`Sb`SSTF<>0.7&1>,.?,+>*+>(2E/2E/1B/0A/2C31B2.A.-@-,?,<O;EXB,@'(: +> Ka;8N*&=!*='%2 "+ &%+*2%-:)-;**;)'!"!! &,0")+(,$'"$$*2%8;0IK@OOCMMALJ>LL@FH;AG99A2*5%&'3%2>01>-1@+L^HJWC*7%!.&!,"/%0"!,'*!"("0#(8+0B4&6)-"&6+&6+!/"$2#,%01#NP;KK3<8E<QB!ZF#cG"hErK xN|UÉe%ãt.àw/Ñz5xn1[S"ME ?:75@<!kb;Ñt@êy3õÅ,ûÜ"üä§ó%§ó%£ñ&¢ë'§ì+¢ê*†ì+¶ù8¶¢?••O©ßj∂≥Ü¬æô¬ºö∏¨Ü©òl°çZ°èQ¢ôL£ùG°õC¢ó>§â8§|4úf(ìV êS$ëW)äV'ÄU(mP&YFVJ"e]9yoTànéÜÑìâëëáêÄz~ff^lpbzÇwêôî¶Æ±ÆµΩß´¥ÑâèhpsS]^O]`hyÄåú©•∂∆µ∆⁄∫ ·ªÀ‚ªÀ‰πƒ‡¶±œ¢ØœÆΩ‹Æª€¶¥—°∞œ£≥Õõ©√vÉî7AK(44$6*+@/+B.)B--J4CcLJiWB_M5M=3J:7N<@UBShW;P?4K75L8*B,47!1K28U95O4"8#"#'3%/=,;H60;*-8'(7$"8#LhQFdH6T8wìzGaH4N34Q33P11P0>];EgBGlA:_40S+9X6(C$"<.H+5R41S2/Q0/P1,J.*F-+A,+( .!!3%:WEEbN(?-0A1( %15J7[r^cyd\mZCTA<R=8P:,F-+E,/K2?XBdyjxä~yãuä{àöäpÉo[rXE\B1G2,?,-?/.?-&7$.A+'>$%=#'?'%=%#;##9$ 3 "3!$7$#6""5!06 7#4"%6$)<)+>*'8%&8"'9#)8%#1 )*1?06C29F4EQ=HT>CJ:@D3RT?fdOWO:GA+GK2VcI[mULbKLdNE^KG\SzçãuÖÖÇãêtvÉ]ZkLIZ=<L5<LirÅqtÉ-09!!&(  #(!+ $,2:-5@07B25>-7B46B8AMIGRV?LRO\dWenMYgBN\FPZ;DI!!#!& ! #(!!%3"'5$ ,%#-"!+ #$ % $"'! %!#-"+9*;L<PaQP^MR_MblTJT9R\ADQ5<J1CR;L_I2E2*:-&3*"/&/%.#/!!6%#8%#:**>25F<.$'#-$#-")!/ 3A2)5'!+ !+ )'1##7+(>1+A40G79N?<N@AUIAUJ?PF6G=@G58A.0=);R6<b95d64e64e64c71`42a52a32b02[/, 	
+
+% 1!4# 5$4#2!1 /'	
+)++0241*).4#/A1;M?>PB4F8/@0/=.&4%$2!5C2=N;6H2'6!)5!19*)2!DI3chQ?D-*4+8&4B1#4!#2-<))6$%$/&,>B4@G7@D3DE5CD4DE7DF;@BAGKT^i{dsàjzáAPWGRXKT[R\hKWeXfsL[bBNN8C??LE=JA0=3+7+'1&*2%&,'-*0$;>3EE9DE7DB5CD6BD6>A0=@-9>*5:&6:)48)37(-6%6?..6'3:*48)7:)7:)15$15&-1"&*.1&25*24)13(02'22*77-:<19;0::0<<2MK?caUqocom`ifW[XIJH9;<.6:+19*,7'/<*/<(1>*1>,1>,5B14B1.?,+<)'8&+<)6L57N4?V:1F'ZpL6L(+?$1C-+8&7@/;?0=?1:>/08).<+#4$&&!!%'!#!$(+ '*28*#),2$$*FI>MOBPPDOMAKK?EG99@0*2###)8>2?E7IRA<K46H.6H.0B*,;('5$ -'5&%2!&3""/##'3%+7)%1#!/ .?/3E5*<.&8*%5(%3&#1"*!,	^C.nP4kJ'qN$wQ"Z%ãg-íl.îm*ör,ùv+ùz(üÜ*°é/°ì0úè/ñã2éÉ4Äv8qg4d[2k_7áyHê~>ôÑ1ûä)ûå ùç†ì £ò$§ô&£ó'§ñ)†í'†ì*ßû5¶£8£§>§§L©ßZ≥∞kµ≠l≠†\£íLùâB†êC°õC°†C££C°ú>°í7§à5°r*ôd"ùk,£u7ûr5îj0â`,|T#zP&|X4áiMî}môäáûìóûïöêääywj^aN]dT{Çzû¶©™±ªßÆ∏çîú}Ñänxz_ikcpvÑêú†≠Ω¥ƒ‘¡–„∫…ﬁ¥¿ÿµ¿‹™µ’£∞“´∫€∞¿·≠æ‹ß∑ÿ©∫÷¶∑—ãö≠S`i2@@'9-(=,*A-*A-)B-2N8BcPJkXGcT6Q@5N;;T?G`JKeL9R<5Q89U</K2*C-(A+1N25R6/G/.$1 '8&'5&'5&'4#&7$+C)EdD@bA7X9UsYPnV8T=0M1;X:Ba?Dd?:\75U06V14V39[:*L)0R/2T12T33T51O3-E-34!4G4$2#(##7)KfU+D1+B0%5('03I4#9$+A,/B/+@-2I55N9-F0%>(*B,?VBjpvã|{íÇrávrÉsXfU@O<8K76M96O:;T>>V>4J3)@&(?%5M3)A'":"%8$"3!"0!"0!!2"-..3&=!'>$(>',?+':''8(*8)+9(/<++7)(4&#1"+9*1=//:*LXB@L6LRD7=/YbOYaJ^cM=E.AQ7NbGcv`_u`VmYYobWkió©≠vÖåãï°åí¢ü¢µù£≥ñù≠Ñçûâí°uxâ,.;#'&#'#&$%"#!,'4#3@.4?/1=/9F?N\\M[^Q^fFT]HYcUcpN\iEMX?FL#'(##*#%,$ *($'&3"%1#%& *#-"#%#!'#!+#%1'-;.0>1):*)9,>NAASC;L:?N9<K4L`E:Q50G-5K4>SB*<.$1( +#&#%/ 5""7$#8)*>27H>#3)&( (&2I\I3A4".$'1(!-#.#%7+'7-&6,"2(.#!.$%3&)9,2D64F8>P@4;),5"$1-C,>b<8e:7h;7g=6e;2a75d85d67e4,Q(	
+'#3&"4&2#4#22/%	,,+/403 7%.(- 2$&;,6K<<SC8M<(;(*8'+8'-:)3B/;J77D0(5!/:),7&9C+V`G?I1(6-<)3D2+<)'8%.((!)69.;=0=A2BF5CF5AD3@B4@C8:?;X_eivÜgwÜ_pw/=@4<?RW]GPYLV`hu~ANT7CA6A91>4+9,)5)"-$*26(+/!.2$06*,2&;?1<>08:,8:,:>/<@18<-59*68*79+46)37)09&;G3.5%3:*57)8:,9:,46(13&.0#+-"(+ #&$'!$%$$(( -/$24)46+99/CC9\ZNpnbvrfpm^b\LZTFLI:?@2=A37=/7?07?03<+,5$$,*2#'2"%2!"0+9(*9&)<(2E/7N46M0KcA7O-1E*.@*-:(5@/>B3=A2:>06>/,8*,'/$(+"/1&..$""&&;=2;=2690*-"4:,/6&6=-)0 /3%HJ=NNBKK?JK=HL;<C3 &#:<1CE8CE8<C34B+.>$+;!.>$1@-'5$'5$4B1*8'#1 *!*)4$1<,1<,0;+/<+3A26G7-?/&6)(6)&.&'1$G(c;!}U2ä`6íh6õq7üv6£{5™Ñ9Æâ9≠â5™Ü.®Ü,¶ä)©ñ-©ú,™ü,¶ú+£õ0°ô7ôêAåÉ@à{FàxEëÅFôÜAúà/¢ë)¢í#üí°î!§ô#§õ$§õ&°ï%üì%¢ñ*¶û1¶•1••5¶§=¶£B®§I©£KßùD†í:úä4¢î<§°B†•Aü§>úú8õë0¢ä0üx)ún#ßÄ5≠â?®Ü?§Å=†y8ïk/ïg3ók>òrNôyd†âÉ≠öú´õû†ëéìÜvumXXUBuwlù°§£™≤§´µòü©ÜçóÑãì{ÑãwÅäâï°û™∫∞ΩÕæÀ‹Ω»⁄Ø∫ŒÆ∏”´∂‘•¥’¶∂ÿ¨º›®ª€®π◊Æø€Æ¿ÿú≠økyÇ:JI+=1-B/(=**A-)@,0I4-M8IhVPm[KfUB[H>WAG`J/I0*F-:W;0N26S7-E/":$%=%6P77Q8(@*(*6(ReQ#9$*;++;.&2$1B0QjM8V4Cb@?^>NlTKhR/M5B`FPoP^}[@`;0P+5P/1L-1P19Z;BdA;]:/R1.Q3.O4)E.*=*(!.C2,A0"4$"2'!1&,AYI:UB!:'*?.*$+#'2$&5")<&9O8,B+)?('<)#8' 5$(?+1H43J6/D13H5QfU>UA;R>LcOfwgfteVbTCQB6K:5L86N87O71I1)A'1H.;S92L1,F-$<&2* 0#$4'.%6$.@*.B)+B&*B(*@));+(8+)5+,8,0<.2>0(4(*8+-;,5C40<.+8&XeQ[hT_jZCN>ivbCR;VdMWfOCW>OfLvåuoÑqQfU^sjväãè†™àñ£•±øñùØòü±qzãBN^DP`jvÜMTf+1?#*2') &"")!"*" &4#-;**7&+;JCR``O\b?MV=NXEUbP^kJVbHQX5:>)-, %$$+#! ""! *'!&!.)4& +$$' ,"'$"$*7.4D:4F:5G9-=0'7*+;0(8-);-4F6<M;?P=/E.-E-(@()A+&=-&8,) #","4$ 3 1&;,/C74E;)9/#0'*"!-#+5 I^K5E8$0&$/''2*"2($4*(5.'4+"/&) &(%3&0 ' 3 *. $**,?+@b?:e::g>9g@:fB7d=8e<:h:9d6#C  )$4'"4&2!3 4! 3 0 %'23 -04114"!6%3$%7)*<."4&$9*.E55L<6K:+>+(6')5'+8',7':G5.;'%06A0>K7:I2BQ<,>(':'&9&-'$!"(),!,.#/3%.5%3:(4;)4;+5;-7>6R[XesteuuGSO/:4HLK=ABNQVZ^gmx~]kl$1*&2()4&)1"+1#,0"13&<<0,.!"&!')/%)1"*1!*0"26(7;-6:,37)37)/3%,/$),!$*.7";G1#*$*%'&(%'"$%&%($' &$"($' $' '( '( %&()!*+#/0(::2MJAnl`|xlyvgsm_b\LZTFJH;46).2$)/#(.$(.")/#&, *0&%')-:)'4""//>+4H/E\@<U79R42I/$7!$3 '4#'2"'2"-9+.:,'2$*2%+-"00&KI=C?431%" ,,"*,!),! # &#)6=-29'8A,%-8:,HH<IJ<HJ<?F4*3""/3%BD7AB4@A3@D33<)#/,5 ;D/0=,%2!4A/8E3'6#-!." (6>/:A18?/4;+6=-39+<G79J:->.-8*20!D2b?!ÑS+ñb2ür;¶ÄA´éHÆóIØòH≠î@´ì;Øò;∞ô;™ì3•ç-¶ê-≠ú2Ø£3≠¶1´¶0ß•4¶•;¢ûGúñLóåLñÜJöàHûäA¢ë7©ó1ßñ*§ï"•ò%¶õ%ßû%¶ù&£ò%üì#§ò*®°/ß•.¶•/§¢1£°4•¢7•¢9¶û9ûî2†ì5¢ô:¢¢>°¶?û§:úö3úî1£ê2û{)öu%®à;´ëD®ìD¶ìD°ã?õÉ9†É=ßáJßÇUû{]¶Üy≤îí≠çé¢Ä~£ÇsïzexgSwj†üù©¨≥ß™≥†§∞çì°èï£èó¢çó£íûÆù©π•±¡≤æÃπ√œ≥∫ Æ∂Õ™µ—©∏◊©π⁄ß∑Ÿ®∏Ÿ¨ªÿ≠ø◊¨æ‘õ≠ªary3C@,>0.D/&<')?*(=**?,(?--F3JeRPkXPgSCXE3H5 8"'A&B\?1N/*D' 6 3"5!-C,4N50L3%;$.F.GdH(E)$6&/=0'1&JWFQeL3L.HaCC[ANgQEaKA_GGhK>`?EgB2P.0K*3J.0G+.H-<Y=6S7/L0+G02O;>[I@[J>RF, &*B2<YE?_HNkUJcP3#&=-A^J&C-*@+&7$!#%1##4!#9"<T:,C)$:#!4!/(-#5%0B2:O>8O;9Q;6N6,D,2J4K`MnÄpÖìÜzà{XdXQ]OFTC9J80C/-C,4L23M02P44U8?]CB^G:S@1H8#8'%7'/B/,?+)?((>)*?,*<,n~täÇ;B:;C8CN@(4&+9,-;.5F6=N<+<*4E2`s]vâsrÉpizgfxbL^HJYBHZBAS=DWA\r]UjW;OCL_[k~ÖdvÑèû±¡Œ•±øß∞øOWj/:LÇè†àò®Üñ¶vÑëXbn'.4#)%" ,*8)'5&,-=3;KHO^cHYcJZgDR_DP\CNT,46#!$ $&! %#(!!&  #$+#' +(4&&.#%#$ *"(( 0%(>1<TF8P@9P@9MA,>2 0&(5,)6-+8/.>33@6=I=NYK0<0*8),?,*?,&;**<.*7. -$%+ 0#!3%0 -,>0-B3/A5(8-&6+%2('3)*'>*CZF1C5!1&"/&$1($4)#3(!.%( (,",""/%(4*+!'!2"%( ->]>>fA>hD=iE;gD:fB<i@=h==b7*	 		&"2%!3#!6# 5""7$"5""5"!4! 3 27!403501"2&&7-RdXGYK#5%,1#$9*,A08K8,=-)7($/!%"/0=+-:(=J88G4.=*-<)%6#&9&'8($ $'%+)1".7&+4#+3$.6)/6./91.95)6//903:2?D>687CDHUY\lvwYec +#$*2%(. +/!35(CC9DF968+$'"' *5'%
+	-9%7C-	
+/.)b_V{ym}pvsdoi[a^ORPC@B4)-#&%(!$)"#+ (3%)4$7D3"-5B0DV>9P4<U8@Y</E.#6"#4"#1 $2#*8)'7*$2%&1#06*24)86*A=2LH<C?3*(+-"+.# #),#+1'"(28*=D2:C.3;&)-IK=AE6?F6*3"&+1#?C546)>@2<>08<-+2"2;(@G5BK80;++8'>I8/;'1>*&5 ,9'",2$39+?C4EI8FJ9EH7BE4CF5?G2@E/@>)N@&lK,ä]3ßr<≥Ç@µçE∏õM∂¶O≥™M±®I¨¢@©ú6™ù5±§;Æ°8´ô3•î,©ú,∞¶3Æ©1ÆÆ4∞±9Ø±C≠¨Oß¢QüïNüêOúâGüå@ßñ<¨ö6´ô-©ó'©ö'©û(©°%®ü&§ô#£ò%¶ú+ß†,•£*•£*•£,§°,•¢/ß§3¶†2†ô/°ò3£û:•¶>ü•9û°6ùú2†ò3£ì4õ}'öw&•Ö8¢ã=£îAßùH†ôAûî?¶óFÆöQ±îZ©à_¨åw±èÖ™Ö}°{n£zdöuZålUÇk[üêç¥Æ≤∑¥ª™¨∏íï§çì£îõ´ó†±ï†≤õ¶∏¢´∫™≤Ω≥∏ºµ∏ø≤∏»±º“π…„Ω—ÏªÃÍºÀËπ…‚±√Ÿ°¥≈}èõDVX*>5-?/&9%$7#(;'+>+*=*(;(0-D2BWDL_LQdQ3H7$;'.H/4N1(C$*C%$8)% 2/I.3P2/I.'A&?^?8R7(9':E7^fY{ÜuBT<4K/PgKVmSD\FKdNEcI4U87Y89X63N//F*,@',?))A)2N54P9<XBLgVMhYJfX>ZL-G:2J<@[LJgUQq\Tt]B_I(A."+>YF1O7)A)0A.('$) 6AY?(>'"5"3!'5&,"3##4$0A1*?0.E34N5:T9'A(+C--D09N=EUHn|oÄåÄéöéak`DOA1>-+9(+>*/G//K41O5;Y?@^FHcPIaQH_M>UC1H4(?+)>+,A0*?0PdXàóê©¥Æ^h_WbTR_N'5$7E67E62C30C0):(8K7AW@SjPWjTcu_BS@L]J6H2@R<FWDAT@>Q=7J7=ND_onl}áãõ™{âñáìüoxÅìú•ÖéùÉëû}çö{çô{çô}éòâìù(/5!'#""'5&#1$$2%%5*"1*CSSO^eIWbHV_5@F#&#!!"#&(+"(+$$!&%-"$%#/!#/!$%'"2'+=1<NB>RF;SE9TC<WD5M= 4(!2()9/+;1$4*+8/0=40<29C8U]RJQI",#'5(.?/0B2.@0.>1/?4-;. 1!1#0"/"!1$/A31C72B7)9.&6+%5*'4*0"-D2=VC/A5.#,#%2(&3)'4*#.&!-#!-#&3)%2((4*#-%!+" .!&6)	
+9U>@eF=fF<jF<jF;iD>k@>g=4S1 
+			  '"4&&;*%<(%='#9$%;&":$!9#57!":$6 42 1"/%#2-)83GXPl~pAR@#2+,(,:+7H65F4%!)&4#/=,->,+9*-9+RZK1<,#/!+9,"."" (#+ "*'#!!& #)%$!(!#("+0,+/.9=>IMNHNJ5?7.5-*0&/2'.1&*-"*-$+1'$')3*$.#			9D34?.	
+	
+	
+
+DC>rrjwylpqapn_igXXYKLM?<>1#-$)5)+8D64B18G40B*0D)8L13J.)?(&9%*;)/"4&'9+!1$,$0"&.!*-".0#;9-FD7OM>>?1'*#!$),#%+!#))1"*3"09&1:'3<)29)*2#!%'-!17+(+ 8;0;>3<@25<,>E3=F38D0/:)(3"4=,*6"ES<1@),9'(&,:>03:*8?-@G5@E1EG2MH2PD*_L,hN+wV-çc3•{A¥çH∂ñIµüJ∫¨S∂≤Q≥¥NØ±DÆÆ>≠ß7≠¶4Æß3≥©6±¶3™ü,´û+Ø¶/≥Æ6≥µ8µ∫<≥∏B≥≥OØ´TßüT•òT¢ëL£èF™ôAØù9Øù1≠ú*´ú'™†%´£'™¢&ßù$¶õ%®ü*¶ü*•†(§¢)¶§)ß•,®¶/´¶1¶†.°õ-§ù5•†8§¶9†§5ú†1üü1†õ3°ì2öz%ös&¶Ä5°Å6£í@©¢J£üD†üC£üF´£RØù[´ïcßéoßçv´êuÆëq´âc§~WõnOãaKôwnµ†üø¥∏µ¥º†¢Æëóßìö¨îúØò£∑û¶π£™∫•™∞®ß£≠©¶´¨±Æ∂√¬”Â»›Ú≈◊Ìø—Á±√ŸïßªqÑìJ]d)<8'9-'<)"5-#2):():('8&-#1 3@/FQ@WfSNeQ8T>.G19S:%=#'>"%< 0&&5 HaDFaB7Q40H.@X>J]GITCyÄpxmbkV9I/;O4dx\lÉgE^AD^C7T8/M1:T76O20G-2F-8J42C0,A.1J53P<EaRKj[Jh\FfYHh[IkZNq]XydSs^A\I(?/ 2$*	
+3L9@\F1+<*,*#&!7"AW@,?+#4!+#/!"3!/@-*;+M^N)4#,H1B`F,F-&>()@,-B1/A1!3%HZLn~qutrzo[aW/5+$)")5+'9+2I76N88Q;D[ID]JKbPG`MIdQGbO4K;+@1;QDnÑw|êÖãùë[l\UfSCU?4F05C22@14E50A1(9)0C/0G+auZZlT /#0*8)/=,AR@J]II\F:M7=P=Zj`n|}zÜíÜèûjp~aen9:>;?@S^bwâçÄíñÜóûéìesv5?@ )&&! " # ')&'#/+HTTFTU@KM*32#"# %%(!),%%(!"'19,'/$%"*(6)+)#7+3K;;VE:WE=UED\LE]M9QA+D1%<,)?33G<-A6(9/&8,%5*'3)!-#(2'JTIdkc/6/!'##.&,>03H55G7,>.%6& 3 '<+'<+3$%7)-?32C9.;2 -#,"/"(:,(=,/H5;R@,<1 +#)3*)3*(2)$0$$.%!-#*+".")#"!/"&8*(?/CcL>gI=jI>lH=kF?lA>d=+  					 " ! &. 1 #8%(;((;($<&&?)%=' 9#!:$$=(!:'7)"6-,<;ZhkYiiGZTmqTeRHWB&5 !.%0"!-$2!9J83@/,9(2?.)7&/*%3&&2$rzk:C2(4( .!)7*  
+
+	!-/*"!& !&" 043QUT382!
+&3=5				
+	
+				9D4,9(	%(! 
+  	
+			
+SXQem`fn_jpblpb\bV[aUJPD7=3
+
+!'#&2(* #""0!,:),;(-?)4H-BV;&<%#6#7I9#5%'9+ 2$*"0#(4&(3%#+!'#%9;-IL;BF7$' #"  *0<(0<(&1 &%)&'&)1$-5(19*18(2;(2>*3@,.9(/:)6A0(3">L56D-*5$)1" &15'15'25$@?-JD.TD+_H)sU1émB°ÅN®àO±éLπôPº£S∏ßOµ´L∏≥O∂∑O≤∏J≤πE≥∏@≥≥;∞Æ5∞¨1¥Æ4∂∞6≤©0∞¶-±ß.∑±7∫π;πª<∑ªC∂∏M∂≤W≤´[∞§\ØûX≠õO±†H∂§B∂§8±†.Ø†)≠°'≠•(≠•(™†%¨£*Æ®.´ß,¶§+¶¶*©©-¨¨0´©0ß•.•¢/§°0•û3•¢7•ß9¢¶5û¢1†£2£†5¢î1õx$üs(®|3ûz.•ì?©¢H£¢E¢£E••K´¶TÆ¢Z¨ô_¢åcûäe≠úq¥¢r¥üj≤îb∞Ü\üqPóhX´Ñ}æ§•ø≥∑µØπ§¶≥†¶∂ú§∑û©ª£Øø¶∞ºü§®ìêâÜÇwxxvÅäè´ΩÀƒ€ÎƒŸÍ≠¬”xãúPbp6GQ/AC&7/%7'&9%)<&&5"%4!%3"&7%'8%.!.*5%BI9YdSSjXJgS<WD<U@(@*$:#(?%,@'/>+2A,ZqUVpSF`C9Q7G]FpjÇãviq\W`KFT;6H.D[>]tWc{[_xZ4O01N24N36M3/B,(>)0E2;N;AVE0G51L;5TDEfUMoaVxj[}oZzk]~kTu`;[F#>+%!(	
+)@.F_J%<(0&4%!/ #&":$:R<*=)$5" '8%3F26D3;I:- 2!,H1EcI3L6%='.#5%.?/(:*(?/TiXgufcn`Çà~ÉÜMOJ070,7/<L?TeU2E28M<:Q?7N:8Q>=XG6QB9OBKaU\rfiÅtoÖy]sfNeQÑöÖNdM4G10A..?-3D40A1+<,5H5;O4[oT2?+(& , %3$0A/<O;AT>4F0=N<í¢òÑíì{áì°™π~ÅêggqOMR354)(6FC`porÇÅ_kk-76&!#( '#!%"'++*!,$+$+$+$!!$).'#(!$%& *,'!& -5(2=/&'+.!%6&&8(4F8>SD?WG<YG:ZEDaMLeR9P@'9+"7('>,/F43I<*>33'#5)(=.0"'!"7A6embT[T(,+$!,!);+2D4$7$!4!,B-3I45L84I80E6+?31B8)6-%&!1$%7)%<*4M:8O?%5*%/').(#(! (",#",#' ! $2%"4&   
+%FaRCgM=iH?mI=iE>i>3U0
+	
+
+
+		
+
+!#!$#"'#  .!);+)@,*C-%A*">'#?)%@-(@3(:<=NVáò¢lÖ_rnMbSNaKrÑj?Q7*9$.9)2=/5B0IXCIXC5G1&7% 1,( 0#&7%bo]>K7(4&#1"(6' 			$$"+-($#'&7<8
+		
+5?7*4,	
+				:E7$1  +,&)(#!"!#)%KWML\OK]OO_TP`UN_UQbXO_RERH1<6 !&"+2+!,$$"'+"0.@&I]B%8". 2"3E5$6(#3&( .$2#(4&*7&%0 $"(6<.&,68-HJ=<<0**#% #"  %$/(5#9F4&3!)6$*7&)5'(4&'5&,:)-:)-:(+6&)4#0=+4C0&3"'4#)6%.;*/;'4@,/8'FM='+46).."6.!M7)[8"}K0ë]6§vEªó[¿©eæ∞eº∞^º≤Yº∂X∫¥R∫≥K∑≥Gπ∑HπºI∑øF∑¿Cµ∫<≥¥5±∞1∑¥3π∂5∑≤2µ≠0∂¨0∫∞4º∂:æΩ?ºΩEºªOΩπX∫≤_∫Æbπ´`∑®W∫´Pª¨Gπ®>≥°1±†*≥•+≥®,Æ§(¨§'∞™.∞±2≠Ø0™¨/®≠/™Ø1™Ø1©´0®®0©®4®¶5•°5®®:¶´7¢©5°®4£¶3§¢5°í-úx"§t(¶w/ûx-®î>ß†E§°D¶•I®¶O¨•T´ùT≠ôZßì^§îa±®o≥≠o≥´l¥¶i∂ùdÆäZ£pQ®p_∂ÖÄøõù¬±∑∑¥ª´≤ºß±Ω£±æ§≤Ω•¥ªèõõrxnOQDDG@ENMzäó®øœº÷Âõ≤¿DQa'1;(353?;)9.%6&%6#*;(+:%%4!!/$5#&9%$7#."-9=.HO?SeUPkZHdU>YH/H5":$(>')?(,>((;%?U>JdILiMMgJmÖktÜn_kSKW?GV?4H/NgJQlMIdCLgDFdB/L-1K04J3(;(%7'1G:=UGOj[Rn_?[LIjYQvdV}jW|jX}k]~kRo[4M: 5$)%'$!6%=VC9P<,'&- +)B,4P7'?'0!'4G3/B.)7&"0"3#4#(D.GeM.G2.'&+/A10G31J4\t^H[G?K=_i^ÜêávÄwPZQ=G>S]R@NA?P@F[HVlWOfR2G8H^R}íâ}íâRg^XoeYqdF^NjÉniÅk/E0%;&*@+&9&):*+<,*<.8K8K^HHZB*5$ +"%* .%4!5D/5D/5C2°≤®õ´´Éëúî†∞¨≤¬dfsIFQ,+0 )&"/("1**70#,'$%&' "%%)%3$%3&"0#,")"/%",#%'!)%?@;%&!!,4)",!%+!"2%*?.;T?FbLC`L9VBB_KC^K>YF1H6$4')&#9Q;8Q;#:(,*%6&.@0-$%/$T_QoypMSS!*)%,""0# 1,?+9O86L51G03K55L85L<4H<(8.) %- %:+%<,3L94K;&3)'.'(*%$&!"+2*/6.'.&!""$'5(#3&   
+
+3I=CcN>gI>jI=gC=c<7
+		
+
+
+	&#! ! "#"$
+
+	$$6(+@/,C/)B-)B/+C3/F>3FLCUactÑmãnÄÄWk`FYEK_D=P49I/>K7OZIJWC>M8(7"/,))+!#1$(6';H67D0%2!*!2 '8(%
+
+		
+')&-2,			
+
+  	
+&,(8C;
+	DO?)!#'(#! ! 
+		
+
+	
+
+
+	
+"+;0=OC>PDEVLARH?PFASEAQF?OE=JCALH]hdWaYU`X:G>*:0/>7)81%5+&3)&2($2#9K3:N52#6#$6&'7*+!2?53?3(#!-!(4&'3%,8*#. (&, GI>OOCRPCBC502%%)"!"!!'@M;;H6*7&)7(3A4-=05E83E5"0!)+&4#7E4/>+"0!/,+'4"$02;*FJ;/0"6.#>-#J. pG3è\=™oGπM√ìU…©`…∫i∆¬i¡¬eΩ¡`Ω¿Yæ¿Uº∏J∂≥B∏µB∫πCæ¬Gº¬DªΩ>≥¥4∂≥2∫∑4ΩΩ9ΩΩ9æª:Ωµ6ª±5Ω≥8¿ºA√¡J¬¿Q¬æZΩ∂^æ≥cø≤dª¨YΩ∞Tø±Nª™@¥¢2±†,∑ß.∏≠1≥©-∞´-¥≥4≥µ6∞µ5Æ∞1©Æ0´±5™∞4¶™1®©2≠¨8®¶5•£6®´:®Ø;¶Ø8•≠6¶©6•°3¢é+õs¶r'§t*§1≠óA©†C§üCß£H©•N™¢Q´óN∞ôV∞ú]∞•e¥±l≤¥k∞∞h∞¨eµ´f¥ú`µâ\∂`Øve≤Äyºöò¿≠Ø∏≥∑©Æ≤ü™Æñ®™ê¢¢qÑ~]n^AN:LTE5@8GV]sÜîî¨∂ç°™N[d&,(%2>4.</$5#"3!'8%-<''6! .%6$%8$&9%!2  --1"6:,AM?QfWOj[LhY>YH%>+'<)-@,,=*/@-4G3CYBMeKRlOWpSTkOP`EEU;8K50H0RlOIfGHeF=[9.L*+H)5O6+D/*A19OBC_QNm^RreUwgUwfUwfYj[ÅlWzfGgR2O9/H3$7$!-&"##'' +=TBD[I#8))# 0# 5"0L53O6":"(*)<(7M8(>)&,%3$!3#&B,IfP+B.!(+@-(B):W;H`H"5!$2!AO>fteëùèÇåÅlvkS_SL\OXjZata=RAG[Pj~ujÅwyêÜBWNNdXQi[látlÖoC]D1I3C[EVkXcue/=0%3&);-.@2,=+'6#$/!&"%+%1#)6%)6$&3!=K:[kavÜÖì§¨gtÑ_hyëóßkjx::D)//&1+&2()$$%%%!%'"0!)7('8(&6)"0#+$.#%/$"*$,!%!672 ! "*&,"1A4J_NWp]JfPA^HMjTB]J4M:%<*+(%0F1<V=:R<)@,.+=-2G6,  #AM?r~ru~{9BA)2/#.(* (0,?)3F04J31I31H42I9:NB+;1!,$")#8)$;).G4/F6$1'$.&-2,*,'-2+07/!&"' "#'$2%#3&   
+-%B]N@cK>eF<a?7Y8 		
+
+	   ' $###  !!  $&'
+	 "2%&8*,>0,=31D@I\bRes4D[ETiuÜêl|{H]J8L0:M/DW9GW:>N3ET=,;&))&#4<-8C2+8&+9(4E3$5#'
+
+02-).'	
+#$8C;#.&GRA%#)!#
+!" 							
+
+
+
+			
+	7>6PXKV^QLTGFQCFRDBPCERHBRH>OGBSIAUJBVJ2F:0F95K>1G:1H80E6.@2/@0.?-6G41':'%6&!/"%/'9C:)$0"$0"$0"*$,!/0(B?6JK=NOAFG7:<.)-!$$,-8'.9)),8.0=67F?GWM>PD&3)#1$!/"-;,;L:&7% /"1-&5")8#%2+6%68*:0&E*m?0êWC™rOæäZ…õ` £^∆¶Y»≤] ¡f«…hƒ hø«`æƒXΩ¡PøæJºπD∫µ@Ω∏BæºA¿ø@ΩΩ;º∑7∫±0ø∂5ƒ¡>≈«B√∆C¿ø@¡∑<¿¥:√ΩC ≈O»≈T∆¡[ƒ∫a√∑e√≥e√¥a√∏\√∑U¿ØGπ§7∏§3º´5ø≥9π±4∂≤4∏π9∑∫9≤¥5±≤3±±7∞±9¨∞8´¨7´¨7´´9™™8¶¶8¨Ø>´≥<ß±7ßØ8™™8©°4ßè-°r"¶p&•u)≠à7≤ùB™ù?•úA©¢HÆßOÆüNØïK≥ñP≤ûY∏¨d∑µh≥∏h≤µh∞±e∑±g∫≠gº§fΩôg∂Ñ_∞xa≥zo∫çà∑üõöíè~Ö}l~rbxlOjYLjPRoQThM/>+%0,<GKTch\kn@LL +')!/9.3?1$2! .&5"+='+='#5);%%6#$5"$2!#0"*(. 5;-=J9I^MOjYLhY@[L+A4,</4@28C5T_OtÅoTcLJ^CIdEIdEH_B@T9*@)F^HLfMPjOPhN4L2.K/7U;=]FAbOHjYRtdMraRyfRwfSxfSydIoX?aI4Q;$=(3 .):'*9& %!)'/ !*DVF3E5#8) 6*<TF_xe)E.2N57Q8(?%$8*A';Q:/E.1.'5(%3&-:$KiQ/D1//G14Q5@]A7+$:#8P8OeNNdOzãy{å|hxk`rdWi]IZPÉòëlÉ{mÖxû∂©í®úlÇuÖùçtçxGcJ<Y=D`G?XC2D6$1(*")!,901>4 ,"%1%'1($.%!+"'#$!* .FTE$1'FURö©∞ó•≤âî¶êò´ñùØgm{/6<#,))!$#$ ,'%!!"'*(6%*8')7()5' , &) !( #*"")!#*" %0".E3SjXXq\Xv^PnVLhRAXD-?1.!)&%&'!%( 1)?*2L36R90L51J52I9,<1 *"##-9+bnbiskT]Z-33!'%%$'* 1&9&-D0,C/,C3+=1+6. *""$1!%<(+D/*A//$ +#)3+291+0) &!"!""'"0#%5**@4DaM@cE9\;%?$	
+
+	"(!%&'!"$(((%%''$	'(fwÅ*;M>NhÄê™åú´ÇñïaveH_CBW8GZ:K^>:M18J2)#+$6<.LUD*7#):('8&!7:3"'  
+	!	#-%8C;CK<$,!	
+	%'" 	
+									
+HJ?dfYrtfeiZ[aSW_RKUJAOBAQF<LA:L>:L>8J>5I=4H<1G:-D4'>.$6(' 2@10!2 !2"'		 ( ($,%/$&.#%&*'11%BC5BC358',0!"( ')4$%0"%$/'<HD5D?7HB<ME;JC;KA5E::K;2D40+ / .+<)#4! /(0!>:.Q;0g@1°gQ≈Üe–òg’ßi’µl“πe∆≤Y¡≤S≈ø]… d∆Õe¡ ]¿…VøƒN¬√K¬¬H¬ΩE¬æC¬æ@¿Ω<ø∫:¿∑6ΩÆ1ºÆ1«¬@…ÀF≈ I√»G≈øC≈ΩA∆¿FÕ»RŒÀZŒ…a ¡f»ºh»ºj«ªg«æc∆ºZ¡≤Kª©=Ω´;√¥?¿∂=π≥7∏∑9ºΩ=ªæ=∑π:∑∑;≤≤:≤≥>±±?∞∞@∞∞@≤≤B∞∞@¨Ø>Ø¥@≠µ>´µ;¨±9≠¨8≠°5´ç-®s'™p'¶w)µë;¥üB¶ô9ßú@Æ•J≥®O∞ûJ±îH≤îK∂†Tª∞`∫πf∂ºfµπeµ∂fπ∑jªµiΩ≥l¬™l¡óeºÑ_∏t]≥te≠rõqíáu\^ILXBK_FHcD>[<2K- 2('0++62-95+81)5+%/$)4&4A0!/,$2!+<)-@*/C*,@'$6 $5"$2!&3"!,$,07'1<+3D2D[IRj\OgZK\R6C:V]Uu{o}ÉubkZDP<7I/>X;>[<B[=8O55M7JbLKcMXpXE[D<T<MgNMkSHkUHnYLs`Kr_Mt_Jp[@aN-N;+N60R9.O4-G.1/) /.;)$#
+6>/S`L 2=RC"9)3K=MgZ]xi@\F:!=W>4N3(?%/F,4K16N4,?+.!1$,'-#A)OmS.F0),3M40O08Y:/L01K04N36P37Q6:R:EXDnoÇîÜàöéVg]Wh`vãÑáûîkÖxç•óé§óï´ûsäxQjUA]F<Z@+K3"?+%9.%60!2,/),@54E;!1'&6+/$ -#'%'(%)#/!,:+(5+7F?âòõ•∂æö™∑õ®∏ó£≥íú®LU\%$&'!%('%# !$ #'". ".  , ,&& *!%&!(!&& ");-I`NXq\Xq\NjSFbK1J4#8%, "#!$",!#/!+$<$3M46T<8U?5N;%7+'$&,VdU\h^tzv8<=!%&##%!#)*?.0G55G9+8.,6.$#%-(>)+B.'>,!3'* $1'(4*&"  , &4'"2'	 1F7B`D:Y:(
+'!* &)&!"!"#$())&(+!%
+
+
+   9?U(3QwÜßbsèû¥¬såâ<TD2J09P3EZ;=Q60+-//&"+1#MVC,:#"+<)%3$##%$)"692				
+			
+
+$' 6=6
+
+"-3)		')$
+	
+				
+
+
+		DE=lj]sqdtugtvicgYeh]OUG?E7?B77=1%,$)!'!+$ /(,%"/(%1%*$2!)5'-9-!+ 	
+  !$(+ "$  ))9;.48)'/ '''$!&FRF3?3+!9F?6E@HYSGZT?PJ7H@$8,>SB-?/.+ .!/ #1""0!+36-D7/ySH¶s^«ípÿ™yÿ¥v’ªp’√o’»lÀæ^√∑S≈ºWÕ…^»Ã]ƒÕX√ÀR√«N√≈H≈≈I∆«Hƒ≈E≈≈C√¿?√∫;¡≥6¬Æ5¿¨3≈∫<Õ GÕ“Q…”PÃŒOÀÀOÀ∆NÃ«Q“œ^—ŒeŒ»jÃ¬k…øj ¿i»¡f«ø]≈∏R¿≤E¡¥B∆ªE¬π@º∏=º∫?æø@æø@Ωæ?ªªA∏πB∂πF≥µG≥≤F≥≤F¥≥G±≥E∞¥C∞∏AÆ∏>¨∂;Øµ;≤Ø<Æõ4≠Ö-´o&Æn'®w(∫ñ>∂¢C´ü=™†?≤®Iµ¶K≥ùH¥îG≥ìH∑¢Oæ¥]ººb∑æa∏ºe∑ªg∫ªkΩªn¿πq√±o¬üg≈íc¿YªtV¥qV•kSçcJgL1^M3SN1@I,=P2:Q5+A*)"**2'(0%"."!-*&2$5C2"1*&3"$3 (;%0D+5L2-A($7!%4!,),)6$'4"+6%5B1IUIVbX_ia~Ö~åëäz}r[bREN;&1 '9#0H0<V;9Q73J0<T>F^HSiTNdOAWBNfPEaJ<\D9[C:`IAgRCfP?_G0I38K83F3*C-4P70L3/I0 6!0!0&"1)6%!#"/@W;"<8#/J9B^PUteTpa<WD 7# 6?W=3K1%;$CYD>T=2J26I59L9=OAASEASC=T@.N6RsX7Q6-D*(6%#. $= 5T43V54W66U50M/0J//G-+D'8O5$5#0>1N^Sctj~èÖpÑyhÄsÜ†ìrä|óâ~îààúëFZNI`PKcSJgUStcXzj]{s`}x^|t^~sXxiXwgSo`MhWFaP;SC1H6'<+ .!'&)($0$#/#$4)atpÉóòñ©Øí•¨ë¢™Éíô1?B ,*"-%&'$'%))('&!%! ! $($!)&+$"!%3$:Q=?[EC_IC\G>S@&8(0 %!!  %0;-(#((;'3L67S<:V@5L:#3&!-!%'[lZ^j^ryrghj,-/"&'"!$%1F70E6<J=)3*-2,"#'+%;&,D.(=*.!'7,"2'%5(&4')!"'%3&'3'- (<T>8P8
+		)"+!))%%&%% !%+ -"+ '+!(
+/muöjxùh{ô£ª«Jbb*-%<"8L3&7$+!2"'7*-;.->..?/'7* -#!"-LYE5C,,#2&4%	
+ 
+%$"%					
+		
+	*+%
+	
+
+
+			
+!"'("				
+$&!			
+
+
+	
+	PMDigZqobsqdmmaeeYUVHZXKYWJOLC671!&"  !+,#.0(35'13#" $.#". )"-*5')5)'3'#*"  $&(,)+ ! #!$+1%*2##.!.*& !(3?3`l`2@35E:J[QI]TI^WDWQ6JA/F69N=#4$ 0#,!/""0#*6*5B8&-%61-O82òm]Ãö‹≥Öﬁ¿Ç€«~”ƒq—√j÷ h“…b ¬W»ΩS ƒV ÀV»ÃT«ÀP∆ÀM≈«H« I« G… H««C ≈C≈º=æÆ4ƒÆ7≈Ø8«∑=Ã«Gœ“QÀ‘S—◊Y–‘YœÕTÃ…T—œ^‘”i—ÕlŒ«l»¡i»¡i…ƒh»¬b«æY«ºP«ΩJ∆ΩF∆¿F≈¡F√¡F√√G√øDøΩBΩΩCΩæG∏ªJ≥µG±∞F≤±G≤±G≥µH≥∫FØ∏AØ∑=≠µ;±∑=≥≠;±ò4ÆÄ+¨g"¨g$¨y(ΩõA∏¶DÆ•@∞¶D∂©I¥£G∂ûH¥ìD≥îD∫©Qøπ[∫æ]π¿`∫øcπΩf∫æiºªk¡πpæ≠hæõa√ïaƒå[≈ÖY¡|S≥oLô^<ÉR1|T1rS4XE'LE)HQ4@P5.=("/(1 '/ #.%2!*6()6%5D1&5"+))"3 *=',C)1H.*@)#4!(!. /$3 &3!&/04&69.NQHÅÉ~û£ùw|u\dYAN<.=('6#):'4L6KcK8N7/E.<R=I_JTgTM`MJ_LAXD4P9,J2,L42T;>bH8ZA5R6(?%7F3AP=2H15O61K01K0&<'.,#"/ *+3M01S2:X@FeSOn^Po_8SB31%8"<S94K11D.;N:;Q:/E.&<' 3 &$*-;$Xv\,F+%8"$3 "/+=O7=V92Q1/Q0.P/.K-&>$1&06M3$7# 3 -?18L@QeYZnbYqcgo[rbmÅugxnN`THZLJ\LN`PI]QKeZSqiYvtYvtUrnTtiPpaPq^Sr`Ur`Sp\To\Yr_SjX/=0()"-'&)- *;3Xkgyããi{}?QS/.+( -&)"&$&&* ,)('$$! #$""((+$%(!!",!>O=8O;,E0"9'/,$$"*(3#%$"+ 8"-I05Q:9R=8M:1D1 ,  1QbPr~pY`X{Ä|MON()+#$ ")!%2(6G=+;0.8/-3)-0)!$!&.%;&,D.3J6(:.$4)'9-$4'+9,-9-%/&&$)  , '5(!/""0# 	*#1"
+	
+,%)")* &* +&#$$&(,!0%-"**!
+/ajëÅè≤}ë™ê§Ø"$/%6&)$"0#'%!-!)9,*<.+=/*<.*<.(9)+<*<N85G1,;&,%1%
+"'# 	
+					
+	
+
+		
+#$%&!
+"#$% 			
+
+!#
+
+
+
+
+			NKBfdWki\ywkecWecVfcT_YKXQGOLE664!&,;CNjsÇãôåïMX\)%#/%1=/!"0:/)5'&4''4*$1'+!$"#+.#)/!(. (0!$/!"- ,+"-#. (" '"."%2!2@//A1J^RG_RE]P:NC3'AXF+@-/"$1'#.&#0'-:3=JCLYP14-?+*iHAØÜp€µêﬁ…í›–äŸ—Ä–≈l»∏Y“¿\‘…]—ÀYÀƒR«¿LÀ∆P…«NÃÃPÃŒOÀ—M…œI…ÕE…ÀD……EÕ»HÃ¬Fƒ¥:≈Ø8Ã∂?ŒªCÀ¡FŒÕO”ÿZ’€_’Ÿ`‘’^–—\–”b‘÷k’”nÕ iÀƒi √iÃ«l ≈g…¡^«øT…¬N»√K«∆H…»J««Kƒ¬I√ΩE¡ªCøøGø¿IπºI¥∂H±∞F≤±G±≥H¥∏I¥ºE±π@≤∑?≥∑?∂∑@∂¨=∫ô:∞y)´]™_≤Ç0ø¢Dπ™C±™@µ≠H∏ÆL∏®I∂ûF≥ê?∂óDΩ∞RæºXº¡[∫¬_ª¡aª¿dªæeº∫g¡≥hª§`∫ñZ¬ôa«ùcÃüfÃôd√ã\∑yP±sJ≥xN®lGçP1rC']J,PS4@P30G+/<((3"%0,7&,9(+9(4E2(9& -"#.%8"%;$)A'1I1,B-*#2'6#%4!$/*0"79.XULzwpÉÇ}ÅÑ}`lbOaS?WA*B*)?(/E0MeOE]G=S>;N:FYFL]KN_ORdTVkXAZE@\F6T<)E,+I--N1/P1.M-0J-.D-$:#4N5:V=1K04L2-D*-,$&&#&';/.L48[=FjPHjRC`L0I6+*%3"#5CW>4K/=Q8@T;6I3 62H1(>'1!'_ta"5")4A-M_G,>(4%B&3P43I2!
+!#;#.K/0N2/I0,D.3E59K;H_MTk[gyk}çÄboebn`ÑëvjrwclpaDQJK[[ü∞∏GXb/>C)<8&<0-E5+B2+@/)@0*A/.C2.@0"0#% +*"(&%'+!&3*)6/!-)*#* *8+0<.(	&%"%(**'%'$%",!$.#"   "%%& (+&!&" !'$#$##/'A(+G.2N52N53M4.F05 &<'-@,ive@K=ai\{Äy==?*+/"((%.+*70-:17D=*"$),#,/&$* #2$<$,E/:S@/C8.')"#0&!-!(4&-9-#-"$("."$2%&4'*!1$
+ +')"+!)*-")#$'*+ * )-"2'.!, '
+
+	3â¨Ñï±áôØåü¶&*6,(!+7- &,!0%!5)'<-(:**=*->+2C0$2#!-!	
+!!
+
+	
+	+,'&'"!"		
+			,.)
+		
+	XXLefXmn`nl]geVdaPb\N`ZN\WQMMM]alô†≤{ÜöÇè¢Ñë°=LS)55 -&5A5$%3=2*8)$5%'9+&8*#5'"2%' ! #"(%-,7)*6(&2$!-".""-,4%39+-1#"'%(*-;*3F3<Q@DZM4J=$6*'9)CZF4!+;0:G>-:38D@ETQBNLU^YE>8W53îe[»üÉ·¬ñ€œìÿ‘ä÷—}œ∆i ∏VŒªR—∆S‘ÕX—ÀS ƒL»øH«æE»¬HŒÕOŒ—NÃ“LÕ—H» BÀ»EÕ»H—…JœƒHŒªC—ºE“¡KŒƒK–ÃQ◊Ÿ^Ÿ›dÿ‹c€‹gÿÿf÷ÿj÷Ÿn’÷pŒÀjŒ«lŒ«mÕ«oÕ»m ƒd…¬ZÀ≈UÀ∆PÀ…NÃ OÃ Q…ƒL»øH√ΩE¬¬Jø√KΩ¿M∏∏J∂≥J∑¥K∂∏K∂∫I¥ºC≥ªA≥∑?∂∑@π∂Cπ®>Ωñ;≥u(±`≠bªç7¬™H∂©@≤™?π≤Hº≥Læ´L∂ùA±é:ª†Gø∂QΩøTª¡Wº√\º¬^Ω¡bªæc¿∫f¡Æb∂ôU∫òY∆§eÀ≠mœ±q”±r–®mŒüi“ùk‘öhƒÜU≥kCöZ6ÇZ6~nLOV4?R2:I2*9$'2!)4#)6%(6%0A.*9&#0*,"1!2':$$<$)A)2H32E2->+0?,,7&%,?A4ecW|vjvoetqhLRH<L?G^LB^G7S:)C*5M5F_I;S=6I6@Q?HYGEVFFWG]o_CZFF_J:V@-F0(B',F).M.&E%/N.5R34N33P42P43T72O13M04K11 /#0,". %
+&20ATP\tg/O83U:>bF/O7 9$$'#0!.#@T;1H,BY=<P5%9 +-E+6N4/B.$2#!+ !*:- 0# &&
+'?'8R96L7 )-C,6S72S4/N/,F+%;&$7$#5%BWFG\MdtiÑêÜak``h[nucX\EqkU|vhX\[Éåï∆—„Ydv'3?+,0',A2 0#.!/!+)*&$"-!) &#&'%/$&0%4>5<F=3=2*7&:G5AN<6>1%" %&+,,%1#(4&&# #!$%&! ! #"!#3I2.H/"<#)F*0M1/K20J1/G/#6"(*>I8s{nmnp349,154>?".,3B=2=7! #%(#)""5!%=%0I3:S@:NC$3,'!"# +*!+ % &"."&2&+%!1$	*&+#+!-#3'/#)(%*-"/$-#+!-"0%2&.")	
+%~âüì§∏¶π«\nr 
+,6-!-!!*%0<2#,% 0-+;:(85):2)9.'7*'8(+9*:F<6B8$0$' $ ,"
+	
+			
+
+
+
+
+
+
+
+	01,*)%  
+
+
+
+
+
+	
+
+
+'(#$% 			
+
+	
+
+
+		#&RVGadQjlWlkWur_jdTebSgd]UVXTZj}àûÇç£ï°∑ù™ΩÅèú9HO+99/<3)'". 4A0&4#"4$$9*%:+(:,#4$!/ $!,(5$)6%*6*&2&#/#",!&, ,/$;<.FG9?@2&*'/ !-) , ,*8'2C1+<,,=-&7',8I77M8"7$ASGIZR6GAEXTI\ZHTRONLbMHáUNæÉs⁄≠é·≈ñ€–í◊”â÷“yŒ…eÕøVœΩMŒΩI—≈M”ÕQŒ»L»πB¬Ø9ƒ≥=œ√K—ÕOÃœJœ—IÀŒCÃ CÃ…D‘—P÷—S”…N—¬K÷«R‘ÀT÷‘[Ÿ›b⁄‡f€ﬂfŸ⁄e⁄⁄hŸ€nŸ⁄r÷÷r—Œoœ»n—«pœ»p— pœ»mŒ∆d–…_ÃƒUÕ∆T— VŒ«RÃ≈PÀƒO ≈Oƒ»M¡«Mæ¡NΩΩOπ¥Lπ¥L∫πM∂∫I∏ΩEµªA∂∑?∏µ@º≤Aª¢;∫ã3µq&¥e"≥m%¡ö?ƒÆHµß>µ™>ª≥F¡∂L¿¨I≤ò9±í7¿¶E¬∫Oæ¡PΩ√Uø≈Yæ√\ø¡^Ωº_¬∏cΩ¶Z¥ñPø¢^»±kÕªsÃæu—æz—æz—º{“πy“∞qÃ¢fƒèY∏~L¶mBéd<_O+OS2@P30D+0?,/<+,9(&4#1>,(5#".+#0&5"#4!&9%&<'&<'(=*.C09L89H5<C1JK;qmayseul[pkXLO>'4#0B2@YF3O87S</H26O94L64J5/@-6D38K88M<QfUOfR7P:7P:.E1 6! 6'?%1N2*G),I+*G)1P13T53V61V50R10O/2L/$8%4) -!-&3),$,A<Slhb}x]{o8XC3T98V:1#&&*5%%$DWC0H.8Q46M1 7%>![vW/I,9O:*;+&$#5%+>+`o\8E3$*@+>X?6P79/L0@_@=_<7Y63R2'A&1#4"'8("2%8J>9K?EUKdogdkcRXLUVF`^I~r\ÄvjhimµºŒ∂¿€cnäFVf8KQ'<5.B6"2'(&$%&&%$$"$&&&)*,8,;H7/<*3@.5@0)1& '*#%""%&,$2%*8+(4(%!#&$!& #"! $' (""#!#"$!##7F3+<)-2(@*1K2/L0/I./E.#4!%#0R]OÄÜÇ^be@DM29A$23=LI(3/%!#% *-$*-"%&&9%$<&(?+:Q?AUI'7-$/)&$#)"(##"($0$$.# $2%!-)-%.$0&2', ((%&%,!/%-#/$/$3'2&,!	
+
+
+
+
+#+8-;FqÄá))	(3+$.%-80'4*!.$)6-(40+99.;CQ_hL[b"22/>9>ND0@5!.$jumQ\T'-;.2?5.;1'5('
+	
+	
+			$% ()$&'"	
+	
+
+	
+
+		
+
+/0+			
+				
+	8?7-8*1<+LU@T\GdiUfiVdeSnpb^aZàçë$->_jÄ±Ω”wÉô|àûåô™^lwAPU-95#.&'3)+7-4@2,/2!"4&%7)$6&#5%&6)-;.'5$&4#&2&#/#&..$@>1FD7CD6+/ !*(!.!-,"0!!2"0,:+)7(-8I7-@-)>+2D6J[Q0D;EXRL[XKPLXMGÅcY≤}k’úÅ·∑ëﬂ√ì‹Ãé◊–Ç”Œr— bŒ¡QÃ∏E µ>À∏?—…J“ KÀªA¬≠6«∞<“øGœ LÃÃHÕŒFœ–F—œHœ–H“‘O÷◊U’—S‘ÃP—ƒQ’ V⁄ÿa‹‡g‹‚hŸﬁfÿŸbŸŸg◊ŸnÿŸsŸŸw‘—t— p”…r”…r”Ãt“ÀqÕ«i–«bÕ¬YœƒZ–ƒVœ√S—∆S—»SÕ»R«ÀRƒ…Q¿√P¡øRª≤K∏ØHº∫M∫ΩJ∏ºD∂∫Aπ∫Bª∂@∏´;∫ö5ºÑ/∑r%∏k#º}.…ßF¡∞F∑´=∏Æ=º∂D√πH¬¨F±ï2≥ó4≈ØIƒæN¿√N¿ƒS¡≈Wø¬YææZø∫^¿±\πúPªõRƒ™`»∂jÕ¬sÀƒvÀ√z–»—ÀÅ“»Ä—¿xŒ∂p—ÆjÃû`ΩÅMò_4tN)]M,OX9<P57J49J7DUBAR?CP>GRABN:9E1(5#%4!+:'):')<(*=)(9',=+9H5JUD^aPtqbtn^qjXyr_ZYD<E00A.,C/+D/&B+)E..J32K52H3+>*3B/2A./B/:Q=SlV5N80J19S:(@*7!'=&.F,/I.,F+'A&#=" =!"@$*K,4W77Z96X75R3+B&#4!%3"(6''7*/C8E_VQogVuo]|tRrc-M6/M3<Y;2!6>/!"/H[G1I/>U9/F)!8,E(?\=!>8P:?P@% )%5(BYGVnXL^H ""%":$@]AA_CEdE?a@;]<3U2'F$$>!.%*&6+*:0)9/<KD7D=LWOY`XSVKGE6jeR~savmîîû´≥ äì≤]jäK]uGZhE[Y?TK*<0) !&''%# "$$))#')6%;H6;H67D2(3%#+ '*!14+ #!'$%&,- &4'$0$"&'.&(-'+0*%*#!$&"*!#''$"#!"!$#&#%),7*D)0H.1I/4G3;L9,=*?M<~äÄêöôfkq?FN.<=DRR$.-"(&!%&%(%- $2!(;(5 /7N:AXH/C7,90%/')0)!&',%&!"*%1%( ,8,(/! -&.& 1) 1'0&* )* , *))+  4)5)1%1%3'- 				
+
+
+				 %&&7E8%6&$5%'5(&3, +-!+7IThHTlYfwPakBRRXgbL[TCPIyÖÅR]W)!*".:0.>1+=/$4'- 
+
+
+		24//1,
+
+
+
+			
+
+
+		
+
+
+
+
+
+
+	 !			
+
+
+$,!,8*->+#4!'6#0?,8E3?L8AN<GSECLIñü¶zÉíÜë£ö•π`kNYoÄç†sÄêlzÉ2=A6B@1=90=61>5-:0(8+'9+(8+3E7*<,%:)'<-%7)!3%-*%# ** 8:-8:,-1"(/(!,$1 )%3$#4$,1?..<+'5(*:-);-,>0- (:,4H<FVLRWPVOEu_Q©âr»°Ä◊∞á›Ωé›¬ãÿ√Ç’ƒv”…j’ `œΩM«∞<»Æ7»∞4Œ¡A’ J—¬E√±5 ¥<”¿G“…JŒÀHŒÀFŒœG“‘L“÷M”ŸS’€W◊⁄W‘–S—ƒQ÷…Y›÷d›‹hﬁ„k€‡hÿ›eŸ‹iÿ⁄o⁄⁄x€‹~’‘x”Õu‘ u‘ s’Œv’Œv— p—«fÃ¿\œ¿[“¡YœæT”√T”»UÕ»SÀÃU« U∆ƒU√∫Q∑•Cº™F¿πNæΩI∑ªB∏ºAΩøDΩ∂A∫®8ºô5øÇ/ªs'∏s%√ç5»≠Fæ≤B∫∞=ºµ@ø∫D√∫E¬´AÆí.π¢:≈¥Hƒ¡L¡ƒO¬≈T¡√V¡√X¡ΩYƒ∑[ΩßR¥ìD√üS»Æa…∏jŒ√s»√qÀ≈wŒÀ~–œ“œÄ—»yœ¬t‘ƒv—∑m»òZØuCó[6qF&RM/GW:;T7,I-3K3<R;BS@IVDLWFEP?9D33>-4C0.=*,:).;*1<,7?0MTDjm\qo`hbRhaOto\XZE?I16E0,B+&>(+G0'E-/M51O72K52E13B/9D39F43F0;S;;U<5O62O39U<1M6-I2.H-,D*(@&*B(&=##: &9#/1$B&0S39\;IhF,F)$#3&(:..C:Jh^TulImcUvkKl[1Q<)G-'F':Y90I,
+	'-.4&&O\KM_I4K/BV:#:4)A)7T5!>5 @RB5G9/ 9P@LeRGcM9R=*"&+0J/SrRCeD:Y:1K0(@&0)2+(+!$3,1@;+:5AMI7C?aldÖèÑv|nop^{xg~xl|xw®Æºèô≤tùSbÅeyîJ_t5LRCZTF^P(?-%&&)$!$(&(" #2=-:I48G09G09F2,4% %#"!$(,!/"+ , &"$!%!+"")"'.'#*#+.'%& $$# (((&##!"&/&9#%;$.D-6L5E]CBZ@:P9yé}ü∞¶äìíÖçêYdfLZ[5A?+41%!$"-*8''8&-+4I6>VF5M?5I=:KA1@9,%)2--4-$*"$0&" "/:,8@+-5 *. #+$/'!2*#4,0&+!0(!2(1%)* /%/$2&5)4(2&3'1#	
+					#("'5(/ 1!@S@!4!,++'&0:^f{JUsAOlTb|sÉìm|Å_onrÅ~R^\yÖÖ]ii>IE)%5(+=//A1'5(%
+
+
+					"#(*%350
+
+
+
+
+
+
+
+			
+								
+	"*$1 !4 3/11 1&7%&6+2<=gpyô£Øçôßåò®≤ΩœèöÆ~ä†fvÜGWf,:E8GNP_b--*&*5-+7-)+1=13A2$5%*<.&8*#5'%3$)$$!##!$&,07'AE4=A0)0("/)&4%+'#1"3A25E8DTGEWK;M?(9)**:-5=0`ZNp_Oûân»∞åŸ¡ì‹≈ë⁄ƒãŸ¡É◊øy“Ωl”√d–¬W—ΩLÀ≤<«©1»™0Ãπ9÷«F’»F»π8»¥7”¡E“«Iœ«HÕ»FÃ…D“‘M’ŸP‘⁄R◊›W÷‹X÷◊XÿœZŸÕ]Ÿ—bﬁ€j›‡k‹·i‹·i‹·m€›r‹‹z›ﬁÄÿ◊{ÿ“zÿ—y’Àt÷Ãuÿ–{‘Õu‘…o—¬c“¬b÷¬aœπT”æU–¬UŒ«UÃÀWÕÀZÃƒY¡≤K∑ü?¡´H¬∑KæΩGªøDΩ¡F¬ƒI¡ºDƒ∞@ƒú:¬Å/ªs'∂x%…ù> ¥Gæµ@ª¥?ø∫B¬æCƒπCª£7Øí*ø™=…æK≈≈M¡≈M¬≈R√≈W¬¡U¬ΩWƒ±Uª†IªñF…§V∆´\Ã∫hÃ¬m»√oÃÀxÀÕzÀœ{–“~ÕÃyœÕx”—|‘«xœ¨h∆íY≥nEãN/_D)ML0H[=:W8/L.3K14E26C1;F5BI9FJ;CJ:AI:<D54<-9A2JN@^`Rkl^igX]WIc\LlgTTS?9B-,;&*=''?)'@*6R;4R:6T<5Q:6N87H5;H6AN<7F31I/3M24N38R71K0.J1,H/(D+"<!!9 8.E+)@&)=$,>(%6#!7"#=$,M0,O/=_>+H,2!,@49NEOjaNofJndNpb8ZI(H11O5&@'92Q17R3#0")>B3.2#GP?[hVEW?=Q8-?')$'=(7T6/L.-2I7?ZKKgXTq]HeO,E03 ) !!.LdJ2O14S4*G+))&!,,$$+<4k|vo~ySb]L[VkxqÑêÑ}Öv~Öunqféêçõû•°®ªèô¥3>Z&4Qwà§xä†"4>*><:RBShU4B3%#&&$$%(+"! +*9&5G/?O5=K43>- (!#! #'"0#$0$$0$'!+"%,$$ &)  *" *"")"25.$%'&"(%"   !%(%6#):'/03&>&.F,3K3kÇn†µ¶~âÉíõöãïóÉéêqÄ}cokZd\-2+$)6%+:'%2!&"'<)=VC2M</"1E9H\QFWM7G=1>7%2+)%+')#  $0"AI29A*<A+.3)- $,%3( 4) 4)-#0&"6+!5*/#+,"!2( 4)!5*2)!5*5( 4(1% 
+-4,1;0&.?/1D15 BXC,,"/%,884=NwÅúãò∫êü¿ãõ¥óß∑~çîgwwyááHVW_jpWbh>JJ(21),(6'+9*#/!	
+	
+	
+
+
+	! 
+')$461	
+
+		
+		!!		
+
+%':$&<%-A((:  21B0%2(19<LS]oyÉco{ivñ§ØåùÜì¶jyêhwézãüí£µ^p|9HO.89395AD;&("#!$#-5()4&+7),:+.<-+8'"- #&&*,!*3"&209&BJ5FK7:?+'.$-+6C2((0=3?OB6G7>O=@S@?R?+<*,(31"fT@òÄdæØÜ“»ï◊—ó€”î€Œä◊∆~’ær‘ªg‘¿a“ºVŒ¥E–≥>À®2≈¢*Œ≤5÷¡A‘ Dœ«@Àæ<œ¬B—∆FÕ¬D–∆J“ K““P◊⁄Uÿ‹T‘⁄T◊‹[◊‹^⁄⁄b⁄‘b÷–b‹ÿjﬂ‡k›‚jﬁ„k›‚nﬂ·v››yﬁ‡⁄€}Ÿ’zŸ‘y÷ t÷ vŸŒ|ÿŒyÿÃv’«n‘√i÷¡d–∂Y“∏WÀ∏O—«XœÕ\œÀ]ÕæWº§B∫ú<≈¨Gƒ∫I¬¬H¡∆H¬»J√…Kƒ¬I ∂F√ô7æy,∂l!ªÉ,œ©D…∫Gæ∫?øΩB¡øD≈¡F√∏Bπù2±ï*¬∞@»¡L≈≈K√«L√«O√∆S√√S≈æTƒ∞OºûD√ùJ…§T∆™WÕπcÕ√lÕ…p––xÃ–yŒ“{œ”|Œ‘|—◊“÷”Œ|‘æs“©k≈ÖYß`@ÖI1fB*LK/J]?>Y:2L/4G1,9'-4$56(97+=9.@=4@=6FF>[]Rik^mn`bcUWSGYPAe^LSU@<D/.;)+>+,?,&>(,J24U:9W=9U>:R<8K8;I8@N=DUCCYD0M13R34N1,E()?($<&#;#&@% 8  8 5'?%.F,#: +='$5" 3!;"*K.+N04U8)G/!<-<VKOjaPndPpeLj^2N?&C-%A((B',0,F):S53A(*2CE0QT?q{cL\B=P:AT@-	
+	':&9V83T56 >[IMm^WxgC`L&=)*#- ('%!&-+;S;2J4%#"!$I]Rè•ôqÇxnwxãÖ{åÑê†ï{ãÄçöêo{wñ†©®±¬°ß¡fmä-4P1;Tlyåèù™.9?".,/?41B0;F8%0"'(2)-61DJF043#(* '$"3!1B/4C.5B.-8( (#+". +'".$",$ *"&! *"%/'(/($+$%  &&% &+):($5# -#1 %'(;'.A+9O:ì¶ìtÇu}àÇgpoMWXJYTN^TBME!( !#. *8')8%'2"(!!1$9R?8Q>0!#5';P?@WEI]QE[O=RK+?=#32#//"!!!#1$8@+:B-?G227#8='59(!'"!!! 	
+       	+$"3) 4+"6-0%3("6+2'2'/#-" 4)"6+$8- 4+ 6*"8,!5)!3'
+ 
+
+		(+7)#1 )!4 .D/DZE%	)5@B@K]GRp]kéfvóú≠«¢≥√oÄáRbbåúúbps[envÄâuÉÜ;IJ #!+ $
+
+
+	
+!#!  
+
+8:7%'"
+									
+	
+		
+
+
+)1& 1!8)@&-D(/C'#5)7&+7-2:<Zai|Üèq~Ü^mt]kt^n}ó¶πÉí©¢≤Àô™ƒg|ë{éùì¶≠_jlRXT[\T^^TXULRRHNPEFI>47,08+/:,,8*/<+,7)(.$ #%'8:->E3<E2?F4CK6HM9@E1;?.9B1#.,9(),8.GTJESD9G6;J52A,1@+/<()4#%,/,ydI¥ûwÃ¬è——ï“‘ì’÷êŸ”â÷À{÷¡n÷æd÷¬a’æVÕ≥BÃØ9”∞8Õ´0Õ´0“∂8“ƒ=” A–»C—»E—«D ø?Õ¬F‘ÃP÷“T’÷T⁄‹WŸ‹YŸﬁ]‹·cﬂ‡hﬁ›i‹ÿj›Ÿkﬂﬂm›‡kﬂ‰l‡Âoﬂ·sﬁﬂw‡‚ﬁ‡ÿ◊z⁄’z⁄–y◊Àw⁄œ}€—|ÿÃvŸÀsÿ»p◊ƒh”∫^’Ω]–ΩV”…Z”œa–»]Œ∂Tªù=√¢AÃµKÀ¬M«…LƒÀJ¬ÀJ≈ÃK«√H»≤Cøë3øu*∏n#«ñ9—µH…æH¡¿B¡¬C¬√D≈¡F¡µ?≥ó*µô,√∑A≈√H√≈H¡∆H√«N¬∆NƒƒR«øT≈≠K¬üE»ûLÀ†QÃ®TÕ≥\Œ¡e–Õpœ”uÕ“vœ‘x–◊zœÿ}—⁄“ÿ~““|‘«y—≤qÕòfºxS´aFèS;`B(LG*T^C9I.<H0@E1FE3LI:ZTHng_Åztmhdspiooegg[TREQMA\VHd]MMJ7?G2?N;6I6.C2'>*+G16V>;\A<Z@>WA3I45F4:K8>O<FYEOhR/P35V71K.%=##9$$:% 6*A'(>'7#;#$>%-E+"9)'-5)G+)J-0P80P;DcTQocNlbOmaEaS.I88#$>%)A' 7).&>$9R48K-'4;A'Y^GWdJEW=6L5<Q>-9+$.#%':'8V:9\>IiRXweIjY5VE1J71F3(% , !-!'!!#*5K66L7*'!E[N{ìÖdzmlÇvÉöêíßûé¢ôtÖ}oÇ~zåêï•¥©µÕö£¿SYy<C`ELf\bxPWg*.7"((&!'08+#. /;19D@FON8<?%&( "#'!"# 1!1B05C2*!"" ")+&".$".$)!&&!% &&")"#*"$ #!%%$ !!%#1 -;*!/%(%"0/=,/@-,+<*?M>frfs|wOXU9EA7F?LYP2>4$.#*6(&4%"/,7),4)!)2G6;R>%:)*<,6K8#8%*?0<REF`UGaXCVT3CB$0.($/%1C5 (*2#/5'18(=A0AE47;,*0$#!$ #"#"
+$#2+#4.!4.2)3(#7.!2*!5*1&0% 6*$:.&<0#8/ 8+#;.#9,#5'  		
+
+	
+		 (4&*;)01+A,,B+*@+&.<=DQbÖì∞uÖßÇïµï©¡täòvâè=OOãõõaop]fmÉçñwÜçâòù?MN
+
+	
+	
+$
+ &$#  "! 
+8:7					
+
+
+			
+
+
+
+
+
+									,7),?)'@#'@#)B%,C',@''8&7C9Yb_uÄï£§ÉíïrÅÜTemè°Ø≠æŒò©Ωî¶ºâùµÇó¨ê¶¥Äîõ5GG@MFS]Rdg\[]PZZNUWJMOB:</8:-<@29?15@22=/,6+.6+57,55)35'13%23%<>0AD3@D3GK:FM;:E40=,+7)?K=GTC@K:AM9GP;AI2HP9OWB7>,04#66tjG∏≠À…êœ—íŒ”ê”’å’”Ü’Õx”∆j‘ƒb÷≈]’√S”ºHŒ¥;”∑:◊∑<Õ©/À©-œ∂7◊∆B‘ÃE’ŒI‘ÃGÃ√BÀ¡E‘ÃP÷“U”‘UÿŸY⁄›\⁄ﬂ_›·f‰Ân‚„n‡‡n‡‡nﬂ‚o·‰o·Ên‚Ên‡‡pﬂﬁtﬂ·|›·ÄŸ⁄|Ÿÿ|›ÿ}◊–x€—|◊Õx÷ t€–w€–vÿÀm’¬dÿƒc”ƒ]ÿÕa’Œc—ƒ\Ã´N¿õ@Õ∞L–æPÃ«O…ÀL«ŒM«ŒL∆ÀJ…√G…≠?æå-ªr%ªw&œ®CÃªG«¡G¬√D¬√D√ƒE≈¡FΩ±;±ö*º•5∆ΩDƒ∆G¬«G¡«I¬∆M≈∆O«∆R»ºP≈ßG…ùF ïEÃîGÕùKÕ©QÕ∫\“Ãj—’tœ÷vœ÷v–◊w–⁄z—⁄}“Ÿ|““z” {’¿}“ØwÕöm«É`∞fKéM7k;'[E0VN9icMsmWzr]wn]qi\qmb|{vÖÜÄrul^_WJG>JF;ZPD\TGHE637&,;(.C02I7-F3/K5<\E>`G=]EB[E:P;7H57H57J40F/3I2D^E1R36Y95R4-E+%;& 6!3%;$+B()A')A) 8 '?%%<"-+)0)C(*H,.P7IjWPpaJj]Nm^?[L)@.3K5/I.(A$)@&/$.$<"3N/7Q./D#3C(=K2FT=*<&(>)F[H+<,#/!#1"+>+3T79^?JlSAaL1N:<UBXnY,=+## *&!%,?+8K7".  "';0aykeÄqPk\nä{à¢ïtáÅtáÖ{éíë£≠∑»‹¨º÷ÆºŸß∞—tzûTWzUUw33O!#2$)/%!%0"(4&4A7BNLFNP36;459(*)%"#$(%$'$2%#1$#!#   !&) ,"".$)! *"$$"$& "!#  "$/>+-;**"$!.+9(.<++&')7&KXGgqfnun@IH;ED>MF3D:*:/)7**$)1&08-$%+>+3K5+A,/E08K8#4$!/"*:-(A,?ZGH`SLcYI^W7LE.D81I;',2$6=-4:,&.#%#'#&"&&   	
+&5.$41!4.2)"7."5/ 3-"6-!7+ 6*!7+'=1'?2%<2#;.#;-%;.$6( 				 .&7%"4$"5"'=&+A,3E5@PMTboåúµÄëØ~í≠jîyèöQdh20Sc`=KKLU\âíçõ§[lt[jo))
+
+ 	
+"$"!!! "!$!	
+
+
+,.+).(
+			
+	
+
+
+			
+
+'2$,?))B%'@#)B%*C&'>$#4">J>|Ü~pyxq|~sÅÑÄíñúØ≥õÆµxäîi{áê†í§∏ê£¥í§∞Zlp9JD4A7;G;X`SbfX\^PVXJQSE?@2BB6II=KM@AG99A48@3>F9EH=SSGUSFTRESQEOM@KL>HI;GH8EH7>E5:C2=E6CL;FO>JS@MU@IN8CH2BG1;C.4;)26%=?'okE∂≥~ ÃçÕ“è“’é’ÿã’‘Ç◊”x÷Ãk÷Àb‘»Z’∆Q‘¿G—π=œ∂7◊∫<”Ø4»§)œ≠1‘ª:÷»C◊œH’ÕH’ÃK‘ Nÿ–Tÿ‘Y‘‘XŸ⁄[€›^⁄‹_€‹dﬂﬁj„‚nÂÊq‚„nﬁﬁl‚„n„Áo‚Ên‡‡n›‹pﬁ·z›·Ä‹››‹›‹Ä€◊~€”~Ÿ—|ÿŒw⁄”x€÷x⁄‘t◊Ài’»bÿÕdÿ–eÿ—f’∆_œÆQ¬û@—πO‘«TÃ O«ÃK»œM»œM»ŒJÃƒHÀ≠?Ωã*πu" ä3”≤GÕ¡I∆¿F¡¿B¡¬B∆≈G«æEª¨7≥û+ƒ∞=∆¬E≈ J¬…HƒÀJƒ»M∆«O»≈PÀ∫N…•E«ì= ç= ç= ñBŒ¶N–º[‘œi“◊qŒŸsœ◊r–ÿs–⁄w“Ÿyœ’u––v”Œ}’…ÅÿƒÖŸ∂Äÿür∆Ä\≠`FùVBê_NãlZÇpZsgQcVC^UD^XJcaUhiabe^\]UAA7D@5ZTH\TIGA324'*5%#6#&?,,G65R@AaLAcKAcJCaI:R<:M99J7:M93K3(B)-G.<Y=2S46Y94R6(B)#;%%;&':&!7 *A'+C)!9!2 8(>'!2$2!,(;'+C++G.0P9GhUKk\IhY9VDC\GG_I2J2,F))D%$;0	*%<"-H)3Q-0K*(<!,;$#2&"7$NeS,>.$'9)8O;2U77\=6X?2O9;R>DYFI\H3D1"#! "'+(9':M:&2$
+	 !%!& DYPTl_IdUWvgpéÇ}ëèvâç~íùè§µ ﬁˆ¿—Ìµƒ„¬œÒ«–˜±∂ﬁÜä∞GJk57L*.9'--#",!:H;;K@R``Vae\ag:=BIJL#$""(+)))$ ,"$  
+  %".$* '*"!+""!( $)"!&  $  # +,>((5$!!%". *7&+! !$1 =J9T_Quvlur>HI6E@5F>0A7/@6-:0+!",!.6+$* &):(0F1-E-;S=L_L"3#$2#.?-4L4A[B-F36N@CZP<VK/I<-H9 "! '&&!'!&")%'!) '
+ $1* 4+"7.3*"70!80"91%<2$90 6*!7+%<2$>3$>1&@3"=.":*#7+	 $0$+<,.A-=S<-B/(<1O^a|åõçû≤vã†e{âÖô†,,'"(70*64/8=@JTÖìûÅíúuÑã0>A!"#!#"$'$ )& )&!'#
+.3,""& 	
+			
+
+&.#+:'*>%*C&'A$'?%5'8&0<0chblpomrx{Üåjy~i}|]rmWjhGV[uÉån~ésÅétÅ_hcgodIQB1<.9D6FQAXaP[_N\]KWUF^\OgeYeeYddXacVOSECG9AE7NPC^\Ob^Rc_Sd`TeaVeaV^ZNYUIUSFRSEMP?GJ9EH7DH7<A-=B.;@,9A,7@-1:)29)/3ab:™™t≈ áÕ”â”÷â‘÷É’’}÷”t÷—k◊œd◊ÕZ’∆O“æC’Ω?“π:÷ª:ÿª;—Ø1œß+‘±3ÿø>‹…HÿÀI÷ÕLÿ–S⁄‘XŸ◊\ŸŸ_‹‹`‹ﬁc››e€ÿc›’f‰‹mÊ‡p„‡oﬂŸi‚ﬂl‰Ëp‰Ár··oﬁﬁp‡„zﬂ·|ﬁﬁ|››}·‡É›‹Çﬁ⁄É›◊Å€◊|€ÿ{€€{€Ÿuÿ–k’Ãcÿ—fÿ‘h◊”eÿÕc“∏W…≠J”¡S÷ÕVœ–Q…ŒM œNÀ—MÃœLŒ∆JŒ≤DΩê+∑|"‘ù@◊πKÃΩF»æE≈ΩA≈¿B»¿D ªF∏§1µ†-≈∂?∆≈F≈ IƒÀI∆ÕL«ÃN«…NÀ∆NÃ∫J ü@…ê9Àç:œí?—üF’≤T‘¿]’–h“◊p—ŸrŒŸqœ⁄r”€v“ÿtœ”r–—t“–}◊—Öÿœä◊≈Ö⁄∑“ûn∆Ä\∞dJéK8g6%P5"PC0YP?SM?ZXL_aVQTIEH=JH<KE9XPCYSE><0,.!$* *$6(,D42Q?GhUGjVGhSHeO6N88I7;L:>Q>>V@1J4%A(*F-4Q52S47X95V9.J1+C-+@-'<)$:%#9")@&3/5*@)*;("3!#4$2E2-C.+D.+H2Tt_>[G?ZGAZD7O73M4>X=4Q2#A!: 4)*<&&=#(A$2P.0K,/ /'5$&-I`P7N>4L<Xsb>^G.S45Z;1O5?XBJ]J);N;=R?.' &- =N>2@3#&)-YghPa[@ULgÉwå™¢èß©ãü™¨¡‘´¡Ÿ√ÿÛ¿”ÛªÀÏÆºﬂ™π‡≥¬ÈΩÕÔ∂≈‰åñØEL\+06 $# 2>47G=fvvUbhALRCJPCGJ"!! &0 ,(%"% ,"'$ $#%'* $#!( ")!%#" !$ !#2,>(#0(%1#(! #. 7C5hthàìçmwvcomIXU6FC4GA0D9.@4(4(/7*-3'&1#'8&2H3-E-6N8FYF#6#!4!1G0>V<IaI"4$/!(?/.F6,E2,E2#$#!&#%!'#*&)%+'+$(    
+	"&3,%6,"8, 5,$90#:2#=2'>4'>4#;.":-%<2#=0!;.%@1%@/":*!6'$2#&9&7M8C[E(?/&977HOtÖïqÑìkÅåráä%$4)(70!--6DGÑìöxâêÇîò~éé&)  '
+				"%"!% $ )$!*'(% )&#)%!
+
+")!-7,'3)%1'%3&#1$)
+
+
+
+
+			
+
+	",#:(A$(@&%;$,=-+7-OTPPQVvzÜèó§`nwoÅÉ^oiSd\HVVcpvhtÄ[eoENKTZP`gW`gWEP@(5$2?.CP?QXF_dP\[Ia_PgeX_]P^\OXYKZ[MVXJJL?KM@a_Rb`Sd`Tb^Rmf\rkaqj`hbVieYcaT^_O]^N]^NWXHPQASVCPTCLSA+6%7B1>E5?C*ZZ4¢¢l¡«Å —ÅŒ“~——{“—u’—p”Àf◊Ã`ŸŒZŸÀP”øBœ∏8’º=ÿΩ<€¿?Ÿº<”≠.–©*‘±3⁄Ω?€»HÿÕOŸ—Tÿ‘WŸ◊^⁄⁄`€›bﬁ‡eﬂﬂg·‹gﬂ”e‚÷hÁ›nÊﬁo„€l‰·nÂËsÂÍt„Êsﬁ‡r‚Âz·‰}›ﬁx⁄⁄vﬁﬁ~ﬁ›Åﬂ⁄Ü›ÿÑ›ŸÄ‹€~⁄‹{Ÿ€vŸ÷oŸ’j⁄◊l€Ÿl⁄ÿk⁄”h⁄«a‘æX‘»X’–X–“SÀ–OŒ—Nœ“O–”P”ÀN’∑I∫ç(ºä)◊¨F“ªIÀΩC æF»æC«øB…øD»≥@µû,æ´5∆ºA∆«G≈ÃHƒŒK»œM…ŒNÀÀOŒ»PÃ∂G»ó8Àç6—ë:◊õC’ßI÷∂S’ƒ\‘–e“’j–Ÿn“€p”‹s”‹s—ÿq”’r—“u—–}’‘Ñ’”à÷œá⁄«Ö⁄∑}÷†q≈Å\¢[?w:%kH4ZI7MF6UVHZ\OGI<8:-A?3IC7XPCXRDEC4+/!&.!&0%.>13J:=ZHMn[IlXMn[GgR7P;,?+6D38F5<O<1H4,E/*F--G.-J.1P18Y:8Y<1O77N:.@0(:**=*$7#)<&%8"$7!0'=&(;'!4!3H7RgT4J5*B*)E.2P8/K4Zt[=U;#;!*D)6S5@_=*H&4%9 3E//A+2I/.G*2O02M.#5-->."&?WGHcRZweXwe;]E,Q22U5DbF?W?8I70 BWF5H5)
+#/90!#%<L?:H;)"$'EJPÖåîu~ÉO]]Na]`yuÄúù•ª∆∞≈ÿ∂ ‚∂ Â¶æ⁄¥ÀÍƒ◊˜åúæl~§h|°yê≤é°¡∞æÿ£™Ω04=!%&]kkSbeN[aITXGPU@EH!%$#)- 0##1$$#' ," ,"* #( ,"%) ")!$ $$'  " !);%.@* +"#!# "$*VdWs~v~âÖó¢û}âáFTT4GE4I@2F:5C40<..9+)6%&9%1I3.F08P:<Q>)?*2H1<T:B\?+C)"5"'9),C/+D/.E1.E1!$#!'#!+**(*&+',%,%(    !,&'8.#7,!7+%;/%<2$;1%?4%?4$>1%=0%=0'?2%?2#>/&?,$;)1#
+			
+	
+	();+#8%,C/.E5'#%*iyàqÉëd|Ä<RO-"(!6%*?03'.B9=PN:NMÅïìuàÑ/%"2')7*&4%&",!  # &## % #!
+	"&4'+<,&7''8("4$--	
+	
+
+
+
+	
+	
+ *7&%7./'; ,@' 3-=2?JFz}Ñ[]lkpÜntås~êR_hAMK<IBXdbvÅÉlväêQZUIQDDM<LUBT]L@K:*8)/=.?L;U^K^aN]^LcdT`aS`aSQRD_`RefXfgY]^P\]O[\N`^QfbVeaUc_ShdYdbVb`S^_Q]^PXYK^\OdaRdaRcaRMP=AI4;B0BI7EI8AC+]]7ùùgø≈≈ÕzÕœ{œÕv“Õq’Ãm’≈c‘√Y⁄ÀVﬂ–SŸ∆F–π9’∏:Ÿº<÷Ω<›¬?⁄º:’Ø0”•+ÿÆ5ﬁ≈G‡”S›”WŸ”W›ÿ`€Ÿ`‹‹`›ﬂdﬁﬁf‚ﬂj„Ÿh‡‘d‰ÿhËﬁmÂﬂm‰„oÂËs‰ÏuÊÎw‚Êw·Á{·‰{›ﬁv⁄€u‹‹z‡‹ÅﬁÿÑ⁄”Ç‹÷Äﬁ⁄‹ﬁ}€›x€‹t‹ﬁs‹ﬁsﬁ‡sﬂﬁr€◊l€Œf◊…^◊–\’”X–’Uœ÷T–÷R—‘Q–”P’ÀO”±E∂â"«û4ŸªK—¡H ¿DÀ√GÀ√F ¬E æD¿©5∑û*≈∂?…≈G∆…FƒŒG≈œJ…–L œNœŒP”«OÀ¨@ ì6–é7÷î=◊ú@‘¶Dÿ∏Q÷»[”—b”◊i“⁄m”Ÿm—◊m”Ÿo”ÿq“◊qœ–r––z”“Ä‘’Ö’”ÜŸ—â◊≈É⁄∫‘•qø~TõZ:wG0`C1]VDQSEEI:24&A;-OE9VL@UOAEF6:C2(3%,:+FWGNcRKfSStaTwcTwcQnZ=VA4G42C1-:)'5$3D22H3+C+-E-(>'*B*+I-6W:;]BFdLOdS8F9+7-(4()5''6#+<)':$6#;#*?,5L8D]H?XB8R9,F++E(-G*:T7C\?(A$*C&+E(1N/5T21P.6!8':$:P9McL1I/+H*4N1&9#+*<,-!9+Pk\_~nSr`IfT)G/+N.3W36U54M0):(- &EWKCVC(9'*"(+5*",!"!5E8CQB+8''/ @B4=;,B@4ÖÖÉ∑∏ºòù°t~ÄJXXbttRfmÇò••∫œ¥≈ﬂØøŸfwì1Ieë™» ﬂ¸©º‹oÅßåû∆•∑›ûÆœgrêioÖ15> !O[Y+,IX[OaeKZaR]c%.-%!%),)')) )(+* $ )  *!!)!#-$% !""' '3E/0B,$#!)(&R`SfqipzrÅåÑëúñÜíí4BB/@:4H=1F54G41B0):($7#)A+5M7=V@8P81I/;T7?Z;0J-'A&&@',E/-F1-D0)>-(:*  ! +'*&*(*&,%) )        '4-):0$8-&<0'?2#;.(?5(?5'>4'>4(?5)A4*B4'B1%>)$;'+
+ #()#+,&,/(+.%.4*08+.9+,7)3;.5;125,36/05/05/271*1*3>6.>30"'<+#8'(<0*;5**;JQzãí[om 7-(1)@,,C/'<+$9*"6-':45HB.B9*(.>1(9)5C4+7)# !$"
+
+
+)!)7*%7'':'#5%"4$2!..			
+	)0(-7,(4&+$/!	 2A..B'*A$+?# 4*>%':&5E;IUUszÑv{éÖü}Ñ†p{ëvÇê=KNYecs}||Üà}àéqzHQLBJ?2=-1<+8A09D4,:++;.2@1@M<RVEOR?RSAUVFVXJVXJ\^P`bT_`R[\LWYKXYI[YJZWHYVG]ZK_]Pb`SXYIQRBQRDYWJb`Q[XIc`QXWEJK9NQ>PSBTWFYZH]]ColIüùjø≈}«ÃxÃœxœŒt—Àm‘«g÷¬_’¿U◊»Qﬁ–S›ÃJ”ø<—¥4’∏8Ÿæ=›¬?·ƒB€∏8÷§+ÿ•/›ª@Â–S‚◊[ﬂŸ]‡‹aﬁ‹a›ﬂbﬁ‡cﬂ·f··iÂﬁj‚ÿe„ÿeËﬁkÁ‚mÊÁpÊÎs„Ît„Ív·Ëx‡‰v‡„xﬂ‡x‹⁄s‡ﬁz„‡É‡⁄Üÿ–◊œ|‹÷~‹Ÿ|‹‹z‹ﬂv›‡uﬁ·v‡‚wﬂﬁt‹ÿm€ŒfÿÃ`‹’a◊◊[’⁄Z”⁄X“ÿT“ÿT”‘R◊ÀQÃ¶9≤á–≤@ÿ≈L–∆J ≈EÃ«GÕ»Hœ«JŒæE¡¶3¡®4 æD …J»œK«—J«—J “KÀ—M”ŒP”¿J»¢7–ë4‘ç5÷ê8“ï8Œ°<Ÿ∫NŸŒ[‘’`‘Ÿe“÷gœ—c‘”g”◊i—◊k”ÿq—’tŒŒv““|“÷Å”◊É”‘Ü÷œáÿ…Ñ€º|—öd∞oEîW;|O<YJ79:(;<,@>/OC5ZN@SK>AB46A13A24D7?QC>SBD]JOoZQr]VyePp[9R=4J51B0->,'5$(++>*.F.,D*(;%"8!< 3T7>cD@aF[p]n|oisjR\S7A6+8'*9&'9#$7!'=&?TAG^J3J6.G1+C+)A'*D'1L-:U69R4.G),E(*C&'B#,K)2P.";!8(>'2H1/E0!9!*D'3M0*@)-&=+<TDZuf[whYxf9XF:'3)K*2T1/M+)C&+>*'7*4F:_sgZo\:M:(6'+%%3$-9+#-$*7-JXIAL;47$UR?Ç{iß†êÖÄz§£°ôöû[bhTbeuÜéyäöÇî™åùπ¶µ“}â£%<&>Ñû∑√€ı∆€˙∫ÃÚ±√Î¨æ‰™∫‹âî¥7?V%,6 #
+#,)3AAHXXJY^MX\# ##& $$&$&*)("$.%(2) *!(",#("#!"$%#!,4F0-?)#! 2>2%3$0M^N{â|_lbjvlÄãÉ~àá3??-<9*;3.C40G54F6/B/'=(5K6D\F8Q;5O6>X=9S6+E($>!'A&)E,*F/,E0)@,0 $6&$ +'+$+& -&+"% *70&:/&</*@4'=1+?6,=5/@:-@:,?9+A5,D6)B/$=($9&$	$%'#$'&7B>):2'9-1C5*:-+!*:0,;4)&"1,1C7%:)%:'&=)#:&3 0 1#/#,"* +!*,!1$$5%&4%&
+ '$ !		
+	")7*(:*#8'#8'"7(3"-.-%			
+
+
+						
+$.#-;,+>*%;$':$*
+'4"*A%+D$*C# 9'; /B.I]Rîß•í§®ö®µóü∂Éä§àî¨∞¿–arzKY\&)%-0Çãíqz)21)3++7--9+'3%!-"0#)6,/?2:F8<E4CH4GJ7KL:LO>KM?IM<HL;EH7JM:NQ@VWEbaMedP`_McbP_^L_^L]_J]_I\[GYXD]\HYXD\[GVUCWXF^]K^[L_\KfaNfbIicAõógΩæx∆ vÃœxœŒr– j”≈b÷¿[’¿U◊»Q‹—Q€—KŸ…B’Ω9“µ5Ÿ∫;‚≈CÂ E„¬=€©,◊†)Ÿ™4„√J‰’X·‹^ﬂﬁ`››aﬁ‡c‡Âgﬂ‰f·„h‰‚i‰ﬂi‰›hË·lÊ‰mÁËpÊÏr‰ÓtÂÏx‰Ëy‚‰w·‡vﬂ‹sﬁ€tﬁﬂy‚‚Ç‚ﬁá⁄”Ç◊Ãz‡÷Åﬁ‘{‹ÿwﬂ‡x‡„x·„x·‡v‡›tﬂÿp⁄Àf›Ãd›÷b‹⁄_⁄ﬂ_ÿﬂ]‘€W’€W÷◊U◊…O¿ö-æñ'’¡H◊ŒM–ÀIÕ EœÃI“ÕK“«IÀ∏@¿¢2«Æ:ŒƒHÃÕK —M»‘L»”IÀ”JŒ—L‘ÃO“¥B ô2‘ç1ÿà1◊ã3‘ì7Œû8€øQŸ–Y’◊\”◊^‘’^—Œ[”–_‘‘d‘ÿj—◊mÕ“lÃ–q—’w”ÿ|“ÿ~”◊Ç’÷Üÿ“Ñ⁄∆÷≠mƒÜS´_=àH/W;&;3 A:(OF5\P@TM=>B38D67I;:NB8I?/C8;SEOlZNnYPrZJjS1M7&=),?,"4$"4$(9)03,D,-G,2L1.D-23/N/?dC:]=>V@CTDQ]Q_i`dncR_N*9&/@-<K89J7^q^f{hM`M*=*%:'(>)-E+5O2?Z9MhGE^>'>!+?&&=#,G(0K,*C&!9#9"(>))2*B(1K.-G.(A+EbN^{i^{gOlX5R<2N8/-+J+1S02O0 :*B,PgUc{kpàxG^JLbM7H6&2$ +A*oÖn&4'	#,)JTKZ^O_ZD~s]ÄuacXFVL@haYLJO(,7_mz¶∑…Éì¨Åè¨ëûæâî∞39O"3!2láöµœÊª‘Úº–ı∂…Ò≤≈ÌÆ¿‰µƒÂ^hÅ-	
+!)40+62'0-! !!$)- ,&% '&$##  ,"'3)(2*!%!+"%"'#"'##&!!$#$5"3F0%7!% !#3A06I51G2;S=lÉokÄqM]Rbof{àÅdplS_]7FC+<4-A63H92G6;P=G]H>V@?W?AY?6N4'?'%=%'A(*D+*D+,E/,C/.E3.&;* *&-( /(,% -$$
+    
+		
+ +'';0(>1)?3(>20A91@9AMIAPKEVNFZO(?/&?*4"8#
+%'*)'""!&+2=A"013D>3D: 0%$%0=4AND(6)(9',?+'=(2./+&.!#3&+!'4* !-$6&0 %	
+!%""-)&"&"$ "
+
+
+				 *"&6)&8(!6%!6%!6'0!+,.(					
+
+
+
+		
+$5"'=&&>$'>$&7$'2!*A%(C"(C"%> !8)?*,C32IA:OPPblZeyÜê©û≠ƒ®πÀäú®*1 #bkrajoISR%0*1>4/=0$2%'%$1'(8-3A47B28?-47&12".0"(*-1"8<-?B1AD3EH7HK8MN<JK9LM=NO?OP>PQ?TVAUWBWYDVXCTVAKM8MO:LN9MN<ON<\VHb\Ld_LgaIi`?íå\ππsƒ∆r  r–Õp”Ài‘«aÿ¬\’¿S⁄ÀT›‘S‡ÿQ‡‘L›…DŸæ=◊∏9ﬂΩ?Â«C„æ<·≠3€†*◊†,‚µ@‰ÃR‚◊[‡⁄^ﬁ‹a‡‡f‰Êk‚Êk‚‰i„„iÊ·iÊ‡hÊ·i‰‚iÁÈnÂÎq‰Ïs‰ÎwÂÈz·„xﬁ›s›⁄s›⁄sﬂ‡x‚‰‰„á‡‹Öﬁ÷É‡÷Åﬁ”y⁄—r‡ﬁw‚‰y‰„y‚·w‚›u‡◊pﬁÃh‡œe‡Ÿeﬂ›b‹·a⁄·]◊ﬂX◊›WŸŸW‘ƒJæò)Œ™8◊»K”–K–ŒGŒÃEœÃG”ÃJ—¡GƒÆ7ø°1À¥@œ«HÕ–KÃ‘M…”L…‘IÃ‘J—”L’ LŒ≠<Œó2’ä-—Ä'ÿã1’ï4”ß>‚…Uÿ“V”’V‘‘X”—V“ÕU”ŒY‘’`‘ÿg—◊iÕ”iŒ’n“ÿv“Ÿy“Ÿz“Ÿ|”◊Ä’’‘«xŸ∏q—õ_∫mAîK+e=$U@-[L9\TAXQAKL<?L;7L=;QD7OB2H<>VIWse[zhWwbFcM2N8'>*2':'"7&/&8(13I20H.,D,+C+1G0.D-+C)+H*ChFFiI;U<4G3,:+1=18F7BP?3D20A.PaNL^HOePTjU8N9*@+#8%,B-<R;<U8LgFRmJ?W7/+"4,C),E(.G*7 8 !7"(9'0C/'?%0J/.K/Wu]Zzc]}hEbL&B+$@':T;2-*G)1P03M01(@*7P=kÉsräze|jVhXFWG/;-"+7Q6ZtY'5(/6<LUT\_Vwr_g_JG?,IB0D</kf`FGL[bræÕ‡Ø¡Ÿãöπü¨Ã¢≠Õu|ò$&;/#0Jbn°º—±ÀÊ∂ÕÌ≥ Ï±»Í±ƒÂ¡–ÌdoÖ-
+	
+
+	
+
+
+
+
+
+
+
+),% %  "'*&$+!%'&$!!&$0&%%'#"487#"#$# !(*;(=O9.%!  !2 .D/.F0.G1MiSmÜsUi]O`VWh^uÖ{tÉ~crmG[R5K?=TDJaOKbN:P;;S=;S=.F0%='+B.5L81I3,E/,D.+B.'>.(=.)>/7L;(&!0+!2, 1).$(		
+	
+	
+				
+
+		+?3+C5*B5,B62C;0?8ALFbmemsUj[$;'%='9":""	
+!'+,((&1-19<2;D1;GkwÉQ`g8HE#3)$*&bnbM[J(9&2/*$1 ,"'3'/;/+9*+,(9'(=*10*8)
+
+	" (# )$ )$")%&" 		
+
+	
+	#)6,%5*"4&1#1#0"+*+/,		
+
+
+$+7)%4!# 2)=$&=!(?%)<&(&+B('B#'B#'@""9 6%='$<,*?82CJ_lî†∫©∏œduá™º»*/#%[cfgqrr}yDQH.</)9,!/""  ,"*8++9,9D4&.48*(*#$%(02%>@3?A3:<.13%02%13&26(48)48)6:,;=09;.<>0<@/>B1AD1AD1DG4FG5NL=RO>WTA\V>bY:äÇS∂≥n√¡n«√lÃ«i”Àh”∆^’¬Y◊≈W◊ÀS‹‘U‡ŸT‡ÿQ·–L›∆F‹Ω@€∑<„ΩB‰∏?‰≠8‡¢1ﬁú.„´<‰øLÂœX‰’`‚Ÿd·⁄f„‡k„„k‚‚j„·jÊ·kÁ‡kÊ·k‰‚kÁÁo‰ÂmÂÈqÊÎwÂÈz‚‰yﬂ›vﬂ€w›€tﬁ‡u„Ê‚‰É‡·ÑﬂﬁÇ‡€›“v◊Õl‡€u‰„yÂ‰x„‚v‚ﬁs·ÿo‡“i„◊i‰›i‡‡f‡„b‹‚^⁄‚Y⁄ﬁV€ÿUœ¿C√¢/ÿπDÿÕM”—J—ÕEÕ…A“ÀG’ L”∫D¬§2¿•2“øGœÃIÃ“JÃ‘KÀ”JÃ‘KÕ”K——M◊…L”Ø=”ö3‘á+’Ñ)€í4’ú5◊≥C‚œV◊‘S—“P–œP”œQ‘ŒR’—V’÷^—÷`—ÿh–ÿk“€r–€s“⁄u—Ÿt—Ÿv‘⁄z”“v“∆p÷Ωm“ßb√ÇJ¢]3q>!eB.eS?\UCJM<CN>=O?8O?4I:4J=@ZMWvg^lWxc@]G4P:0G3%7'!#4$+>+3 3"%:')?* 6!4 14'?'2L16T8<_?FiK6S79Q93F2$5# 12E27J7<R=TjSOgMHaDF_B>[?<Y=.H/3K3G^DJaEF]@D\<LdBMbC5D-"1)<&$;!0J/!; 7/E09O:,B-(?%.F,0M1TrX\zb<ZB,E/ 8 !;8P6"5!*&C%0M./H+5L2,?,*<.cymïâxåÉ+:3R_V=H@*4,#GaFKeL*5- &-?ÑãûCIWRW[ehaLNA=@/>B38>4@IFVdmæœ·¡”Îñß≈†∞—π»È∂¡·qvî8.#-#7>à¢±õ∑Ã´≈ﬁ≠≈·´√›Æ¬€|à†,5F '/							
+
+
+			
+ #!#	%'%#&("#'$#"#( "&487-10$('! $%""+-?)9H3'$  $ !$6(&;*&=+'@+8S@eÄmE`OE]MD\Lbzjvåtä}MhYFcQNkWNkU@YC8P:2G43H79N=<SC9P@3J:0G3-D0/D3/D5):0%6,&8,+=/"#2-"6-';00F9- 		
+% ;QD0K<-G:(@3*?6+?49F=BOE2D6$;'+C-+C+(@&%=#/C*#5		
+!&,.,+) &01:CJjsÑMXlQ^qn|â]mmFUP[f^DNF$ =C?\f]rÄo>P: 3/*(*5%#.)% .&7'!2 )$7$$9&,10>-	
+	" #!'"##&"# 
+
+		'#3("2'!3%0"-,()-++
+	
+		
+$#+ *&7$':$(:$"4)=$&=!&=#)?("3 # * 6%>! 9 8 72#;#&=)*?6L^bÉì£í†∫ù≠ƒÜó©Öó°&5:	9??pyxuÄzWcY/=0-;,#1$!%$2%!/"(3%%(!"%%*#*0&14+03(,0"(,$, &%-.7&04%/3"15&6:+=?1BE4FG5JJ2QL.|uG±¨h¬Ωk…¬jŒ≈h—«e–√[œæT‘ƒS’ÀRŸ—R›‘Q€”N‡“OﬁÀJ‡ƒG›ª@⁄≥:·¥=‰Ø=‡¢3›ñ,‚ü6Ë≥IÈ√VËŒ_‰“b‰◊g·◊f„ŸhËﬁmÊﬂkÊﬂkÁ‚lË„mÊ‰mÁÁo‰‰lÊÁpÁÏxÁÎ|ÂÊ~„·|„ﬂ{‡ﬁwﬂ·v‚Â|„ÂÇ‡‰Öﬂ‡Ç‡›~›’s◊Õk·‹tÊÂyÂÁyÂÁy‰‡uÂ›rÁ⁄qÈ›qÂﬁl‚‡g·„dﬂÂa›„[ﬁ‡YﬂÿV—øCÃØ9‹¬KŸ–M‘“K—ÀCŒ∆?”ÀFÿ…Jœµ>ø†,Ã≥<◊…L–“MŒ÷MÕ’LÕ’LÕ”K—‘O——M’∆I’´;’ó2“É'ﬂé3‡ú9÷£8⁄ΩG€ÕPÿ’R““L“ÕK“ÕM‘œO‘”T‘÷[”ÿ`—ÿd—€j—›o—›q”‹s‘€s‘€t”ÿr”–o“…l“æh–¨^ ìP±r=ÖJ*uK5bP<FG5>K9>Q>;P?1H83H9AYIVue\}jJkV7W@/L63L7.E3#5%(!2"+@-(>),!6#!6#/*0#6"34#@$)G-+L/8V:;W>@XB/G17!7M87M8BXA:R89Q7;R8=U;8U93P43M43I2<N8?N7=M3=P4CV8N^C?M6#0(:$$:#*D+'A&$<"9Q9IaIWoW=T:,D*0M1@]A-I0+D.&<'3";=V9#9"+'A&/L.3K1DZC7H8+=1ÅóãuäÉtáÉ"21L\\Tbb4?;&6+LfMSlVçôïls}äí©äë≠=EZ7?JT^]FRHAL>?K?0<81CG∂…ÿªœÁ£¥–§µ”≥¬·≤¡ﬁ∂ƒﬂº∆·HIe.*,5+?Juãôè§∑Çó™J]n2BR"1##'			
+
+
+	
+	
+!  (&!"#'&$& 
+# *!$'.21).* %$"! ! -7I12A,&!'* -#+"* "2('8.->61E::PC;SC?XE?ZG>YF<YE:WC<YCB^HUq[PgUG_O5P?4Q=7W?<Z@;W>4M7)@,%<*&;,'>.1H85L<2D4(:*);-&8,&7-)81+!,!$2B8.B7+C5;SC6Q>#;%+C+*@)'-
+			
+
+
+			
+
+
+	&3,CYM?[M7SE,H<+G9.H;1I;.E5*A/+D/,E/,D,%=#8(A#1H,	
+
+( /$2&/ -.!+" ,,<FP'<#? *EVcvrÅà_on_pjN^T6E>FSJR`SrÉq\pW=Q6(>)0%,($")"3#.C21F5"7&2*!3#1!-B/6H8		 $!!# )%%!##%"#,"#1$+!,#'###.&"2'!1$0"/!.%)+**%
+
+
+	
+			
+	 (%2 *9&%8"6#: &=#'>$'>$$;!#: %<"$:##6"!2 !2"!4 1//.0 3&;,.C<UhlÜóßäö±í¢π†±√k|Ü(+$"#$6<8;A=&-&)3*%1% ,"$#!	%)' !&$#%0"%1###,4'4<-1:):B+BE&kj<®•`¬ºh…æeÕ¿bŒ¬^œ¬ZŒ¿U”∆T÷ R◊ÃPÿÀKﬁ—N‚‘Q„“P„ŒOﬂ∆HﬁæC‡π@ÁΩG‰¨=ﬁï/‡í0Ë§CÔ∏TÈ¬YÍŒcÎ÷k‚œf‡…aÍ’lÍ›mÈﬂlÁ‚lÊÊnÁÁoËÈqÊÁpÂËsÊÌ{ÊÏ~ÂË}ﬂ‡x‡ﬁy„·z·„x„Ê}„ÂÄ„ÂÑﬂﬂﬂ‹{›Ÿuÿ”kﬂﬁrÊËzÁÎ|ÁÎzÁÂxÁ‡uÍﬂuÍ›tÂ€l„ﬁiÂÂi·ÊeﬂÂaﬂﬂ]ﬂ‘V’¡H‘ªDﬁ»NŸŒN’ŒI–»A—…@◊œHŸÀHÕ±6ƒ®-’√E‘œM–÷NÕÿNŒ÷MŒ÷Mœ◊N“÷N‘—N◊√H’¢5—ã)”Ä$‰ì7ﬁû:⁄¨=‹ƒJŸœL’”L‘“I‘ÕH‘ÕI‘œM‘‘R”’X’Ÿ^“⁄a‘›h”›j’›m‘‹m‘⁄n‘◊n”‘l–Œg—…fŒø` ØXÃûQ∞x;èS/vH1OD0>J6<O;7N:/A1+=-8P@Ur`YydGhS7T>1N83O9-I20I4-D0%8%0&<'+A,1/*=*.+#6#%8%"5!15#<&#?&3Q7=[AA_G8V>(F,0M16N44K1.A+1B/3B/2C0)?*-C..A-0?,:E4EN=KTAKTAQZEJVB=H7(5#+:'$7!'?'PjORkM3L.B[>SmR;T7(B%,F))C&!9# 3 #-%=#=W:'?%5*D+1K29Q;NcPRgV.B6ÉöêiÄxyçãJ^_™æ≈ñ©∞GTZCSPG_OWo_ºœÀ≤¿…ëùµëú∏ó£π~äñ]kkP]TIWJ5D=.@DsÑî∏Õ‚é¢ª•∂–™∏“¢≠√û´æñ®º∂«€ßØƒ46K!2,/>( * *$!#,1						
+
+
+
+
+						
+
+	" !!#),$!% 
+
+
+"%,$%+!!(!%
+
+%4!<N8*<&1*@)2J47P;@[HA^LFeUA`PA`QCaU<[L<XI7TB8UA6R<7S=9U>6T<:V=8Q;/F2SeU1F7(?-*C./K22P44R69W;8T=1J5(?+1H4F[J:L>+9,#1$!1$"4&2D8'8."1*%2+3G;BYI5M==ZF=ZD;Y?9W;9V:-J,'A$+C)2-(
+
+		
+
+
+GWME]O\xi_{m0O@-M>,M<+J8.K70K8-I3+D.&@'": 1'B!0K,'
+% -#0$/ 2# 5& 1' /,*2".><F_dmäçò¥ï°∑{åñmÅíê[njyçÑUi]]s^`w]E\?F]A+A,%:)'-)$1 /:*3@/3E5,C1 7%.$9&'*-)@.4I8!	!#" ! !,(($#" $)+- /1# 0%!1'"2'#0&(  "-%$1'"2%0"/+())')#)
+
+		+6((7$&8 #:#<#<#;!%=#&=#$;!$;!&=#$<"!9!!6##6# 6!11.-,/$9(1F=*@>mâ¢≥√ë¢≤üØºTch   '(!	#()'%"()'+&	%/&%1%*'*6(&3"*6"28[\2†ùZøπe∆ªa ª\ÀΩZœ¬Z“ƒY”∆T◊ÕT÷ÀO◊»I‹ÕLﬂ–O‚”RÂ”S„–PÂÃNÊ MÁ…MÍ¡MÁ®?ÿé-ﬁë7Á†FÈ±RÓƒb’nÈ“jﬁ¡]Â»dÎ‘jÎﬁlÁ‚lÁÁoÁËpËÏsËÏtËÌwÁ}ÊÓ~ÁÍ‡·yﬂ›x‚‡{‚‡y„·|····Å‡‡Ä‡›|·ﬂxﬁ›qﬁ‡rÂËwÊÍyÁÎzÊÊvÂ·uÍﬂvÁ⁄r„’jÁ›jÁÁm‚Ág·‰c‡›\‡“WÿƒKŸ≈J·œSŸ–M÷œJ÷ŒG÷ŒE◊ÕGŸ»F ±2Õµ7◊ÕJ’÷N—ŸOœ⁄O–ÿO–ÿO–ÿO‘ÿP◊”N⁄¿Gÿû3Õ~“z ‚í3›¢:·πGﬁ…J÷ÃF÷”H‘—F“ C÷ŒIÿ‘N’’Q‘’S’◊X“ÿ\”€a’›f’‹h◊‹h‘◊f–Œa–ÃaœÀ`Œ«]«πV√¨N«°LÆy7ìT+i: PH1?N9-B/1H6(:*-B1Vq^ZzeGgR6V?2N85Q;+D/-F1,C/&;(*=* 3 #9$+A,%8%.&7%*;)&9&'9)'8($5%%6&$7$)>+#<'(D-;YA>`GFhO4U:0M11H,0B(-?)5D17D3+9*.!2'5$-:)9D4JSBHO?T[Kip`v~oitdBO>(6%1B/4J3RjPoÜi<U7SlOOgM*B((@&+D'$;!2)&-(>)9S8?Y>iÉj:S=5N;LcSsá{l~r;OCpÖ|nÖ}í©£oÑÖ•Ω«ƒ⁄ÁÅìùK]a6KF5LDmÅÇû∞ºäò≥ü≠»µƒ◊≠æ∆sÜÇXi_6G=:MKM_kúÆƒ®π”ß∏‘†∞ ≥øŸãëßnwàGWgsÖì≥¿–ïûØ_dwQTg," %)
+
+
+
+
+
+
+
+			
+
+
+
+
+
+
+ "&&&!# 	
+
+	#&/0*
+
+	
+"'!&-&"
+&7$7J4 1AR?DZCA[BA]G>[E<\G=^K=^K<]L<\M<[L:WE:UB4O<0I4+B.(@*(B)B_C:T;0H26K:2D6,>0$9($<&*D+1N25R65Q86R9;T>HaKJaM-B/&4%%3&(:,0E60B4/A5;LB:IB@`I;[C:ZB:\A7Z<7Z<5X88Y:+J+,K,/N.,K+)F(!9.-'
+			JZOKcSIfTlã{Xyh/Q@-P<.O:-O7-M6+H2&B+%?& :2/L-.I(%>!%
+) .#/!2!!6%!5)!1.&5<N[n\hÇçõ∏N\wzä°•∂∆ÜóüdvzpÜpÇÜ{éäXo_F^FB[=NeH;R6!8$+@/*--$5#:H7(6'/!+ 7%)@,#8%*"7$,C13L9(@0-&#"! # *&($&"#('*,,/#0$1#!3%#0&* *!"/%!1$.!/+))&#'14+'( #"%$
+-.&
+
+!)"/)8#&:!'@"%> &?"%< !8!8 8%=#":"54"8#%=%60/-,4)A)&?*%=/;QNáúùyéèASS'31	
+  "#&)'!%+&- 1 1%3"". !+"(4($2#!"$0$'3%&#(JL'ïîTº∑e√∫_ æ\ ΩWÀæUœ√U–≈Q’ÃS◊œR’ LŸÃL‡ŒP‡ŒNÊ‘TÂ◊TË◊UÊÿUË⁄WÍ’VÎƒO·®?€é4‰è>ÍüLÔ∂]ÒœkÓ’nÁ≈c⁄∏VÁ fÔ⁄oÎ‰oËÍoËÏqÁÌsÈÓvËyÁÓzËÔ}ÊÏ~‚Âz‡·{‚‡|·›y·›z‚›‰ﬂÉÂ‚Ö„‡‰‚{‚‰w·„u·‰s„ËtÊÎwÁÁwÂ·uÍ›wÁÿqÊ’kÈﬂlËËn„Íi‚Áf„„a‚‘YŸ«K›ŒO‡÷S⁄”NŸ’M⁄÷N◊œH◊…F÷√BÀ∂6ÿ«Eÿ‘N’ŸP“⁄P—ŸO–ÿN“ÿP“ÿP÷ÿQ€“O⁄∫CŸñ.Œw÷x ﬁã-ﬂß:Â√H› G÷ÕBÿ—C‘Õ?—≈=‘ÀB◊÷J’ÿM’◊O”’P”‘T’◊X÷⁄_◊€bÿŸb’‘`—«X“«[—…Z…¡T¿≥K≈ÆN«¢J±|6îR"l:NG*6D-!/*<.*?.OhSbiHhQ6VA1Q<7R?1J7+B0+>+$5#!2 #4"#6##9$+A,.A..),=+.?/0@38E<;JC:J?&6+;M?'<+";&/L6?aI>bHEgL7T83E+5C*0?(:L6M[J+9*#0#0!. -7F3[hVIUA<H4:B3JRE[gYYgX'3%8F5IZGj|d]qV?S81D.#9$*(;'-C,#6")&#-"&!1F3?]CDeJ`{h`xjh}tÉîåxáÄVf\OcXsâ}â†ñÑùôîØ∂º÷„√ŸÁgyáIZaqÉá}èõõ¨¿äòµ¢∞ ñ™µqáÖe}pG_Q@UPDW[àõ¨£¥Œò©√üØ…§¥Œ¥¿⁄msç:?U(/?%1@Q[úÆ∫≠ΩÕ≠∏Ã+-F/((%(										
+	
+
+
+
+
+						$#& .!$!$		
+
+									,-(%& !( ")!!
+#*;(7J6$*(9'1D16I68M:5J73H7-D26M;*A1"9)6$'>,'9)"3# .0!7 ,F+A^BRnWHaN8M>)9,)7* 0#0 #9$+C+3M45R66T:7U;7U;4P73I4)>++@--B1'9++=/.C44K;<`D9^?7\=6[<4Y:3X96[<2U70Q40Q2.Q0)L+$F# ?<94*!
+	#>OEJbRMjXYxfgàuBhQ1W@0S;-P8.P8+K4%A*%?&70'D%5R36T2/$(.#!3% 5$4#!5*#33=KXäñ∞áï≤ï•øô´¡ßºÕ~íù_q{ÑïümzägxÇ]qp<RF=U=HaC-A( (7I;*)02 1,);+4I80G3+C-"8#,(?+5N;*E2+F32G8%+!-!#! "+&#$ "+!(((). . / 1 /")#$1'!1$.!+))&"()#;<4::2>=8;:5=>8<=57808919;0&'
+$)8#*>"%<$80#: '?%'?%'?%40 6!'?')C&&@#!94.0 7#<$<"&>((>1*?6)=4+:3$/)
+
+! 
+" "")!&$#&% ) 2"./"5"!4!&7%-) (4(&4')"!-!&2&'+8<èèQµ≥`¿∫\∆ΩX«∫R«ªO–≈R“…R÷ÕT÷ŒQ÷ÕN€ŒNﬁœP›ÀK·œOÂ‘R‰◊TÂ€WÁﬂZÍ‡\Ìÿ[Í¬P‰¢A›ç8„êBÔ®VÒ≈fÛ”nŒlÿ∂T›πXÓ—kÌ‡nÎÈpÍÏqÁÌsÈÒwÁÔvËyÊÌyÂÏ|ÊÍ|‰Â„·}·€y‚‹|‚‹~‰›ÇÂﬁÉ„ﬂ~‰‡|Â‰z„Âw‡„r‚ÁqÊÈtÂËuÈÂyÍ›uË÷pÁŸlÌ„pÍÏqÊÌl„Ëg‰‰b‚‘Yÿ…L·÷V·⁄U‹ÿPﬁ€P€ŸPŸ”K€ H”æ>“ø>€—MŸ⁄P“ŸM—⁄M—⁄M“ŸO“ŸO”⁄P⁄◊R›ŒMŸ∞<ÿå*“t€y €à(ﬂ¨9·∆EﬁŒE⁄“CŸ—B’Õ>‘»>ÿ—E◊‘G‘÷G”÷K”‘L””O”“S÷ÿYÿ⁄]ŸŸ_’–Z—ƒR’»Vœ∆Q«ΩJ√∑K≈≤Lƒ°GπÖ:ôW#t@MD%/;% ,%5(3J8TpZHhQ9YB8XA:WC0I6'>,)>-1C32C1"0/01'=(-B/ 3 -1B25E89I?>MHAPM?NG$?OE-?1"9%$@*4V>?bJGiP@\C8J22@'/A)2D.4E3*8'7D3#.+* 1L]JFU@?N91=/(4(5C6M[N)5'AL>FSBGT@FT=;J37F32C1&4#*;).A./%&!+ 		,@\E@^FÄõäaxng{yÄêêó••ÄåäK\ReymÉôåà°õ`y~à¢Ø∆‹Ò∂ÀﬁzäôuÖîù¨¡ò¶¿ì°º¢±∆dw}G^V9TE3M@;QOrÜè©æ—ù±…°≥…≠ø’°≤Ã©∑“´≤ŒikÑ)!$>QXï´∏ºÕ·bgÑ:;WIKbJObJObLRb58I!
+	
+
+
+
+
+
+		
+
+	
+	
+
+
+		
+
+ !$*% " 
+
+
+													&)"(.$&,",3+"1B/3D1#. ""# &(%#+*=*)7(*  0%=#,I-QoUjÉnYp^>P@.<-!-!&$.$<$/I.4P73O63Q73Q75O66N64L6/F2$7$"5"'<)<S?5\=7^?4Y:6[<3X96Z>4V;6X=7Y>3V8/R41T4.Q0*L+'F&#B"#>!8
+	
+
+	#O`ZTi`jÑweÑtDePbào@gL2V<0T:/Q9.N7$B*#?&!;".%?"@]>:Z5.$,"#3("4&3$3$&7-'77:HSáñ≠áó∞ç¢µÇö¶e|Ñ9MT'7FVcvï§πÄê†Üô†EZU8M:BU?
+=J@(8+(-0/A+&8">V@7P:0J1!9!4!.-B1-D2+F30L6,C1$!%"."!-!!  )!'$	)')('+/!/ -,,#0&#3&/")($
+45/891-.(./)58/8;058-47,69.8:/;<4<=546+-0%&)/5'&2-+#5'>$*C&+E('A&10$:#)A'%?"&A"$= 52#:#:"9%<$;!$7#/'0:1'.&		""'*#'/$%!! ',0!4!4!2!4!#8% 3 , .%+&6)+#!% *# $14ÅÜF¥≥`º∑Y¬πRƒ∏L∆∫JÕƒM” Q‘ Q“»M÷ÃP‹—Q‹œM‹ÕL›»I‡ÀK‚—O„◊QÊﬁWË‡[Èﬂ[Í’XÍ¡O·£@⁄å9ÍùMÚª`ˆŒlÙ◊oÊ∆a⁄ØQËΩ^Ò÷kÏﬂmÍ„nËËpÁÌsËwËÒzËÒ|Á}ÊÌ}ÂÊ~Â„~‰ﬁ|‚‹|‚Ÿ~Â⁄ÄÊ€Å‰⁄{Â€yÂ‡zÂ‰x„Êu‰ÁrÊÍrËÎxÈÂwÁŸp‰”iÁ€kÏÁqÏÓsÁÏlÂËg‰·`ﬂ‘X‡“U„⁄W›ŸS›⁄O›‹N€⁄N‹‘K⁄«D“Ω=ÿ E›’N÷ŸN’‹P”‹O‘›N÷›Q”⁄N◊€P‹ÿRﬁ∆H◊•4—}⁄v›~$⁄å'·µ<‡ Cﬁ”Cÿ“>◊œ>’Õ>÷œA€’Iÿ“F‘”E÷◊M÷◊O’“O’“QÿŸY⁄€[⁄÷Y‘ÃP—≈M”ƒMÀ¡H√∫E¬∂H√∞I≈¶Iºç?†_'xCL>!!)+"2%3K;=ZF8UA8U?;XB*E2)@.(=,,C1+B./D30B2/@0#4$-$9&,C/ 5$.!3@6FVLKZU@NN>NM@PM)#@QG0E6(?++G0+K4:\DEeNTpY?V<2D,(>''=(1D1(9'/<+%0( /&7%*=)3F2AT@;N;9K;;PAAQD8B7DLAHPCZbSen[T]JDM<<G7;H65D1?P@+=-3"/!"0#	
+ASCH_Mä¢íhwNaeñßØ∆’‹»÷ŸxáÇbsiyçÅaxp3JP]tÑ≤À·√ŸÒ´ª“vÖúßµ–úß√®≤ÕÇçüFUXFZQVl_WndEZ[ù≥æ´¬“îÆΩó±æ{ï¢pâü°µŒ¨∑”êñ∞,!xãô∞¬÷Üçßpvé_fx`ixiuÖYeubi|mrÖ&(5
+	
+
+	
+
+
+
+
+
+
+
+		#"."'$!
+
+		
+"(0%,6+!( $
+&7E4)7&'/$"' +&9&(6'#)+B((B%'A$B\CZrZZsV:Q7&5"&!"3 ObL9L90E2/H21M42N55O65O64L42E/1D.@S=DZE8_@5\=8\@5Y=;_C9]A>`E>`E>`E>aC;]B4W92W6/T2*M,'F&$? !5
+
+
+	K[X_to|ñçwñáVwb>eHCjK<aB5W<3U<0P8'G/%C)"?#9#= GdE5X0,J(!,"!1&."**-"2(!!!);HXè°ØlÉãH`d#6:#+&3Fåò≤âó≤Çë®§∂¬fzy1F5:M9	'2*>NA+4#!4 HX>8J0C[A0J/*B(53 /'<-,C3,G44P:1J5&;( " .!)7(!-!  $!%))*)&*,. ,- ""/% 0#*%"
+	560'(" #& # !12*!"#)):')@&)B%(B%%?$10"9'@#(C$#@!82$;&?!%> %>$=#:/#)/%"%
+
+
+
+
+	
+
+""$(!!#+0 3 24!4#4!"7$//"3!*)7("0#!%# &16{B∞≤_ª∏Y¿πQ¡∂J∆ªHÀ¬K—…MŒ¬Jœ¡G÷»M€–P›”O›—KﬁÀJ›»H„œLÁ÷RÁ€U‰⁄T‰‹WÍ›[Ô’ZÌ¡TÂüGÁöHÔ≠Wˆ√g¯◊pÙ◊oÂπZŸ´MÎ≈bÔ‘iÎ€jÊﬂjËËpÁÌsÁÔvÁÒwÁ{ÊÌ{ÂÁzÊ„|Â‡|ÂﬂÊ›ÇÁﬁÉÍﬂÖÂ⁄~‚”t‚÷r‰ﬂw‚‡qÂÊoÂÈpÁÍuÁÂtÂŸm„’hÈ‡kÏÍqÎÌpÁÏlËÈiÂ‚a‡÷Z‰Ÿ[„‹Xﬂ€Sﬁ›Q€⁄L‹€M›◊Kÿ«CŸ∆Cﬂ”MﬂŸQÿ€P’‹PÿﬂQÿﬂQ÷›O◊ﬁPŸﬁPﬁ÷O›ΩB‘ó,“w€v⁄} ›ñ,‚º?ﬂŒB›”@’œ9÷Œ;’Õ<Ÿ‘D›ÿIÿ“F÷”FŸÿLŸ◊PŸ’PŸ‘RŸ÷SŸŸW⁄’U‘ÃM–≈I–¬G«ΩA¿∂=¿µB¬±Gƒ¶Fºè>°c(zEE6$)&2$3H9@XH9VD=VC<UB1J5'>*4#&;*,C/#:&4#*<,4E51B2$5#(;(-D0.E19K;CSHDSLTc^JYV@OL8ICCTJFXL4I8+D.1M4*G19V@OoXOmUQkR/G/&<'!6#)<).?-)7&&5"',?+0C02G4&<'1I34L6UlX@WCAVE<J;U`R)4&@H;X^Pfm]ioabj[JUDS`NBPC:J=<QB<QB>KA$/':D<NYQJZPrÖxåãk}âµ≈’¥¬œ√–ÿhvvpÅ{wäÜK_`BVacxã©¡ŸΩ“Ì≈‘Ò°ØÃ•≤“¶±œ¢¨≈^jzZjjQd^C[NC]TJdc|òúyñûkáí`|áQkzayëØƒﬂ¨∫◊òû∏2!]o{†±≈W^x8(%)9juáekÅ?DWOQ`
+	
+
+
+
+
+
+
+		
+
+
+
+
+	
+
+
+%/&&# !"#!""$+#&0%)%*#"
+%1#:G6!.#"0!+<,'5( #*='2K-&A",,B+I`D?S80?,&!-hyfESD8H;3H5,E/,H1,H//G/2H13G.7K2@S=@S=8_B8_B7]D>dK:aD?fGChI@eF;^@4W96X=9]A;cA4\9*O-#B#(
+	
+
+			
+
+
+! BPPMc`màÅ{õéqî~BiJ1Y4/U0/R15V91R5-N1'E)'D&#@")D%IgCFk?0P)
+%/$(:.)>/#8)+
+	
+$$=ML,A:("%/fqáÜë≠guíö™√ç†Æ}ñì 8(:R<!DTI0E67L9!5TcDJY8BW8.E)$7! 3 5"0!';/1G:2K84P:3L6!8$  !"&&2&!+ !!
+	#)'*))()+.#.#*!1& 0#& #
+
+23-!"
+	+,'23-
+'4#->+,C)%=#'A& 8 /#6 (?#'B#$A"!>:4#<&A"&A"%@&A %@%>!(:$!()$'(# " "%&&,.222 3 !4!!6#4!,1"3!%6&&4%%	
+#'$# (+2u{?Æ±`∫∫ZΩ∫Q¡πL≈ªH…¿I ¿GÀ∫Dœ∫C‘¿G÷«H‹“Lﬁ’Lﬂ—JﬁÃF„ÃJÁŒOÂ—N‚—M„’RËŸXÏ⁄\Ò“^Ì∑SÂüGÈûKÛ±[˜–k˙€qÒ…g”ßH‚±TÚ»fÏ—fÈŸhÈ‚mÏÏtÈÌrÊÔrÁÔvËÌwÂÂwÂ‚yÂ‡|„›{ÂﬂÅÁ‡ÖË„áÊ›Ä‚œsﬁ k‰÷s‰‹o·‡jÊÍoÊÏrÊÁpÂﬁjÁﬁiÍÂmÌÌqÎÌnÁÏlËÈi‰„d‰ﬂaÊﬁ_„ﬂY·‡T·‡Rﬁ›MﬂﬁNﬁÿL‹–Hﬂ”M‡÷P›ŸQ⁄›RŸ›R€‡R⁄ﬂQÿ›M⁄ﬂO⁄›N‡‘Nﬂ∑>”é&Ÿ{!‡|$ŸÅ ·ü/‰√@·“C‹–>‘ 5◊–:Ÿ”?‹⁄IŸ◊F’–A÷–D⁄ŸM‹⁄Q€”NŸ–M⁄”O⁄’S⁄’S”ÃJ–∆CÀ¡>¬∑7¿µ9¬∑C¬±Eƒ¶DΩê=®h+IG605!;I:BXK:UD=XG;R@,A.)>+.C0(;(.A.,A..+,=-HYGk|iVhR2E/.F00I34K7ave-A6Sd\IUQ'4-&6),>..C0.F0/I.+H*/I0(D-:ZCOqYQs[B_I4!-$5#0A/,=+218O;1H48O;8Q<>WAD`I<X?BZBPhPE[D<O;+>*'5$,8*DOAXbWck`W_PyÅrovnLVNJWNXh^ANE7B:7B:JTLT]ZOY[gv}ãõ®õ™øî†∏∂¬“ñ£¨pÄÄvààfxÇÉñßì£º{å®ó¨…Ω–Ó√“Ô±ø‹û´Àº Áîû∑kwáQcgI_\Sng_}u^}x]}zWwvNmpOivqáû≠¬·±ƒÂ¥¡·ovê'(:"yÜñëù≥<3)'+)2&
+
+
+		
+
+
+
+
+					
+
+
+	
+
+
+!&")!%,$%,$#$' #$
+	0=,7D3&6D5.?/"/%#%#/6O14M-.))6$.;)'/"%#4!^q]=K>1A65J96O:4P:2K6%:'':'*;(/A+1C-7I19`C:aDAhMBiN@gH>fD;`A/T3.Q13V61V7/T52Z78];4U6&>&
+				
+
+Xdb^uohÜ|vñârïQvU:`94Z3,P*,N+2T3.P/$E&&C%8*H&>^7InB9#0$%:+*A1+@//!'#5);PA6M=(<0,6?;H[|ä§xÜ£é†∏ó°Spl'D05Q8+C-/():0<QBAXD)@$YjHL^8=R1+?#'9#%6$);-0$/C70F94M:/K5,E/*!"$! 
+	'%"!		
+%(&&()*(+ /#%7)'9+,#$%01+	
+
+%&!450'!/"3  3$:%3-!4&?"%@!$B  = ;63&@#%@!&A $B !?!:#6 '	
+-.)+,& "!#	$%*).1022"5"$7$"7$0/1#6#"3#$$ (((*!))0gj1´Æ_∏π[æºUøªO¡∫H«æI∆∫B…∂@œπB–∫B—Ω@÷»Cﬁ“H·—HﬂÀD·∆E„∆HÊ LËœPÁ‘SÂ÷UÈ‹\Ó⁄aÒÀ^Á±OÂùHË¢Mª[˙”l˙‘o‚∫Xﬁ´OÒ¿cÔœhÌŸiÎ‡lÎÊnÍÏoÁÌo‰ÌpÁÌs‰‰r‰·v‰ﬂy‰ﬁ|„ﬂ~Â‚ÖËÂàË·Ü‰”w‹»i‚–lÂ⁄n„·j‰ÈkÊÏpÊÍqË‚jÈ‡gÈÂhÏÌmÏÓoÎÌnËÈiÂ‰eË„eÁ‚b‰‡[·ﬂV„‡S‚ﬂP·ﬁO‹◊H‹”Hﬂ÷M⁄‘J›€R›‡U€‡R⁄ﬂQ⁄ﬂOŸﬁN€ﬁO›‹NﬂÀHﬂß8◊á$·&‰Ç'‹à%‚ß3„«@‡÷C€—<”Ã6Ÿ”=›ŸD‹⁄G÷‘C÷—BŸ”G‹€O›◊O÷…Fÿ G›‘Q›ŸTÿ‘O“ŒIŒ∆?∆º6¿≥0√∏:√π@√≥D√™Eøï?¨o0ÄKM<@H3DUE:RB@[J6Q>(?+*=*&9&,?,,?,/B//B..&*0A/]oYap[CV@0H22N7";%/F22&BRH@MD=J@,3 8"*D++E(*D'(@&'A((F.AcKMpZUva&=+."0!+<,0E40/K59U?2N8<XBEaK?]E>ZC<X?AYAOgMC[A8P88N9BUB7E6BNBYd\wÅyck`dla{ÄyäëäÖêàÉêâr}wephZd[_eadilêóüØπ≈•∞¬Üê©tï¢´º^kt`rvÄîõÆ¿‘∂«„¥≈„õ¨ °¥“≈÷ÙÃ€¯µƒ·Øæ€π…„≈‘È¨º…j}Éi~^wsSpkLjbIh`Cb\dÇÇØ…÷´¡ÿµ Á∫ÕÎ≠ª÷-5J"%4#, 8EKñ§±juã975!:CGb^b}ÄÄòIHZ
+
+
+
+		
+			
+
+
+
+
+
+
+
+			"#  #"*"*"*$  & &#!
+
+6A3)4&  "->O=->.* )!!( $ $+B%<U51C+)#+#+$* $"!.A-QfS=MB8H>&8*0G55N96O:1F3&9&%8%*;)-<)-<'=fFAjJDmK:d@2\8'O-*O0/T5.S2/T2+S1-U20T0.M-1
+
+
+	
+			$)%@KE\qh|õåoêZ}geäkKqL>d;9`45\0-R)-Q-)K* =92P.Ee>;`48
+&/! 7%$=((A+4 .E36Q><YEIiTGdR0E>3GHI[gÇï¶Äí®†µ∆ä¶™&E=0S;0S5.O2&B+(?-#9,, >TG<UB9S8MeAI_9:O0'; +<)/@0+;1'803G;3K;*E26R</F2+""&!&+!2""3##4$%6&"0+" "&$&)+! -#+ ,*<,-@-%$% *+&
+	.0+"$		 ,/01 8 'B#"@#B"!>"='@#!: 7!8$= &A"#@!$= - 46302--0)*-&
+
+
+
+$#.&*..0/ 3 !6# 5"%:) 5"+0%8%$5#(!"$$%&%)^^(•£X∏∑[æºWª∑KΩ∑E≈∫F«∏C«≤;œπA”ΩE“Ω@“ø>◊≈?‹»A‚ D‡¡BﬂΩA„øEÓŒUÍ’VËŸXÊ€[Ìﬂb‹cÏ \Î±P·õC„°J¯¡d˚ÿrœh‚¥TË∫\–i€nÍ›kÊ‡hÍÎlÁÏkÊÌlÊÏn‰ËpÁÂvË„{Ê‡~‰ﬂÅÊ„ÜËÈåÁÊâÂ€zﬁ–m‡—jÂŸm„„k‰ÈkÂÎoÈÎpÈ‡gÂ€`È‰dÌÌkÎÓmÍÌlËÁhÈ‰fÎ„gÈ·dÂﬁ\‰‡Z‰ﬁT‚‹P·⁄Lﬁ◊I‡ŸMﬁ÷M€’K·‡Tﬂ‚U⁄·S⁄‚O‹·O‹·O‡ﬂQ‚‘M›∂=⁄ë+Ÿ{!‚}%ÂÉ(ﬁè&ÂÆ7‚»?ﬂ◊D›◊Aÿ’<⁄ŸA‹‹F⁄ÿE÷‘C⁄’F⁄◊Jﬁ€P›”M”æ>⁄«F‡ÿSŸ⁄R’÷N–ŒE…¡:¿∂0¿∂2≈∫:√π>≈∏E∆±Hƒ†H∞v6}MTF)GP;=P=@YD0L6)E/(?+(=*&8($6&)>+.C0*=*. .+-1?..<+6I52J47S:!;"4-&#-9- 1!(>)%>((B)'A()C((@(+C+*D+*H0HkU[|iNiX%:+ -#"2%/D3&B,;[D7YAAbM?aI:ZCB`H9U>2L37M6@S=@T;>Q;>T?>Q>:F8>J@KXQcokyÇU^Y\c\Zd\Wd[jzprvÄäÇÜãÑÉÖÇ°¢¶ù†©ÜäïsyázÇï{Ñïêö§N[cNahç£∞¿‘Ï√÷ˆ¬“Ù ⁄˚’‰ˇ‘‰˛ Ÿˆ∏«‰≠Ω÷úÆ¬õÆΩìúSflYmnausf{vK`Y@UNB\SNkgï¥π∞Ã⁄∑Œ‡∑ €áî§&3<&+68FVSpÇÇü≠∂ëû±èô¥ñúº°¶ƒ¶¨Ã∞π⁄ù¶«y|ù&&B!	
+							
+
+	
+
+								'('* *%'$.%#-$) %(&""#+ )1&#+ "!"%$! !## """
+	"*  2>06I6+>+ ,# &:8Q1@W;!3!,"(&%)&6O9MfQ7K@/>7$5+#5',C/5N87P:0I4#8'.!,/;-AjH@jF0Z4&P*&P**T0.U84X<8]<9^<1Y4,P, =6 	
+	
+		#%"5:47C9J`STsa\}jNq[NpUHmK@i?3]//V'(O"$I ,N)<#A6V1IlD8[1/) 5$$='+G..J1-K3EcKMmVSt_VwdZvh\uoUmmQjoé§Ø´ƒÀxñî@2+N6+P11S8-N3+H29(&>01I;9TC4P:>U;AU9@T;2E/2C1.>3Sb_GWT5I@%=-1L92N8!8$" !%
+(- 1 3 !4!!4! 3 !4 %6$"3!#4$#! !"#$"(!4!$:%(						
+	#% %&!
+
+			%#1$,+!;"(E'&C$"A!!>#>%> '@#4)$;!#;!%?"%=#0%'"794?A<9<5-0)"%#+%-##&.!%$1$1)
+	,0/114!"7$!6#'>,2.4!1!2 -,)"$!%RN°öT∑≥\ΩªVΩªN∏µB¿∂C∆∑B≈∞9…≥;–∫@”æA“ø>œª6’ø8ﬂƒ?‚ƒB›ª=›µ<ËƒLÎ“TÈ◊WÌ‡`ÔÊeÔÁhÚﬂfÙÀaÁØN€ò?≥X˘‘l˜ÿlÎ¡]›≥QÌÕfÙﬂrÓ·nÊ‡fÂÊdÂÎeÊÌi‰ÎiÊËmËÁsË„{‰ﬂ{„›Â‚ÖËÈåÈÍåÁ„Ä·ÿq‡”kÊ‹m„„k‰ÈkÊÎmËÊk‰ÿ`‰‘ZËﬂ^ÏÈfÏÌkÎÏlÎÊhËﬁbÍ‡eÍ‡dÁ‡^Ë·]·€S·€O„‹M„‹M„›Qﬂ‹OﬂﬁP·„Tﬂ‰T€„R€„P‹‰Pﬁ„Q‚‹P‚ F€®5ÿÑ$ÿr‡x!‚Ñ$‡ñ)Â≥8·Ã?ﬂŸC›ŸB◊ÿ>€ﬁEŸ‹C€ŸF€ŸH›⁄K‹ŸLﬁ€NŸ–G—Ω:ﬁÀHﬁÿP◊ÿN”‘HÃÀ?√ª2¬∏2ƒ∫6ƒπ9ƒ∫>∆∫D«µI¬£H¨z5ÑV%YL,HP9AR?1H4#<&%>(*A-+B.(;(1%:'0E2(9''#/#&2&!-*+,"8#/G1.D/1!0#&("3!.D/*C-&?)(A+/G1.F.2J2/G/%A*.N9Yxf`}k9QC'$#:&2P8BdKCeM9[C8XA>WB3J6/B.2E14G37I3>P:;N8=S>1F3/=.2?58HExÜáùß®wÄVa[`mcN^SDVHHXMYf]qvpÅÄìñù©´∑Ø±æü£ØzÅëÑéöàìôbqvkäíß∫«‹˜Àﬁ˛ºÃÌ√“Ò’Âˇ“‚¸±¡€ö™√ü∞¬`tZnwdw}fy}yããÜôó©∫¥vÖ~O`VG]Q'A8*HHå©≠ã¢™nÅàwÜâP^_=KLTdcj}yäûú¶∑ø¨ºÃ≤¿⁄∑¬‡¶Ø–FPs'J#0SMUy@Ee0"
+	
+				
+				
+		
+" ,  ,, -#/!(&4'(6)#/#(*#1" ,""	  " %!!& %*$,1*#+ %$ $(''%#$$## "" !"$#
+	
+
+ $5C44E3"3!&%$ ##5.E(B[>3G.%2!#+$%(/9U?D_L3G<#4,%5+!3%1*B*3O67S<2I73$- #1$0Y1'P(*R-/W21[76_=7^?<aB<dB?e@<`:7U3-  
+
+	.1*7<57E8ZrbXwe^}k\}hjét;cAEnDGqC4[,-S$)M!*J!?+K"5Z.Fk@:]5," %+!7".H/=W>8V<DbJUu]@`I7WBPo]FeUPo`:XLC^YbzBbU1RA'G0*K0*J2/M5,I3-H5*B2+A4?WJ'>4GXP/@6_qcK]M>NC7F?|äãbtv6KF2L?4Q?/J7.%!$!/"0 020 12 3 3  5" 6!#6"0
+	&-!7"#6",$	
+
+%&!
+
+#/#-)%?&&C%#B""? "? #>&A"&@#": &,.%;$%<"-#("$)"#0$3&5 $3%4!'6!"1 /$(0120 5"#8%"9%#8%/3 42020	  #PIõëS∑±]∫∏T∫ºNª∫FºµA√¥?ƒØ:∆∞8À∑<—æ>‘√A”¬>◊¡:€√;‡»B‚≈Cﬂ∑=‰ºCÈ…NÎ”UÎ‹]ÌÊdÏÏhÔÍjÒ·hÔÕ_‚¨JÊÆOÛ a˙ÿlÛ–h›∫TÁ«`ÙﬁqÂoÈËiÊÍbÊÌcÊÓe„Èe‰‰hÂ‚mÈ‚x‚⁄u‚Ÿz„›ÁËãÈÍåÁÂÅ‰ﬂw„ÿoÊﬁoÂ„lÊÊjÁËiÁ·e„ŒYÊÕWÁŸ\ÈgÌÌkÎÁiÌ‚fÍ‹aÌﬂdÌ‚dÎ‚_Ë·\·ŸP‚›N‰‚O‰‰N„„Q‡‚Q‚ÂV·ÊVﬁÊS‹ÊR›ÂQﬁ‰P›·N‰ŸL„Ω@⁄ö,€~!ﬂu‡y›Å›ö)ÂΩ:‚”Dﬁ›EŸÿ@Ÿ⁄A€ﬂD⁄›D‹⁄G‹⁄I››Kﬁ›Mﬁ€L◊“C÷ @ﬂ”I⁄◊L◊÷HœÃ=…ƒ5¡∫.∆º6«ø:≈∫:≈∑=ƒµB≈¥H≈´L≥Ñ<à_)dT2KM70<('8%+>*%;&*B,,D.(;' 3$:%5H4(6%%&",!$0"$1  -)%($5##4!#2-!.*1(@(*D+*C-1H6F]K2J42J2/G/)A+ 9&B]LcpVrc"6*2!,H1AbG>_D7W?=YB<Q>@L>GMAGM?:B38E45F4'8&0C0>V@&>("3!4D:QccüÆ≥ü™Æ{ÖÜTaZL^RD[I6O<?VFWi]nyultw`frõ¢≤©Øø°ßµíò¶¢´¥yÑà[jo{éùê¶æø‘Ò≈ÿ¯»◊Ùœﬁ˚»Ÿı≈÷Ú∏ ‚äõ≠ÖòüqÉÖ}èèãõõë°†ï®¶ß∫∂∑»¬çöê`nacug&:.+E<TmgtâÑnÅ}uÜÄm~vsÑ~m~xrÖÅÖóôö´µ¿—„Ææ’∑≈‡t|†B,O•µ◊±¿·ö•≈~É°;<X&
+						
+				#("0!-#1"+9**8+#1$-;.#3&*' 1!*;+#0&$ #&$!(($%$#&$&%#%#%$%&%
+
+
+%3$7H63A2($%#)$& /2<U8KbH#2/;-*2%!+ &/<WDB]L.B9#2+!3'&6)#4$/)C*4P75Q:.G2$9($4'(Q)*S+0V13[63]96`<:b@>cA?bA?a>>Z4+C#   		)1&.:,0A1A\IPp[måz{öàdànDiJ<b;/X,,V&,T"*P&J#G+O!.S'Be=8 !##%)"8#4L46S7B`DFgL9Z?/O7*J20P9Ss\*J3+K61P@7VG;ZH3T?*J2%E-&D,&D,)G/-I3,E2*B44KE/CDÅêóIX]fvuarl~çÜ`oljw}[lt7JN'=:-D:3K=5I=&6+(! '$,.!0 .//.-.0154!7" 3-'		+,0#6"$7#"5! 1#	
+		
+&'"
+"+ 1*B,$A% =#@!#@!"<'A$'A$4% )0'%$.##*".8-$2#&7$$7! 4"611.)#).25 4!$9&%<($;'4!/ 6!4334.#
+
+!NFïâM¥¨[∏¥Qπ∏LΩªJø∏D¿¥>√Æ;√™4»∞4œ∫;“ƒA‘∆A”ø8◊ø7ﬁ∆>„«B„Ω@ﬁ¥;„ªBÎÀPÍ’XÈﬁ^ÏÈdÎÌfÏÈfÓﬁdÌ«Z‰µMÊºPı—c˘ŸlÍÀ_‡¿YÌ’iÓ‰kÍÍhÁÎ`ÊÌ_ÁÓb‰ÍbÂÊfÊ‰mÈ„uË·yÊﬁyÂ·~ÊËáÈÎäËÊÅÂ‡x‚⁄oÊﬁoÊ‰mÂÊgÊÂgÈﬂc‚«R‚≈PÈ◊[ÚÈhÎkÎ„fË⁄]È⁄]Ó‡cÏ„dÍ·^ÂﬂW‡ÿO‰ﬂPÂÂO„ÊO‚ÂP·ÂR·ÊTﬂÁT›ÁR›ÁR‹‰PﬂÂQ··OÁ‘J‚∞7◊ç"‹ Íá*‰Ü&ﬁç$„≠3È…B„ŸF›ﬁE€‹C€‹C‹‡E›ﬁE‹€E›ÿF››IﬂﬂMﬁﬁL‹⁄Iﬁ◊IﬂÿJ‹◊H◊“CŒ»6ƒº-√∫/…ø9∆Ω:∆ª=¬≥<≈µD…ªN ≥SºìDïk/iL$D41/(/*7%(;''=(,B+(>'#6 %8"8I6,9(! #!,$1 "/ -'&$1 * /*9&,/'=&*D+)C*+B.G\MF[L:O<*B*.D-.D-%<(5N;Sr`cÉn6Q>>ZD@^D:[>7X=5Q8:R<K\J_g\nog[]RJN@6A17H6,?,+@-?XB/H3$6&7H>yãã†≤∂•≥∂p~~aujAXF8Q>4M88O=OaU`ljVagcl{®∞√∂æ”©∞√®Øø≠µ¿ozÄbpyáôØ}êÆ¨¡‡‘Áˇ›ÓˇŒﬁ¯π ÊªœËó®∫tÜêÖóõí¢°•≥≥∂ƒƒµ≈≈äúûô´Ø≠øøÑêågtjbreI[KE\LcylìáÉïâmqrÑxÑòçbuotáÖê¢¶©π∆¿œ‚µ≈‹∫»‚æ…Áô¶»ù≠Œ∂…ÈªŒÓ¶∂◊¥øﬂπæﬁ&&B 	
+
+&'3%!/ %6&(9)"3#$2#,:+(6)#1$)7*#1"( .'8(,=-!/"(#
+	
+#)#"'#$#$&%')$$$)&%'&$
+
+4E33D2.:,)# &%&()%3"-!7 =S<0)5'/9.#-")!3#@[H?ZI->6#2+$4))9,$2#).&@'1O54P9/F2&;**T..X21Y40X3.X02\44]55Y39W3>V42C#&3	
+		"."*;+6L7;T>6R<IfRkàvÄ†ãvñgälVzV?f:1]**V!'R&N(N.R$4T-(C$%(--C.2L1/L05T54U6.O0,M0*K0CaGFdJ-K1#A)'D0.N96VA?aI@bI<^C-N3(I.0N4/M51L93J@9OMEX_`pÄp}éXfqBPSWcaHVVR_h|äóqåWhp/AE!42*;34F:9K=3E7#4$#4$%6&/"1# 2"1!0..//./3 45 4!2%3"$
+)-.5  6!5 #6"&4%
+
+
+
+
+	#$!#!)!4 %=#%?"#>$>!3": '?%0$$0$(6'$2!$5#+9*$2%*;+):*)<)%;&"8##9"!4,*"$*-3"8##8%&=))>+&;(1"7$ 5"4!"5"/00 !#E=êÉL¥´\µØO∑¥KæªJ¡∫F¿¥>¿´8ø§/¿¢*À≤4Õº:—√>”ø:–∏2◊ª4‡ø:„æ<›¥6ﬁ∞8Í¿GÎÀPÊ”SÎ„^ÈÍ`ÍÎcÍÊaÓ‹`ÍÕX‰øMÏ∆W˜ŸgÔ”e‚¡XËÃaÏ‡hÈÊcÊÈ\ÊÎYÊÓ]ÁÎ`ÊËcÁÂjËÁqÍËyËËzÁÈ~ÈÎàÈÎàÈÂÅÂﬁt·÷jËﬁmÂ„j‚„dÂ‰fÍ‡d·«P„∆PÏ⁄\ÂeÂgË›_ËŸZÓﬂ^ÔÊeÌÊdÍ„_ÂﬂW„‹PÁ‚RÊÂOÂÂO„ÊQ‰ËS‚ËT›ÂQ›ÂQﬁÊR›ÂQﬁ‚O‰ﬂOÈÕH‡°/‘Å‚é+û:Áö2‚•2Âæ?Â“G·€GﬁﬂEﬁﬂE›ﬁD›‹Cﬂ‹C›÷@›’Bﬁ⁄EﬂﬂKﬂﬂKﬂﬂKﬁŸI›÷G€‘E”À:À¿0«º,«æ3…¡:À¿@«º@√∑A»ªIÃ¬SÃ∫V≈°MØ=âU%^3B,50,5"0&9#2I/.E+!8%7!+:'(3#" "#)#0%2 #0"/%2!(((9&)<&+B(*D)(B')B,9P>HZN"4(H]L,B-/G/0H.-E-WqX;[CRt[EgN<]B8V:7V7/M1:V=7O9DVF]i_xxxwS[N:G69J79Q;8Q<<YC6Q>)=18IAqÑÄô≠´õ´®Qe\IaQ7S=5N95J7GXFq~tÇéé¶∞π¥¿Œ∆—Â∏øŸáé®≥ª–•Æøco}sÄëåú∂}çÆ¶π⁄≈⁄˘ªœÍ∑»‚∂ ‚ñ®ºfwÅn}Çzâå±ø¬¨∫Ω£∞∂ï¶Æé°Ø≥∆◊¡“‚ò•ÆdppgymWlYLcOhÅlç§êñ´ò_r_fxhdzmiÄxå°¢ß∫¡øÃ‹ö•π1=SSbyí§∫ó´√õ∞À©æŸ¥…Ê±ƒ‚©π⁄ΩÀË\`{ 
+
+
+
+
+	 ,"):*(;(0C01D1'8(%3$.:.) (#/#*)#1 *;)&7'!/"( 	
+	 &&$"!!%'''&($%%))&%(&% &6G5/@.'1&#*" &#+ "-$1 !-- .-+-#1"#/!%/$ , )&8(?ZG@XJ(8.%2+$4)%5(-(*4#(A+4P7:V?3O9*R/0U36X74V57Z93W3'F$,G&,A"'6%/',"&"			
+		'"-%+"0=3AQD@UDB[EB`HEbLB_KXuakàryôÅnëqlêjMtGGs>@m44_).V!,Q.M#8 
+		
+-C.0J/,I+2Q1*I)*L+%F)3T73T76T85R6)E,%A*'C,.K55U=6X?7[?8Z?3U:$E(%C+.I8Md\Tgkk{à3BW=IauÇìxÖéqÄTbcJVbö•∑Üë£¶≥ƒí†≠}åì<LI+!&8*.@03E55H5&8(-#8'6K87L9/D1$7$/0.--/000/0!/!		
+,- 3  6!":"6 $7$
+		
+ 
+
+
+	
+	!!/'>$%?"$? &?"-*5 '
+
+&4%':'+>*(;')<)&9&(:*':'#8%$9&"8#%;&(;%.+
+*1!7"%:'$9&&=)(=*!6#"7$ 5"4!#8%!4!1-,!";3ázEµ™[∏ÆO∏±Iº∂Hø∫E¿µ?æ™7ª†+ªù%¬¶)…∏4Œ¿9‘¬<‘º6“µ-Ÿ∑1‰ø:‚∫7‡≥6‰∂<Î«LËœNÊ⁄RÈÊ[ËÈ]ËÈ]ÏËbÓﬂ^ÎÕUÁƒP÷_Û⁄fÌŒbÊ \ÌﬂeÌÈdÁÈZÊÍWÁÏZËÌ]ÂÁ`‰„dÁÁmÁËqÁÍuÁÎ|ÈÏÉÍÎÖÍÂÂ‹s‰ÿlËﬁmË„m·ﬂdÂ‰eÎ·e‰ŒT‚ NÎ‹[ÊcÏ·aÈ‹\Ìﬁ]Ó·^ÁdÔËdÍ„^Ë‡YÁ‡TË·RÂ·L‚·K‰‰PËÏWÂÎUﬁÁP‡ËT‡ËT‡ÊR‚‚PËÿM‡π8‘ä€ÖÌ†8¨A„•4Â¥;ËÃG‰ÿH‡‹EﬁﬂE›ﬁD‹›C›ŸB‹÷@›”>ﬁ‘?ﬁÿD⁄ŸCﬁﬁJ››Iÿ÷CŸ”A÷Œ;–ƒ2 ª*…Ω- æ4 ¬= øA»æC…æHÀ¡N…¡R»ªS»™P¡ïJ©q4çU&j?I144#1+?$F_A0I,6'9#,9'&. "%*(5#*7%$1"/-'(:$)?(+C)+E(+E*)A+%7''+ K]O3H5-E-5O4.H-?\@:]?;`A8[=3V61P10M1.H-5M53F3:J=IVOHSMRYRCMB>K:5F37P:3P:5U@@]KBXK2F;J`TiÅtawk8P@6R<1M64J5=N<S^NáéÜâìî†™≥™∂ƒ∏≈ÿyÖùLXrtÄñî°≤Äçûò•∏äò≥éùºï•∆ë¢æèü∂åù≠}èõ^qxcssestõ™Øƒ”ÿ≥¿»çñé†Æ¶ªŒπÕÊÃ‹ˆ∂¡’hr{aqgSiTOgQWoYjÇlvåwL_KM`MPdXavqwåë±√—ƒœ„^f}.	&,<Üú™ï¨æúµ…Ø≈›´øÿ°≤ÃæÃÊotà
+
+
+
+
+#1"':&*@)3I25H4):(%3$%1%**),#4"(9)(6' , 
+
+
+
+
+	"&%$  $%'%#'&(&)+((&() ()4&4B1/=, ( %&,")1&(3%!-'((&&%%#"!%'<)>VF=UG#3)'4+(8-$4'(6'$2#@NA3E5=U?B\C?[D:X@#E"&E%/F,/':&+<)%&."' % $#	
+ 	!*2G6AZGIaQF\O,B51E9Uk^fÅnKhTUr`YtcXu_QoWbÉdkèkdâ][ÉOJw<;g,6[(.N&A!9  
+ 
+
+		):(.F,)F((G'(G'(G'!?#1R51R3/P13Q53O6.F.,D,+D..J3;[C=aG:aFAeK=_D-K3.F6=PJXglP\lBLeú®¬çö´ñ§≠]lqETYî¢Øî°≤û™¿éö∞\k~m}ä&66"&'-'9)/D1)A+;U<.H/2.0,-++-,-,-.1 -
+	
+	
+&-"7$$='9 !9#.	
+	# 
+  ! "&3"(<#'@#(A$(?%# "  "&7'':'&<'&<'(>)&<'':'*=*&9&':'&9%':&'8%+*$-"5!%8$%:'%:)(=,(?+4!4#$6&%:' 5"!4 1*,$ 1+	|o:≥£Vπ™K∫ØF∫≤Cº∑BøπAø∞;ª•.æ°)æ•'¡∞, æ4–√9”¿6“µ-‘∞(€µ.‚∫6„∏6›µ2‰Ω<ÎÕIÁ’MÂﬁPÁÊVÁÈXËÍYÏÊ\ÏŸX·»JÈ‘WıﬂgÚ€g‰ÕYÂ”WÌ„_ËÁYÊÍWÂÎWÊÎ[„Â^„„aÊÂgÊÊlËÈqËÎvËÍ|ÈË~ÏÂ{ÁﬁuÊ⁄nÎ·pÈ‰n·ﬂd‰„dÏÁgË€[‰’TÍ‡\ÔÁbÎ‚_Ëﬁ[Óﬂ^Ïﬂ\ÓÊaÔÈaÍ‡ZÈ‡WÈ‚VÎ‰VË‚P·‹J‰‚OËÎVÂÎW·ÈU·ÁQ‡ÊP·ÂPÊﬂPÍ…F—ô"”ÖÔô2Ú´?Ï∞>‰Ø;È¡EË“K„€J‡ﬂGﬂ‡DﬁﬂEÿ◊?€’A›’Dﬂ”A‡‘Bﬂ’@‹÷@ﬁ›G›‹F⁄÷Aÿ“>”«3Ãæ) ∫)Õæ/—ƒ:Õ√? ¡BÀ√G»ƒIÀ∆P ƒR…æT∆¥R…´S√ïG≤{8ôZ%n=C42;2E%5N.+D&"6$6 *7&%#)  +"-'6#&5"(,+#5(>'-G,0I,*B(2%6&$2% 2D69N;*D+3P21P18Z99\;6Y83U46U67T63M26L5NaNJXK>KD7CAEON>C=9?53>.,=*5N98UA3S>?_JA\K(@0+G19U?=YC7P;5L88N9>M:@K:txjîóêïöù£¨≥±ª«√–‡ΩŒ‡¡‘Âºœ‡ΩŒﬁµ≈’¢±∆†¨∆§≤Õ†Æ…ï°∑âìünxzpxpÅwdumpÄƒ’‹ŒﬂÈ≤¿…o}àô™∫µ ﬂø”Ó…⁄ˆÕ’Ïu}àP]VFWEEXBCYBJ`KF\G@S=QdQSb[M\_àò•ô•ªó†Ω:?\/"8IQÉô§ì´∑∏Õﬁ∑ €ó§∑RYk'		
+	%3"&9#&=#(A$*B(&<%%8$):(*8) , $)(,&7''8():*#1"*			
+	'&* $" #"$'%$$&(+)**'')* (
+!/<+4A0(4&%!"' '' ,!/ -)&""%  $'-B/>VF9P@%7+*:/+;..?/(6')7(7E67H8<O;7O74N52N5#B  9(!( 
+"%!"! "-%7G<@UD7S=:WAKkV[xfIdUPhZbzlhÖs[{fVsalâunãuRsX8[;<`:@c9?c5?d1'H54Ha9G]7,<" 		
+
+	
+
+'5&1G0+E((F$*H&!@ "A"+M,2U4/Q0.K-3K3@S?<M:.C0*C.'G03U=7ZB<^F5U='C-$:-)96ERZyÅîèô¥äîØû´º°Ø∫4CH~åèmwÅU^oìû¥©µÕú¨√†±¡cuy*%! $/.!9!"<!9#;!4,,,.-..///1!0	
+
+
+"!3#%='!;"":$':'#	($&""$
+
+%')'#!% ! (:$(<#!4% !*!-!$2%'8($9&$9&%='&<'*@+)<((;'':'&9&':&%8$&9%.'% $2!$7#&9&'9)&8((=,"9'5!$9(%8%#8%!7"0)#"#"/)	xl8±üS∏®IºØGº≤Cπ≤>øπA¬∂>ø¨4ø•,¡®*¿≠*∆π/Àæ4œæ2“∏-–∞'–¨$‹∂/‚º5‚º7‡∏4Ê¡<ËŒFÊ◊JÁ‚PÂËQÂÈTÍÍXÌ·W‰”OÊ”RÚﬂ_Ò›b„œT‡ÃOÈ‹YÂ‚U‰ËUÂÎWÂÍZÂÁ_„‰b‰ÂeÊÁhÈÎnÍÎsÍËwÁ„wÏÂzÊﬁs‰ŸoËﬁoÁ‚m·ﬂdÂÊfÎÎgÍÊ`„›UÁ·YÔÈaÎ„\Í›ZÎ›ZÁŸVÌ„_ÌÂ^Í‹UË€QÈ›SÎ‚UÍﬂQ‚‹JÂ„PËÎV‰ÍT‰ÍT‰ËS€‡H‡‡JÏ›NÂµ7…Ü€äÙ£8Ì©:‚©5Êµ>Ì JÊ”I‰‹I‡ﬂFﬂ‡DﬂﬁE⁄÷?›◊C‡’Eﬂ”Aﬂ”?ﬂ’@ﬂÿBﬂ€D€◊@ÿ“<’Œ7–¬+ π#Ã∫(–ø1—ƒ:Œƒ@Œ≈FŒ…K »MÀÀSÀ≈S…¡T…ΩWÕªY–±VÀûMº{9ãR]AA>2A .G'0G+!8!3)6% %&-&#*#$ ( + -'6#%4!!0$1"1%<"7P31I/%;$+,:H9'#!6#-G,2Q18Z97Z95W61P03P1VqR8Q4=T:as]zàwgrjGRN>LLvÄmniYYQ8>0+8&-B1:UB7T@@`KHeQ1N88V>5Q83M43K3?U@SdQN]HEQ=ÄÑuµ∑¨ªº∑±µ∂ëñöq|ÄuÜçù±∏ü≥º°¥¬£¥ƒú´¿ö¶¿¥¿⁄π≈ﬂö•πmq|age_k]`q_brg|åâ≥≈œºÃ€≥øÀâï°ë£±¨æ“ƒÿÒ…⁄Ù”ﬁÙô°¨`lhPaQDV@CW>>T?J_LG]H]o_tÄ~~àëÄâöWazW]}_dÑ%'@*	%*5HN`qyXfo$/!			
+
+
+
+	#1 ':$%<"&?")B%(A$%<"%8"+<*->,#1"!-),"0!+9*'5($2%))
+			
+
+
+
+
+	 '+! ,"!-#(# !#$&%#" ***&(*(')*"-$,!"
+*2?.5B1!,$!$%*#&+$!)%&)+)&   &&5J9AXH;RB%9-,>0,</?P@/@0):*)7('8&)<(!7 $<&*D+$D8*4VXBmkR~}aTW:"&"%)$(
+
+
+##1$8M<E^KPiVRmZ]zddÑomäxoã|qé|mävjäsIiRkãvRr[iârjãp<_?$C#3(<!/C'
+,OhAJe:8R+' 
+
+
+
+
+$0C/'@#%@(F$;#B &H#(L&*L'/H+DUBiqb`h]=MB)?2&C/%E.$A+&B,'>,)>/6J?(87ER[Üë•}á¢åñ±û´æò¶±(88PZ[=@EVXdô†≥ú®æò©Ωù∞øå°§2G@- ##4" 3 45!9!#="'A&,F+*B(0.,/021#5"1*
+ ,#0"0!&,?,&>(#;#':&	)+>+)?*3I4"4$"&))+!)%#&
+	
+"*+7) . !#")*;+'9)#5%$6&"7&$9&"9%'=((>)(>'$:#'=(%;&&9%#6"&9%"3!'"3!%:'':'(:*1!#5%3""9'"7$%:'%:'2,( 	#*&&,'vl9≤¢U∏©LΩÆGªØAπÆ:Ω≥:¡∑<¡≥8øß-º£%≈≠/¬Ø,∆∂-ŒΩ1”æ1—∏*–Ø$÷≤(‹ª0Â¡9‡∂0ŸØ)‡∫5ÁÃAÊ⁄HÂ‰L‰ÁN‰ÁPÍÂUÈ›SÂ”MÍ÷SÓŸY‰œO›»IÈ€VÊ‡TÂÁVÁÌYÂÌ\ÂÈ`ÂËe‰ÈhÂÍiÈÎlÍÍnËÂpÁ·qÌÊ{È‚w„‹rÂﬁsÁ‚m‰‚gÂÊdÍÏeÍÎa‰„UÂ‰VÌÁ[Ë‹RÎ€TÈ◊QÁ‘Q„`Ó‚\Á’OÊ“KÎŸOÌﬁQÁ€K‰‹KËÊSÁÍUÂÍR‰ÈO„ËNﬁ·HÊ‡JÍ—C⁄û"”Ü‰ô&˜∞>Ó´8ﬁ£-Í∫>Ó…GÁ—GÂŸG‡€C‡›B‡€C›ÿ@ﬂÿBﬂ’@ﬂ‘>ﬂ’?ﬁ◊@‡€CﬁŸA◊–7÷Õ4“«-Œæ#Ã∏!ŒΩ)‘√5‘«=Õ√=À¬Aœ LŒÃQÀÀQÀ∆Q…√SÀƒYŒ≈\–¬_–∑[«ôK¶v6wU%K<6="62I/5!2)7&". %/$#*"!! (#))8%)8#(5!#13NeI0G-2",,=+/@.("1N05W65W63U41N/=X9JcE@W:5I.:L4M\G`n]lyp`ol<JJs}|`_[VRIOPBHO?JXI7L=AYI@]IMmVUu^5Q;1I3:M9J\FUhRat^QdN@O:oxc®´ò®¶óñíÜ}ynY[PMYOmÄz\nnJ]dÇì£†Øƒùß¬´¥—Æº÷∂¬ÿjl{efkkrj[gYq~uççéú©ó§µò¢¨Åãîäó†•µ¬∫Ã‡Ã›Ò“ﬂêö£frnbscYkSNeK3K5NeSlÉs}éÜèöúçï†ch|'-G:pvòadÉ/	
+	
+	
+	!/ *='(A$(@&*C&'@#";&=#"5"5"&7%#1"*, .#/!%1#&&$			
+
+
+"&),"/%".$'$! $%##* , -&%**))**"-$%3"4B13>0 (!&&)"+.%,2($,!!#!!#%%&$6M;AXH4J=&;,/A3-=0.?/4E5':'):*%7'2%8$*?,0H2,L'1K(AK0\_BjjHnkHWY4-1&)#%&(*,/2,0		*5'5F47P;A\IZudfÅpQnZJgSNm[Ss^_h^ÄgZ|aWz\:\A?`ESs[bÉhMnO1P0)#5-?% *C6V'4U&-I!  
+			
+
+(6%)=$";)D#;>%G")K(-L-9N;_lbryrrxvÄèäEZQ$?0$A-/H59N=EUHhxm+<2"2/DP\âî®Éç®ñ¢º¢≥≈õÆµ(;99F?LNM89=Çäóñ£≥†∞øáô£\pq'<5*'):("5"-.$:%&>&(B'+E*-G*&?"2+-3 73-"
+	$0$.?,+>(-C.3F3.?/&%6&2H3'?'&<%&/<23H74M77S:2N5*B,(#%* )+!* &!!%(#
+
+&	 "##)$6&(;("7&$6&"4$4!#8%&;(&<'(>)'=&$:%'=(%8$%8$ 6!':'#1"##!-"4$'<)&;**<,)<)':' 5$ 7%%:'"7$1+*#%!!)&4'+9*(6'*3*)
+sk:±•Yº≠Pª¨Gª≠@µ¶3π™3º∞6ø±4¡¨/ª¢$Ω§&¬©*ø´&»µ+œº/—º-‘∏)’∂(◊∏*‹∏,·≥,⁄™$ÿß$ÂΩ7Ë“AÊﬂH‰ÂK‰ËMÊÂOÊ‡N„÷IÂ”IÈ’N„œJ„ÃJË÷PÊ›RËÂVÁÎXÊÓ[ÊÌcÂÎe„Íf‰ÈhÈÏkÊÁhÂ‡jÈ‚pÌÈ{ÍÊzË·wË·vÈ„q‚‡e‚‚^ËÈ_ËÎ\‰ËVÊËWÈÁV‰ŸKÁ’KË“KË‘OÛÁaÓ‚ZËÿOÍÿNÏ€OÏ›NÊ€KÁ·MËËTÂÍR„ËNÂÍO‰ÈNÊÂLÍ‹H‰¿6€ô‰ó!È§-Ú¥=Ê®1ﬂß.Èº=Á≈?Á“E‰ÿD‰€B·⁄A‡ŸB·◊A·◊B›”>ﬂ‘>ﬂ÷=›ÿ>ﬁŸ=‹”8”».—ƒ(œ¡#Œªœº"“¡-’∆7”∆:Œ¬<ÕƒA”ÀLŒÕOÀ…P ≈P ƒR »WŒÃ_œÃe”∆f–µ^¬úUée/V:BA#.>$3G.4 1*8'". "!&)'4"'3%1"11C+*;(%(0<M;4E2+>(7T55T42Q2-J.0J/UnQKbF@T93E+.=&7F1O]Ldtj`pm8HHyÖÖ{{{DA<FH:RYIYeYEVL@THD\LEeN1Q:(D.)B-QgRfyc^q]L_K;N:/A+R^H~ÉmåéxÉÅl{ue~qOZLL]SqÉÉ=NVàô´≠º”™±Õáé™ëù∑ø ‡¢•∏nqzáéáUaUyÜ}àìïìü≠¥ΩŒîõ•|ÉãÑçîû´¥™∫…ºÃ€¡œ⁄|äç^kdrÄqK]EH_E<T>:S@nÑwxãÖ∞ª¡ñú™ß¨øae~6TYw•®«24K!			
+
+
+
+
+	$):'*A'*C&'?%&>$$;(?#(;%#6 "5!$5#%3"--!-!		
+
+
+"%$%+ .!%2(!.$'% "#!& , ,*&+,". *))"-&.?/8I7,6+"!$ #$'"%#$&%#""!%(->UCBYI4I:$6(.@2'7*)4E3*=*$5%&8(+>+/B/-B/4I6/M).H%BQ0Q[8Y`7X[0^a6^_5WW1NN*GD%@?!8; 8;&#'IM>HV?<P7=VCGbSNdXKcVeÄqbkJjS<^E:\AChG6^;:b=.T/+N-.O0A`AGfGBa?FdBCa;A`44S'%A1	-.O"9_,@d6#<  
+	
+"3  7"=>?'I(*F-/G7=PL\knì†¶L[`ZilÄìë1I<+C3*A/9K;[iZã}5E8$3..;Dâî¶ó£ªñ¶Ω¶º è®≠!82/A5/;//919CDftw2ADEUUN^]J[S0B6/&7%,$&0$:%(@(*D).H+'@#3	'/.&%!%6#%;$'A&*B((@(*D+0H2%:'$"5H5+C+%=#!4"! 
+* (:.:S@6T<5V;4U8.L0+E,.&),") +#( '&%()	
+		
+
+
+
+"%&(*1!&8("4$!3#"5" 5"!6#&;(&<'(>)':$(;'$:%$9&"7$$9&(=*(;(%
+	!&"3#(=,'>,)@.+@-!6#"7&%:) 5"21,"#" #/#$5%(:*(:**;+(401rl<Æ•ZªÆR∫¨Iº´Cπ§7≥ü.ª®0¿Æ2¬≠.Ω§%ªû ø†!¡§$¬™$ ¥*Œº,‘æ,’Ω)÷∑(◊≤%›≠%›ß#⁄üﬂ®'‰æ5Á“AÂ‚I‚ÊI‰ÂKÂ‰L‰ﬁH„ŸFÁ€KÂ‘HÊŒH‰ŒG‚–FËﬂRËÍXËÌ[ÊÌ_‰Îa„Èc‚ËdÊÈhÂ‰fÊ‡hÍ„oÏÈxË‰xÁ‡vÍ„xÈ„qﬂŸ_‡€YËÂZËÏZÁÎXËÍXËÊSÁ‹LÁ÷H‡ AÁ”LÒÂ[Î‰XÈ‚TÍ‚QÍ‚QÈ·NÁ„NËÈPÁÏTÊÌRÂÏNÂÏNÊÍMÎ‰MÌ‘Dﬂ≥,·ü$Î•,Ï∞6∫@‚¨2È∑:ÎƒA„∆<Ê‘BÊ€EÂ‹C‚Ÿ@‡÷@‰ÿDﬂ”A€œ;‡’?‹’<‹◊;›◊9ŸÃ.ÃºÕπ—Ω –ª –ø'‘ƒ1÷ :—ƒ8–ƒ<—…D“ Kœ…MÕ«O…¬MÕ«UŒÃ[Œ–b–—k”œn÷∆n—≥j¢s;f?K@$BL40B*"8!"3 &3" #&&'/ '2"&3""-#+;I8;M7H\A>W96Q24L41I34L6=U=<S9BV=6H08J4CU?TgTm~vgzx5IJn}Çïù†BHFBLAHTFQaWWh`BUOE[OB_K:ZC)F04Q;GgOEcK<U@4G40>/.;*/:)GS?ks\]eP`fZgqiGTM>NNàô£Åí¢´ª“≤æ÷≤∑‘mqåU[sò†µ»–„âífqk\h^kxqù©©¶Æπµª…®≠≥Üãè|Éãïü®ò¶Ø†Ø∂ßµ∏°∞´ÉêÜlziYkUI_HBYE=UEOeXÄìç≈–‘†®≥¨≥√∏Ω—9:OA?T≤≥«VXg"			%3"*='*@)'=&#9"$:#';"/C(&9#$6 #4!$3 $3 !/!.	
+&'$(,!/"#1$#1$!+ '$! ") , +'+ ,!+ (* +"-!,"!!!  "4E56D5 ' #!$" "#+ #$$!!$%'")AXDBWH/D5"4&*<,'8(&/=,,=*$2!%6$-@-/D10E24I69R2.F$EY4Ra8Zf8W_.eh9ba3ih:tqFqnEfc@ST5<>(*,OP@ÅÜpKY@L`GSlYhÉtuãnÜyiÜtbÇkIkP:_@5Z93[86_75^42X/+O))K*/N/CbCOqNSvNZÄOT}E@l/3\".U *O.T#=e1QyG5U,
+! 
+	#6 ;#A#B (E)5%.C<K]a^ow[mwhzÑÄëôZln:OF7N>*A/)>+@N=eqcGXH/?5*-[iróß¥ó´∂ô≤∑Oif$</*?.->,0>/0@6^mf-%<MEIXQ:IBEWK5G90%!#'#6"#9"": &?"%> 0%*21-+($(#6"&<%$>!!> %?$$>!!> "?!%=%"8#0&9%,D,#;!#: 1 1,"2%+=/=VC7W@7Y@7[?-P2,M0,H/5))* '$$+!* ),(
+				"(*-  1!"4$#5%"4$ 3 "5""5"4#4! 6!%;&*=)':&(>)$9&$9("7$"9%&;(%8%!"3#*?.)@.)B-'>*#8%(=,3" 5"!4!,$!%%$# +$2#"3#"4$!4!$5#'347nj;¨§[µ™P∂®Gª™B¿´@∂†0µ†+æ®.Ω®)Ω§#æ°!øùºù¡§"∆Æ&œ∫+—¿,—ª'”µ#÷±$⁄™"‹¶"‚¢$ﬂ¢#€™'Â∆8„ÿB‚„G‚ÊG‚ÊG‰‰HÁ‚HË·KÊ◊FÊ–F‰ÃD·ŒCË›OËËTÁÌYÂÍZ„Í^‰Íb‚ËbÊÈf‰ÂfË‚hÎ‰oÏÈvÈÁx‰‡uÍ„xÏÊt‚‹b·⁄VËÂXÈÎYÍÓYËÎVÂÂOÈ·NÎ‹M‚ÃBÍ◊MÔ‰WÏÁWÎÈVÍÈSÎÁRÎÁPÍÎRÈÏSÁÓSÊSÊQÂÌLËÍKÏ·IÌ»<·™)Îß,Ú≠4ıª@ÒøB„≥5Î√@Ë»?„Õ<ÊÿCÂ‹C„⁄A‡◊>‚ÿB‚ÿCﬂ”?ﬁ‘?ﬂ’?ﬂ÷=ﬁ’:€Œ0”¿$»±œ∏“æ!‘¡%œæ&‘∆2ÿÃ<Õ¬5” A÷ŒG”ÃJ–»KÀ≈K…ƒN–ÕX““`–“e“”m”ŒpÿŒu’ær∫âNÇS'O7C>*;I2-@,'5$ -	#$ #!!%- %- $,!"$/6. , 3A06H2^uYIbD]vY@S@0E22J45M5AW@L`G2D.2D.4F.M`L\pdgzt8LKewyxÉâKVXERK?OE;KHQa`brq;NHB]LOlVUr\PmW=]F7T@2H;0@62=55?67C7<I8BQ<FUBGWMTdaVhjfxÇ´ºŒ≠Ω÷±¡⁄∂¬‹∫ø‹uvíWYphmÅØª…°∞µXe^WcWWd[´∑µæ≈Õ£ß≤∏Ω√ñôûotx|ÑáxÜâï••áñë|åÇ}ã~KXGJXG6G5.C2<SC@VIáòí≠∏ºØ∑ƒûß∏£™ºÖÑñ<9Jbaommy			
+	
+	
+
+),?+/E.2H1(>'"5!&9#)=$)=$"5#5!3!2"3 #4!'5$							(**- (*!/"%1%#/#((%"! %))(+ ,)(**#.#. '"#"*4E5-;.! #$ ! &$ $''$)!/2@WCBWF,A2$6():*%3$%!.&4#)5'-!3#4#2G40E2.>#@Q1Mb9Th7We4NV%^a2[Z,a_.ki8sqAig>@?!21)*CB0ÇÇjz~eQ]IYlYrãxhÉruêxïÅvñ~kçrUzYChG>cB<dA9a<2[32X/4X22T1.O0CdElènwûrR~IBs2?q,0a/]/]-X 6a+WM8^/,	
+
+		(: (B#A+I%/J+(?+,?9ASS\nr?PW,?F7JQR`kÑìö}íãkÉs4P:(A+/@0|ä{\m[1C32C9,?9@VSe{xG^V(>1)<));%(:",(=,;RB.E5/F6*>3BSIaui#5')""!%+!4 #9"$= %> !86%>!(@&)A'(@&$<"$;!"9$<",D**D')F()F'&@##= "< 9!:412!9!2-,+*<S?;VC;XD9[C7[A7[?*M/2S60L3,'&!$)+!+!- - 
+
+
+	
+
+			&!+"+!'5(*;)&9&"7$!6#"7$#9$#6#"5"!7"5 !7"%;&%;&%;&"7$$9&#:&#:&#8%!2 # !1$*?.*A/)B-#<'.F0(@*$:% 3 *!#%)&!)!.%3"20/".*/mk;™†Y¥¶N∑©Fª≠BΩ∞@ª™8µû*∫°*Ω•)π†!ø§#¡§$æ†ºû√ß Ã≤'Œº*–º)Ã∞—Æ ‹Æ%›®$‡•%‚•&Ÿû‡¥-Á”>„ﬁB‚‰C‚ËF„ËDÂÁFËÂJÁ›HÊ÷EÊ”F‚”BÊﬁKÊÂMÊÎS‰ËV‰Ë]ÊÏdÂÌfÁÌiÊÈhÁÊhËÊkÎÍtÍÈuÊ‚tËÂtËÂpÊ‚eﬂ‹W‰„UÊËVÂËQ„ÊOÊÊPÎÁRÍﬂO·ŒCÎ⁄NÔÈWÍËUÎÎUÍÈQË‰MÍÈPÍÓSÈÓSÁÒTÂÔR„ÌNÊÏLÈÈKÔ€FÁµ.ﬁöÈû'Ú¨3ıπ=Î∫:‚∫6ÎÀBÁ–BÊÿCËﬂF‰ﬁB‡◊>›÷=‚€B‡€AﬁŸ?ﬂ⁄@·⁄A·÷<ﬂœ4’æ#ÃØ–≥—Ω“¬$“¬'–¡*÷À5÷Ã9“ ;’ŒB’œE—ÕGÕ»J…≈JŒŒR’÷^”÷e—”h”œl“Ãn⁄”{‹∆zœ¢aük<[18!;>+2C0)7&,
+
+% (#!)$,!&.!'"(*0&47,3;.%1#1B01D.WnTXpV_w_CVC+>+4J35M5DZC`s]ew_SbK8H.5G/[nZZl^:NERba^ikWbfN]`CRUO^cerx\jmRbaC[NQnZDaK8S@2J:>RIJXXisuèîóousVaYDTG2G6>UED[SBZZ\r}é£∂™ª◊™πÿ´∫◊±ø‹Ø∏◊ü£¿usãLN]pzÉ≥√¬`pcR`OWcU≠∑Øª√∆≠¥æ∂Ω≈∫¬≈àåçtzv~ãÑ§≥¨éüïrÇw{â|zÑy6=54;4&3)(:,<N@]nföß≠º»÷•≠¬Z`v•®ªikz$fdo"(4(
+							
+&7%1G20H03I4'=(3'=&(?%&=# 6%8"#6 !4$7!$7#&9&-
+
+
+						
+
+
+
+(". $2##1"+((!-!!-!)&$ ! !#&%)()*)+( -$1 ) ' ' !"0!5F6-#&" %$!#&!$ *,#8%E\HAVG-?1+;.,8,$0$%&0%'3'%/$++0"3H71H67D&N^:Vl=Qh2K\(>JEKPQ%\Z*ea1li6SP#96CA(FA+hdKkgJ^aDVbNwâynátOlVTq[RrZJmOGlKAfD@eCBgECkH?gB>g?:`94X24V38Z9MnOsóskïgQÄI>q/3f!.a+]1a#9f+9f/R|JEk<*#			:N33M*/J'84!6'7GD.1yàç):A<OV>PZåô©°≤∫ÅñëfÅp>ZD$='(:*<J;>O=(;(3"(?/0F9,B5.C2*=)%41@)+?&!7 +C-+D/*A-#:&6M=#8)3$*&7',!"#%)!4!8 9#<&?!#= 'A$*D',F),F)*D'(B%%?"#@"$A#<:7321/.+,.,)*,01M6>[E;[D7YA7Y@3U:,O12S60N4#<&# "%'* +!,"- !
+
+	
+
+		
+#4"&9%$9&"7$5 32 3 5 413 5 "8#3%:'%:'#:&%;&%8%*$ 2$$9((A,*C.-F0-G.$<$0(""! ()( .+*&&*/if9®õW∑ßP∫™JºÆEΩ∞@ΩÆ;π§1¥õ%π°%º£%º£"√´'≈®&æ¢Ω°¬¶ ≥'—ª*Ã≤!Ã¨◊≠#›´&€§#›¢"ÿõ÷§„«5Á‹B‚‚BﬂÊA‡ÁA‡ÂA‰‰F‚›E„◊CÁŸEÂŸEÂﬁGÁÊMÊÈPÊÍWÂÍ\ÂÎcÁÔhËÔkÁÓjËÎjÁÈjÎÏtÏÌvÍÈuÊ„p„·hÂ‰e„‰\ÂÁVÊÈT„ËN‰ÈOÊÈPÈËRÊﬁMﬂŒ@Ï€MÓÊSÎÍRÏÌTÁËN‰„JÈÍNÁÎNÁÌOÊQÂÔP‰ÏKÂÈJÍ‰FÏ“=Â™(·ïÎú&Ò¶/∞4Â≥0Î≈>Ô÷HÎ›HÂﬁEË„GÂ‡D‡€A‚›C·ﬁC·ﬁC·ﬁA‚›A‡◊<‹Õ2⁄¡)À¨«•‘µ“æ!’≈(œæ&—¬+ÿÕ7÷Œ;’œ=◊–B‘ŒB–…DÕ»HŒÕO◊Ÿ\÷⁄a‘◊f’“i—«f–¬i€‘|ﬂŒÄŸ≤m¥ÄNq>!9DA.+:%0B,3D1)8%%%)!) $* 2:-&,.1&>A6CG9;C4-;,/B/ 1AT@KcMUmWI\I"5"5K45M58N7BV=N`HO_EKY@L[DYkUK^K@RFFWQ^lmVciQ`grÄâp}ÜlyÇ\iqkz}<QJ6PCFaP@XJ<QHÑóìàñôçñù~ÉââéëÅåàARJ7MA;UJFaZ=Y\kÖî∞»‡≤√·£≤”∏«Ê≠ªÿû©…Æµ“opÖGIVMXZgxp_p`IXEYdT±∏∞µ∫Ω¡»Œ®±∏éòôóûñ~ÜyrÄqqÉuuáywá|•≥¶≥øµ`dcQUT0;5%2)+;.8IAí§®«‘‰πƒ⁄dkÖbi|†£∂FEU,*7'5&->.2>0(
+	
+
+	-)<(2J4*B*$:%1"8#)?(&>$'?%"8!!7  65 6 6$7#'8&$0"$ !&
+	 ,!/ . ."0#*$&(%!  "$%*%*))+) ,%1# +$"! ,8,0>/!"$' #(!""#"$* !!+ ,-D[GAVG,>2/=0,8,#/#%$.%2<3/90.:0)6,#5)4I:2I7M^4Uh:Wp7Ha(BV#9I<GFK#SQ(a]0lh9UQ$]U0icAwnM}wU~xVonPbnZdyhYr_?]E5S73V62W68];?dB@eC>cACiDAjB?e>:^87Y46X5@d@bÜbròq_â[L{E8j+,_,]/]1^%@l7]âT\ÜT6\- 
+!
+	?S:9R5'>$,1!+=11B:'74;JMUclewÖctÑäö™úÆ∏DZWD_P9P>*?,,=-;I:3C6. 5$(=,(:*$5%7D2,9'*7%'8%"8#!9#%;&7!1 8"-E/ 6!&,;N:*!$(+3%>!#<:89 ;;657842866353/-)&***)1'?',H/B`F:ZB9YA7X=+M2.P51S80P80"$)* !-# , +$#(4*!&4%#
+	
+
+		
+
+
+	
+"0#-$7$(>)%;&%;&&9&%8%&7%"5"5 5 1!4  5"5 2 6!"8#$:%"7$!4!/% 2"-D0+G1-I21K2&>&"8!)"!$"++)**'%$5;_^2¢òS¥¢Nº©M¿¨Iª´<º´9ø´8≥û'¥û$º§&ª§"æß#√≠&√≠$¡ßæ¢ƒßŒ±'‘∏)Ã≠œ®Ÿ´$◊•"⁄£"›§!◊•›∫,Ê“;„ﬂ@ﬂ‰@ﬁÂ@‡ÂC‰‰F‡€A‡÷@Ê€EÊ€EÊ›DÁ‰IÈÍQÊÍWÊÎ]ÊÏdÊÓgÁÔh‰ÓiÁÓlËÔnÈÔsÏwÎÎsÊ‰k‚‡e‰‰bÊÈ^‰ÈW‰ÍT„ÍO‰ÎOÁÎPÍÈQÂ›J‡Œ>ÎŸIÌ·OÌÁQÏÌTÁÎPÍÎQÁÎNÊÍKÊÏLËOÊÓM‰ÏKÈÈIÌ‡DË»5Ë¨*Èù#Îú%Ú¶.Ô©-„¨+Ï»<Ó⁄GÍ·HÊ„FÂÂGÂÂG„„G·‚HﬂﬂC‡‡D··Cﬁ⁄;›Œ3⁄¡'”Ø •—Ø÷ª"“Ω$—¿(À∫$◊»1Ÿœ9◊–:÷–<’Œ?—»=Œ∆Aœ J’‘V’⁄\’€aŸŸg◊–hÕ∫^÷¬k›”|‡‘Çﬁ¡{ƒõcéY7DHB,#1 78Q3SjM;O4"1#&# ,!!$%+3&.6'18(CE7HJ<>B4+3$,=+*=*,.AVC^s`RdT1)?*3K34J34H/4F,;K1>L51@+8I6H[H>PDK\Vjxy\ioUbjåïo|ÖvÇéÑíùzãìJ]acwuDYRNe]F`WPfcj|~záçbfoy~ÑÇéé@PMSfbTkeD]ZC_cwï†∫’Íµ»ÊÆø›ƒ”Øæ€öß…¨µ‘ÄÜú>GPJYVL^R_p^N[IW_Pû£ú¢´™¡ÀÕ¥æø|áÅwÑsixai{eÜôÖÖóáwâ}î§ö™∑∞≈ÕœÄàã/9:(40'7-*=7dw}±√—£Ø≈ü©¬Éâ°NPg0
++7).A.2H38K75F30=,(	
+	$"3 ':$,B-&<'-0#;#,D,*B($<"&<%$:#$7!#6 .A+*='):'(9'+9(%1#$.#!( 
+	!"
+		
+
+'-,"0$2#!/ ))*("" !#%*'+"-)+!-!+". !-& & &0'$+#!#&"""'%'*2#&.!%#&!/3 E^IAXH'<-+<,)7(#/#".")?I>5A5+8.;KA$5+5J;8M<K_,Qe0Ib)@X$4I-?4@8>II#b]5oh<ng9tkBÉzSèÜ_åÑ_Å}Zsv[zâtvç{påvmãqMnO=`?8];7\:5X76Y8=a=<b=8^74Z3/Q,1S.@d@YXdäeeéddèbL{GHz=?r06g&3`%9d/?i9XÇPWÅOBh9   +>(2%45%<('>,&:1(7:[iv~ç†]lÅàò®}éò?US5LB2G8ASCAQF`pe_oe>PD'<+"5","0*7%,9'*9&#4"3 435 8 $<$(@("8!%2/E.'=&0$).!4!83148746:887 ;67754/-(())+,3$<".K/9Z?=]E7Y@2S8-O43W;1U92T; <&!  #'3'9K;/D17L97J7&
+
+	!& .:0%3&2C3+>+)>+/E0)?*5 &9&':'):(%8%"5! 3 3!4 !4!32 322!4!2,%!6#2I5/K50N6(B)$<"-	")((*+( %!! "& -$1  ,?E+QR&°óR≥°O∑¢Iº•Eª¶;º®7¿≠7ª®0µ°&π¶&ªß$π•∫ßø¨!≈Æ$√© ¿£≈• ≠!—≤$Œ™”©!Ÿ™&Ÿß$‡™&·Ø(Ÿ∞$ﬁƒ1„Ÿ<‡‡@ﬂ‰@‡ÊD„ÂF„‡E‚›C‰›D„‹C„ﬁDÂ‚GÊÁMÊÍUËÌ]ÊÌcÂÌfÁÔh‰ÓiÈlÎÚqÍtÎÔvÈÈoÈÁl„‚c‰‰`ÊÈ^ÂÍXÊÏT‰ÎOÂÏNÁÎNÍÁN„ŸD‰œ@È‘E‰‘CÓ‰OÎÍQËÏQÁÎNËÏMÈÌNÁÏJÁÎL‰ÍJ‰ÍHÎÈIÌÿA‰ª-Ì¨,Ò¢)Ìû%Ù™/Ï®+ﬂ´$ÎÃ=ÌﬁGÍ‰HÊ‰D‰‰F‰ÊG‰ÂI·‚Fﬂ‡D··C·ﬂ?‹”6ﬁ∆.‘µ…°—©◊∏ Ÿ¿(’ø+–ø)”√/ﬁ–;⁄–:ÿ—;⁄‘@◊œ>“∆<œ≈A”ŒN’÷W◊‹^ÿ‹c‹Ÿh◊ d—∏^‹√o‡÷Å·Ÿà‚–Ü÷∂{Ø{S`7F?%,: 2K+7U39T10I+,?)):("3#0 +$((3%6>/AH8HK:=?1$*#4E3#6#&,-?/ASC#4$1!4!3K52J27N4<P5=O5>M8<N8BU?MbO7K?Xicáïòì†®ñ†©xÖéeq}äò£ÄéõL]gIZdj{Ç^prCWUMf`B[UOcaçùùqvypuxo{y=MJK[Xç†û<QRF_dYwÅ¢øœØ≈›æ“Ì«ÿÚ≠Ω◊®µ’™µ—äúERX?PJ\n^`o\\hT`dVwynîóêºæπ∫øπäíáo}f^qUoÜjÜûÜä°è{íÇÅïâ•∂Æß≤¥QZa)27&01%4/(;7Ujoö≠ªü∞ƒ•±À¶∞À®¨«AAY)2C18N96N64L46L53D1-<)+". &3"(7$#5)<&"8!., 6!*B*/G/(@&*B(*@)"5!4 !2&7$&8"%6#%6#(6%)7&#/##! &$
+	 ),,!/!/ 1!/ .!/ "." , )%%"!!#(()#. (#/#$0$ , !-! ,%!!(/(#*#!"# "%&'$/+3$08++3(&%+"9%F_J@WG&;,'8(#1"$0$.:.%;G9GSE-;.BRH%6,7L=1F5Ld*H_)9O-B$7&6(229MO*fc:d`3ib6vKëÖ]ëàaÑ~Zx{`vÇjpÜoUqZQmTCaE@aB?a@>a@<_>8\81U1-P/0S20S2/R1+N-;_;IoHbàaièjfèg[Ü[ZâU^êSCv44d&3`'XÇTHoB?g5V~J6\+	' (%6$1B09J8;I8:K8=T:<Y::Y96X50R-'I&&G*)D3);?\izçôØìüµõ®πêû©kz}h{wrÜ{ÅíàSb]ixuó¶£<MG!1$(9)%3$)7&,=*&7$$3 ).)?(*D))C('A&": )A)5 &1-G.1K22J4,
++*46 : ;!:!<:<:9::961-,**((*-2 7#;#'E+2R:9[C3V>*L1.S40T83W;/Q6.$
+	&&%(',5G76M97P:8P:6N84I6-	
+
+
+,6.3C6!6%/D3(=*(?+5M7+A*3"5!"5!"5!!4 $7##6"#4""3! 312 6!//.+('&;(1J5/M51O5%?$#: #$%)*++,- .#4$&4#"0,) &.:&>G,BCûïR∂•S∏†Hº¢CΩ§=Ωß8Ω¨6æÆ4∫´,∏ß%πß!º®!∫ßª•¡´!«∞$≈™¿£∆ßŒ≠"–Ø$—≠#◊≠'‘•!’£‡Æ'ŸÆ$”≥$·–:‰ﬂCﬁ„AﬂÁD‚ËF·ÊD‚‰C‚‚B‚‚B‰‰FÂÁH‰ËMÂÍRÁÏZ‰ÎaÂÌfÊÌi‰ÎgÁÌiÎoÎrÎÌrÂ„jÍËmÂ‰e‰Ê_‰ÁZ‰ËU‰ÈO‰ÎMÂÏNËÏOÍ„L·—>Ë—CÁÕB‹≈9Ú‚QÌÈRËÈMÊÍKÈÌNÈÎLËËJËËJÁÈJËÍIÎÂIÏŒ<Â¥+Ô•(Ìù$Ô£+ÛØ2Î≤/Áæ2ÓŸBÎ‚EÍ‚BÂﬂ?Â·BÊ„FÁ‰G··C‡‡B·ﬁA‡◊:‹Ã1ﬁø)œßÕ•ÿ¥ÿø'◊√,”ø,‘√/⁄Œ:ﬁ‘?⁄”=‹÷@‹‘A÷Œ=–√7“»B◊“RŸŸ]÷⁄_€⁄d‡‘hÿ¬_Œ∞X·»t·ŸÑ‡€ä„◊ç‚…âøécxM+JE'?O2<U51L+$=#: (;%':&#8%#6#,*!#"."7B4FL>HL=:>/$+) .4E3,)!"+9*(9)#5%1 ,C/4M79S:;R6DX=@T;@T;BY?IaK0F:rÖÅâñúÖèôYeq]iurÄãÖìûêû´qå9GTGU`Ubk3BE6KFMdZH_UctjZaYuzs_lc;LDbsmàòóUdgDW]Eaekàê≤Ã€∆‹Ò√ÿÌ≠ø◊´ª‘ñ•∫P]mIX[?SJUgWYfTho]geVd^NéÖvÇyjzreöôáwÅfcxYnáiyï|äßìç™ñá†ãâùëÇêëgqz7=I&/6$30&;6AY]ú¥¿ù≤≈Ø¡ŸØøÿ≠∑–ìï¨+)7(5K4=S<8P84L45M72E1+>*%6#&7$'9#"4$7!+>(2,5(@(*B,&>&(@&)@&"5#5+(."3 $7#&9%):(&4#(  ""%&!'".  .---"0$2##1"&2$$/!!-! , ,  ,+& $%(())%1#". )) .+**&'"'.',3,!& !#!'" '(0!/7(.6)%!)&+4 D`J?VD%7)$2%"."$0$$.#*.;*M^L8I9$6* 2&9MA2I9Qi-Ne/3H..!0$19@!JL%[Z.ie8ÄyMêâ_èà^äÖ_~}^yÉjrÑnIaI;W><X?9W=4R61R3/P14U67X91R3-N/6W88Y:6W85X78^9GpF`â_jêkdçeeêcTÉODt8/`.^"5a,bã_bã_bçXPxC+O:/A)<J96G5(9&/"+%=#+H)%G$(J%2T/:[<;XF7JNéõ´éô≠Ñè°™∑«û¨µãöüèéizrhyqXgbn}z≤¬øevn0>1$2!(6'"0!%6$*;($3 -!3,?)/G--F)'?%,D*(>'.)+.H/-I0$;' $%	
+	%
+	 3 3(@&(A$%> %@!"?  =<:987841-,*')/54#9"$>%&D,6X?7ZB3W='K//S70T83W;2S85#!('&-#6#'<)2G46N80L51M65Q:0L51M62I5'8(2>44I8!8&'>,2I5'>*+C-+A,55 #6"%8$%8$(;'':&(9'&7%#6""5!4#9$11"3 0,1+C-5N80N4'E)&@%$:##4!"0!/  . .*-.0"3!%6&%6$$5#%6#%6$."9D3.8>@ïçN∫©Y∏†Jπú@º†<øß;Ω¨8ΩØ4¿≥3ºÆ+∫®"Ω©"¿≠#ª®ª®≈∞#«≠"≈®¬°∆¢ÕÆ"“≥'‘∞(œ•“¢⁄®!ﬂ¥*÷≤&‹√2‰ŸAﬁﬁ@ﬂÂC·ÈFﬂÂCﬁÂ@‡ÂA„ËDÂÍF‰ÈG„ÈIÂÍPÊÏXÊÌ_ÊÓeÂÎg‡Êb‡Ê`ÈÔkÍÔoÂÁlﬂ›dÈÂjÍÎkËÍc‰Á\‡‰R·ÊL„ÈKÂÎMËÈMÈﬁH‡À:Ô‘GËÀAﬁƒ9Ú‡PÌÁQÁËLÁÎLÎÌLÈÈKÂ‚EÊ‰DÎÈIÍÍJÌ„FÔ ;Ê¨'Îù!Óõ#¶+Ì±/È∫0Ó–<ÌﬂAÏ‰CÈﬂ?„€:‰ﬁ>‰ﬁ@‚ﬁ?‰ﬂC‚‹@·ÿ=·“7›≈-‹∏$À•‘≤ÿΩ&Ÿƒ-⁄…5‘¬0⁄ 9‚÷B›÷@⁄‘>ﬁÿBﬁÿD◊œ>“«9◊œFÿÿT⁄‹]€›bﬂ⁄e„Œc’πX“¥\Ê–{·ŸÜﬂ‹ã„€ê‡Õã»ûnáa<\W9HW:7N1$= $7!&7$%6$$7$4! 3 /&4#$0"$%",!5A3GRDJPB;?0")')0A/0C/$5# ,0>/,=-"4$"7&/F42K6:S=<T:1H.4H/2E/)?(-D0,B6oÑêü§ëù©kwÖ>LY?O\Yixó§¥èú¨|âöxÖïtÄéIV^#647LCI_RH]NMYKDQ@BSC;M?eri\hfzàãBTXC[]JfgE`giÅç¶º ¢≥≈èû≥S`q7EPEUUBSIM[JW`MZ[IZSA\Q?}p]o`K]P=áÇlyÇecvVwêsfÇihÑnà£êé¶êÑôäàööåïzÇè'.8".,$73"::wêó†µ∆©ª—Ø¡Ÿ≥ø◊∏Ω—')6,=+:P9<T<7O7/H2;S=1G2$7#"8!#9"*<$%7':$ 3-01":"'?)%=%&>&*A'':$+='#0%"0#4"%6$#1") " "! &$#%"
+( ."0! 1 . .!/ #/!%1#$0"". ". #/!#/!'3% , #!!"$%%)*'&),)- +)* &%$+$'.' %"$%,$'"! ! #"*&.&.(0!& (#+4GcM?VF#5) -#+!".$"."'3%$2!3D26I6/A3);-;PA5L<Ti0Nb/2D,-$3,9>H#NQ&`]0yuFäÜYçäaàâaÅÖbhqR[jSBXC3L6/K5.J4/L68V><ZB:X@?]E<ZB5S94R8?]A>_B>aA;^=Bh?cç_NyKR{Qsúrfêb@l7<i.1_!.[$5a0iîgdèaPHKxA6Z,1K("1+*8'&9%4626,C3:LLãò†ìùßü©≥Æ∫∆∞æ«üÆµ~ééj{ufwmbrhWg]ë¢ò[m_8F5"/%)5' -BO=.=*"14F0+='&8"#7"5)<&%8%/$5%+3K52J49K=&2.QX^imv!'' '	,4G1#;!%>!&A"%> "; ;976 =,K,4S4&E&31-**3 1!*)A+2N5,M2;]B6Z>,P4/Q61S:4V=2R:)E.(  "&*(((9'6L73L65N83L60L57S<4Q;1N81O72P80L50J10F1(COE5J9'>*(?+4K7(?+&>(3I4'=(#9"'=&'=&"8!1--0221#6 20*>%*A'*B*3M45O62L10J/#=")C(&>& 3 !2"-+*),-"0!&4%%6&&7%':'(;'$7$#4$-!  #" ,.;*+7#9?áÉF∑™\∑°Kµõ>∏ö:Ω¢9æ™9ΩØ5¿≤5ºØ-∏ß#ª©!¡±&¡∞$ø™ø®∆¨!»´!√üøõÀ¨ “µ)“≥'Œ®œü÷¶›≥+Ÿµ)’π)ﬂŒ8‡€?›‚@ﬁ‰BﬂÂC›‰?ﬂÊA·ËB‰ÎE‰ÎF‚ËF‰ÍL‰ÍRÊÓ]ÁÓbÁÎc„Êa·Â]ÈÏgÏÔnËËl‚ﬁcË‰iÎÏlËÎf‰Ê^·„T‚ÂN‰ËM‰ÍLËËL‰‘@·»8ÏÃCÊ∆?‰ ?ÔﬂNÍ‰NÁËNËÏMÈÎJË‰E„›?‰‡?ÎÈGÍÎH„GÓ√6‰£!Ïú!Ú¢'ÚÆ/Ó∫2Í≈6Ìÿ?Ï‡@Áﬁ;‰ÿ4‰ÿ4Áﬁ;Â›<„Ÿ:‚ÿ;‚’;·–8ﬂ«1›ø)€π$”¥ÿ¿(⁄∆/€ 6⁄ 9÷≈7„“D‰ÿF‹‘A‹÷B‡⁄F‡‹EŸ’@ÿ”A⁄ŸK⁄ﬁVÿ›\››a·÷b‡≈\ÿ∑Vﬂ∆j‰“|·⁄â·ﬁè„›ë‡—é“±~üXa[;HR9.=("5"--!/" .!.!*!/(6%*8)&4%'3%1<.GO@MVE;A3"*#%27M8,?+-;*%1# ,'0A11C33"0E4'>,%:':P;=U?2H3%!!$6(1G;Wnhç†§éü©ôß¥äóßé°o~ëuÑóíü≤zÜúyÜôyÜójxÉ<GK)831E:H_MH_K'?);S=BUB[g[`ifÜëïqÄÖ>QOJa[C\X#;;yåìsÉê~ãõr~ä:EKAMKEUJCN=UWBRL6aR?TE2f^IrlViaJhgKnwZiy\ñ|àûâJ]Jar`oÄnXi_FZ[´ºƒ¶∞πJSX#.*%4-#64?TU™æ«¨øŒ®πÀ•≤≈JP`
+
+):*9O87O7<V=+D.=T@3I4"8#$:%$:#*<$$6/)+0 6'?'&>&+C++C++A*/C*.@*(5# $& !##"*'#$!(-  . ,)($0"%1##1"$2#".  -". '3' .!(& !$###&)')- - *))!-! ,") *!$! $+$ *!#-" *!#&$#' ($&,4%&1!%.3LePBVJ.$ -$( (&4'#1$"0!->,/@.3D43E59N;>S@L`/.@):(!00>%4A#@J%V[2noEÄ|VljDpqOkrQGR44D)/B.,C/+D11L93N;7R?GdPKhT>[I:UD;VEVq^JfPCaICcKBcH3T5EiCHrBFrA^á]cådUQJtB3^(4a*Co><g9OzLHtC9h1=g51		 &!+ )!2 )?(!9#;#-D04I@@PM{ÖÑû¶®esvuÑâ£µπ}èènyWg\HVIAO@FXH9J8<I71<++7)*,(').0B,);%-@*!4 ,$)*.C04I8L[TblnBHVrxÑjtv'!#'
+#)#: 6';"&:!353!; .L2;\?9^=3V6;7562/+')>+=W>4U:<_A4W9,O12T94T<4T<3Q9%<((& !$'+).2G42K5-I0)E,/K22N50L51N86S=0M7-M50N4.L2.H/.D/+	/<2;M=-D0(?+5L8&=)'?)(@*2J4.D-%;$!4 1/// 1!4 5  3&9#"54-D(+D'+E*+H,.K/+H*$>!"<%?$6/,('&$(,%3$(9)*;+(;(&;(&;(&8('9)%7'!2"-$()+#/!+6%6;{v>≤¶Z∏§N∂õ@∑ñ7ºú7º§6ø¨6ΩØ5ºØ/ª™(∂§æÆ#√≤&¡´!∫£¡ß Ø"…™æù√§“≥'“µ)œÆ!Œ£‘¶ÿÆ$Ÿ¥(◊∏)€«0ﬁÿ:›ﬂ<›‚@›„A‹„>ﬁÂ?‡ÁA„ÈA„ËC„ËD‰ËIÂÍP‰ÍVÂÍ\ÁÎbÂÎcÂÎcÈÔiÏÔnÍÎlÎÁjÎÁjÎÍkÂÁbÊÁ_Â‰VÊÊR‰ÁN„ËMÊÊJÊ÷BÊÕ=‰«=ﬂ¬:ÊœEÔ‡QÍ‰NÍÍNÎÎMÈÁGÁﬁA‚ÿ9Á·AÌÍGÌÍGÓﬁAÎº0Â†ËöÒ¶)Ù∏3Ô¬5Ó–<Ô‹@Îﬂ=Â‹7‚’/‰Ÿ2Áﬁ;„⁄7‚÷6„’7Â“8‡»0Ÿª'‹º)⁄º(€¡,€ 2€Õ6›Õ:Ÿ…8Ÿ ;‰ÿH„ŸF›◊A›ŸB‚ﬁGﬁ›EﬁﬂF››I€ﬁO⁄‡X‹ﬂ^ﬁÿ^€«V”≤K›π[ÊÕq„”|ﬂ◊Ü‡⁄å‡›ê‡÷ë‹¡ä™èd`W8>B+.;)):*&4'%3&#/%$0&!/"+- .*8)4B3-9+0=,CL;BK:!,+)*+>*6L7#6" 1$0" ,(5H53H71 9N=1!/.?-@S?>Q=&-;.7K?'>4ráàÉïü†∞Ωãõ´àó¨Öî©rÅñâò≠Éè•uÅóxÖòsçbkr",+/%-D4KgQ?[D@Z?AT>NYK^d`{ÖáàìïKZSAUJOgZ)C:rÜÖqÄÖåïÇåïR\]6A;ITFCJ8OJ4ZN8aQA[N>QN?jkYww_ehMbkPesY~çzÅíÄ`l^[gYama(5.(*{çëtÉkts#-%$0&!0)=MJ}èëåù•kwÉ5?K	%6&7M81I11K2+D.7O9.D/$:%#9$(>)&8"*%'*04%=%$<$,D,(@(*@).A+.=*$
+   $$$ &%(+,)('!/ #1"!/ $2#%3$(5$%1#+,(##"! "%)$)- +%"(+!-!+''"#%(%/$ *&#$%$&#'&.4?/%2!%- 9$LeP>RF /(*! +#- "0#)-!/ (9'0>-(9'6G55H56J'-"1,"0-;":E'@I*V[;CF'58%)/9!>L5.@*(;'5J9;RB9TEJeVFaPPkZ`|mWse:TIIcZIb\kÖzpç{JgS<YG:WC>\DUxWHrDEq@gêhièjoïl[ÇV@g;>g=FpHGrGdê]TI3['%E
+	
+
+%##+'@#+I'.M-6U6>ZDMbQ]hXRZM0=6J]Yê§¢tâÑTe]EUJ]k\N]J4E26E07>,;B2#(4&&5"0?*(:"#7#<.F,0&<'%;$2E13D2'5&". $2%1A4->4AMMwÅä{Çîãí¢ï†¶íûöT`R$)#&&&'(-%='.J1.N62V<8\@5Z;4R6,I+"?!:!9!,**+=-AYC:X>=`B-P2/R41S81R7.L4 9$+( 1!#4"#4".2'=(+C-.G26R<-I3)E,1N2,H/*F-.J3-I3+H21N84R:0N6.L4,H1.F.,B+.%4F6/D1'>*4K7.G1+D.)B,/G/&<%1,$2!&7$!2/.111%8" 7 7'@#&A")C&(B%*G)%B# =%?"#="*"$""!#' .!$5%'9)(;(%:'%:'%:'%:)'<+&;(%8%+%,#0%3$(4&2=-9="qk7Ø¢\∑•Qπ†Dµó7ªõ6∫û3Ω¶4¿≠7æØ2º™*∂£ ∫¶ƒÆ$¿™ ∫•Ω¶∆∞ ¥"√™¡¢…®—≤$’∂(“≠!“©”®”¨ €¿+⁄Ã.‹Ÿ6‹ﬂ:›‚>‹·?‹·=›‚=ﬁ„>‚Â@„‰@‰ÂB‰ÊEÊÁM„ÊQ‚ÂVÊÌaÊÓeÊÓeËiÈÔkÈÍjÁ‚dÔÁhÎÊfÂ·\„ﬂWÊ„V‰‰P‰ÁN„ËMÂÊLË›GÂ”A„ÃBﬂ«?‰—GÎﬁQÎÊNÈÊIË‚FÈ‡EÈ‹@‚ÿ9È„CÔÍHÔÁGÓ÷>Ë≥'Ê°Êù˜¥1ıø8Ìƒ6“>Ï◊<Áÿ7Â⁄3„ÿ1Â‹5Â›:‚Ÿ6‚÷4‰’4È’8›ƒ*Ÿ∫$‹º)›¬-‡ 6›œ8›“<ﬂœ<ﬁŒ;ﬂ’B‰ﬁH‰‡Iﬁ›D‡·E„‰H‰ÂK‡„J›·L›‚Tﬁ·\‚ﬁa·–\‹ΩQ◊ØOË¡fÈ–v„”|ﬂ”Åﬂ÷á·€è„Ÿí‡ ê©ìdSF&53,4%*8+*:/)6,+!+!+* , #.:,AM?5A3=J9?L:.;)&4#(9)):(&9&8K70C/%8%$5%!2"/):M:1F5-AQD'*5'5D1>P:.9)<J=7L;$:-%;8f{Äû∞ºãõ´ãöØâò≠Üó´âöÆï§πyÜôq~ëtÄênwÄ"#*#1#*C0B^GGdH6L59D4@G?MSOFQK@N?1C3JeV@\ND[UnÅtÉÜ}àäMVS5<4EL<HJ5RJ3RE2VJ>le]NPKKRJSZJHP;CK4aiTowjt~upzryÉ{LWQ+'$!amkBHFX]W,4'!,".",# 
+
+		
+$1D14L60J1)A+0F1-C.%8"&<'$:%*%-,04$<$'?'*D+*B,-E-*@)):'+
+!"##&"# ,!/!2 !2 0-- -  0##4$'5&&4#(6%"0!,*!!" !&(#(!-!'$#* ("0#- ''&!$$'$.#!+ &"& (#+&'!)#+"- ,(29#KgQ?SG/%&)7*-;.,+'3% ,,4A0AN=5A3(4&,>&1$6 %7!%3*61;"%- % 
+ "*#1 *=*'<+3H9<REE]PKfWE`QA\MMg\9SJOhdiÇjÉÄvëåtíÜZvg6PCdphÖqdÖhNuIMwGqópgçhwùv@f?;a<bàcuûv^â\eí[:b-%F 	'((#4+I'/R*1U/;_;=^?4Q5L_CL[D.@0DXMNcZEVN;F>ZdYyÑs\kT)=$);!4=(29)%1#-+<)9M4:N3)@$'A$ :),B- 6!+>*1B0<J=MYOGRJO\UEQM<GIT]fyÄì|Öñíüß^mj?M@2?-,;( .%#!"$#  #+2I59W?5W>0T:,P60T87X;5T5.M.1O32O3-E-+*(:*AXD;Y?4W9)J-/P30Q6*H04 1!&7'%6&3F3/E0!7""8#%=%)C*&?)2N73O95Q;1K2)C*2N51M4,F-/H2-I3.J40N62P6+I1-I0.H-+B(+>*/!4!,?,)?*6N85M7+C-+A,$7#-&",,*,-1 3#6 45#<#>*E&'B#%@!; =&@#1#!& .'8(*<,(=*&;(&;(%:'$9(&;*%:'%8$"3!"0 .#1 *8+*8+4?1:>%fb2™†[∑ßRº•G∂ö9∏ò3ªú2Ω°3¿©5¿¨3æ´+ªß$∏†¿® ƒÆ$¡¨æ©√Ø∆∂"»¥!√ß¬°»©—≤$”≥$—¨Œ£—®Ÿæ)›œ1€ÿ5€ﬁ9‹·=›‚>ﬁ„>€‡;‡„>‚„?ﬂ‹9‡⁄:„ﬂ@ÊÊJÂÂO‚ÊT‰Î]‰Ïb‰ÏbÊÓeËÓhÁËfÊ·aÎ‚aËﬁ[„ŸU‚⁄Q„ﬁO·ﬂLÂÊM‚ÁL‰ÂKÊ€E·œ=Ê–F‚ŒG‚–J‰◊KÈ·NÊﬂHÊ€CÈ‹BÍ€@ÊŸ;ÍÂCÓÈG„EÏ—:È¥(Ó´&Ô¨'˚¿8Ú¡4Ï∆3Î–7Á’7Ê◊4Á‹5Ê›6Ê›6Â‹7Ê⁄6‰◊3Â÷3È◊7‡…-·√-·√/‡»2ﬂÀ4ﬂ—:‡’=‡–<ÊÿDÊﬂIÂ‰L‰ÂK„‰J„ÁJ„ÁJ‰ÂK·‰M‡‰Q‚ÂZ„„aÊ‹a‚«Vﬂ∏Q›≤SÏ«lÁœu·—zﬂ”·Ÿà‚‹é‰‹î‚Œì≠óhYH*@9&18(%6&%5('7*!/"%$&*"5A38D62>04A0?M<3A0/@0+<,&9&#6#9J8%6$.-!/ -(9L80C0(:*?P@+3('4"5B.AL;% 3?19L92!+%EYZö¨∂ó©∑éûÆãõ´åùØÑïßí°¥ì†±Ñê†{Öëens)($/'"0#3"*A-G_GBXA(5$-5()3(&0%(6%+>+9TCDcS5OBG\SbsmP_X5A7-8*?H7MP=LJ3FA-MJAopkLUT@KG@J?>G6=D2ip`ô†ô°™ß_hg9BA)21('! U`Z(/(.4*#+''!
+
+			
+(9)0F10H0&>&,B+0C-(;%$7#,'(-*11!9+C)0J10H00F/+>(*8'!
+
+   %&'(!/ !2 "3 !2  1!.!- ,0 !/ "0$2!!/-%$!# !%%#(&'$%'$2%#1$,)'!#$('1&"-& )#+!)'2"%0  +&$&,-5 GcM:O@()7*.</&4%**'3%+*6C2GTCR]O5@2+>((>'"8!&9#!0 ,#,$"$!%$2#0 /!"4&%:+5K>;QD-C7.E;=TLIb\\urc}zgÅ~jáÇbÄxMh_VoiyìàtêÅnètUzQ^ÖXRyLdçasúrCiBInLÄ¶Åjîf@l7gî[/U"$ "(&#
+5)G#/T)3Z.9_6.T-+Q,7[7;Y7-G*7P:8Q>.B6;G=RSKÉÉwv~iYiNE`A5P12F+0?*,=-"4$*@)5L0-D*%>!!;(B') 6!4$7$/"$1(AMK<HHp|zeqoQ[\OX_lsÖâí£âí[ge.91+#1 )7&,:)+9(0&(%!# 0#5L8:X@4V;4X<1U;.P5-P2+N0.O21R54U88U9&<%&1 >UA;Y=*M-*K,,J.+G./	%5G96K:7N:4M75M73K3";%$='+D.-F0,E/+D.+D.,F-+G.(D++E,,D,/I0-G.0M1-J.-G,.H-,D**A'*='':$!3!5$:#5K4,B-)<)&"&".-0 4"6457!:&A"$?&A :#>(A$/"!#+!2 $7$'9))<)%:'&;($;)#:('<)%:'"5" 10'8(*:-+9,3>07<%[Y)¶ùZ∂ßRΩ™Kæ¶D∑õ7ªõ4Ωû2æ†.æ§-æ¶(¿©'∫¢º§¬Ø$¬Ø"¬∞¿∞√µ √≥∆≠√ß≈§Õ¨”≥$”∞"œ§…†’µ$› 0Ÿ÷3€ﬁ7€‡;›‚=€‚<€‡;ﬂ‡<·ﬁ;ﬂ’5›–2‰⁄=Ë„IÊÊPÊÍWÂÌ\„Ï]„ËZÂÈ^ÁÌeÁÈdÂ‡^Èﬂ\Á÷R‚“KÁ⁄P„⁄MﬂŸGÂ‰L‰ËM‰‰H‚”<ﬂÀ8Á‘GÁ’K‚—M„“NÊ÷KÁÿIÂ◊CÍ€DÁÿ=Á⁄<ÌËFÓÈG‡BÎŒ5ø2Ú∑/Ò≥,¯ø4Ïæ-ÓÀ3Ï‘6Áÿ5Èﬁ7Áﬁ7Â›4Á‹5Ê◊2„‘/·‘.ÊŸ3Ë€7‚”2·Ã1„À3›»/‡Õ3‚”8‚’;‚‘=Ê‹FÁ‰KÁËN‰ÁN‰ËMÁÎPÁËNÁÊNÊ‰Q‰ÊWËÊ_È·dÂ–[€µJ·¥OÊ¿_È mÁ“w‚“z‰ÿÇ‰›å‰·íÂ›ï‚Œì∂ûpfN2B7#4<',=*5F4&7'!/ ) ,((+*8'*8')7&3A0*8'-)$#'!-%2!/<+)6% +""8K7-@,4E39G6 %!, +=E6"5A3;I8, '74nÅÖúØ∂ù™≥çö£hvÉhxáäóßò¶≥Q^gVae/85'#-"#. ++(9&DUB,)(++1!#>->[IA^L1I95J;:L<3D4*;+3A0HUCDP<@I8@G?cliIRQ096'.&$,/6&T\OåòñøÕ–ûßÆhowTW^,/408:@KG%&%% 	),?+(@('?'$<"+B(':$*'&&)3%<"*B(*C&3L/0H.'?%%<"&9##1 
+	 !!!!$$' 
+$+-/"3#0 *)))+*&##""$"# !$!# $"0#$2%!/ +&%!#",#%0" -*6()$"0!%0"*&1#+7)#/#(&*'',F]I5J9"4&*:-%3&)$0$ .')#1"1?.(6%Q^LO\J 1#6".A+)<&+ (%""!!&- 0"0!4%"8+%;.G_RRiaNgaOhe\vs[ur[xscÅyb}vkÑ~téÉrè}gàmbÜ`RyLGqA\ÜXjìiV|Wlímz†yMwG4^,PxF;
+
+  !!
+./M)1V*3Z-:c71W.8^58a7;a8.R,1S2/M1+D..C0CP?ooc][L[`J/?"9T3CbB?Y<1I1,C1$;'+E*+E(*B(6&>$/G-(,2#5%,!.)aopyáä^lm^jjhttQ\`yÇìÇéûÉçógrv&&!
+	","3#&  # 5$8T>6X=6Z>3W=4X>4X<.S4'J,&G((K+0O04N31-6O90N2'H),I+,F+4
+'5&3H51J5.G1,E/(B)&@',E/1J42K56O92L3+E,)B,*C-0J11K2-G.+E*-G.,F+(E)(E')C&)A''?%(?%*A'(<#%923(;%0$$ '+*!2$8$83457#<97 9!:1 !"%',0.1!0 !6#%:''<)#8%$9&#8%#6#2 1!):*-=0-;.2<1/4GDúîU∏¨Xº≠N√ØNª¢>∑ö4ºõ0ªõ,¿°,¡®*¿ß&øß#æ¶Ω™¬≤!¬≤√≥¡≥¬¥∆≤»Ø«´Ã≠–±"’µ&‘≠"»°Õ™€√-Ÿ”3ÿ€6ÿ›8Ÿ‡:⁄·;›‚=‡·=ﬂ‹9‚‘5ﬁŒ0Âÿ<ÁﬁEË‰MÂËSÊÎY‰ÈY·‰U‰ÁZÈÌdËÏdÁ‰_Î„^Ë÷PÊ”IÍ⁄OÊ€M‹‘CÂ·J‰ÂIÂ‚E‡œ7€≈1È◊EËŸJ‰‘M„“N·œI„—GÈÿJÌ›IÈ‹BÈﬂ@ÎËEÓÊEÍ÷9Á√-Û¿3Ú∑/Ô¥*Ûæ0Î¬,Ò”7Ïÿ7Í›7È‡9Ê›6‰Ÿ1Âÿ1‚œ+› %ﬁ–)Â⁄2‰€4„◊3‰’4·œ1ﬁÃ.‰—5·”5‚’9ÊŸ?Ê›DËÁNËÈOÂËOÊÈPÁÍQÊÁNË‰OÈ‰TÍÁ\ÏÂaÌ›d⁄ºL›∞IÂ∑UÎ…hÈœpÂ“v„’|Á›Ü‰ﬂç„‡ì„‹ñ‰œñΩ¢udJ/=./7",=*,=**;)%6$$2!+*#0)7&,:)*8')8%.=*)7&#1 !-*$## +0;+EP@BJ;*5%'6#8I6,=*1B07E4.:,)'1&4?1+6&#)9E77E4'5&',%!42SeeXdd=GI'587FMèú•Çèó'(1=9+!' +$/#+"-&3"!0/,-&%, 7%'B/E`M7S=$<&%;&(;('9)*<,BTDGZG7I97D;ITP3<9#0<2L\[¥√»¥æ»™∞ºõù©Y\c:?B )$##&"
+	)!2!8$;!6#: .'%&)2'>$)@$1J-1J-.G*%>!#<$;- -	
+
+	 "  !#!+""#*"$
+	"!/ #4$ 1!+)($#" !"	 %))!/",'$"!%#/#!-&4#'5$)+0>/&2$'2$". !-$0$$0$"0# .!*&(9N;1F5*<.#0&* +%1%$2#!/ +-;*&4# .-<)WiS
+	"1%4+ #/ +"%&!(/!2!#8''>,5N;A\KB\OE_TC\V[tpRli_zumãÉrêÜká{käzhàqiånY}WRyLMwGKuGZÄWW}Vz£{QzP:a587
+				 '1J,0U*.Z)0Z,3\02[17`64]39_6.R,$F#$C$*D'5L2:L6wÄoAE4MV;6E&'@ )H)A_C4R82N8*F0GdH-J,&@#4%<"3F0.+%!/") +)êü§åõ†fvvgwvèüû}åëò¶≥êù≠ô¶∂rÄçtÅäEPR!		!%&"   *(?+6W<4X<5Y?4[@2Y<4Y:3V6.Q1$E&$C#'B#'@#.'A&%D$'D%%=#1&(04!9&@',E/,E/*D+-G./G/3M45N8/K4.J1/K20L31K22K56O95N84P72N7.J1/L01N2.K/)F**B('@#%>!"9"6 43*
+
+
+
+	 &#$"3 &:!"6 71137367/' ""(-0 0 4#0 "4$21!2 "5"%8%"7&"4$$5%+<,.?/2@31?2&0%-2><ëãO¥¨[∫≠M¡ØMø©D∏ù6ªú2Ωõ/ºõ(√ß,≈¨+¬™&¿™!¿≠ ¬≤√≥√≥√µ¿≤¡∞∆≤»≤…∞ ∞‘∏(’∂( ©»§‘∏&Ÿœ2÷◊3’⁄5◊ﬁ8⁄·9⁄·9‹ﬂ8ﬁ›7·’3·”4Âÿ<„⁄A‰›GÊ‚M‰ÊT‚ÊT‚‰S‰ÊWËÏaÈfÍÓeÍË_ÊŸO„—GÍ⁄OÊŸLﬁ”C‰›G„ÂFÂ„C‡–5⁄≈.ËŸ@ÁŸD‰ŸK‰◊MﬂŒJ‡ŒHÈŸNÎ‹MË›EÍ‚BÍÈCÏ‰AÍ–5‰∏$µ-≠(Ô¥*Òæ/ÓÀ3ÒŸ9Î‹7Íﬂ8Ë›5„ÿ0„÷/„“,‡…%ﬂ…%„’.Á‹4‰‹3„ÿ1·‘0‡—.ﬂ–/„”5„÷8Âÿ<Â◊@Á›GÎÂOÂ‰LÁËNÍÎRÍÎR„‚LÈ‚SËﬂTÈ·ZÔ‚bÔ÷b⁄µK„∂QËæ\Ô—oË‘s‰‘u„’|Êﬁâ‰·êÂ„ñ„ﬂò‰‘ôøß{iN3;((,%6#&7$$7#&9%(9&&7$%4!2?-3@.6C1-:(&3"!/.$5")7&&4#!.#&"/%1#6A1LTE*5$.:I6'5$(6%)7(&4'-9/2<1)4&*!' ( <J92@/"0*+* -#(3+3>6'4-$3.P\ZETQ*#)9,#1 !.),#.!,#.+"3 0+=',((5#+>+4 2K8HaL/G/*='%6&#3&%7)5J9IbO7N>+;15@:
+.$,=5Xhh≥¿∆£´∂™∞º°•±ÄÉå(,/ &"%%$"	
+'4""4./0,'()+,6!8 7"9&>$'@#"9$;';"((
+!!#$&3=25?408-!) % .!/-+&$%$ 
+	
+
+
+			
+	"+!)''&% *%1#'5$,:))7&"0$2#'5&,$1 '4#$1  .-". #/!",!$0$-'9+*<00A7(5,( !.$"0#!-$2#/1B0%6$.$5"2E1*2#'0*5$&1 "-$/!.)'-+(!$/0E48O=3L73N;3P<9VD6RC<XJWri^|paÇqjãxYzeUw^DiJ@eCGpH=f:IpCQxLsôpYX[ÑZ0V-#E"!
+			
+ /1Q*-W),Z).Y+1Z.6_37`63\0+T(#I #G!(H##A(A#D[AyàsAN:7F)J]?NhK3Q5=^C9YA6V?0M7)G-(E'(B% 7/#4!,(*#2>:yáäÅêìVddFURL\[P_bM[hÅé°ß∂Àm|èP`m#$
+"&'%$$6&7S<6X=4X>2Y>5\?7\=2W84W70Q2)H($A"$? 68!>9(/"6!88!;&@#'A&%>()B,2N74P79S:7Q80L51M61M62N75Q81M43L66O94P91M62P88V>1O5.L0/M3,H/*D)(A$#;!50-1 2$		'((!*$8#76-1//0307(>'&9%"5!#4!0)+()/0 !3# 5$%7'$6&#5%#6#..0 0 #4$$5%0A1:K;5C65A50:104#::Å|E¥≠]∏ÆOºÆK¿≠Gø¶A∫ö3ºö/πò'Ω°&«Æ-¡™&º¶¬∞ ¬∞√≥≈µ!ƒ∂¡¥øÆ¡≠»¥ ¥ »ÆŒ¥#÷º+œ≥$Àßœ∞!‘ƒ)◊”2÷Ÿ4’‹4ÿ‡5Ÿ·6⁄‡8ﬁ›7·ÿ5„◊7‰◊;·÷<‡ŸBÂﬂIÂÂQ‚‰R„ÂS„ÂTÊÎ[ÁÓ`ËÔcËÈ_Á€QÊ÷KË€NÁ€K‚ÿE‰›F‚‰C‰‚@‡”7ÿ»-ÊŸ;ËﬂDÊﬂIÊ€M‚“K·ŒKÁ’OÍ⁄OÁ›HÍ‰FÎÈFÔÊC“6Á∑%Ó™#Ì§!Ò±)Òæ-Ú—6ÌŸ8Èﬁ7Ë‡7·Ÿ0‡’-Êÿ1‰—,‡…%Á—-ÂŸ/„€0‡ÿ/ﬂ‘,ﬂ“+·“-‰◊3Ê⁄8‰⁄;Ê‹?„’>ÍﬂIÏÂO„ﬂHÁËNÎÏRÍÎRÊ‰QÌÊXÏ„ZÏ‰_Ú„fÍ»Z⁄ØG„∂QÓƒbÔ—oÁ–p„”tÂ◊~ÊﬁâÊ„í‰Âó‰·ú‰’ö¬´kP5?,.1 "0"3!(;'$5"$5"'6#,;(4A/8E32?-(5#"/!/$2!'5$,:)*8''5$&3"$1 )%(4&CN>AL;/<(9F2* ,!-!) *!&0%+6((!)/:,*8'AO>2@/#1 '4#%2!)5''3''1&.8-".$* +"'4++*;+5D1<K6:I46E0/<*(5$$1 !/$6 "48F/-6!/4 19$7D0 14!.E1McN/@-#$9*@[H<WD, ((+8.8J>DXLJ^SCVP}èè∑∆Àò¢´∑Ω…∂º ™Æπ;<@#("'&$ 	
+")8#$63/*((,,-15#<*C&+D'%=#";%< !5*%&
+
+
+
+
+ "#(*($')$/!3>0>I;'2$	
+
+!*-/ /('&%  #$ 
+#)%%! ,%3"%6$$5#,:+)!/ +" -#0'4#!/  .%1#)5')3()5)#3&(8-0@6BOF.91)!$1'!/"+!/ ):(3D2&7'/!2 )<(%+#
++.0 "4$"4$!3#."$4)1C5.E3/K58V<4W92V:BfJZ|d^ÇhS{YYÅ^OyUJtNPzRUÄUHuJ"M"4Z3TxRmìjV|S8^7.P/4				
+
+
+	'2M*.U(,W),\,2`19d73\0.W+(S&*S')P#,Q%$G=:.H+TkQAX>;T7JdG]{a0P8BbKEeN<\G9YB-K3)F*@[<*A$/($'%)%2)#/+4>="+(*$3?;)46@IZv}óü´≈ó¶ªö¨∫'8?$	'++*,! !6%8T>2T;7[A6Z@2V<2W84W71R3,N--L,'F& ;7 ;78#= %?"$>!%?"&C%%B& =!!=&5Q::X@3S;4R:6R;6S=3P:0L61M75Q:7S<4M72K58T;7U;0N61O77U;8V</M3/K2.H/%=#30/01 4'8%# '%&)"&%6#&:!#:1+,++*-8'D&.K-1N22N52N50J12K5*B,-.0 #4$$6&&8(%7)(:*#8'!6##6" 3 /,0 $5%1?0>L=2>22>44@43<+36vtC±´]∑ÆOπ´Jø´H¿©CΩ†8ªö/Ωù,∏ú!¿ß(≈Ø(ª•æß√Æ√≤∆∑ ∆πƒ∑√≥ø¨√Æ…±…ÆÀ∞—∑$“∂&Ã©»®—π#‘ +‘’/’›2ÿ‡5ÿ‡5€·9ﬁ›7ﬂ◊4ﬂ”3·‘6‡÷9ﬂÿ?Â·JÊÊRÂËS„ÂS‚ÊS„ÁUÁÍ[ËÎ^ÊÁ[È·XÁ€QË€OÊ€K‚€D‚ﬂB‚‰C‚‰A‡⁄:€”3‚›;Ê‚AÊ·EÂﬁHÂÿKﬁÃF„œLÍÿRÎ‡PÎÊNÎÈGÔÊCÒ”7Â±®"Ù•$Ò¨#π)Û’9Ï›:Í·:Á‡7„€0Â⁄0Ë⁄3‡œ)‡Õ(Ë◊1‰Ÿ/‰‹1‡ÿ-‡’+ﬁ“(Âÿ1Ê⁄6„⁄7Â›=Â⁄@ﬁœ8Ô·LÏ‚LËÂLÍÎQÈÓSËÌSÍÌVÓÈYÌÊZÌÂ^ﬁ`‚∫K‡ØIÍ∏U¬bÈ≈gËÀo‰œrÁ⁄~Á‡àÂ„ê‰Âó‚‚ö‚ÿõ≈≥ÖlT:C2".2#&4%!2"#4$%3$%1#)4$+6&)4$+8'&4#"0%3$"0! .%2!)6%*7%-<)'5$'5&'"#/#AN=GS?R^F-9#"%&")! * ++7)/=..?-CTA/>+#0#.'%'!'17+ (%".$"0#'/@0+*)6%/=,7F35D1+:'-!4,<"=E-GG/E@*EC.@E1$0,#DRA#0'5P=DaK5N;:Q?>WD=VC9R?4M:5L<+A5uâá•∑ª°Æ∂≤ªƒ∏æ πΩ∆OPR(-'*(# 
+	
+	
+#,*8"620"%/256!8!8%> )B$*C%!:$;%9 -%) .,				
+(1?(*8%2&3!,&$#. .9+-8*)5))"#&( '%# '*)*()%''(%$'()*'$$&##%
+	"$%#!#0$3 /,,%%#"+!/#1 !-!-"-!,$/!)5'*8+&4'-9/1;2".$)5+#0&%3&%3&+):(1B0-9+,8*!2 "3!	 , "3#"4$"4$%:)%:'$;'"7$* )$@'DgGKpNDlIIqOOsW}¢É[É^MwOS}UO|SNxRkïoP}V9c?=`?NrNAj@3\0.T-'F&#
+			$"
+
+!%>!-P(.X(,Z+1_12]0.Y,-V*1Z.6_32\./V'%K@;;+H*9V8FcGA_C.O4bÇj=_GPp[VvaPp[9YB4Q;3O6LeGD[>+!+'$"%3$%"*"$00<CUéïØï°π†Øƒ†≤æGY[$& ,+*+.(#3&,C/:X@=_F:\C6Z@3X9.S20Q21S2/Q0*I)'B# 9";!< =#@!'D%)F((E''D&(E)'D()E.3Q97U=:ZB9W?1O71N87T>:V@6R<2N86R;:V@:V?3O84P7:X>=[C7U=4R:9U>4M7!9#!9!)?(6222!8&<%#4!
+ ))"$("+(;%&=!!84/)*,'0!:%B#+J*+J+/P30Q43T74R8-I0-E/+A,#6#%8%%8%&8((:*'9)%:)$9&$9&$7$"4$ 1!#4$&4%'5&2>24@48D87C70;*59 ce6´®[∑±S∏™IªßF¿®D¿§@¿°7¿†3ºù)æ†&√ß)¿®$æ§√¨"∆±$ƒ≤"≈∑#ƒ∂ƒ≥¬≠æ¶√® ¨ ¨Ã∞“∂$œ¨»•»Ø—¡$’“-”÷-‘⁄0Ÿﬂ5Ÿﬂ5⁄€5‹◊3⁄—.ﬂ—2·‘6·ÿ=Â‡H„‚L‰‰P‰ÊT‚‰R·„QÂÁUÁÍ[ÊÁ[Á‰Y„‹P„ÿKÂ⁄J„‹E„‡Cﬂ‰Bﬁ„?‚‡>‡›:‚·;„‚<‰·>·€?‰ÿF‡ŒD· H‰–MÎﬁTÎÂSÎËK‰DÔÃ2Â≠Û¶"ÚüÏ§Ò∫)ı◊9Ó·;Î„:Á·5Â›2Á‹2Ë⁄1ﬁÕ'„“,Ë⁄1Ê€1Â›0„€0‰Ÿ/‚÷,‚◊/‰€4Â›:Êﬁ>‰Ÿ?„’>Ó‡KÍ‡JÈÊMÍÓSÍÔTÈÓTÏÔXÎÈVË„TÎ‚YÌÿ[⁄∞BÍ¥Pˆ¬_Ïª\ËΩaÂ√i‚ÀnÁ⁄~„‹Ñ·ﬂå‚Âñ„„õ‚⁄ú«∂àjU:B5$26',:+&4%.<-1=1/:,4?1+6& +'3%'5$-(6'$2#)1<,AL<*-:).<+'8((6)* !-!8E4HUAQ]E?H3 %$+,*>O<&5"&'"$$&, 03(&) %)5)- (1B2/""%(-#1 +13?)FJ3?:$>6!SK8BC1(/!,+"/%1'.>14I81J5B^H?XC1J50I4/K5*F0*C.0I6-C6Od_ñ™©û≠≤Æπø±∏¿ïòù:<;',%$0$"0!'!
+			
+
+	
+	!*(6 410"(!3"6 7 7"9&= )@##<";411.*-!4 %6#+	
+#%*/=&-=#%30=)"-$$/1<.#-"!""#&&& ($%$%"" +)&%%%#'(+- .,- &4'-(***,&2&$.# 		#&$ )#0-,!/(!"". %3"#0)(%)*5'9E71?2!/"#/#-7,4@4;G;&2(".$'3',)7(-;, , '!/ !2 
+	(!2""7$"7$!6#&>(%>(&@''A( 8 +!!1$3K5=Z<AdCJpKPxSU}XRwVNpXxòÅÄ§àV~\XÇ^R{YFmRÇ•çkèuKoSDgI\^<e91\.-S*<
+!!5D]=NiF =9":$TiVsäváúâI\I'#="+O+.W-.Y,/Z-+V+-V,4]37]4;a88_35\/3Z+'MA>"@=\<@bA?bBZ|a*J2AaLUvc_ÄmWxcPpY5U>5U>2N7;T7`tX01+(
+'&3"!%'0<8.8DÉé†î°≤ÆæÀÜïú#11#()(((-.,		+7S<8Y>@aF?bD9^?5Z93U4/Q02Q10J-!7 ,"9 :;>#@"%B&&@%'A&)C&)C(&B) <%&B+:V@6R<9U?;YA4R:1O72O9=ZD:WA4Q=7R?@YCB\C:V=3Q7<XB6O<$;)4#1H43K3)A' 86 8$:#'=&'=&'=&0&, -*""'-)=$)@##< 93++(,58 ;#A(E&.M.-N11R50Q65S96T:3O62K5*B,(;'"5"$7$(;(':'':'(;(&9&$7$$5%+*$(2':F:;I<9G:/:*8='UW/¶§Z∫≥X∑®I∫£Cø•F√•E∆•D√†<√û6√û3ƒ£2∆®0ƒ¶,≈©,À≤3«≥0∆¥,…∏,«µ%«±¿§øü…© ™À≠œ±”≥ ŒÆ»≠Œº”Ã&—”(”◊+÷‹0ÿﬁ2⁄›4‹€3÷œ)◊»'„”5‡÷9·⁄A‡ŸC‚‹HÂÂQ‡„NﬂﬂK‰ÁRÁÎYÊÈZÊÂW‚€M„ÿK‚’H‚‹F‰‰Hﬂ‰B‡Â@‡„>ﬂ‡<‡ﬂ9ﬂ‹5„€8Â€<ÁÿA‰“Bﬂ«C‚ÀKË◊UÌ·YÌÂRÒ›HÓƒ0Á®Ù°ÙüÌ®ı√.ˆ⁄9Ïﬂ8Íﬂ7Èﬁ4Ë‹2Ë⁄1Á÷.„—)Ê‘,Ê’-ÂŸ+‰›-„€.„€0·Ÿ.‚⁄1‰›5Êﬂ9Áﬂ>‰⁄=Ê›DÏ„JË·JÏÈPÏUÍÔTÍÔUÏÔXÎÈVÍ„U‚[ÁŒPﬁ≤Eıø[˜¡_ﬂ™JÎº`„æc· lÂÿ|·⁄Ç‚‡ç‚Âñ„‰ûﬂ◊ô√µÜn[=A6"26'2>0/;-AM?:F8?J<6A3(4&$0" .'8&.!2"*8)%ITD9?1%,8*,=-%7)&3))6,CP?JWCT`H<E2"$'$-<M:'5$$0")$"*%-+1%36+(+"#)-7,+$1A4"2'$$"&!,!,/8%CF3>;(5-IB012"3:(7@-2?+-<'0A.@Q>K\I;L:0C0*@+;S=>T?#6#!2"''&=+9P<7N>5JANa]Åììû¨Ø¢¶©235"'#%/&$2%.!* 
+		
+
+$*9$$61 2/!5';!8 7#7"6"6!8"9!82/-/1"5!7 *='%3"
+	
+&'&(-:&$2+,+(3#,6+' ')*('&(*,"0//".!)7*3A4!-!'+/&6)*:-#1$'" !% ,%! ))%(($+#1"%1#$0$'/$ (%'*.<+1?0+!/ !/ 7C55A37A8+5,%/$(,!/ )+ .%3$ /!6# 8" 8  8 $>%#?&'D((E)(B)-&/?4Yn]fiTuXUzYMuS^ÜdhçnhåpXweqêÄéØöÄ£ãlêv`ÉkJkZáßòã¨õsî|ùÇ|¢}HtCFr??i9(K!+F%Fa@gã_OvI>d;<b=EfI]{cç´ë`~dvîx35'A$(J%/X.,W**X*-V*4]3;a8>d;=c:;b68_37^10V'%J"B"B.M+FhGX}\@eFbÜlFhP!@.KlYNoZHjR7W?FfN:ZC1O7:R8cw\&:!2)*&&2$*#"#(&)#6AE5BKR_g0=C#+%'&%+0  .$
+
+
+
+
+(-9+"3 "<#(F*9W;8Y<6W:6W87V76S5/G-+	*#: $>!!> "A"$A%#@$$A%%?"&@##@"!>"%A(/H2.G2+B.+B.7P;6R<:X@7U=3P:4Q;:WC>ZDB[E=U=:T;8Q;'>,&-8M<6M90H0)A'": #;!&>&(@*+C--E-'?'$:#1,+$(#4!)@&*A$&?!!:5.,,/236:=#@!)H)*K.-N30Q62S84R86R96P70F1*!2 ):():*#4"'8(&7')* &2>21?01?23>.>F1WY4õöWª≥^æ™QΩ§H¿°G≈¶L ®QÃ™Q“ØS”±P÷∂Q◊ªP”πJŒ∑E÷øMŸƒO‘¡H—ø?À∏5»≤+«´#√£ƒ£»ß…©»®–∞“¥ À≠»±Œ¬ “œ(“‘)”Ÿ-÷ﬁ1◊›1⁄‹1÷—+—ƒ ‡—0‡÷7‡◊<‹“<€”@‚·Kﬂ‚KﬂﬂI„ÊQÁÏZËÌ]ÁÊV‰ﬂPÊ€N›“DﬂŸE‰„J‡‚Aﬂ‰?ﬁ„>›‡9⁄‹3Ÿ÷/ﬂ÷1‚‘3Â–7ÂÃ;‚»?ﬂ∆EÂœUÌ€]ÌﬂZÚ€QÓø5„°ÓùÛ¢Ò≥$˜ 1◊4È€4Ë⁄1ÂŸ/Â◊.Èÿ0Â”+Â–)Â–)„—'‚÷(Á›-„€.‡⁄,‡⁄.Âﬁ5‰‡7Êﬂ9Ëﬁ>‚ÿ;Í·HÎ‰KË·HÏÈPÎÔTÈTÎXÎÓWÍÍXÓÁYÒﬂY‰ƒK„≤I˘¬^Ì≥RŸ£CÔ¡aËƒdÊœoÊŸ{‡€Ä‡ﬂå·‰ï·„öﬁÿö∆∫àiZ;C;&7;,1=/:F8LXJIUG9E7-9+(4&!,((9'':'!2"%6&3@/LWG8@3#+2D4$9*=MCP]TDPBS`NJXADP<!;DC=CC"* *&.9H5)7&*&)%- !'$':=2"%,2()3()4D7%5($ !!(*&/6=+#&54"DC148'T]LXcRS_KAP=\mZar_j{iP^O,/&7$'5$!,*?,(?+4K98J>*;3*'P\\ÄÑÉ#* "0#!2"$5#!/)%3"-:)$0"&
+	
+
+	*7&);#"61/"6%=%<$;*>#(<!!5.10032 3$7!+B(&=#+A*#4!
+	
+
+'('+!.,*"-"-&"&('"&*,-/&8(!3%+=/2D6-=0'5(+)+'7*2D6)9,*$$$$"$#!!")*$'##(#  ))7((6).;15A7'.&$+#$$('5$*8)*-.<-ERA?L;1;01;0&0%)4&&1#+7)/:,3?1,:-):*$6&":$":" :8$>#$A%$A%'E)+G.4!!0$ShYMfQXu_sì|xôÑsñÇuòÑÖ¶ìá®óà®õ~ûë~ùéÜ•ñä©ôÇ°ëuìázòåì±•ä©ôÜ®çå≤ãhîaCs9Er9?j5;`4Fk@dçaDoB>h@S{X_ÉgÇ§ãVx_bÖgßÇPyMDk>Ci:7^/GqAHtC5c29c59b6Ah<<c7?f:8_2<f82\,0W(-S$&F2P.@aBJlQcámUx``ÉmZ}g<]H?'CdI7X;0N4?`E<^C3T92L1F]C)<&0++ 1(9'&%'"',7B>#-,
+	&-$&##*- !-!		.:,3D12I/.H++H*)F**F-1M4-I0%=%. 
+)%;$%?$$A%#A%#@$"?!$A#&C%(E'&C%%B$(F**F-&?)/4F66K:2K85Q;6S=;XB;XB>ZCC_H>X??W?7M61 *<0@UF<S?9R<.F,&>$"9*@)*B,.F0+D.3L6)A)#9" 3+$
+$/ 6'>$,E()D%";2-+,-257="? &E&)G+*H..L2/M3.L21M44N51G2%*%1%##(,6+(4(-9+3>.CJ8QU4ëçNºØaƒ´Y≈•RÀ§W€µj‡¿u„»{Á—~Ë“|Í’zÈ÷wÊ◊r‰’nÊ◊pÁŸpÂ◊j‚“a‹ÀW€»P◊øEÕ±4∆®&»¶ …®«¶Ã¨Œ∞«ß√®Ãπ” '“—'”◊*‘⁄.÷‹0ÿ‹0◊’+” #ﬁ“.ﬁŸ7ﬂ€<€“9ÿ—;ﬂﬁH‹ﬂHﬁ„I‡ÊN„ËVÂÍZ‰„U‰ﬁRÊﬂQ‚€L·›H‚·H··A·‰?ﬂ‚=›‡9€›4›⁄3·ÿ3‡Œ.‹ø&„¿.Á >·∆C‡∆OÏ’aÏ‹c÷[Èπ9⁄õÎ°Ù¨"Ùæ(ÙŒ/Ì—/Á’-Íÿ0„“*Ë◊1Ê‘,„Ã&Êœ'Ê—(Ê‘(‰Ÿ)Ê‹,„€.‚⁄-„€0Âﬁ5„ﬂ6Áﬂ<Ëﬁ?„÷:ÈﬁFÈ‡GÁ‡GÏÈNÎÔTÍÒUÍÔWÏÔXÌÌ[ÒË]◊X·πGÂ∞H˚ø]Â•D·ßFÌ¡^È…dÊ‘n‰‹w‡›Ä‡‡äﬂ‚ëﬂ·ò€⁄óƒøà_W3<7!3:(0=,=K:ESD7E6.:.-9+3>02:-.9+.?-+>+):*&7'/@.<J90=,!"',>0/C7Tc^lxtJVLLYHHV?MZF#.  ]ehT[a"#!!( (2'$+"/%3"$2#(6'$0" +!!$(*<>1#)-5(+6('0>/+9*#($!(! !!/"*&4#/<+-:(3?)AM72A.CQ@ITFS^PHUDao`gwm†¨®2;:$	
+'<)(@*!7""5"(6'#!&"'(;'.B)0D+/C*.E+7K25H25G1%3"	
+%1#*<&';"!5!5%<)@#(?"&= &:"4 2 4/.2!8%8"5+B(*B(,D*.E+'9#)	#'"/'4#%2!$/"*&"
+	
+!
+"#"* 1!12$9&/D52D8:L@/A5*<0"2'"2' 0%/$'7, 0%/$&$"$( -#$1''$%)*&%)&"#"%'$7$.@2=MB<I@@KC$.%%-"#+ '$/3>.$/! ,,"0,9'.;'(5#'2!.9)7?0<B4:B34?/=I;CSF+=/$6&&>("<! :8"<#@"%B$'F'*H, 6!"'<-vé~mätSs\lçz|ùå|úè}ùêà¶öç´üí≤ßà®ùzòéÖ£óëØ£ëØ£|öémãå™ûé≠õÖ®äVUJvA3c)Gw=:f1<f8_à\]ä_[à]`çfhínxüÇV}`\Äd|§ÇSÄUJxIHtAHt?HtA\àUEq>Q}J<h7=g9@g;@g;:a46`2?i95_/-W'-R&+K$QpNbÉfaÉjqí}fâujçy^ÅkKnV(J1!B%4R65S7JkN5W<(I.!; ;Q:2C1&7%(6'$5#*=*'<)!4!22(.!/ ;E=+/%'$#)+!-	
+.?-6M3.H+/I,-J,+E*'A(%>($<&&!		 '8%%=%'A(&C''D((E'-J,%B#)C&+E()F(1K0'?'%!(%:+5L:-F1.G47P;-E/6L7+A,#6#!2 '0@5AUI>VF>ZD5O62L1&>$'?'2J4(@*/H2.G13L62L3#;#, 
+		
+"')!4#: #:4/+-138"=$B +H)-L-2P44R84R84R83Q7/I0*B,#6#
+	
+$0$)7(?J:GI;OJ-áwCø®bÀÆb÷µh‚¿vÏŒÖÒŸèÓ‹êÔﬂëÌ·çÌﬂáÏ‚ÉÎ„ÄÏ‰Ï„|Í·xÎﬁuÏ‡tÏﬂoÌ›lÎ◊dÁ—Z‹√E—¥2Œ∞*Õ≠$…¨  ´ƒ§ø°«≤œ¡"Œ…#œ—%‘ÿ,‘€-÷⁄-÷ÿ,◊–(€‘,ﬁ€6·›<ﬂŸ=ﬁŸAﬁ›E€ﬁE›‚GﬂÊK‚ËT„ËXÂ‰V·ﬁOÂ‡QÊ·Q‚·K‚·H··Cﬂ‡=ﬂ‡:›ﬂ6ﬁ‡7‡›6·⁄4›Œ+’∏‹Ω'ËŒ;‰ A·≈JÈœ^‹lÚÿg«QÈ≥9Ì¨,Ì∞$√*Ù“2Î“-Ë”,Í’.Ê—*Î’1Á–,„ %ÂŒ&Á“'‰“&ÊŸ+Â€,Â€.„Ÿ,„ÿ.‰‹3Âﬁ6Ë‡=Èﬂ?Á›@Î‡FËﬂFÊ·EÍÍLÈÔQÍÒUÎXÍÌXÎÎYÒÂ[“V‰πHÓπQ¯∫W‹ö:È≠KÎ¿Zﬂ¬Z‰”g‡Ÿo‹ÿw›‹Çﬂ‡ê€›í⁄€óª∫ÇZV3:8!4;):G65C2+9($5%&7'2@/:G6@K;GTC>O</B.,=+(9'(9'0A/*8'-9+1=11>4,>27K@<LIdsn>KAFTCKZC>M88D63>8akm9@F;?B)-,&%/$#))6%%'/=.6B4* &#&&(46)+1%4</+5*#/#(3A21?0($#* ",-=0.@03E51D10A.-?)1C-)<).?/8D:kujMYKSaTtÄ~ü™Æjnw ' !/"(=*%;&-+))0(/4.			'2E16M37N23J.4M0<U89R58Q46M1,?)$1 
+$'6#(:$(:$);#(<!&:!8 7&:)="&:!#7254&=#+>('>$.G*-G**B(+B($6 &#$/!$0"$2! .*'"%5=(9A*15& $!
+
+	 '"3#"4$0 7%3J85I=6J>;LB0B6%7+.@46H<4F:4D9#3( 0%(8- 0&*!) *7.1>42B7/?5)9."/%(- ,&')'&%"!#'1'<)6H:<NB=LE0=4+7-%/$/7,,4'*2#3;,-8(&1!"/,%4%3'5(4 #.&.)/!7?09D42@11A4%7)
+.%;&#=" =:#>&A"%B#*I))H)5 "#:*eÄm{õÑoëyEfSMn]jà|vîàÄûíÖ£óã©üá•õÉ£ñvñâèØ¢ê∞£Ñ§ïwòáyòÜuó|qóp4^09c1@l9WÉRS~QXÉX[Ö]déhjóppûwWÉ_V_JqRÉ´âXÇ\YÑYKvIZÖXUÄSJxIZàW6b-iñ_Bn;:f5?e<7]41Z.2]//[**V%%O!'N"/R*LnKkåoléulçzgàuiåvcÜnGkO5Y=?$$B&:[><]@.O4)G-(@*+>+/=.`n_9J80C/2H18P88P:;S=8Q;8Q;4L6#8%-7/ *!	*!2"&(%$),-(0 !6#3K39Q74N3,F+-G,*F-)E,%>(#;%0,		!-'8%*@)#;!'?%$>!.H+)C&$<"&>$&=#':$"
+#*+!/",)%$" #3G;C[K;XD5R<:V?0J1%?&.G11J4'@+-F14M8-I21M4$<$-
+
+
+-32125 ;!<%C!)H(*K,1R55V93T71R54P7%='
+
+	
+	
+	
+ %3$+<,>I9RL@XB-åg= ¢g·¿{Í”ÖÓ›çÔÂêÔÁíÌÁëÌÊéÏÂãÎÂáÎÂÉÎËÅÏÈ~ÍÊxÈ„sÍ‡oÌ‚oÓ„pÌ‚oÓ·nÌﬁgÎ€a„œR⁄≈E“∫4…Ø&«¨«®¬¶∆Æ»∏…¿ŒÃ"–“&”◊*÷⁄-÷Ÿ*’”(◊”*›⁄3ﬂ‹9›€;››A€ﬂB€‡E‹·F‹„H‡ÊP‚ÁU„ÂT·‡P„·P„·N„„O‚„J‡‡B‹›:›⁄5ﬁ›5›ﬂ4›ﬂ4ﬁ‹2‹”.Ÿ«%›…,„”8‰œ>·∆EÂ»SÏ÷iÛ‹tÒ◊iÓ XÎπ>„Ø(Ì≈/Û÷4Î‘.È‘+È“,‰À&Îœ-‰»&ÊÕ(Ë—)Ë”*Ê‘*Â’*‰÷+Â◊,‚÷,Â◊0Âÿ2Á‡:È‰>Í‚?È·@Ï‰DË‚DËÊFÈÎJÍRÈTÍÔWËÎVÈÊWÒ„\Ì R‡≤Bˆ¡WÏ±K’ï3Ó¥PÁæU„«ZÂ”c›”dŸ—n›ÿ}›⁄â◊◊ç⁄€ô≥≤|MH(HF1GK<0;-%3""3!&9&+A,AY?WnT->+;L9=P<,B->Q=fwe;I85C22@/@N?boe@MD8G@@OH2C=`ohIWFXgRbqZ;M7JXKdpl`jl9@F-25V\Z) (2'"'(5$'#&2=/%0 '$&*48**0$6>3*4+* &3)6D74B5*(('9)+@/-B1-B10B2,?,*=).A-1C-(9&/4D71=3bnd=I=Q^Tgrtjt}àëòAIKQ[P@H9$* ')9.'9)#4"-)') .". 
+	#4!-D*6P33M25O47Q6<V96P36Q27P2'>"*<&(&2$$2!#0#0..1$;-D'1H,(?%#: $;!+C+,D,+A*,@')@&+D',E()A'(>'%4!"!* +%1%'3%". ,,*$%!,6?*,4!(+/  #
+
+"
+		
+! .!#4$*<.'<-/F67M@7K@(<15G;);/1%+?37K@;LB;KA)9/(:.-?3,=3+;1,<21>5.;2/<31>4)6, -#)%*)( . .(%"%$(0 "4$-B18J<.>3!.$)5) *(0#/7*+3&4?/1:),7&'4"+&5 (7",9%(4 )''(4&,9(.<+)7( 1!
+*&<%"<<:!>'B#&C$(G'.K-1&4!Tq[_hrî|~üémç~cÇseÑuzôäsíÉå™ûé¨†èØ†}ûçmèÖßóxöâyúÜkçr[Ä^;b6Ak;R|LT~PUÄUR|TUYXÇ\båfbèhO}VIwRFoOjìqx¢zFsHcécVÅVhíjdèdYáY6d5Bq;MzC9h2#O@0T.1Z.-X*)U"$P!K+Q(LpJOqPgàkkãsdÖp^laÑnjét:^B7[?1R73Q7;Y?4R81M6-F0-B/3D4;G;bn`N]J.A+$<"": $<&*C-&B)(F,2N5<T><Q@3C6"0#$*8+
+%,"5"*)#&'+&+%7''<))A+1K0:T96P3.H+(E'-K/.L0.J1&@'!9#*
+	$.=**':&.,1D.',
+	6F;>UE=XE9VB;XB6R;0L5(D-<XB+G1,G4*C0:S>/K4-I0$<$2	
+		
+*!56569%@$?%C!'F$)J+-N13T74R63Q5#=$.
+
+
+
+
+
+
+
+
+
+%*$+2*(2'"-(0!3:*JD6_H:ÄZE∏à`‰πÇ”èÙ‰óÎóÓÓîÏíÏÌèÎÍçÎËâÎÈÖÏÍÉÍÏÍÌzÏÌvÈÁnÎ‚kÈﬂfÏ·kÏ·kÎ·hÍ‡gÏ‡fÌﬂbÈ⁄Y„–M”ø8Ãµ+–∂-Õ¥&«±ƒ¥∆Ω ∆ŒÕ#“‘(‘ÿ+’Ÿ*◊◊+”—&Ÿ◊-›‹6€‹9›ﬂ@⁄ﬁA€ﬂB‹‡E⁄›Dﬁ·L‚‰R‚‰S··O‚›K„ﬂJ‚‡M·‡Hﬁﬁ@›€9◊‘/Ÿ÷/⁄‹1⁄‹0ﬁ›3ﬁ⁄1‹”,‡‘0„◊7„‘=‚»?‹æB„«Z◊rÒﬁwÔŸlÌ…W‚ª<Á»9Òÿ=È”0Á’-È“,„ 'ÈÃ*‚≈#ÈŒ)Ë–(Ë”*Â”)ﬂœ$Â’*Â’*·–(Ê”.Áÿ3Îﬂ;Í„=Ë·;Áﬂ<Î„BÂ·@ÈÁEÈÎJÈÔQÈUÍÔWËËTÏÁXÒﬁ[ÎƒMÁ≥F˚¿X‚§=›ù9Ô∏QÊ¿SÊÃ[‚—]‹–`‹”n›÷{◊’Ç◊ÿåŸ⁄òÆÆzGB"FC0<@10=,*;)(>)*B,D^EMgLAY?$7#%6$CUE1F56I6PcPLZIAO@>O?K[P_pjáïïo{y]ig7FAVf\M[JTcNM\G0?,P]SuÅuÅvÑelrBJL%/''1&$')$$ )0;+'"'+.2$*2%1;0(2)%2B51C5'9+1A43D4.C2,A0-B1'<+ 5"':'2E1/B.'8%-#4$5E8 ,"?K?:G6Xe[jxymzÇ}ÜèMWXdnc_jZbg`^e^:E=)6,+#"%+!/,#(7$.B),E(3M06R91M4-I0,F+0J-1J-'@"$;'; !0#-")6*C&:S69R5,E(#;!'?%4L43K3*B*,C))@&*C&,E('?%&<%"3!'*(6)+;.&6)(8+#1"-#1" .!/ -*)%	#*1!#)&+$/!  
+	
+		
+	$,$5%'9).C4/D56L?7M@>RG,=3%7+"4&%9-4H<7K@9MB5E;'7-,>2.@41B83D:4D:$4*#0'*7.'4*,"&"$%3&*(%3"(7$)%%##-*<,);++=-(:*.!+( #+6>13>02=--6%0<(,9' /+:')8%(3"!,(&('8(*;)):*)7( .3$ 5&!6%+(4"?!=; ?!?%D$+H)< / 7%.L4EgNUu^zöÖÇ¢ìâ©öÖ¶ïmé{Tu`]~ixóáÄüèí≥†lèyLo[xõá}ûâ{üÉdçe=f:3\0DmAfèc[Ñ\WÅ[\àdZÑ^]á_cêgbëgP}T3`9QzXtûzM}MDtBM{MItIdéfQ{SCpE3a3ZàWEt>?n7B=,N+2X/.Y+$P L"I2W.KmJoêqrîyjåsmçvWxcX{cSv^<`F8ZA6X?7W?2N7,E0+@/8J:3C6FRFYaV|áwIVBGYA%9 .4.F.'D(;87'?)/G16L76I52$-&9%.+$%)- 1!"4$"7$%;&&<%-E+;X99X83R20R11U17Z95V7/N/.H-"		&! '
+	
+
+	)3H7;T?:V@?[E7S<6R;)E.5P=B_K(E1/L8(C0>WA.J1/I.)?(*
+	
+
+
+	'"677 ;%@+F#)G%&F!*L)/N..M.2P4)F* 8 #
+
+
+
+
+	
+*1)+5,&2&+3&&$=*`<,áWAºágﬂ≥ÑÒœíÚﬁôÈôÔÔôÌÚñÏÚêÍåÎäÏÔàÎÌÇÏÓÄÍÔ{ÈÌtÍÏoÍÈkÎ„dËﬂ`ÏﬁaÌﬂbÎ‡bÎ‡bÎ‡bÎ‡`Ó‰aÏﬂ\ÊÿS⁄ C“¿6œø.Àº%»ª∆æ»√ÃÀ#œ—&—’(‘ÿ+◊◊)‘“'‘“'Ÿÿ0‹ﬂ:€‡>‹›A⁄€A€⁄BŸ’>€◊B‚›K‚‚P‚‡O‡ÿE‚ÿC·ŸFﬁŸAﬁ€>ﬁ‹:⁄ÿ5Ÿÿ0Ÿÿ.◊◊+ﬁ‹1ﬁ‹1‹ÿ.ﬂÿ0·ÿ5‰÷8‰Œ<‹¿;ﬂªIÓÕfÛﬂ|·|Ò‹sÍ’bË‘QÈ◊GÍ◊;Ë‘3Ë“.Í—.ÍÕ+Ê∆%Ê…'ÊÀ&Ê—(‰‘)‚’'Â◊,Ê‘*Â–)‰Õ'Á‘/Î‹9È›;‰÷5Á€;Èﬂ@Á·AÁÁGÍÏMÎÔTÍÌTÍÌVÍËWÔÊYÔÿVËæHÔµJˆ±L€ì/Âß@ÔøQÊ≈R„ÕV·ŒX€Œ^›÷n€ÿy◊◊◊⁄ãÿŸï≠¨vC@!87#<C11@-)<(2J2CaGFdJ=W>(>)"2%+8.ARH=QF<PDEWI\l_fviQaVO`Z}èìï§´Üëïpz{APK>NCR`QHUD'2"),7/Vb`äê[en6?Hens:C@$.%##. ($# !(0# (%+''3',:-.:.))-B36M=6K:2D41B2'7*-  1!2(>)1G0/@-$3 ,**:-:J=$0$4A0HWBO`NjxxÇèóêò£NU[X^Zv}vu{yú¢†äëä,3+%&4#!/');%-D(1K0=Y@=Y@9U<1K26N60H..E+%<  7"6#2$%&
+/%=#0M/=Z<;U8*C&*B(5M58P87Q85M36N6+C)(A$,E(%<"$:#1"5"%8%&8((=,.C2'9)*;+&4%+9*->.):*):*&7'"0!+'"!*-6%(5!,;&+='-?)+='-%	 .!2 )<)4I60E4,A28NA<RE=QF.?5!3'*<06J>7K?2F;;OD)9/&6,4D92B75E;5E;0=4*!'3) ,"'$!#&6),=-,'+%6#&5"*%%&"0':'2E22D4*;+,- * $0;-4?/1>,%1,9%)8#(9&,;("/ !'+#5%*<,+=-&4'"."(C0-I3.J3,F-92:><="A%D$(E'1+D1B^HKmRQvWUw^~ùãüê~ûë|ùåwöÜjétKoUIkScÑo~°â\Éh>dKV}bÄ§äy°~_ä\8d3GqCJsGjïjbådMzSaég[à]P~P[ä\IxJHuL<f@pövzß~GyDH{CEsBGrEeêe7b7/Y1GtIcëbL{G<k4(S3U05T2,R)-W)*V#%O(O":_6FhEFgHlèqXzaCcKBbJ>`G>`G7W?/O8+K6)F2+C3+B2 2&Zj_<J=tÄtfnazÉrjxaYiO5G-*&9#6L5)F('D%"</+,0!8"9#6  1!-.&9%1,$'+/!2!6" 7#*B,:R:.H+>]=;]:3W3,P*1W09_87[76X78U6)B%+
+	
+
+!"
+
+#+3"4K7<U?=YB8T=<XA3L6&B+7T@A^L#C.;XD#?):S=3M2/G-*='*	#&%.38";%>/H*)D%,I*)F'-J+493+&&,		
+&)3(%1%+6(56(>.hB/™v^’ü{Í∫äÚœïÔ⁄óÌ·óËÂîËÎîÍÔëÏÒçÏÒäÓÒÜÏÇÎÓ}ÍÌxÍÓuÈÓpÈÏkÍÍfÏËbÎ„\ÎﬂYÍﬁXÏ‡ZÌ·[Îﬁ[Îﬁ[ÈﬂYÍ‡ZÈﬂYÊ⁄R€–C–ƒ2À¿(…ø"…¡…ƒÃ…"ŒÕ#œ—&‘÷*ÿÿ*””%”—&⁄Ÿ/⁄›8⁄‹;ŸŸ=Ÿ÷=€’?Ÿ“<◊–:ﬂÿB‚›M‡⁄Hﬁ“@‹Œ9ﬂ—=€–:ÿ“6ﬁ⁄9›€8€⁄4ÿ◊-ÿ÷+‹⁄/€Ÿ.Ÿ◊,ÿ‘+€‘.·◊7‚“7ﬂƒ7›∑<Á¡TÒÿtÙ·ÇÛ„ÉÔ‡yÓﬂlÏ›^Ï€OÁ÷@Â“6Î’4ÁÀ*„≈%Â≈$Á (ÁŒ)Á’+Ëÿ+Ëÿ+Ë”*„Ã&„ %Á—-ÎŸ7Ê◊6ﬂœ1Ïﬁ?Ëﬁ?È„CÎÈIÈÈKÍÎQÍÎRÍÍTÎÊVÔ‰WÓ”RÎºHÙ¥JÓ†<Ÿç+ÎÆD¬RÊ»Pﬁ»NﬁÀS‹œ]€‘i€Ÿu÷Ÿ~◊€á◊ÿíüüi>>142>*'8%-E-C_FBbK5U@,D4$8,.>42>:M]ZP`]GXRGVOQaWlypVe^ZjjÖìûzàïèòüÄàäJWP6C97C5(.87fqwÖíõlxÑr|ÜQ[\!*%%,$*%'  $ &%7=1%+9,/?27E8:H;;M?7L;1H6)>--$#4"/B.4G1*=',* ,,1A43C6@L>9D4JYD=N>Rbbéö¶îõ´Öëjruuz}Ñàú¢¢ß©§#&
+ #1"#2,((<#0I,7Q89U<<U?;T><T<:R:4J3-D*(?#"6!31. /$1$1  ((9''A&,K,;X<-J.+E*:T9D]GIbL:T;+E*3K3(@&$;*A'$:#!7 "8#%;&$:%)>+*A-+B0/D36H8/@0->./A3,>0+=-->.&4',("*)4#*9$.@*+?&,C)-A((:$#
+&%#4"':&/D18M</D31F77N>=QE@RF.@4'9-2D87K?5I=%9.,>2).#.>33C8&6+$1('$'' -#$1'#0'(5++;.,:-(#&"1,;("1*()$1 !2 !4!0!2"-%3$#1$*'0<.:G60=+#.'4 (7$*;((5# +!)-,-?/*<,%3& , *G1,J2-I0.K/-L-&E%9>=<"@%B$4$@)B`HFhMFnLPxVaÖi†ãâ©öâ©úã≠üÉ•î`ÜmSz]FmP>eH@gHR{[R{];dDXÑc`çf?m<9e2T}QXÉVfîfKzLO~PYâYQÅO<l8L|H;i85_7\Übsùwgïg;n5I|APÅJ7f2QN0[.6_7]á_VÑU?n:7g-&QA3R06[2/Y+-Y&)S!'N!5\0;_9:]<gäjEhJCdI4U:%F+*K0,J2'B/'?1<RFYngj}wBSK?OE^naéúãcn]sip|dR_EO_D%)<&6L5%?$8U6)H(<-()+./*$0%8$2)&'*.+B.0I38#:V?@\C:Y::]<:^:.T/.T-1W05[43W3.P-2R-7U3.G*.
+	
+
+	"% %&!,-(13.470;>5CF=7:1,/&		
+
+#'5$&<'/G19R<:V?6R;=ZD5S;/K4'C,4Q=<\G%E.<ZB&B)2L3&>&5.?,"0"		!!(.-+?&31'?%+D'/')1!7 $:#+A*!7 $7# 1=1#1"#/!+/!?1$[:'£mQ‡©ÄÀîıﬁõÚ‰ùÓÁôÎËóÈÁíËÁçÊÂàÍËÑÌÏÇÌÌÍÎvÍÍrÍÍnÈÎlÁÏkÈÏgÈÎcËÈ]ÍÁXÍ„UÎ‡RË›OÏﬂRÓ·UÎﬁRËÿMÁ⁄NÏﬂUÍﬂRÊ€Nﬂ‘D“»2Ã√( ¿  √…∆ÃÀ!ÃÀ!—–&÷÷*——#–Œ#◊’+Ÿ⁄6⁄⁄<ÿ’:’–8ÿ—;◊–:ÿŒ8ﬂ’?·ŸHﬁ‘A›À9◊√.›…6€ 4”∆,‹”6€◊6◊÷0ÿ◊/ÿ◊-⁄ÿ-ÿ÷+◊”)’—(Ÿ◊-ﬂ⁄4‚÷6‡ 6ﬂ∫5‡∑AÍ√^¯÷|ˆ‡äÒ·â‡ÄÏﬁsÌ‹hÏ⁄ZÁ÷HÍ÷?ÊÕ2„«(Â≈%È…(Ïœ+ÊŒ&Ë“'Á—&Áœ'‰…$ÊÕ(È”/Èÿ3„‘1Â÷5Íﬁ>Áﬂ>Í‰DË‰E‰·DÈËOÏÎSÍÈSÎÂS‡UÎÕKÎ∂BıÆBÎô3‚î/ÏÆAÌæJÁ«L„ÀM⁄∆Mﬂ–[⁄‘dŸÿn÷⁄y’€ÉŒ“ÜäçT7=1;",>&+C+?[B@]G8WHiÑ}aut,>>3AA>LLGTZYdjQ\^WabKUTKUVR]_jwhtÑÅäôyÄÜ^gf\g_6B8$.#!#!'%-6;ÅéóvÑësãuÄÜ'0/ %$)1$#"%03*@C8)/%1=35E:5E84D7->."4$/B/"3!,.A-/B,$3 $1 )##+7D:1?2?J<GRBO]NQaW£≤πù™∫ãì®≥∫Õ±∏»zÄåilsÑÖáikf ."3 /(7$	-(@&5O2?Y@>WA;S=4L60H0,D,,C)%9 #71 2/10$3*7#%-&7%-E+2O1@]?%B&'D(EaHC_H?XB6P7&@'&>$!8!5#7-"5!':&#6"2/*?,0G52G6(=.#8)&;,.C2'<+,>.,=-,:+!/ (#%*),"3 (;%)@&(?%&8"!0". 	+&7%(;(+@/0G5)>/+@15L<5J;8J<,</&8*);/0D9';01%)$+$2% .!+* "!&#1$+;0/?40@6%2(*&
+$$1  /-- ,**+0/'8&&7'&8(/A32B5/=.0=,/:*,9(+8&+8'(5#)0/3$(* %)):(1D1+<*$2!!-$D,(F,)G+)H)*I)%G$$C!<:;!?!> &D*7W?<^C?dE<eCFoMSw[_Äkyôåê∞•ì≥®ã≠ùpñ}JsUCjKEmK:cA=gCO{XIuR=kFPS<k7Et>TÄOQ|N[âXFvBHyBBu<5h/,_$2c+0`,IsKhíliñk]ç[Ct<As6=n6(W!+Y('R%FlGS|TEsD:i3Fs<,T":9V7=`85\/.X((R"&M 3X/+O)(L(=`?WxYXy\^|`=[?<")B-AXHH[U\lkgvy¨ªæm}|Äëâ]oal}jes\ZfNXeKcqW*: )':&)?*-G.=Z<:Y9.M-#>0.+-,(##6""5'&)$2%/<T>9U<.J3?]E;\A;^@:]=2U4/U00V/2V0/S-(J')K(3U07W2+H)/"%$' *-&%$* ),#-0'36/,/(!$
+%0"+>*.F,9S:4P76R98V><ZB9W?(D-4P97T>3P:,J2:V?(B)(@((""0#$$	
+"!2.443 2"5%=#(B'(B'/I.-G,1K2%;&&
+	'3'+<,#4"(9)35'L6({P=»åjÛªäˆŸóÛÁõÌûÌÔõÓÓòÏÎëÍÈçÍÁÜÈÂÅÈÂzÍÁvË„mË‚hË„eËËdÍÏeÍÏdÊÈ\ËÍXÎÈVÍ‰PÍ„MË›GË›GÏﬁJÎ›IÍ⁄IÈ⁄IÏ›NÈ›MÁ‹LÊ‹I·◊B’Ã3«ø«ø…ƒÀ…ÕÃ"—–&””'””%——%ÿ◊/◊’3÷”6ÿ—8‘Õ6’Œ7◊Õ7Ÿ–7ﬁ’<›÷@ﬁ“>‹»5⁄¬.€≈1⁄ƒ0”ø*’».ÿ“2÷‘1÷’/”“(◊”)ÿ—(◊–'÷“)Ÿ◊-‹ÿ/‡‘2‚œ3„√4€≤2›ÆDÏƒeÚÿÉﬁåÏ›àÍ›ÅÈ€xÈ‹lÏ‹bÍÿRÍ—CÊÀ6Â√,È∆,ÎÀ+‡√ÊÀ$ÈŒ'Á $·ƒ Ë—+Î’1Á‘0Á÷1Ë⁄9È›=Áﬂ>Ë„AÂﬂ?‡€?ÍÁNÎÍRÈÂNÓ„SÔŸPÌ«H„®2Ó¶8Íô0Êô/Ë¨<ÍΩFÁ Jﬂ J◊√Fﬁ–Vÿ”^÷’i‘Ÿs“◊}√≈zot:/92B'2I-=Z>;Y=7T>,G>d~}¡’ﬁÉï°LZeo{á^jzkwápzÜhqz]fm]hnKU^vÇéu~èyÄêX]a=B>:@6?E908+$!$!"&/.ny}ÑëöuÇãvÑ!*' %%!)"*#)!"#'( =>6;<4&,"2>4&3)($0$1?2!2"DUB->+ &3"3D1.A+/!&1!&.!" *4A71=1;C6FNC8C;yáá≠æ»´∫Õü©¬òû∂ãê¶±¥≈qq{:;?#%  ". !2 2 1*7&%%;&*D)2O39S:=U?6L73I4-E-'=&!5"6../!3!3&83);#$/		)'?%6S55R4)F*6R9?[DC_H1J4*D+(@&%;$!50/.02.+23H53H7-B1(=.(=.%<,'>,!6%&8(%7' 1!"0!-&(+". %$, 3(?%*>%-A(,;((
+	#"0%6$2E2%:)*?.-B3!6%*A/$9($5%/.!-?1,>20$($)- - (&$!)'7*.>10@5-?3)9.'$		'.*;(->,!/ (!/%6$%6$+<*3D2)<)?TC:Q?6K<.>1-9+'2"+,9(+8'%.*-01!,,  "!$5D1.?,)8#'4"%0"@&$B("@$%C'#B##B##A<769!>-N/1T64X<7^A:cEAjLNuXUxbmçÄã™¢í≤ßí¥§é¥ùÄßåxúÄfãlIqN6`:6b>7d=9f=M{M8g1?o5UÑNM|FL}E?q6?q22e#1d"/a"2e,5e1L{OZâ]höiWäR<m5/_%.Z%)U"(S%'R'8^9QwPYÖTJyCCn8>&A 6Q2IiD7\1*Q%+R&/U,4X21S0;]:+M*,N-+H*)F*!>"7&=+Ui`jx{~ãîêú®ãô¢brr]nh^pbWjV^mVZhOTbI6E.H^G2,23K56R96T8:\;,J&!<341.( /&8 &$)7H8%:'?W?>X=:X>;\A6Y;6Y;;\?8Y<6Y80T0.P-%G&&E&/N.4V3:Z57R3#
++.%),#"%&!()$*+&&'!(3%,?+,D*2J05O42P4<Z@<ZB.L41O7;YA2P6.J1+C-"8#.&!'%
+
+
+(9&#9$%=%*D)(B'(@()C**D)*G+)F*+H,)E,-I0-I0'<)
+( '5(.A.-C.*?,3:(K8)á]GŒìqı¿éˆ€òÚÈöÔÌöÎÓóÏÌêÌÌçÏÏäÌÎÜÍÁÄË‰yÈ·rË›iÎ‹eÎ›`Èﬂ[ÏÊ\ÎÍZÍÌXÍÍTÈËPÍÂMÍ„JÎ·DËﬁAÍ›AÌﬁEÎ‹EÍ‹GÎ›HÁ‹FÍ‹GÁ‹FÁ‹F‡◊>—»-√Ω»√»∆ÃÀ!Õœ#–”$—’&“÷)÷ÿ/◊’3‘œ3÷œ6‘ 4÷Ã6÷Õ4÷Õ2Ÿ”7›÷?€—;’ƒ.”Ω)Ÿ¡-⁄¡0”Ω+–ø)◊Õ0◊—1÷—-“Œ%“ !‘…!”À"÷œ&Ÿ’+ÿ—)ŸÃ(‚Œ1‚«0ﬂª/◊´2‰πPÚ”yˆ·ê„ïÏ‰ìÌ„åÌ„ÑÔ‡{Ì€mÏ”]Ê…I‚¿8Ë√4Ê¡(‡ºÊ≈"Á«$Á∆#·ƒ Î÷/Á÷.‰—,Â‘/È‹8È›;Êﬁ;Á‚@„›=Â„CÎÎOÍÈPÍÂMÏ›LÎÕGÍΩ>Âß0Ó•6Íú0Áü3ÊØ;ÁøEÁÃK‹…F€…I€ÕR÷œZ’”d“‘oŒ—x∑∑oW\$-<6M0<Y:8W75R4.J3.H=3KM±»÷ø”Îxà¢tÇùåöµì°ªî¢ºù©ø°Øº®µæâñüÜêúìüØ{ÉêPSX<=8HF7IH6=A239+#' &-5(%/'+62kwwdno9B=&)1$%-  (!)&, "(!$!"$$=>6&) %,$1=3(4*! 180(4&<M:(;%&8"%4.@*%7! 1&!'2$)1$&<H>-9/7=3>C=1;<ß¥ºm|èó•ø©≥ŒsyìBCXrqÅ••±=@E!,$2!!4 2-		$7$'A(4Q58U9<T<;Q:2H1-C,.D-)?(110.3!5004&:!)6$		!&<%.H+)F*1N2JfM>WA6O9.H/-G,*B(-@*!2,+*,+*.(=**?.(=,'9),>.,A2$9* 5$$6&(:*'9)$5%"3#,,((*(%(;%%< )B%.B'$6 %+!2 $7$5G7.@0+@/)>+%;&/E0#9"&8"./->.%5(!1$&%&(('!"');-0B41C7/?4)9. -#(&	
+'5$2E/4J3,=*$5#):'/@."3!:K;%6&:L<:O>4K95J;3C60<.#.&3"+8&&1 "+#%00$%%""(6E21?(+7!7@--6#+I1*K0.O2-N1*K.-N/+J*%D""@=(C$-L-2U57^?>eHHpUPy[NwYMtYSv``Äs{ôëé≠•ë±§yúàjçuhäqqîvDlIBlFQ{U>kB;h=N|M@o8Dt8L~CEw<:l/4f'/`+\)\.`!/`(4d2=l>XáY]í\Bu<*Y" K%O%O&O#3\2LrM]Ü\TÄM>k43^)( !<6P3GfDOqLCgABf@Bf@1U1*I'6U3;Z8.M+%B#-J,D^A1K00E4CRKWbhuãù¶µõ®±ÄèíyâÜ\peMbQWiSEU;O^I.@*oáq5N9*&;(/F2.G2[y_BcD3U0$D<41.'&&*,>&&#%1D11I39Q9=Y@;\A8[=7Y>:\A>_D>_B6W8-O.+J**I)2Q28W79X6<Z8+D&!.4("*#
+
+-.&69014-,6+4E20G-2I/5M36S7;Y?2N79U>4P9<Z@2P4.H-/),+$($!! #$++ 		
+
+
+
+				*;).D-,F-*G+-J.-I0,H/)E,&C'*F-'C*+I/)G--K1/H2 
+
+)6,-?1.C0)A+%='/8%H7'|S?»ãlˆºå˙ÿòıÂòÍñÏÎëÌÍçÏÈàÎÈÑÈË~ÏË}ÌÁyÌ„pÍﬁhÍ⁄`ÎŸ[È€TÍﬂRÎÊTÎÍRÎÍQÎËMÈ‰HÁ·CÎ·BËﬁ>Îﬂ?Ìﬂ@Î›?Áÿ=Í›CÈ‹BÁÿ=‰’<ÊÿAÊ€Cﬂ÷;Õ«) ≈#…∆ … Ã Œ–$–‘'—ÿ*’ÿ/◊’3‘Œ2÷Õ4÷Õ4ÿœ6÷œ6‘Œ2◊“6€÷<›”=◊»1÷¿,◊Ω,ÿº,÷∫*Ã≥"”¬*÷Ã/’Õ,–«"Õ¿œ¬“ !”Ã#÷Œ%‘…!÷≈ ﬁ )·»-‚¬/‚∏2ÂªEŒl˝„è¯ËùˆÏ§ıÏüÙÈôı„ëÚ›Ñ÷uÔ–dÎ»RÓ…GÁ¿4‚Ω'Ëƒ(Â√#‚ø‰«#Í’.Á÷.‚Ã(‚œ*È‹8Ê›8Âﬁ8Ë„?ËÂBÈÁEÍÍLÈÊKÈ‚IÏ⁄HÈƒ?Â≤5Î™4Í£1„ô,‚†0‰≥<Ë∆HË—M›ÕF›ÃJ‹ŒQÿ“Z’”dœ–j……q§•_EL;P)<W84Q2-J++D'(@(%;/$9:áû¨ƒŸÙñ•∆Ñíµ™∫€®π◊o~ùn|óÇì•©π∆©µ√ò§≤†¨ºßØºcdiUQNQJ:[VB?C24<-+/!+/!/5'(. '")!/837@;05.,2(-3'/7*&.!$,%+" !**"?@8&-%2<3'.&"' 2<1=K:&8"'9!*<$+=%1 1)' ,&#-$:F<,6+03*3501;=~åóbsáö™ƒ®≥—ìö∂Üàüghz\^k038'#1""3!!4!1%$:%(B)3P48T;7O76L5+C+!9!$:#'=&!4/01 42/02!8);%
+
+#-@*0I,,F+;X<D^E7P:3K3+C+*B*.D-+<) .''&&')20 0 "4$$2!&4#1!. 1!%7'*<,#5%&8("3#!1$,)+((-':$(?#+B%.B'%7!'		"0!!2 1B03E57I9,?,'=&%<"!8 7$6&8 $5""3!.)'%$$$!%"4&(=./D52D8*:/+;.+9,*# 
+3A02E/,C)-@**;(#4!,=+ 1!):*+=-5J9$;)+B04I:0@3,7))1"-8')4#$/&/*,    &&1>-5B.1='4=(7@+,5 ,L5,N52T92U7-P0+N..Q0-Q-,N)'F$'D&9W=9]A=fHEmREnPGpPR{][Çgmê|zöçrêàÄûñmãÅdÖtcÑoiãrMpRBjH4\9PxS@jB2_4?m>@o8=m1Dv7;m.+]1a#-`([)Y0_(<j9LzK[â[bí`IE0c(GB"G$K*Q%6\3NwOR}RGs@4`+6a,E0O/A_CCbCHiJ?`AMpOGjI;^=;!>0M.:Y7/O*%E $A"'A&/B.ERHÅâã∂Ω≈´µæÆª√Åêìí•£Zoh1G:DWDCU?IWF+>+|ïÄMiS 7#'>*0E2NeQjÜo]~a8^9*P)*I':7)(&$(+?$*'"1/B.2J45Q:;YA8V>;\A8ZA8Z?7Y>8Y<5V7,N-0O06U56X79X6:Z5=X78L0-<%!.&3"'6!!3)'	
+			
+ #9<1"%!&-%0=,/@-<O94J32J2/G/-C.3I43M29V75R34)&8"0B,2E/6L7=R?3H5:O<+A,'))**) 
+
+
+
+
+$1?.0H0/L0-K1(F,+G.-I0+G.)E,)E.)E.*H0(F.+G00I3$7$	
+$3G;.E5)@,$;'"8#-6#E9+rM;ø~bÚØÖ˚Ãî¯⁄îÚ·ëÊçÔÈãÓËÜÏË}ÈÂwÎ‰rÏ‚oÌ‚lÎﬂeÎ‹_Î⁄XÈ◊QÈ⁄MÍ‡MÏÁOÍÍLËËHÁ„BÊ·?Í‡@È‡=Ëﬂ:Íﬁ:Í›9‰÷5Ëÿ:Ï‹?ÈŸ<‚“5‚“7Ê◊<Â‹A⁄‘8œ…) ≈!Ã  …» Ã!Œ“%œ÷(”÷-◊”2” -”».÷À1÷œ6‘œ5”Œ4÷—7⁄’=Ÿ“;ŸÀ4÷¿,—±"÷±$ÿ¥(…™Œµ$÷¬+—ƒ&Œ¬Õ¿–ƒœ«—…‘…—ƒ‘¡€≈"‡»*·ƒ+‚ø/‚ª8ÁæR˜‘z˚‰ò˙È§˜Ë•ˆÂ†ˆﬁò˜€íÙ◊âÙ‘}Ù“qÀ`È√HÈ√:Ëƒ0·Ω!ﬁºÍÕ)Í‘0‰”-ﬁ»$‡Õ(Á⁄6‰€6Âﬁ6Ê‰:ÊÂ?ÂÊBÁËEÊ‚CËﬂDÏ÷DÊº6„¨.È®0Á°/Ê£2Â¨8Á¡BÏ—LÊ‘L‹ŒG‹ŒK⁄œQÿ“Z—œ^Ã e¡¡kâéKLY$=V/1N//I,'?%%8"&9%,>2+?=]p~¿“ÍèûøESvù∞–ΩŒÏiwîM[v2BYù∞¡üØøù™ªô¶∑ø∆÷iisHBD[SH^XHBF84</69.36+/1&+-"$'"%',%*/( %#'-#+3&$$"'  !--%22(#))0(!( %(!"/7,7B2+8&'4"'6!*>%+B(/E.(>)!2 $2!*!)5+8D8*4)(+ &)"",-M[d™ªœ¢±Œ§±—ìûºãï∞Ñä†13B!/"0 "3!0*%
+%;&,F+5Q88T;6N88P:4M7/H2.F0$:#2.-../1455&:!,	
++>*,D*5O48R73M41I12H3)<(/$5#!/'   %&'-0 / .&1!#."0!"2%&7'!2"./4% 2$- - "0#,(*#$#5(?#+B%*>%!3 
+	". 0A/,=+-@-+>+%;&!8 7766!5"6!51)*%# #(!3#"4&(:,/A3,</)9,+;.(6)+$
+	
+	,9(/A+':$3F0,=*"3!.+#4$#6#!6#,C18O=7I;*8+(3%*2#/8''0#,)0 *,&&'%%%$/8G4.=(/8%,5"(4 .:&,L5/Q81U9,S4/W5/W42Z51W05W28,FbIEgL@gJHqSMvXPyWR{[aàmoï~É£îå™†ã©°ç´°Ç°íÅ†étñ~SuZDiJBjHHpM6^90[05c4;j4:l1Cu6=o0+](X&X%W+Z#2a-DrC]ã\^å[UÜO:p47h0@>B!F+P'6\5BjELwLCo>Bl::b0)N#)H(=[A=[A9Z?7X=7Z<4W7*K,"?! :#@"9W5.N),L')F'%?$(;'1?2s~z{ÖÜs~Ñï§©etwk}};NL;NHAQDVdS7E4):*tãy4M8$;'"8#QfS[r^\xafálInM'L*A 461&&#%)="/*)8#,?)1I33Q97W?4T<:[@<]B0R73T76W84U65T44S44S33U47V49W57P2);! /!0):'(>'*A'+>(+<),=*"		
+
+
+	14+?B7$8G4)=$1C-4G1+>(&9%!2+>(7R1<\5;[4!?1);!.B)>U;F_ILePNgTG`K7O9#;#$7#0()+$	
+
+
+
+
+
+
+	+/E./L0+I-*H.)G-&B)+G0.J3/K4.J3)G/+I1)E.0I33J6''/F6+D1(?+&<'$7#09(E9+gB2ØlRÂôuÙ∫àÙÀãÛ’åÚ›äﬂÖÓ‡}ÒÂyÔÂrÎ‚kÁ›dÈﬁbÈﬁ^Îﬁ\Í‹UÈ◊MËÿGÍ‹GÍ·FÍÊEÈÁDÁ‰?Ê·;Í„=Á‡:Â‹5Ë›6Ë€5‚”.‰“2Íÿ8Áÿ7‰’4·œ1„”6ÊŸ=·ÿ;◊—1Ã«%À»! »ÃÀ!Õœ$–‘'—”(’–.–∆'Œ¡%‘ -“Ã0”Œ2“Õ3“Õ3÷œ6Ÿ–7◊…2’¿)À®œ¶’Æ"»•«®“∫$Ãπ«∏ÃΩœ¡Œ¬Õ√Õ¡ŒΩ–æ◊¿‹ƒ$›√&‚√*·æ0ﬂ∂:Ìƒ[ı“~˘‹ñ˚·§˙‡•¯⁄ûˆ÷ô¯÷óˆ”èÛœÅÓÀqÈ∆^Í≈PË√?ﬂº,‚¡(Îœ0Ê–-‚œ*‚Ã(Ê”.È‹6Âﬁ6‰‡6Â„9‰Ê=ÂÊ@ÁÂBÊ‡@ÎﬁDÈœ>Íπ6Ï∞4„¢*È®2Á¨6Ë∑>Ë«DÂÕEﬁÃBÿ»A⁄ÕK÷ÃP‘ŒV ∆X≈¡^π∏fv|>IV(6N*-G*'>$%7!$3 '5$0@50@=GYc∂∆›äó∑;Jkõ¨ «ÿÙKVrO[usÉöò™¿è†¥ù¨øÄè§´≥∆çåöJEKOGDokbGJA5<4$'780&& &5=0*2%$"<<4++! !!)/%! $* 5;/*2#(3%,$6 ';"(>'.D//E01B00=, +!0<06B6-5(12$++#)%LY_´ºŒò©√®∑÷êùΩçò¥åó≠AGU*" .!2".%
+	$%8N74N3<Y==Y@9R=:S>4P:5N80H2*@)"8!0/2224*B**D)(@&(?%)8%):(0F1=S<-C.4&9&$7$("&$$  %,()4&6<.6<.%0"'3%.:,+<*(=,*A/-B1"7&0".#1"*'''!'2(?#*A%%9 /(&+):('8&#4!!4  6456 765 7 7!5!3#2('/&8(-?/+=/-=0*:--;.,</ 0#+' '),%6#'8%$2#,/-"5"*?,/D31F5/?21?02=-4<-3<+(1 $-.7$DH:02%$$+- %..;'9H3-<'/;'-6#,9%1@+,J00Q62W82[;1]:3_;8b:;a:*H&&)5L0QnPPsUNuVT}[Q}ZP|YKtTRy^Y{j~ûìè≠•ì±©ñ¥®ì≤¢ä™ïÅ£äsïz]ÇcLsT;cA3[6:e84b16g0:l19k,2d%#U&V+[!5a.Bp?TÇTZäZYäSVáOEv>$P>:="E.R,?e@<a?JrMQ|ODn@6]0:+I-:X@B`HLlTFfN/Q8$E* >$#?&$A%'D&5R3%B#.K,#@"+E*&>(5J9/C7':4vÜÜM\aÇìöYjq-<Aâóò4@6\iX4A0/=.'9)4#%8%%;&H^IWoYNjSB`H'D.="(I*,K+&?!2&""$&: 4* 2(>'0J1/M36W<4U83T72S60Q4/M1/N//N/1P0.M.-O.0R15T26O23',"3 #9$*B*+C)-E+.E+&=#(
+"58/5;/ 
+6E0F_?8S0.B'4C./>+&5"6G4?V:Aa:9_0>f47].;%=2I,BZ@G`KTo\Xp`D]J8Q;6N64K14G1((&%
+
+
+
+		
+
+
+
+!,0C-1J-.K-,J.-K1,J0(F.(F..K5.K51M6,H11J51J50L6)@,!,,A.'?)%;&$7#$7#4;+H8+d:*•]G€åm∞ÑÙøâ«áÔŒÅÔœzÌ—p⁄mÚ·mÏ‡fË›_Á›ZÁ›WÈ·XÍ·TË‹LÂ’AÊ’=Í‹=Ë‡=ËÂ>Ê‰:‰‚8Â„9‰‡7‰›4Ê€3Âÿ1·“-·Õ,Â—0‰’2„‘1ﬂ–+·“/‰‘6‡”5ﬂ◊7÷–0À»#…∆À  ÀÕ"Õ—%—”(”Œ*–∆&Ãæ “√(Œƒ'Œ»*–«,Õƒ)—∆,’».’»,”√(œ±»§œ©Ãß∆¶œ¥…Ææ•
+ÀµÕ∫Õº»∫ ∫ÕΩ–æ‘ø⁄¡›¡"›¿$‡æ'ﬂ∏,‚∂;ÎΩ]ˆ»{ˇ÷öˇŸ•˛÷£˚÷¢¸◊£˙’û¯‘ñ¯÷èı“ÅÒÕoÌ»]Á≈IÁ @È–8ÊŒ0‚Ã)„Õ)Ë◊1Á‹4Êﬂ6‰‡6Â„9Â‰<ÁÊ@ÁÊ@Á·AÍŸAÊ≈8Î∂4Ë®,€õ Ì±7Ë∂;Âº>ÂƒA·«?€√=Ÿ∆C◊»G’ÀP–…T«¿V¬Ωa≠Æb]e,AM%9L.CV@@O</:*&1!!,$/'-<9UfnÆΩ–ü≠»wÑ§≈’Ô≈’ÓZdmwí¢±»áóÆö™√§¥ÕÄê™àí´´ÆøMKV,'-sqrDJHdjfJMF./'33+
+	
+	
+$.6)DL?"# GG?$$)/%!$'36-/2'!)'#0$3(9&)<((>)-@,9G60>-*4B37B4(,D?,TM;A=2EIJ¨ºÀï©¬•∂“õ™«àñ±êõ±ku#-.,##1"!/ '
+
+
+$(5$=T86Q22O39U<=VA:S>=YC9R<4L48O5*>%02!866"9$<"/I0,F-7O7.?-
+&(6)(6'"#+*%#!! %.,)(0!<@1>@2*0",5$5@/2C03H51J5-D0&=)$9($6&#4$!/"+'%#%$8';"%< 30!0-/!4 $5"-1222!5"62 4"6!5$6!3 /%+'8&-@-0B21A4'5(* +! .!)*&%$%&&+!/ )(,-./ 1!(9)6C24?.4=,/8'&29E1@H9,2&*-"+1%&3!6E00?**9$+7!0<&3B+/A)3+I-2S86X=:aB:cA?e@1S.0$9;O*;Q+8R+PnHX|XTyWTyXBgH1T6NrXVye|ûêã´†ëØ•ó∑®í≥†Ñ¶éÇ§âvô{kêqkísKsQ4^8FqD3a0-^'1a'3e(+[!)Y'V3b,:h7HvESÉQ[åUSÖJ<l2I:68:"B&J&-S.BgFS{VOxN8a5/S-/7U=@]G7T>*J3&F/(H0'G/'E+ <# =!"?#-J.#@$(E)%?$(B'JdKXt]Sn]Nh[I`ZìílÖ4EMTajπƒ»ALFYeY/=.-;,,&7'\o\/B/6I6\s_)D1%B.GdROoZ5X:4V5*D',-((%"9 7,1+A*1I1-I02S61R50Q2'H)2Q2.K-1N03P23R25T56U67T52K.1%)0!7"$<&(@(+C).F,-F)-A( +
+
+
+
+17+9B1
+$IaACd9Gh=>V6%7#5$6 2F-B]>Dg?Ak;?l5=e02S$!=(A#3K3G`KLdTG^NCZHI`LMeM:Q7.B)0 /%"
+
+				
+	%.=(0G-1K./L.-K/,M2-K3+I1'D.)E.0L5/H21J51J50L66O:.0)?(%;$$7! 2*9&;<*[@/ê]H»ÅeÎ°|˘ºç¯«çÙÕäÚŒÇ wÍ∆hÈ»]Ì“]Ì◊]Ï€YÎﬂWÍ·TË·RË‡MÈﬁH‰’<Â–5Á”4ÊŸ3‰‹3Â·7‰‚5„·4‚ﬁ4„€2‰Ÿ1‰÷/‚—+·À'ﬁÀ'·–*·”,·”,ﬂ–+ﬂÕ-ﬁÃ.ﬂ“4ﬁ÷6”Œ,Ã…$Õ #ÕÃ"ÃŒ#Œ–%“œ(–»%œ¬$”≈'Œƒ'œ∆)œ¬&»π π!ÕΩ"œ¬&–¿#œ¥∆§À¢…£À®ÕÆ…ßµñ ≈ß«Æ«≤∆¥
+»∂ ∏Ã∫ŒπÕ±€Ω›ø!ﬂ¡#ﬂº"‡∂,‰≤AÓ∏`˚»áˇ—ùˇ”§ˇ◊©˛ÿ´˙ÿ®˚€®˘⁄°Ù’îÒ‘àÒ”{Ì–hËŒWÂÕGÊÕ=„ 2„ /Ê“1ÊŸ2Â›4Âﬁ5·ﬂ4„·7Â‰<‰„=Ë‡?È‘=‚Ω1ÁÆ-€õﬂ£'Òª=Êπ:·∫9ﬂæ9ﬂ√>ÿ¿<⁄«F’»H’ÀRŒƒS∆æY¿∫dõõUx~NEP.P`Ecr]LWG2:-)1&'/$6A9bnléïØøœ®∂–∂ƒ·ÀŸÙ≈”Ìdmä_jàõ©ƒí£Ωû≠ £¥“ñß≈åöµÆ¥ÃPSdBBNPPX<ADKTQ`e_,-%891/0(#$
+
+#CK>17-()#12*CC;#% !' '( 03*!$1 #2+:'#6"':$':&'8%(9&,4E23>.48'VO<TL9VPB783õ©≤ù∞¡™ªœ†Øƒåô¨ñ¢∞@KO!-)#1$#1"#/!	
+*5%3G.*C&'D&6R9>ZD?[E?[E?XB<T<.E+$833 7%=#!9!%=%$<$)E,)E,3L68K8
+
+'//,&%#!#%$'*(&!"(/3$.5%$/$1%6#.F0)B-0G30G31H4-D0&8(/+(& #2%8"!5020,."5"3 01.1!3"4012/!3"1*!%+9*/@..?-1B2(6)!-#&&& ,  , '
+	
+#. '""%',(())(.$6&0B24B12A.1>,0=+-8';F6IUIFPG5<4+5*+8'<K80;*,5"-5 5>)/=$.>$ 862%<(9U<.L0+E*,'=DZ+H`,A]#:W8U7T(*E$0/6"KgQVwbaÉrmçÄyôä~°ãy†ÖiéobáeX}[cãhT|WUYDqF7g7Cr<>m62_(&U(T*Y%*Y%2b.DtBSÉO]êW`îVCu8*W =215=$C!)K(7[7CiDJsKGpD>d;4S3.:V@;XDAaL<\E/O8%E-&F.*K0,J0)F*">%7!;"'A(72L1GfGOpUmçxaÇqlã|uêá7LO0AIó£Øò£©M\W5G;$6(%7',/CTB0A/$4'';/C[NgÉw`p`ÅnGkO:_> =!'/'9#-@*!8!:";/1(;%2H1/I0-J.+H,+J+'F'/N./L-2O16U65T57V7=W:7N4."0 00!6#*B,-E/,F-.H-&=##	
+ 6A0<J34G)$=Da5Hl<Cg9TpJD\<7N1.G)A^?<[9EkD<f8>k4Am2=b.;5,?)5J75J9?TCCXGF[HG]H;N81C+/A+)8##,)&
+
+
+
+
+$,?)/G-0M/0O01O31R73Q91M6.G1(B')C*,E//H3.J44M8,A.-,@'%9  3"41=)H=)O9ƒbÍ•|¯ºà˘–ê˜ŸëÙ›èÚŸÖÔœxÈ¬eÍ¡XÎ¡QÏ»NÌ“QÎŸOÍﬁNÁ›HÁ‹DË€?Â’8‚À-·…)„–+‰÷-„Ÿ,„›/·ﬁ/·ﬁ1·Ÿ.‡’+‡“)›Õ"›»›»ﬁÃ$‡œ'ﬂ—(ﬂ—*ﬁ»'⁄√%ﬁ -‚“5‹“3”Õ-Õ %ÃÀ#ÀÕ"Œ–%–œ'–Õ(—…&œ«&Õ≈%Œƒ'Õæ#»µÀ≥…¥…πœº Õ≤ƒ¢∆ô∆ô≈ú…£«£∑ë ∫ï ƒ°ƒ®ƒ≠≈∞	¬∞»≥…∞∆¶Ÿ∂›ø!ﬁ¿"ﬁ¿ ‡º&‚µ4Â∞HÚ∏oˇ îˇ”•˛ÿ´˚ÿÆ˙€Ø˘·±˘„±˘‰≠˜„§˜„öÛ›äÓ◊wÎ”gÎ—ZÊ…G‚∆7ÁŒ6‰“0·‘-·⁄1‡ﬁ3„·7„‚:Â‚=Á›=ÊÃ7‡∑+‰´*ÿõËµ6Ôø?›∞1ﬂ∂6‡ø:›¬=◊√@Ÿ«G”»J“…RŒ√W∆º]æ∑gîìSrxL9D$DR9UdO`k[T\O:?85<4S^Vl{xáôù≠øÕ≤¬€∫»Âƒ“Ô√—Óhrñmzù†Ø–ß∫ÿ¥ƒÊ®ª‹™ΩﬁÆæﬂØ∫ÿbiÉORe"$0(-0?EA$""%AD;"%$' %$ +3&GM?$03*BC;<<4!#-3)& +' .5D1*<&&7$#4!'8%$7!2H18K51>,=D4B@1LI:JF:560ITVãö°tÅáalpOY[7A@$/)%1'#1" -)4&'
+',9'(<#(E)2S6CaIC_IC_I;T>2J2"966251I10H2+C-$=',H/8T;2K5:O<'3%
+
+* 3 40-,*%##!#%%%##$&)010!9#%<(-F13L94M8)B-&=)#8%2+%#
+!0$8 42-, 2100-.-10/00.*!  !&0 "3#(6'(4("!$)()"-'
+	
+	 +2?.*##**!/ !-$0"%1# .-&7'2D40B2,?,7J6:M9IZG7E6BND\hdYecHQN;D?7C7@K=6:,./!,),.&0(6+A*		!+,(0EX*Og-Kh&HfMk!Lf%6M&
+)&;,EbNUxbyúàá™îeåo`àfU}ZQyT`âa\á\_ä_RÄRQÅQIyGN}FJw>Jw>2_(#O0\+0_+6f2M}IYäRXäMN~B:e/)O :0*0 ;#B )K(<`:DjC?e<1W.#E"&/.I64T?BbK?aH9YA7X=9Z="C&'E))E,*F-#=$25 8 *5T5NqSfäpnë{kéz^|p)>ASdló§≠rÄÉUf`, /!"4$%8%,+#6#*HYObyqxìäpéÇ_Çncäo<aB5,4!7 %=#$= !<'@ 2(#4!2E11G0*D))C('D&)F'*I))H(,K+3R27V79V89R5!4
+
+"0#"4$ 5"1"9%*B,*D++C)-D*,;("*"-*"
+	%/<(8K/Kc?SpBDf4Jp?\ÄT\zTtèl]{WGgBCgA<b9[ÑZDn@Bo8Am2Cl2%F.1*;(0A/5F64F66H81D1/B.*='3G.'9##+%4!!3#2#%
+		&,;(+B((E'*G),J.,J0,J2-I2.H/,D*&>$%>(*C-,E0/G13I4'%9 !52)8!8='YC,†^D‡çk˘∞Éˇ«å˚÷èˆ‡çÛ„ãÒ‡ÑÔ’xËƒcËºSÌªJË∫BÁ¿?ÈŒCÎ◊DËŸBÂÿ<„’6‰“2‡»(€ø‡«"‚Õ$‡”%‚ÿ)ﬂŸ)ﬂŸ+‡÷)⁄Œ"‹Ã!ﬁÃ"›»⁄≈€∆ﬁÃ"‹À#‹À#›≈#‹¬#ﬁ∆(‡Ã/ﬁ–2Ÿœ0”À*Ã…$À "ŒÕ#–Õ&Œ…#Ãƒ!Õ≈$Õ√$Àæ" ∂∆Æ…Æ»Æ ≤À∂À∞«•¬ó
+ºçºë∆ù∆†∏í∂å øó¿† ¡®¬´¡´ƒ≠	≈©ƒ°‘∞›º€Ωﬁ¿ ·¿#·ª,‰≥:Ó≤\˙æˇŒõˇ⁄≠ˇ‡∑˝ÊΩ˝Í¿¸Ó¡˚Ìæ˙Ì∏˘ÈÆˆ‰¢Úﬂìı›áÚÿwÍŒaË RÍŒI‚Ã:ﬁ–2·ÿ3„ﬂ6„·7‰·:Êﬁ;ÁŸ;‰∆2Êª0ÁÆ-ÿû Ïª:Êª9‹±1ﬁ∑6·√=ﬁ∆@‹«Gÿ∆H—√HœƒPÃøW≈∫`ø∑nÅÄGFJ'&0IVBIVDuÅscmbHMFOVOU`XP_ZÑñö¢¥¬π…‚≈‘Ò…ÿıÀ⁄˘éõæï£»¶∂ÿ∫ÕÓƒ÷˙¥»ÌÆ¬Á∂ ÌøœÒ¥¬ﬂ|Ñõ_eu,17$"692"" ($%%('"-AI:3;,8>2AG=/2)!&!',4)&.!&)&4E21B/&4#'-$5"&9#+>(2A.HSBÉâ{y{nFH;EKA"-'".*094kum=G>".$$0$%1##/!$/!+"52O36W:@^FC`J<XA4M7+C+#: 54430H29Q;8Q<'C,.J1@^D7S<BWD+7)	
+
+	" 37!441*'&%'*#"$$&&&'+"5!&;('<)'?)#;%!:%$=()B-*C.)@,&;($7$/%"	
+&!2$7! 4/$3&8 "4./0 2$3!0!0/+"  !#%"','"$("&'
+
+	)6%6E2#0&&'+"0!!-!-$0" .!2""3#&8(!4!!4!-B/:P;J_NKXONYUMWXNWVXZWUUMKI:MH2A:=29*	7*9489&
+
+(+,=Yn6Tm)Ok Sp _}'[u,'7 !!.$GcMUy_dàl_ÜgW]aâfgèjcåd^á[TQIxDGwCIxDEt>JyBSÉIP}DHu<6b-7c0@o9M|ESÖJN~B=j3 H7$=%< 5.-6 ?#G#*P):`76Z4(G'+/7P;3S;>_DNqSOpSPqRCgCB!&C'+G.7T8-J.!>"5/+8U9OpSOqV_Éihãu4RF2EKäò£ù¨Ø]mj'7,"3!*9&*;((>'!7 #9"+A,+->4Zqgmâ}_~n`ÅlaÖi.Q3&B)$>%-E/1K22O1,I*(C (B)=!!3/->+-@,(>'&@%'D&)F'(G%(G%'I&(J'&H'.I*70	
+&'7*$9&%:'$<& 8"%=''=&'=&+" ' +&!/!.
+*+:#4I*WsJQuELrATyPá©Ü}úzcÉ^\ÅXMtH2\.?j<[ÖWS}MNzE?l18f&4]%%?"42A.8F5DRCARB<M==P==P<8O55L0.B)*(+!003 4$8';"!
+
+
+
+
+
+	
+!#6 &>$)A'+E*+G.,H1.G1/H2.F.)A)&>&&>&$:%&<%,?)- 30!4,8 CB&sT8∑kQÍçl˚≠ˇ¡Ü˙”à˜›ÜÚ‚ÇÓﬂx€rÈ ^ÁªNÎ∏EÈµ=Â¥3Âº0Ë…3Ë’9‰÷5ﬁ—-ﬂŒ)‡«%‹ø⁄ø›≈‹ ﬂ“#›÷%€’%‹“#ÿ ÿ∆€…⁄≈÷¡ÿ√‹«ÿ∆Ÿƒ⁄¡⁄æ›¡ ‹¬#›…*ﬁŒ0ÿÃ,Œ∆%À»!Ã…"Œ…#Ã√ æŒ¿!Ãø!»∑≈≠≈©ƒ¶ƒ¶≈™«Æ»Æ≈®Ωó∑å ∂ç ¬ú√ü∫ñµå ºóºû ø£æ•¿ß¡•¡†¡ö…†‹∑€∫›Ω·¡!‚¡&‰∫0ËÆBÏØ\˙∆äˇﬁØˇÎ¡˛…˝ÒÀ˘«˚Óƒ˙Ïø˚Î∫˚Í¥¯Ë¨˜‰†Ù›ëÔ’ÅÓ—uÏ–e„ÀO„“D‰Ÿ?‚›9„ﬁ8‰›7Êÿ7„Ã1·¡0Ï¬8Â∞,ﬁß&Ë∑6·µ2‡∏5·ø:‚«B›∆B◊¿@‘øB“øG–æPÃ∏W≈¥b≤´gdd248 ",!MYO~äÄiukT^VkumcnheqoÅêóñ®∂∫ ‰¡“Ã›˘œ‡¸–·ˇÕﬁ¸»ÿ˘¡‘ı¬‘¯¡’˙∏ÀÛØ≈Ï≥«Í¬’ıô©¬sÄìpxÉ 
+
+893"%"(+,'3%.:,7B4=H:7?4.6+  #+ !( '/$%- +3&!)+&.?-#1"' ''4#'6#&5"+<)1B0GUFp|ndoaCN@%0"!,MUHwÇr&2$"0!%3&#/#!
+
+	)8L3>X;BaBB^E?[D?XC:S=4L445 8541I39R<:S=3O8/K29W=<X?D\F". 
+
+
+0"8!"8!34,**',,)%##&()*,/"5"(=*&;(#;%%='$<&%='!9#!9##9$!4 2-'%!"%."4&8 &8%9#7"6%7!$6 #2$1#2-$%$5"*;((9'&7'&4'-  .! , ( # 		
+2?.5D1+8'*&', 1!(&'(- ./"3!$5#,=+8M<asgWb^]egIMP]\Zk`ZveUw^@|a4çt;óÄ=ìx5c$jPYC%8$
+*>N*^r7Zr(Wr!^z&d})Pe"
+ 		'4*@\EW|]OtUnñtsõxnñqcãffëf`å[KzDBs;-_$0_(2a*5d-O|ELyB>i49c3-W'?i9Eo=Fq;0X$C+'/#6 %;$#9"6&C%(J'.R,4Z11[-&K * &9&2N7;\?DgGFiHXyZeàgMsN0S2'C*$='%A('D((B))A)5 2$>%2P6AbG\|dTt_$@4fxzù¨±ñ¶£=ND$6&<M:8G20B,+>((>')?((;(,!#2+6IC`wmFcQ/L6'E-"@&#?&%A*4P9:X>8Y:+M*5%?$<!5"3 (9''8%%;$&>$&A""@!?"B!C"D!<!<*C&5L2/!/"(9))<)'<)'=(#9$$:#(;%(7"(!$*-.#0$&1 -=#.C"b~UYNV}N^Ä]}ûmèn]ZLsGJvE/[(8g3HrBDn>WÅO@m63c%;f.#?'9!1@-8F5M[LL\OCTDGZGBU?>U;5L0"6%,.--0 7!8#:&:)6$
+	
+
+
+#0 7"9(@&+E,/H20I31K21I1.F.'?'#9""5 2 20.5(>'8D,RM0}Z<≈zZÌìnˆ¶u˘∑z˜∆zı–wÔ÷rÓÿkÓ◊gÈÃWÊΩIËµ?Îµ9Á±-ﬁ≠"„ª&‰Ã.·œ-⁄À&Ÿ∆!⁄¡÷∂“≤’∏ÿ¬€À⁄– ÷œ◊À”∆“¿÷¡”¡”¡÷¡◊¬◊¬ÿ¡◊æ◊∫Ÿº◊ª⁄¬"‡Ã-‹Œ/”…)À∆"À∆ Õ∆  æ∆∑ŒºÃº∆≥ø•¬¶√•¿¢¡£√®ƒ´¡ßæö∑é ∑é ºìºóπñ∂ê ∫ñπõ πù ∫û ºüæù∫í Ωë ¡ï◊Øﬁª!Ÿ∑›Ω‡¿ ‚Ω'‚Ø/ﬁ•<ºpˇ‹°ˇÌæ˛Ú ˚ÛŒ˙ÚŒ˘Ï…˘Îƒ¯È¿˙Èª˘È∂˙ÁØ˚„ß˙ﬂú˜ŸëÚ“Ì–jÏ”\È◊OÂ⁄D„Ÿ<Â◊8Êœ4€Ω'·æ0Ëæ4·±+‡´'Â≥0ﬂ≥0‡π6‚¡<ﬂƒ?‘Ω;Õµ7”ªA‘ΩI–ªPƒØR«∑iîêSLO$7:%LWQdoiYd^vÅyõ¶ûs~xcomWfmï•µ∏»‚∫ ÎΩŒÏ©∫÷æœÎÃ‡˚¿”ÛªŒÔ¥»Ì∂…Ò≤»Ô£π‡≤…Î≈⁄˘û≤ÀtÉòÖéù7;DAB<-.(&'''')5'1=/FRFjvh6A3*5')4&!-!%) !+ '!,.6)$,-**$(4(4A0(6%"3!&7',=-1B2FTER_N*5$+7#?K7;F5$1 %2!&1#"
+		
+	 /;R89T59V7=Z>GcJ>WA<U?-C,!87%=#&=#!9!/I08Q;:S=8T=/K21M4:V=;S=(	
+			)(;%#: &<%#9"0/111"5!#6#*%#&&(*..1!4!&9&3 "8#'?)0H2-E/(@*(@*&<'&9%#6#/,+"0!"$/);#)=")@$*>%(:$"1.('%!!&&7$.A-5H57H8/=0)$%#!)!#	 -5G14B1&4#+ ./ 1!*++*.!+, -$0+7!VcOq|kila{{sb^SÅxiê~h¶él∏ògø†_≈™[∆≠Sƒ©N∂òB™áCü{?"=K(_q7`v+]t"iÇ1_u,(9 		;M?nårlëpgåmqôwvû|eèkeèi^â\SÇL<n35g*.`#+[+X,X#=g5Cm=Dk>;^6/O*5U0&D "=!<5+$*!4 %;$'A(-J.<_>2X13Y0-W).Z'-W'=)$<"@ZA<Z>FiKKnMLpLTwVHkJEjHLoQ5Q;(A.#<'";%"9%%:'&<'"8! 8"#;%0I38Q</H5?UHK`Y1F?;QD1H6+@-)<($5"#4!0#6"%8$/+81=IG\jj@QK.C4,C/'>**C.0M7>\D[ya_ÄcV{Y/U09!<!;///0/8!<<!?!?"A%D$"A!&C$%B#(E'%?$1 '%3&&7'&9&':&&9%%6# /,&3!.!3"4!
+$&3!/=&/?$:P,`{RZ~P_ÑXwôxrìtvòw\ÄZFmA?k:+W$+Z&1[+<f6fç`Go=8e,8`+!<&:!3D1DUCM^NDVH:O>=S>:N56J1.B)'((.++22"6%< )=",		!(,,#7#: &>&+C+/G/1I12J20H0.D-'=(!4.-. 3?W?H`HJX?\V<íqR‘ïlˆ™yÙ´t¨k∞fÒ∑cÒ¡_Ó»[Ô–[ÌÕRË¿D„∂7Ê≥3‚¨&‹ß›Ø‡ø&ﬂ«'◊¡‘æ’π“∞Õß“Ø’∫◊¬’ “»–≈—¡Õº–ª—º“Ω—ø”¬’¿’æ÷ª‘∑÷¥◊∑⁄æ‡…+ﬁŒ0◊Õ-–»'»√Ã≈ ø∆¥»±À¥≈≠º£æ£¿•ø§¿•¬©¬©æ£
+ºö∑ë ∂ã¥à¥ç∂ë∂ë∑î∂ô ∂ô ∑ö ∫ò∫è≤Ç æä ¬ëÕ†ﬂ∑!‹π⁄∏ﬂΩﬁ∫ﬂµ#ÿ®(Â≥P¸–ÖˇÁÆ¸Ó¡˚ÒÕ˙Ò–˙Õ˜Í«¯È¬˚Íø˚Íº˝È∑ˇÂ≤ˇ‚™˝€û¯”èÒÃ~ÓÀqÍÀ_ËŒSÁ—HËœ?‰≈6€∏(„æ1Âæ2‡≤)‚∞+‚≠+‹≠+„æ:‚ƒ@›¿>œ≥5“∫>’øG‘æNÃ∂Q«∂^≈πq††jgmI6:)! :@>p{w}àÑéôì∞Ω∂nzvhttsÇâ•µ≈∂ƒ·≥¿‚û´ÀéõªÄèÆÇí≥û≤’´ø‰´¡Ë≠√Í§∫·£πﬁæ”Ú≤∆·ë©váôäñ¢<CK#$34./0*
+%,+!%*!-0>/JXI:G5+:'*8'&4#"3!'5& , "%/$+7)$0"!-#"!-!$"(4(1=1/=.(6',$2#):(.?-1B//>).;'/<()4#-5&28*VZL!$
+	%7!AZ=4R0;Y7@]>C]@@Z?9S8)@&#: %=#/I.2J0.F,3O68T;5Q:7S</K4)E,8T;=U?!
+
+	
+
+	(9'&<%%=#&>&%=%35 #6"!4 0!4#9$0('%(&(,0/ 3 1.4#9$/G15M74L66N8/G1,B-*@+$:% 6!$7#&7%#1"*+>(/F,,B+)<('
+"   !!#%&7%4G46G7%2((&#!!"	
+	!4F09L6/B. ."0!$5%#4$)*-/"0!"/(1+022GF(opPÇÇ`êäjóålØü}«¥äÃ∏Ü“ºÇ“ªu«µa–¡d…ºV«πP¿™G±ë>µêB):( .9csB]o1]q,at4>O '3%!2".azebÉfnìrtôzrôzlïseèikñkYáVFx=2d%.`!)[)Y.[ +V!1[):d49`4,N))G%(A#$; 42 41)- 6&>&1M4HiLLqOKsN8a7?i;=l57c..S'=3R2;Z;HkKNsRIoJCiD@cC8[=:\C;[FiÉx_vl!9)05J;. )>-)@,(=*1D1=P=k~k-B1;P?;QD)?2%>+#<'"7$-@,):'+ 3&9%$5#* /*FTUëü¢\jj\la?R?]ra`we[waPpXOpU=`BXÄ]0V/<9&@/,+,1478";#<$?#@!#B"'D%)H(+J*,K+1I/2-%$&''(#,->+/F,5N17O5 +:'2D,1C)/D%:R.TpGWxMbÖ]xównçnuóv]Å[RyL7a/1](Dp;IsA2\,fã_hèbR}H=e3"=,@%4F.H[G`s`NcR;R>*B*0G-&:!-'%*.012!4 3 7%<",@')8#"
+)+)%.. 6%=%%=#)A'*A')?(*=)%8$ 2''-5K4D^ELfMdrYÄt\ßÑd‡®yˇøÇ˙ø{Ú∂mÁ®XÂ•MË≠IÍ∂HÍ¬IÏ∆GË¡>·µ0‡Æ)‹¶ﬁ¶⁄ß÷Æ€∫“π—∏”∂–ÆÀ£œ©“µ—ºœ¬Œ√Õ¿ÃºÃ∏Õπœ∫Œπ—ΩŒΩ“Ω—ª”∏÷∂‘∞÷¥÷∏€√#›À+ŸÕ-‘ *Ãƒ#»¡ ø…∑ƒÆ≈¨¡®ø§ø§æ£º¢Ω§Ω§º§∫°	ªúµè ≤É ≠| ØÉ ≤ã ±å ≥ê ¥ñµó∂óπîµÑ©r ∂Ä æàºàœ†‚∏$⁄µ›π‹∏›∂€≤"ﬂÆ7Îø`¯’ë˛Áµ¸Ó«˚–˙Ôœ¯Î…˘È≈˝Î≈˝Áæ˙‚∂˘‹∞¯÷®¯”ü¯—öıœëÙœàÔÕvË»eË»WÈ…N‚º=›µ1Á¡:Á¿7‰π/‚≤,€¶$€™)„¡<‡¬>◊µ7œ±5Ÿ¡G⁄≈P‘øR≈≥QÕæk¿∏wÜâZÖéo:@25<5?ECbhfò°ûñ°õëûóñ£úÄçÜ{ââãô¢¶≥∆û©«ãïπäî∑éõΩåôª{â¨ãûøò¨œú∞’û≤◊®º·ø”Ù¡’ë£ªãú∞~éù\fo((&@A;#"$(,%&(+)3A2;J7%4!!2 '8&(;(#4",!%1#&4% ." #/#&'1&&2&.</0>12>2,8*()#4"):'.=(1@+<I7HSCQYJtzlÑÜxVXK
+*8O31O-6U3=Z;B]>@Z=1J-%>!$<"*D+7Q88R77Q67U;>\B:V?4P94P95Q8<X?9O:
+			
+	 ):*'=&+C)#;#45$:%&9%#6"-2$:%'=( 5",+((*+&*,-.3!7"":$$<&-E/3K55M73K5-C,&<%#9"%;$%6# . "00C-2I/.A-$5# #%''*--%6&%3&$  " 		
+$.@*6M36L5!2 %6&5F6/@0- +"/"0&0/6:;NL&spG¢üræºâœÃï⁄”ú‘…ë÷∆ã€«à—∫vŸ√w”¡kŒ¿_’ aÕ≈VÃ¡N«µG∏ö8µë3  "*KV8>J$7C-9$!.!5)D%0R1:]=TyXRwX_Ügrô|tù}tûxaèaSJHx<5h&4i%-a+^*Z.^"*V!0\)6b-Eo?3X-$B&?!$;#7'; %9 $8!50 7*D'2Q2>aA4W7@eCNsQVUFu?4d*5a,1X+9[6CeDDiG>fA<d?3[83U<1P>.LB3MJë©´Çóò/%(>2ÑïçIZTSg^EYMFXJWhVizhRcPEXE7L;)=11G:0I63!6#&9&*+3F2.D/#4"'/>;CRWfthw~ixqtÜvg|kiÄlRnXIgO>_D]ÄbCiD'K%8#<$>.'%*/16#6+;-= )>$? &C$*G(+J*.M+/N.2O1*D+0+#('8(F^H@^B6W89X94N3&	 -(<#*A%/F)2K+2P*\|SWwPbÇ]oénmålÉ¢ÇjågV}NIt?4_*6a,6a,?i7UzNfç`XÇR:a2%C1I)AU9I]BIaKNgQGaH-E+*B(%<"-%&), 1#6"%;&(>)&<%%;$+B(-D*1C-+6&%-9+ .' *&0#: '@#%>!0*++"!-KcK\v]8Q;HR:nZA†uR‹®o˙∆}˜œzÚÀpÍº\‰ØI„¶<Â©9„Ø7Ê∂6Êº4›≤'◊¶€¶€¶“ü ú”¨Œ∞Ã∞–≥Ã™
+∆û §Ã± µ ∏Àª…π ∫À∑
+Àµ
+Àµ
+…≥À∂–ª–ªœπœ≤”≥‘∞‘∞‘≤ŸΩÿƒ#÷«&”≈'—ƒ&«æ«æ«∏√Ø¬´ª¢ª†	º°πü∂ú∑û∏ü∑ü∏ûπõ≤ç Æ} ßt ™z ≤Ü∞àÆâ ≠ç ±ë≤í¥è∞~¢j ∂z ª}≥p º|‚±(€±Ÿ≤›∑⁄∂›∂‹Æ$ﬂ∞>√p˙÷ö˛Áª˝Ô ˚ÒŒ¸ÔÕ˘È«˚‰¬˚›π˚Ÿ≥˙‘≠˘“©¸“®˛⁄™˛ﬂ©¸‚•˙ﬂòÛ÷àÔÀuÎƒe‰πQ‰ªIÂøB‰ø:Êº6‡≤+‘¢ﬂ∞.„æ:ﬁΩ:Ã®-‘¥;Ÿ√K◊»S—√VÀø]…¬r∂∂zqxOó§älxjlyp´¥Ø°™•®≤©≤æ¥∏»ΩtÑyk{qq{âîü´¡ö£ƒéñªíûƒçôøèúøåôªÄçØãöπï§≈Äè∞aqím~öñ®¿xâõ|åô:GO')()+(
+?B;&'"&*')(!0 +#)/!)1"'$)"/-):(/."3 "4#4!#4!"0!!-$$2%'#,7) +%3$3A27C5<G9!"!-),1>-U`P`k[lteÖã}àä|ÉÖx36+
+-@*1N//N,9X8=Z<;V7*C&,D*,D,4N59S:9U<4R86T:8X@8U?9W?2P67S:=Y@4J5	
+
+
+	
+
+
+'&<'(B)$<"#: ,@'/A+$5"#6"2&<')?(*@)#6"-0-!4! 3 -'(*,25 #;#-E-+C+%=''?)+C++C+-E+0H.-D**@)+<)%3$!!/+>(0D+'8%+%#	#"3!)?*&>(4I64F6%3&):';Q:<R;':'*<,>P@@PC%3&"-(2,276_]$ãÜF±¨h’’è÷Ÿí”Ÿè’‹éÿ›ã◊ŸÜ€“É◊«y’æn÷æh”ø`”¬X’»VÃ¬IÃæCÃπA¬§4∞é"     
+	
+%&##&$*6O16V12V0+T,<f@LvR`áhpózÄ®çx°ÅjónVÑS9i/5f%/b1e#-a!*\'Y'V(T!-Y&@o8TÄK/V)74/%7%7"6#: (<##7!8,F).M.+N-,O/-P2>aC^Éa`ã]@o99h1.Z'4Z3AdCGlJAgB9a<+P/&E3E`WUpkXprìûë£≠/CB<QLm}|éûûî¶¶buq`rfxâwk|iDWC-E/NeQ8O?@XHzìÄ&?*2"5"$2#*8'-C.%;&.,!:HHWfmcpÄn|áQa^2D84I8;S=KdN3Q9Wy^RwV0V/>0$;#<.'&.2 2*6 <F.IS81@#%<'B#&C$)F',K)0R12Q1,I-5 %6&,:-%9G:@UD@\E?aF/R24W69Z;,F)1-A(1H,-H)0K*?]9?b:^ÅYuîrû~pèoZyY~†}}¢yU}KKvA1Y%Mu@1\&<g2RyJbâ\EoAHoB"@%?3F*;O47O7:S=3M4'?%'?%*@)':&-((-- 3$:%&<'%;&&<''=&+B((<#'	#. 0=, .'"*((:$2F-1J-&?"/"4+='%7!-*+!35M3E_DUlROS8jM-™{Oﬁ≠kÚ»tÒ’t’lÓÃ^ÈæM‰´:‡°-‡¢)‡©(·≥)‹Ø"◊£◊ü‘õÀîƒë Õ°
+…¶
+«´
+ ≠≈£øñ «û ≠∆Ø≈∞∆¥≈µ«∂«≤»≤«Ø«ØÀ¥À∂ŒπÕµ ≠œ¨
+—™—©Œß
+‘¥ÿ¿ ÿ∆&—¡$—√%À¡!ƒ∫ƒ∂¡Ø¿©º°
+πôºúπùµôµö≥ôµõ
+µõ
+¥ò≥èØ ¶r ´y ≤Ç∞É´É ™Ü Æç Æç ±ãÆ|£k ¥yπx±g ≥j ÷õ·∞%‹≥ﬁ∑‹∏›∂›¥ﬂ≥0Á∑SÙ»ˇ‡™ˇÏ√ˇÓ ˝Í…¸Â≈˘ﬂæ˝‹ª¸⁄∑˝Ÿµ˚◊≥˙◊±ˇ‡∑ˇÁπ˝Ë≥˘„©˘›û˜—êÛ…Ô≈qÏƒdÁ√U·ΩE‚π=◊™+÷¶&Êª9„¡<’∑5Àß,⁄ºD÷√K‘«T”»\À≈eƒ¬w±∂|]gB•≥öñßïäöè∞ªµ¥Ω∏§Æ¶°´¢©∂¨csh^ndaooåöß¢¨≈õ§≈X`Ö•±◊ï°«ü¨œíúøãñ¥ÄãßÜë≠`lÜ3./+-8>CKN')((*'
+*-&'*#!)#*!/+%0 "*6:,$*(2'""-+7)"0!*$!3'9#/-*+"#!-'5&)&)4$0;+&4%4B3,8*)4&%/$",!#$1 AM?epbjugóüê|Är]aSQTI&," EJD#& 13M03R2DcC>[=,G('A$8R76P7;U<?[B=[A9W=6W<>^F=[C;Y?,J.9V:<Y=4J5
+
+		'*?,*D+%=%)@&3G./A+':$)<("8#!7 %;$#9"2.2.%:' 3 -*)*,27!":"&>&-E-*B,*B**B*)A'+C)3L/5M32H11D02@1##1 +='(:$+&%"
+
+
+!/ .A.;P=7L9@QA5A7
+	%3">Q;6M3(>)2E2BTDBSA2>*.48;YXôíLø∑fŸœxﬁ◊|⁄⁄Ä€‡Ñ÷ﬂÇ÷‚Ä“‹y‘Ÿu“Ãlÿ»i◊¿b ±M—∫P‘¿M’«JÃø=Ãæ;Ãπ8æ°)ßÜ
+!#*,.3:T75Z1+U'-V,3]5S{Vcãi{¢áâØñ|§â{§Çy¶{[ãW@r51d".`!*\0b'1b*1a-2b00^-4c/J{C[äT5\--+&)0"5112"9#= *I*+L-+N00R7bÑlléunñseêcAp:Am82[1=b@CfF>aA,M.@aFC]PkÑ~]vp-BCCS`rèuÜéUgkdvzoÄáyäíl~Ç`qgcvc[nXBZ@4P7?\F8UC.K9\ycD`I22&7'&7%)?*1G2(*:07EHwÉèÜë£Üì£Éóò"7.2!2J40I3Us[Y|^JoM-S,!C+2&= 2!""1%4!IVDBI9CG6AI2/;# 4$= %@!(E&)H(/N.0O/,I+5 1&4%(" !&,=-?TCC\I>^G?aH.Q38[;9\;8Y:'D&"?!,G(-K)3S.Cc<NqGbÖ]ûÜ§à{özOqNcáaXSS~IEp:.V!/W".Y#7b,NvDW~QXÇTRyL(H!/+,/)?*(>)'=&*A'1G0$:%'<)#8%!7"!7"00#6#+>+-@-.C0,B--E-.D-);%$*)6"(7$#2&$!2 %6#-@*0D+1J-,E(4K/8O38O31H,"6/.0'@"7O-GV7rlJßÄUŒõbÊªmÔÃpÏ‘jÍ’bÈœVÁ√H‰≤5◊ù Ÿó‹ù⁄¶ÿß”õÃë	ÀàƒÑ ƒç Àü
+«§√•»®√üæê ¬î «•¬©ƒ≠¬∞¡±√±∆±≈Æƒ©¬ß »±À∂Ã∂À≥	…®Œ®œ¢Õû ù“´’º’√!œø!“ƒ&–√'≈∏¿≤∫®æ•
+Ωü∂è¥ç∫ñ∂ï≤í≤ì≥ô≥ò	≤ó±í∞ä®{ ™x Æ|¨| ≠Ä™Ñ ´âØé±ç≠Äßu ∞x ∑x≤d ™] √Ä‚©&·¥#‹µ€¥€∑‹∏‹∂%„¥@Ú√i˛÷òˇ‚¥ˇ‚ª˝ﬂª˚›ª˝‡æ˛‰√ˇÂƒ˛‰¡¸‚ø˙‚æ¸Êø˚Ëæ˙Â∫˘„≤˘ﬁ©¯’ù¯“î˜–ãÚÕÎ…pÂ¡`·µL◊©9›µ;Â¬B·¿?Œ±1œ±5Ÿ¡G’≈L‘…U–»[À»iº¿vß∞yl{Tàò}o~ibpa¢≠ßµæΩ¿∆∆äêépyvXe^Vc\yáà¢Æº¨∂œ§≠Ã•Ø“∂√Âó§∆ª»Í™∑◊õ§¡éò≥Çå•Åå†#!!	;>5"(&!.+ #+14)<?4 .8/"'2$%/$$&%6#(6%&#-"($&'(%3")&!,)#1"5C42>0%&2&*6*%,%3$0>1GUFMYKåóâ}Öx~Ü{zÅyJTL:C>MTM}Äu44(	#!/ /G-3R2A`@8W7$A#2O1?\@<Z@8V<DbF?]A9W;9Z=;\?>\@.K/%B$1N/2O0,D*-
+
+	
+ 0#2I5*C-(@*.F./E.)?(*@)-C,#;#!9%=#":" 6!5 !6#$9&*=*!4!!4!/-./.37!#;%*B,,F--G.0H02J0,F+*D))C*+C+1D0->,&&#1 -<)!0+(&	
+
+
+
+
+
+&&2&3?5%,%+=Q87N4,B-;P=CXEDV<<F!KNàÑ:™£I€—r÷ fÿÃfﬂÿp€›r◊›s◊‡u÷‡p”€kÿ€h…ΩOŸƒWŸøQŒ≥Bœ∂?—º=’≈<Ãø3Àº/ƒ∞)µô¥ñ+()&*+(&"--4!> 3W11\.-[,0]2;e=sùwcãimîyÑ™ëÉ¨éu°}`èaOÅL3e(0b%.`%3b,>m9JzJJyKXáY>l=RÅMXâQL{D+R%0,)..5&?"'@"5. ;%D$'J*2U78ZAMnYyöÖqò}nòraê\J{D9d91Y6CfFPsU0Q22P6@[Le|t,A<3EE6DQq~éö™∑âú£zçîdvÄqÅëváëQa^N`PLdJZtWKlO2T;0Q<.N9gáp;$!:$41.-C.%;&,2C=?LTñ¢≤ëú≤°Æ¡•π¿1./D5<Q>5N9JjRMrSInL/U.>)-$;!8!!.'6#CP>SYK]aRMU@'52 9&A"*G(,K+.M-0O/+H*+C)%8$*8)&  (/F[JB]J<\G?aI?aH/P3;^>9^<4Y72S4-L-.K--K)0P)Ae9SwIvôodÉcnçnbÑaLpJ[ÅXUOCn9;f.)T1\&=h0:e-OyGEo?\ÜXW~R3V, ;%7!(6%"3!23 6)?(1G0*B,'>*$<&+C-*B,(>)%8%$7$"5")<)-@-(>)/E.5K4/C*+?&2D,5G/1C-*<&$5"(;'+>*)?(4G19L65L28O58L17N17P2*C&5530,E%<P+HN(iZ/±ÑM‡´e»pÓ—kÈ”c‰“V· J‡¬<ﬁ¥.“ú–å‘ê‘ú–õ é	ƒÅ ¬{ ¿} ∆èÀü
+√†¬¢«§¿ô ∏à ¿ê «£√®√¨¿´¿Æ¡Ø≈∞ƒ´¬ß≈™«Æ	…∞»∞ ≠ ßÃ°…ó ñœùœ¶—µ“º–æ “¬%“≈)…º ¡≤º™
+º£	ªõÆÑ ™~ ±Üµç±çØéÆíÆìØñ≠íÆå©Ç ßy ©v ¶s ©x ™Å¨á≠ã≠âÆÜÆ~ ™v µv≥e´X ¥g ‘ì‡±'◊≤Ÿ≤€∑ÿ∏€∏·∑1ÎªOˆ¬vˇŒñ˚Œ§˙“Æ¸⁄µ˛·ø˛Êƒ¸Â√˙Ê√¸Í∆˝Í…˚Î…˚Î…¸Í∆˘Êæ˙‚∂¯‹≠¯ÿ•¯ÿü˚Ÿô˜÷èÛ–Î¡k‡∏V‡æP‚√N‡ΩEŒ∞6◊øEŸ∆M‘»Pœ»T ∆[ Àn™±kÉê[{âeèrTdJKYHåóì∑¿≈…–ÿßÆ∂~ÜàZdcfrnì°¢µ¡œ∏¬€Ø∫÷∫≈Â–›˝”‚ˇ Ÿ˙»’ı†©∆•¨»óü∂xëKNE &$($&,>@546+*4+,""."-8*!/<+%3"		"'%("#!/)(*(%1#8D6<H:)5',:+'3' -;.!2"(9)*;+(6%o{mYdV{ÖzîûïvÄxXc[isjw{mDB3I@1j]Mo_P+!!(?%/L-<[;1P0+J*:Y:B`D<Z>5S78W80O0+J+<[<8W8.K,(E&%B#)F'.I*'@#!2 &*5'BNB=N>8M:-E/+C-+C+'?'+C+,D,-E-*B(": $<$%=%(>)(>) 5"(=*%:'$9&(=*"5""3!!2 3 #8%#;%'?)'?),D.+E,-G.3K15M30J/,F+-G./G/2E/):'("  ,#1 .;*+(''			
+
+
+							
+	"-/A)5L00D+3G,9M*K[,qz9öúI«¬\øµD·‘d÷∆U⁄ Y›“_‰·l›·i‹·i’›c”ÿZÿ‘W÷∆L…∞9◊∫BŸª?—∂5”ª3”¬4œ¿/≈µ$ø© ∫ú √¢."9%4 (;(.-.1!%&0!7 9T5Ac>8a5+Y*.]/0_3>kBO|QS}W]Ñiè∂õ}©ÖUÜY?q>8k34e.;j4=i8KvIcçe`ädhíl\â`M{MZâUXàL5b)8-.3.F.:W9Dd?=`8-R)&I!%C)G#$F!*O-0T8IlTnë}sñÇ|£à^äfMN8m76e7,Y0>fDDiJ6[:'J,"?)*B48KGHWZêû©≤¿ÕØ¡Àë§´ëõãõ™|çüçù¨ãù°L`UTlRKiGfÖfJmO<`F2V<8XA"@(%A(2L1#;!2 3-);-,<9uÉêCOefqç´∫—é¢≠8MN%6.(:,A\IKkSKpQ+P.'K'<..6&=!.
+ -.=*4C0T_NAM94B+3G+0I+#A!>'F&,K++J*,K+1N//I, 6%")!1$:O>FaNBbM=^I=`H6Z@6X=7\;:b?1Y60Q2)H)(E',I*0P)7[/Gl9X|LfâanêkiãfW|S>e8UMHu>Bo6-X"2]%5a&0]"MyD:d2JsG]ÑXDi>$B,@'+<)&9%#9" 6657!'=('=((=*(=*)>+.C0':'->,(:*$6&+>+0C//E.4K1;O66J1.B).B)0G-+B(,D,1I12J25M57M87J67J78I6=K2;K04K/1K.0M/0J-'@#5.G'CS.\Y.yb,ΩåGÂ±[ÓÀgÈ“bÂ—X› I‹ƒ>Ÿº2◊∞%ŒöƒÄÕà	–ïÀê≈Ä¬x ¡u ¡~ «î≈û¿ù¬üƒúΩë ∏Ö ¡ë ¬õ ¡§ ¿©¿´¿´ø™¬©æ¢ ¬•≈®«™≈®≈•»ß §∆ô »è…ê“†Œ•ŒÆœ∂—∫–æ –¡&Ãæ ¡±ªß∫°ªõµé´ ´y ≤Ç≤äØé¨ê™è ´í´ê¨è´â®®w ®t ¶s ßz ´Ç≠à™Ö ¨Ñ≠Ä•s ¥v≥e´S ¶N ¡x‡Æ+’±◊≤ÿ∂Ÿºÿ∏€µ"„±4Í™PÒ∞n˚¡ì¸œ®ˇﬂπ˝Âø˙‰øı·æ¯Ê¬˙Í»˚ÏÀ˚ÓŒ˝Ô“˝Ô“˚ÏÕ˚Ë«¸Ê¡˙„∑˚ﬂØ˝‡®˚›ü˘⁄óˆ’éÒ–ÅÈ p·¿_”¨E—ØAŸƒM‘»N“«Qœ…WÀ…d∆ séîTNZ*M[8brUgw\ap]hwtäó†õ§µ¥ΩŒ†©∞s}~}áÜìû†ª«””‡Û≈—Î±ø‹ΩÃÎ«◊¯Õﬁ¸ºÀÍü™»≠∂”ôüπ8=Q% !		?@;
+ &"-15'FH; ")*8+*8)&2&!,
+
+"'#.$$ *(&&'/""*2=/7C50>-+8'#/!#/#6D5*-@--@,/@-`o\YgV~ä|•Ø§êöë`kcÑéÖú†íSR@MG1zkTÇmXVE53F00J-1N0-L,9V79V74S3.M-5T41N//L->\:=[92M,+F%+F%(F$(C$-F)3%%,7H6@N=.<+!-&!#8%1G0/G/+A*.F.0H./I.0H0&>&":$(@**B,(@*5 "8#&;()>+.C01D1%6$ 1#8'-D0/G1%='$:%#;%'A(2L13M41K24N50J1-E+/G-0D+&8"*)$# ,(6%&3!**&"
+
+
+
+
+
+		
+	
+		
+!$6 4H,5H*8ILZÄã<™≤Oø¬Q‘“Y—«K‘¡Iﬂ Uﬁ…T€ÀR‰‹`‡ﬂ`‹›[›ﬂZ ∆@’ÀE‰—N∆≠,‘≥2‹π7 ©$”π. ∏(»∏'Ω¨º§∆¶/√û,(A+!:$7!!9#4!6##5%
+/4!; 3R09`49d6:g<<kA<kAJwNP}RUWrôzá∞êÑ±äVÖW8j7As@P~M^â[\áZqörpòugëmw°{eíi[âZQÄJP}D#K20!9#5M7JgKPrOCh?3]/,V((O"%I.R&'N"'P(1X9Pv]`ÇqUwfpñeënPÑTG}I;m<.[03[98\@-R3#E*%E04NAXjlçñuÖíñ®≤yéìsàçåû™ûÆæ¨ª–•∂»æ–⁄Zpm4M8B_ACbCAdD2U7BdK+K4NlTYu\VpU6O2 7/*=*1A6#33`m~sÅõï£æ¢≤…áû¶(=>/));/9TCEeNBeG'J)2T3.M-100#6 +='&,#4"*=*2C0DS@O^I<N67N1,G&+I'%D""A!%D$'F&)H(.K,7Q4-C,#)0 ?XEB_K>_J;^F<_G1U;8Z?<a@2Z73[8,O."A"$>#$>!+I%KoCLq>MsB\UlègjågX}R9`3;e38e./\#*U,W*W5b'Cp90\)@j<fça=d8%G"&>$(;'#9$#9"!9#7! 8"6 5 5 $7$&9&*=*-@-':'.A.,?,+>+(;()<(2H18O53G.+B(/F,0G-%=#(@&-G,3M21K0.F..D/moXh[ESD<H45C*6M35O22O0-J+%>!6'?AM'_T&ån0ÃùKÈºWÁ…Y·ÀQﬁÀK◊√<‘∫/’¥'—®«ì¡Ä …ÑÕç	 Ö∆w ¬q ær ƒÉ…õøö¡ù¬õ¡ï∫å æã ≈ï¡ù¡§ ¿©ø™æ®Ω§¡£Ωù ¡ü ≈£«•¡ü æö »° °≈ñ¬Ñ √É œõ
+Ã°À©
+Œ≤Œ∂œª–Ω!œø"∆≥º®∫°ªù	ºó≥á¨v Æx ÆÅ ≥çØê≠í≠î¨ì≠í≠ê¨á¶z ™w´xßy ©Ä´Ñ™É ®Å ÆÉ¨| ¥{Æe ™U °G ±c”†#÷±"’±’¥ÿª◊∫◊¥›Ø%·°5ÊüM¯∑}ˇ–°ˇ‡∂ˇÂæ¸‰æ˜„æ˙Ëƒ˙Ï…˙Î ˙ÌÕ˙Ô”¸÷˝Ì”˚ÍŒ˛È ˇÁƒˇﬁ∏˛Ÿ≠˝’§¸‘†˛◊û¸÷òˆ—ãÌ»z⁄∞\€∑Y‹≈[“≈S”…X–ÃaÃŒmº¡qÄàMKV+9I%XhKrÇgevcjxxó•∞ü™¿£Æƒ∏¬Œö£®rxxÅÜâø«“⁄‚ıÀ◊Òπ«‰µƒ„üØ–øœ∫…Íµ¬‚ŒŸ˜ù§¡%*@)#$
+
+
+	9:5	 %)4$6:+CE8 -;.3A2&#)"*/7*!&&(&,2&'&1#*8)2@/-8'5@/$3?13A2(.A-+>(8J2dv^bq\{âxõ¶òÇåÅr~tâìä•´üabRLJ5nfOÄpY|l\/-!"6I55O4*G+0M/5N0/H*,F)2O16S4/M+/J+(C$9,E%-F&.G'%@!'A$(@&)'/@06I6,=* .%-1D0,B+,B+/G/3M20J/.F.*B*&>(,D.&>(*B, 6! 8"%=',C/1F3+>+$5#%8%'<+.E15M7+C--C.,D.(@(1I14N55O65O62L10H./F,.B));#.,("#**8' -)(%
+
+
+	
+
+		
+%&")67E!JV&Xa"Öâ4≤µL«ÀSƒ«F‡‹W‰⁄V∆±4÷[ËŒSﬁ…L·œOﬁ‘Pﬁ÷O·ŸPŒ√6‘≈8ﬁ»?√•Õ¢"ÿ´,Œ©$≈™Ω´ƒ¥#¡∞$…±-√†*¿ò))E.">'$='(A+*B*)?*-#!6#!;"+H*;]:BkA>k@@nGCqLGsOKxQLuMXÅYkïoYÉ]XÇZR}R^ã`dídnúniîgeêehíjkïqiñoiòncìcM~G:i20Z(@4#=$=YCUs[Yz]NrN1W.)S%'Q!$N!K%O%O(S%1[5MtWdÜulé~pïÉjïwdòh;r;8h6.Y.2W6+M2'I0;[FNi`H``gyáú≠ΩöÆπÖú¢SmjB[X;MW\k~Åêß∏»ﬂç£±°∫æ(B78T>KjKAcB A$4R:-I32K6BZD:R8/F,!8"8!5G7(8.%36jwäñ§øî§ª£∂ƒnÜÜ+#0%)=17RA8UA$B*/M1:\;-L,40+:'$5"#6##8%)@,6N86L7ObL-A(+B&%B##B )G%"@!?#@!#@!&C%&@%,*$2#3F3<U@=ZD?aI9\D;_C0T84W9@cC:_=2X3)M)*I)%?"#= /M)Y|RUyK_ÉU_Xqëlkçj\ÅXUzO>e6:f1An79d,)T(U6f,2_(4`-LxG\ÜX;e7)N%$>!$:%"8#":$ 5"3 5!5!22-0$5"&7$*=)*=).A--@,/B./E.3J0+B(.E+0F/,C).F,.F,/G-*C&(A$(B%,D*1G2L^NyÜ}r}u;H71@+6M35O21N/-J+.H+)@$';9AaOöw5—®LÈ√T·«N⁄∆C◊¡:—∑,À¨Ã• õƒå¡Ä »ÅÀÑ»y∆k ¿h Ωs …ç«û¿ù¿õ¡ò¡ì Ωç ¿ê ƒõ¬¢¡®¡™¿´¡™ø£¿ùºï ºì √ö∆üæó ªí …†Ã†	√ê¡| æw ÃìÀú…¢Ã¨À±œ∏À∂–ª"»µ∫ß∂ü∏ùπñ≥âÆx ¶m ´y ¥â≠ã™è¨ì¨ï	≠ì
+≠ë
+´â§} £u ™y®|ß´Ñ•~ §} ¨É´É Ø}Æn ¨^ ¢J Æ^ √è”Æ"÷≥!“≥÷∏÷π◊∑⁄≤‹ß%⁄ù2ÓØ`ˇ«ãˇ’•ˇ‹≤˝‡∏˚Âæ¯Ëƒ¯Í«¯È»˙ÎÃ˘Î–˚Î—˛Í—ˇËŒˇ„Ãˇ€¬ˇÃ±˝¬§˙ªö˙∫ñˇ¡öˇ∆ô˝Àò˙ÕíÙ»áÈ√z›¬k”¿a‘»d–Ãk…Àw≠≥mâUkzQO^=ScHèugxhuÉÉ™∂¬µ¿÷ò£π≤æŒº≈Œ•¶™ÇÄÖöö¶ß™Ω«—Ï»◊ˆ√–äô∫_míôßŒ¶¥Ÿ≥¬„æ…Ápwì-#&'"
+581!$&))7&=J8^gV9?1 )5))5'% )&-5(:@6!"*'*(&,"'$5F63A02;(2:%(1 9D3.;*#-@,%9 9L0NaCK[AXgRzày|à|q{pàêÖÇà~^aV=A3LN@yvelm]AL>&8(.F03M4+C+1H.5G/)10H0/L..K,1J-50)A'0I,-F)$<"+E*9S:#<&5K6-@-#4$% .#4",B--G..H/*D+0J/2L1+C+(@(+E,0J1*B,#;%'@*.G1*C.&=))>+%:'$9&,C/4L61J42J46N8-C.)?*0H01I/0H.2K.5N10I,%< %9!50 .($'!.)7&+'("		#". !/ .'"  &!)3:AHgjóî7≠¶;¡ªC——O––Jﬂ◊R·–L‘π8ÎÃMÈ KËÀK‰…Fﬂ«C⁄»@·—F€ >‘¡4‹¬9À§!∞u ÷õ%À† æ¢≈≤%…∫+»∂, ≥1∆¶/√û,(D-&B+(D-*D+-G.%;&
+!'=('A&;\=JpKItIGvJHvQHvRDpMNxT_ábtùuFqFNyNItGoömoùohñhióieígeèg]äadêldëjVÖY`ê`<k50\'&M!&H%!>"/K4IiRcÖmTv[>cA0V-%O!&R!'S$P)X!-Z#.Z)0Z2LsVgävxòâwôàsûÇNÇT;p<3a0"K!%H((H01Q:KgXXqnsäêü≤¡§∑∆ñ≠µjÑÉ6TJ<WPL`ibqÑéú∂∞¿ŸÑô¨ë©≥@[V7(<X?RoQ'C*5Q:3L9";(7!!9645K4&9&3C81??kyÜö™∫úÆ∫ò≠∞*D;2$/ "7(7O?*E2'C-;W>*I*'A$2$&&7$"7$'@+;T?:S=9Q9-E+!8'@#"? ;"@%@#>'B# =;-G,"!#!--:)5H58Q<9V@AaJ7Y@6Z>.S4;^@8[;9_:/U05Y56X7$>!%>!*E$Bb;JnBsòllågcÇ`dÜcqñmoîhXÄN4_).Y!0[#'R,Y 6c*1](Gs@TÄOR~MBn;"I"=512!2! 2"1 102,+,,!4 $7#/B.':&)<()?*%<",C)+A*4J35M31I/)A'(@&-E+1J-+E(+C),D,6I6DTIq~t4@27F36L57P31N//L-6P36M1+;CEy^)•~3—¨D‡¿Gÿ¡?‘æ5—∏*À¨ƒùƒó
+√é¡Ö ≈Ç »~«v¿h ¬` æa ¿v Õï∆ùæõ øò ¬ôƒñøè Ωë ¡ú√•ø®¿´¿´ø¶¿§¬üºï ∫é √ó»ü∑ê ∫ë À¢«õºâ æ{ ¡|  è»ñ∆ù«•…≠Ã¥ ≥Ã∏!»∑∫¶∏°∏ù¥ñ≤ã≤Ä¶o ´w ∞É¨á©å™ê´ë™ê®å™å©Üß~´´É	®Ä™Ç¶~¢{ ¨Ö≠àØÑ≤{ÆißR ™Y ≥∆†’µ&”µ“µ’π÷∫ÿµ⁄≠ÿ•%‚©BÒ∑eıæ~˜»î¸◊™˚„∑˘Áø˘Í√˚È≈˙Â∆¸‰»˛„»ˇ›«¸÷¡¸œº˘∆≥˚º™¸∏£˚±òÙ©åÛ™ä¯¥è˘∫ë˘¡í˘ƒíÒ√àÈ¬}‡√w⁄≈r”»vÀ«}ü§dzÑRsÇ[UdGIY?}èysÉvuÉÉ™∑¿ ’È∫≈€∂¡”∂æÀªπƒûõ§öôß¿≈ŸÇç©«÷ı…ÿ˜»◊¯õ©–™π‚¥√ÍØø·≤¡‚í†ΩX^x-!"$%
+!581-0' !$#2BQ>P_JMYE08)%+! #&(4&#
+'(',7)?G:#&.!%&!-*!&$0"1?06G72@/6=+4<'3?+6C1(5$"->+28H.L\AN]F?N;}çÇÇíà|ÖÄu|uW\VJOI[bZNVKRZKBM=?QA?VD3L7&?)4-@,6E0$.)C(+E('=&,/*@)/G-0H.": 6>X?8Q;&<' 1" *@+1I1-E-+E,0J//I..F,(@&/I02L3)A+&>(#=$&?))B,/F24K7-B/&;(-B/3K50I33K58P:6I5,B-(?%*C&1J-0I+-F)&?" 9(?"&=!';"#4!- +(&3""0''&# "	
+
+	
+	
+
+
+
+
+	",!'3%(6%(9')<)):*+(+%
+	
+ )1,1BBro(ïè/∞¶5ºÆ4¬µ3—…B‡ÿOÿœF›ÀC‰√@Œß&È¬?‚ª8ﬂ∏5‡ª7Ÿº4€¿5◊Ω2‘∑-ÿ±.Ãñ∏kÀÅÕõ"ÕØ)‘¡4æØ"Œæ5–π9Œ∞8«£1+D.*F/(D++E,/G/-(>''D&/R1AiDIvMHxNFvPIwSNzYXÅadâgOuNIrFaç\açZ]âTVÖQIyE\åZSÇT;h==jAdêlO|U>mCN{PAl?9`4'J"*I'2P46V>XzbaÉkNpUInM2X34]14`/&R)Y-_$+[!,['3]5T{^gàuoèÄá™ñ}¶àlúrDvE<j;(Q' C%)F0Tq]UqcMfcú≥π£ª≈Éú£ÉùûFd\7UIA\S>RY`qÅî§ª°± ®º‘´¬–Ked(#:&3K3(@*";(?WI?WGA]D3M0G`B;R6.E+$7#BSAIYL7GD@PO5HB(<13!7!"5"3" 7%7P;8T=5Q8)C(0 ((;%'?)3L6:S>6O94L2%=#)A'6P5%@!976!:&A"'D&!> )C('!&!,&-:)3D21I3>\D9YA?aF1T60S38[;?bA0V/5^61W2,N-$>!'@#*A%7R/Ae7`ÜWwõwpìr\ÄZjëdR}H@k3Ir82[!2Z%%P'R'R&QJtBUQMwGBn96^,+I%51. - ++)+-"1-)&&/!2 -,. 3 3(>'-C,*B*(@(-E-0H0.H-*D)/H+5N16O27N4:M7BT>GVC>O<;N::R:3M04N15O24H,:E%UQ$ït1¿î;—¨:◊π7—∫0 ¥# ´«°√î
+√ã¬ÜƒÑ »Å«v ƒj ¬a ≈b ¡d ¿y Àì«õøò æó √ö√óΩë ªí ¡û¬¶ø™ø™Ω® ¿ß¬¶ƒ§æõ æó ƒù≈ú∏ë ºï  £
+¬ô∏à ¡à ƒâ …í√ë √ó≈†≈®…∞∆≥…∏ «∏!∫©µù¥õ∞î±ê±â®{ §p ™y´Ñ´ä©ç©ç®ã	ßäßå	´é¨â	©É´Ñ®Å•}®Ä®Å™Ö¨äÆâ´~¨p •T §U ≠v∏íÀ¨—∑"“∑”π“π÷∏’≤‘¨⁄´'‰Ø?Â©Q∑r˛—òˇﬂÆ˚Â∂˚Êª˚„Ω¸ﬁº˛’π˝À≤˚¬Ø˘ª¨˘æ∞˚ΩÆ˙∏®¸∏•¯≤ôÛ©éÙ©ä˘≠ã˜´á˘Æá˚∂ç˙∫éÙºâÔ¿àÁ≈Ö›∆Éœ¡ÇãâPPX'crKAQ72E1i|ii{ovÑÑ®≤ªØ∏«¡…‹Ω»⁄µºœòô≠bcw†®ª∑√Ÿ'6U©π⁄Ã›˚≈’ˆ∫ÃÚ∞¬Í¥∆ÏØ¡ÂÆ¡‚∏»Èπ¬·IMf '&!
+	
+!#$-<)SbK@N5P\F2=,'(0%&0%(%1#&# +&'$1 4?/' -+  ,!-%!/ ':';N;5F4"/&/-6#:I41B/&3" ,=*#4!*)4$2=/$Ñìêù≠≠ìú°áèíåëî°•§VXU;B:JXKFXJ8M>9P@B[H9R?6!#8%5F3#2 1)A''@#.-0+A*+C)&>$6": ,D*&>&.,)3((/'	,-@,+A,,D.-G,*D'/I.(B'0J/)C(+E,+C+!7"*@+0H20H25M75K6(>)+A,0H24M75M79Q;9L8*@)+B&-F(,G&(C"#>99,G(,G(+D'&=#"3  ,&&3"'!$'$% 
+
+		
+'3%):(*=**?,,A.'9)+-/- '!
+	
+/2JJh`õê4¢ò)¬∂<»∂8Œª8—ø7ËÿMﬂ“Eﬁ»>Î√@ƒìË≥3Á≤2Á≤0·∞-ﬂµ-’Æ%”≠$‘®%ÿõ&∂i¿^ª`∏}	÷¥/‡ @√¥'Ÿ»D…¥5“µ=¡†,+D.+D.,F-/I./H+*!,G(-O*BkCIvMGvJEuKDtLGuPEsOJsQiëny¢z[ÜXHwAAp:=l5=l6Aq=HxHFsHGtMAjHfèm]ÜdVÇ^DnJDlGImI/Q.0R/;^@9[@\gWzdEgO`ÑhW|Z9b8,X'-\&.`%1c&2d)*Z&+X/KrS\}hwòÖ}£äâ≤ív•yaëaMxKA:[@LlUdÑmXweXsj~õñâ®¢]|tiâ~jâzCbR=YM7LM6HR{åúñ©∫•∫Àßø…lÖÇ&4 . 8"17MAIaSEaK(E)6Q2B[=3J01D.YkU?P=/A3N`R=P=.D/5!7"20!6#/F23M4"<#4))#4"#9"(@(/H25N87P:*B*40J1:T9/J+"=446"=*D')C&$>#5..**7%0>-*;(1I17U;;[CDfK+L/7X9:]<5[67`81Z2+Q,$F%(B' 7&:!3L,Cg9Iq?iéeqópZÅU7a1<i0?k.Js9Aj0/W"$O+S!L,T"Fp>NxJS}MBo8?g3=1.+ %"$%+/-'&$%%"""%+01#9")?((@(!9! 8 !; !; %>!(A$)B%+D&,C&,@%,@'4G11G2(@((B')C&.G*/?"=A_R©Ü5—®>“Ø1ÃØ%Ã∞ «©∆ù≈î	√â¿Ç √Ö ƒÅ ∆∆u »i ∆c Õg√f ≈{ Ãì«öøò ∫ë ƒò∆öøì ¿ó ∆¢¿ß¿´ø™¿©æ• ¡•ƒ§æú æú √ü¬ûΩô ¿ù…•	∆ü√ó ƒï»ñ…ó≈ñ«õ≈†√¶
+≈Æ«¥«∏∆∑ π®Øó±ó≤ñ¥ï≥ë	¨É§s ™yÆÜ
+´ä©ã®åßä•ä	ßé™í≠è¶Ö§Ä®Ñ®Å©É®Ä¶Å ≠ã¨ä≠ÖÆw†V ¶\ Øv≤äªú…∞“∏#”∫ —π—∏‘∂‘≥‘Øﬁ∞'‚™;ËØU˘«~ˇ’ôˇ⁄¶˛Ÿ≠˛‘Æ˙…©¯º†ˆ¥ú¯±ü¸¥•˛º¨˛øÆˇ¡ØˇƒÆˇ≈´ˇ√¶ˇΩûˇ∑ñˇ©à˚¢Äˇ´áˇ±å¸≥ä˚∏ç˜ΩçÏ∫â⁄≤Å´è`tg;vsRZbK?M<@UDrÜzuÅ}§Æ∞Ø∑¬¬…Ÿ∆—„ƒÃ·WYp!6êõ≠ù¨¡2A`æŒÔ»Ÿ˜¡‘Ù¥∆Í∞¬Ë∞¬Í≥≈Î™æ„∫ÕÓøÃÏTZt"('#		!&"!		%)DP:4>&KTA7@/"'.&! ,+!%" (%2! -,$2!+#1"&4% .$5%2G45K6/@.( )*9K52D.# *;)'8&q}}ü≠∞ïûßóù©©≠∂ü†•SSQ+!4F8H]NBYI<TD;VC@[H7P;1G2$7!,,?++B(5&8""3 1(>'%;$7$= *C&)@$'; ,9%<G7-3'$"(!,%1#6D3*'0.D--E+-G,,F+*D)'?%-E+.D-,?),?)0F/.F.6N63I22H33I4.F02K56N84L43K1*C&,E'0K*-K).L*0K,.I*.I*%@!"=!<";"5%($1 $!$'((%" 
+
+
+
+!+9(*=*(>)'<)%:'3".!6%3"/!(#			  BEÑÇ8ïã,ûê#æ∞6–¡@≈≤/Ÿ√<≈´#‹≈9Ê”Fﬂ≈:‡µ2”úŸúÏ≠,◊õ‚©&Ê¥-“§÷®!–ò—Ñ®J øOπU ∞uÂ≈>◊ƒ9Õ¿4ÿ E…µ8’ΩC”∂>,D.+C+0H.2M./M)2;[6=5\-2^+4d2:l;BsDCtGBqE?nB:i?<i@CmEDqF>n<>p;6f27f2KyHO}OLyRIrR>bHSv^bÖmiåtOv[IpSQvWGlK3V5@eC@hF9`CeàpUxdWxcxúÇbãi8e<7b58f54e-;n31d+)[&3`5T|Zsñ~}†àrõ{WÑ[[âZ\àW(N%'J)FgLZ|cY~_?fIaàmZÅfLuW:aDDhN\~f;ZH-I;/F@.-/34GKPehnáÉ3K>%>)/I.5O2 810D9@ULGbQ"@(<V9C\>8N78K5^pZFXB,CVBH_C9R5&?)#<'/1%:'%;&&@'0J/*B(- '$5#%=%+E*1K0/H2-E/3 5 7O9<V=-G* ;97349(B%,F)*G)!; 6"9)=$,?)#9".F.5Q8DbJ;\A,J.9Z;7Z99_:8a9+T,*P+#B"1)))A!=b/?g2JqBjëdMwG<h37d)8f(8d)Cn6Cn63^&&N"J,V$4`-Am:UÅL:g0+S!"=/-,!&&!&(&%%))$%#*."5!"8##9"+A*'=&/G--G,$>!$= '@#*A%*C&0I+,E'-F(/H*0J-(B%$>!$= -D'9D$E<eM´â(–¨2À´"…´ ¶«ö«è≈á¬} √~ ∆Ü ∆Ü»Å∆u  m…hŒk¿f √x ÕíÀû¡ö ªè ≈ó«ô¿í øì ƒù¡•¿©¿©¿ßø£¿£¿† Ωö æõ ¡ü ¡°Ωü ¿¢√•¬¢√°√ú ¬ô ≈ö ƒò≈û≈¢¬®√¨√∞≈µ∆∏!øØ≤ö∞îÆî≤ñ±ëÆâ©}¶x ¨Ñ©Ü™â®ä¶â	¢á¶è©í´é£Ñ£Å®Ñ
+¨â™à™Ç	©Å´Ü¨áÆá´y £^ ßb Æu∞ÖØç∫üÃ≥"”ª%–∑–∂—∏‘∏“≤’∞€≠&·Æ9ÏµX¯æt˛√ãˇ√óˇ∫ò˜≠íÚ¶å˘≠ï˙≤ö˚∑†ˇ¡®ˇÃ±ˇ–µˇ—≥ˇÃ≠ˇƒ§ˇµï¸©â˜ù{Ûïs˜ôw¸ûz˚ùw˙úx¯õyÛòy‰èp»_ßpRáeLRG5V]MJ\LOdUjtkçëêîóûãëù«”„«“‰àãú!0rxÜnzä(B¢±–¡‘Ù¡’ˆ≈ÿ˘∞øÊ®∂„¨ΩÈ´æÊ∏ Ó≈”W_v  "!			 ,3+
+&!")<@/=?2"&!!, -*&3"%3"$2#&7'#4$-?/:O<5J7(6%(,9'5I0*<&!):(0A/!
+470õ°ù≤∫ºäëõ|ÇêqtÉääílkg+-"$* 0#.C4B[HB_K=ZF<ZB=Y@)C(&>&(@((@&#;!2E/2 3$:##9"";-H))B"'<3B%RZBEJ604#!%*#1 )7&*8'(6%&4%#1$$0$	
+):**@+.F./G/-E+*A'/A)6H05D-&8"*@).F.5L22I/5M5:R<.F0*B,.H/-G*,I**H&1O-7U3@^<C`A4O02M.8Q3'@  9 963)$1 *$%))* * $!
+
+	(+<*+>+&<''=(-C.4!3 &=),C11F7#3('
+
+
+ ## ONÄ,ùõ4ª∂A¶ú º≠,◊≈?‘ƒ9›«=ÿ∏1 ® Í–EÎŒDﬂ≥.ﬂ®'”íÁ£$ÿó“ñÍ∏1”•–üÃêŒw¨B æD∏Q≈ëÌ÷J›ŒA÷ @÷…F ª:ﬁ M”æA(;(':&60K*>b6&M.V$.Z%/^'1c(*]%:l78h86e73c36f69i7:j:3a26f6<n9-_*)Y%.^.MxKNxPIqOHoT[|giäudÖp_ÇjHnUU|aY}aDiJ9a>HpMDlI>eF[~fhãurì~{ûÜWÄ`8d@LvN_ä]3c/;n57j1-_*2_4MvT|üáÇ¶åuü{M{MIuB#M(J%*I)7X;SvVV{Y:b=AiFKsP5]83[87\==_F,L71L=+A5+@7'<3E\R<SI2M>3O9C_FSpQLiJG`C#9$$5+>RIC]P6S?6P5AZ=?U><O9]oYi{e"(<#H_B2+C-3L9+D1#:&"7$&<'8P84L2+A*
+
+ , %6$$:#$>#*D)$<$3..C07O92L3%?"9634457%?"0M/3P2(E'&@#(B%-E+*D+(B)5Q8;\A9Z?1R36Y85X7=c>,U-.T-&H%2#*<"Hg;Fk7TzIV~LS}M=h36c(.\6c(>k08e,-X &N&N+U#(R Iu@XÑOGr=HmA+E(./$+!))"!))%'''""#'#4"#6")<&$:#(?%*A'+D'.H+,E($= #<$= /H*3N-,G&(C"+F'.I*1J*/B"1?@>U>zV≤é»¶ »®»§≈î¡á «Ç∆| ¿v »Å…ã…é…Ñ≈t »i »b Œk√g ¡s Œê ù√ú Ωè √ìƒîøê Ωç øñ ¬§¡®¿ß¿ßø£¿† øú øú øú ¡°¡§¿§æ¢ø£¿§¿§¬•√£√üΩô øú ¬§¬™
+√¨ø´¿∞√¥¿∞¥úÆî≠ìÆì≠ê≠ã≠Ñ£w ¶}¨Ñ©Ü¶á¶â	§à
+•ç©í®è¶â	®Ü
+ßÖ
+´ã™á©Ä
+•{¶~Øà	∞âØ~´kßd ´t ≠Ç ≠à¨èø§Œµ$Œ∂ œ∂œ∑—∏—µ“±“≠◊¨"ﬂ™6Ê™JÓ™_Ò¶lÒùqÒúw¯£ÑˇÆê¸±ë˘µí¸Ωöˇ»£ˇÀß¸∆¢¯¿õ˜∏ï˘≥ë¸Æä˝ßÑ˚°~˝°|˛†z˙örÙêláiÏÇhË~d—rVµeJò\DiI4OD2T]LN^QR\Qkrk|ÄÉpt}¬Ãÿ∏¿Õîîû?<E++3%)4'8=Lc±ƒ‚ø‘ÛŒ·ˇ¡”˜©∏·ú´÷ß∂›æÕÓ≤æÿ,3E
+.-)		3=4
+	
+	!))1"04%EG988. 
+	
+
+	$!&%"0!+<,-;P=7L90C0"/"/>+/A+(:$'!(9&4E3("%{~wåëç¨±¥ù°¨öù¨~Åêx{Çpsl[_P"(%$$1"4M:A]G=[C:V=?\@$>#%?$6P5GaFAW@ 6"8!#9"#;!%>!%@!(@ 2E'LV;x{`LL4.3+6%*9&'8&%3$!/ +&#$!!',?,0F10F/.B)1A'<J15D-*<&,B-.F.4K11H.4L4:S=4L6+C-*D'-K)/O*:Z5FdBB`>>[<A^?8S4(C$'@"#< 7640#2!/#1  .&!',+!'&
+	&'8(*;)(;')?*,B- 5""9%(A,,E2+@1'7,%%"')ZXÉÅ,†ü3≥≥9«ƒC ¿<¥†ÿ¬;÷√8Ÿ¬6Ê¬:ªï÷∑+Ô–Dﬂ∏/ﬁ¨'ﬁ¢ ’ëÎ§(◊ñ€ß €´#”¢‹õ' j≤@ øD∑S Â∏;ÓﬁM·÷I’ÕF‘ G‘∆IﬁÀRÃ∑@!%93Q+2Z()V)U +Z#-_$+^#+a%.a(#O0\+6e17h14e-/b)._(2c,)\#'Z!)Y%.\-:c;%J(>cBV{\bÜlgãqgãqX|`V}`U~^KsQGoL?iEDnH?h@;c@PtXrî|tólèwqò}LsTx†~dçe>l>MLI|D/a.0]4KtRÄ£ã£â}ßÉM{MCo:?&I!.M+9[8Bd?4V1/Q,<^9'I&#B#=#:ZB1Q:,G45%,C3=TB;WA9W?:WC<YC<ZBLjNYxYVsTHaD%;&7G=M^V8REA^L,C/;Q:H[EXkU^pZ]oY 2'9#;N8)1!*?07P=.J4+D/(A+(@("8!!	#%6$42'@#!9+3,D,2L1/I.!; (B'6*13359"<!6P58U93P4,I-0N47U;%B&.L08[=6[:-R1/T2;`>3Y2/U,(M$'B3" *? @\3Kl=\ÇQmìdbäXAm28f(2`".[ (U"M%M*P)Q-U!Cn8Fq<Cj;5U02)'#!#$&, /*'&'%%'"
+	
+ .%6#&9#)<&&9#%<",E(+D'.H+4N1)C&";&?!'B!*E$-H%-H'2J(8I'=EKFeNÑW©x¡ö ß…£ƒñ¿Å ¡z «x √t √w ÀÜÀî ì»Öƒp ƒa ∆Z œeÀj ƒt Ãå…ö∆ùøì øè ≈í¿ç øå ¬î √£¿ß¿ßø¶¡•øü æõ ¡ù¿û ¿† ¿£¿£ªù æ† ¿§¿• ¿ß¬¶¡° ∫ö ¿¢¡ß¬™¿©Ω¶
+ø¨√≤¿Ø∂†¨í ©è ÆíÆè¨ä≠Ü•| §v ´¨Ñ
+ßÖ	•à
+£äßèßí®ë¶ç•à
+§Ñ	™ä©Ü§{¶{®{¨≠Ñ∞©j £d ´w ±ÜØä®à ∞ì	∆´Ã≥#Ã∑ œ∂Õ≥œ≥“≤œ¨“≠◊¨⁄ß(ﬁû2ﬁî;ÂëKöa˘•v¸´~¯´}ˆÆ~˜≥Ñ¯∏ä¯ªè˙¡ñ˝∆ùˇ»¢ˇƒüˇ¬úˇ¿ôˇºíˇπåˇµáˇÆÇˇ®Ä˛†~˚òx¯ëpÁÖb÷|Y¡uUõbEfB*E<+OUIT`TN[Ru~{y~Åµæ«®´¥Ñ{|tig%"%*)5VhÄ∑ÃÈ∆€¯ ﬂ¸¡“∂≈‰ø Êó°∫FM`"
+,-(#"	
+5?6"')/:)29'=A2)+ 
+ 06,$'$2#,=- 3 =R?6K82(*$"/&5"(7"*9&,&9%9L9'W^WFLHìõù™±∑ìó¢ü£Æ†§ØYac`j_O[G1<+'!)'<)5M71I1$>##<$= ?Y<:T75O2&@%%=##;!.H-'A$7 70@%2; mkR=;"19$*7%!/+*"!$ '$"',:+/@.*<&.>$7E,4C,*=',D.*C-0J1-G..F03K5.D/(@(/J+-K'2R+>^7HfD/L-<Y;A^@.H+$= "96 7531"4.1"5!5 .)/"!+""!
+	%(9'(;'(>'%;$5 #9$'>*%<('>,-?1( 	!,$,%' XXáà+•®7∑π<¿¬=Ã»B‘»BÃ±.πõﬂ√;€æ6„æ9“Æ&¿úÌÃ?‚¡4‰æ5Ìª6€úÕÅ	‰ö!Ê´)”°÷§!◊ñ æZªE ƒOƒgÌ≈BÈ›M‰‹Sﬁ◊S”…Mÿ…Tﬁ Z…¥G	.E)5U.*V#'V&U&U'Z!%X'[/a&!M0Z(3b,._',_$*]"*[#*[#(Y!*[$)X$2]0A?PsRPuSV{ZYÅ_W]MuRMwSCmIAiDFlG:b?;c>=c<CiD]Ä`sïzÄ§ä¢äpîzuôsòyjíp\Ü`]å`HxH=m=8g;FoMiåtÄ£ãÖØãQQL{E)T!F=-M(!A:<#A1,'C*8Y>$E*'E+:!2FdJDcD:[<7U94R81O52P44S48U7,D*3F2Xh]ctl@ZM$>11G;GYM\n`SeUl}m]n\RdN?S:4F01B0&4'$4'1H65Q;,H1'A((@(&<'"
+.0,7*C&6#;!,F+,F)-J,<3P40M1&"!4//588'A&5R6;Y=5S79W;<Z>+J+7X9/R1*O-5[64X44X2*M%%C"9"*B Dc9RvF\ÄP\ÑPNw=6d&-[!Q"M!I$J"H#I-U!>i3;c/+N$,&""#'**,-+)*)))((&	" .$5""3 &8"%8"%<"+D'+D'+E(4O0+F'$?(A!.I&0J%/E4EGP#jj6êÅH®áB∞~'¬é »°…•«ü	øå ¿{ ƒs ∆r «s ƒu ÀàÃò ó»à¡p Àe À] œa Õf»n ŒÖÀó üƒòøë ƒë¬ç √é ¿í ¬û¬¶¡®¿ß¿§ø¢ øù æú ¿û ¡°ø¢ æ° ∫ú æ† ¿£æ£ Ω§ æ• æ¢ º† ¿¶¬™
+¡™æß	æßø™¡∞¿Ø∫§Øó¨í ≠ë≠ê´ã¨ä´Ñ§v ©}©ÅßÖ	•á†á	•ê©î©î®ëßé™å™ä¶É¢y•z	¨~©z¢u ±Ä
+§j °h ≠}ØáÆâ¶Ñ •É ∂ô∆¨!Ã∂%ÕµÃ≥ÀÆŒ∞ŒÆ—Ø—≠÷™Ÿ£€ö$‡ò4ÁõEÊöN‰öSÁöVÓ£bÛ¨lˆ∞t˙∑Çˇ¬íˇ»õˇ»ù˛√õ˛√õˇ√öˇ≈òˇ√ïˇΩåˇ≥ÖˇÆÇˇ¨Ñˇ¶~˚ûsÚïjÌñk„îk≈Ñ^ë`@Q8">8(AI:JXKHSKW`]•¨≤áàåá|xÇtk ('%".\lÖ¥»‡ƒ÷ÓÃ€Ú•∞∆NUh!$5"
+'&!	0<0'3' %''$/09&,3##&!HKD!+ )7(+<*8K86K8*=)&&(3#+,9(.!0%4!/'=(<Q>!2 )5'ù•öâêâêññàçêÄÉàÜâéòù°;DAAM?/>),9%+8& (
++-@,$:#": 3!8+D')C&*D'%?" :"<!-G,(B%3L/.E)*: $,~}hB?,24&,0" ëóìotw9>AKPSYcdS]\.42 &,.;'4C,3B-,?+(>)-E/-F0.G1'>*&;(5 6)D#*H"*J!/O(9V7.K/4Q56P50J-*C&2K.'@# 7 7#7!5/. 7$<$*B*.F00H2,?,#1"" 
+	&4#$7# 33$:%)?*%<(%>)0I4/D3*"/8:A]]åä5¶¶6πº;¡√>æº5À≈;√∂,ﬁ√>Øé	“∞*‡ª6„æ9Â¡9“¨#ﬁ∫.Ô–B·Ω1›Ø(Î∞0¡w –Ü›ù‘û÷§!ﬁ¢*…q∏R ÃfŒ{ÊæEÓ›[ÈﬁbŸŒX—¡R’¿W÷ΩY–¥Q%*,E'2W,*V%&U'S 'S #R$V*\*Z !M5a,-^&+^#)\#)\#*[#*[$/[(/[*.X*5Z16$A#BfBFlEHpKEoIP}TAnC@k@@i?>d=4V3;Z;6U6;Z89[8MqMhãkÇ¶ävöÄtöÅpó|z°Ü|£Ü|£ÑmósbèfHwI>o@8g=Qx]Å§å{§ÑoúqFxCNHE8547862.;Y=/R1$J#<e;4]1+T*.T-7[7?a@JiJQpQ]|]QoS.L24N53I40C03C6GYMD\O(?7%55zàãqÅÄYjdl|rSdT]qXBY=&:!&4#'5C6?TC9Q;6P51K.%;$,?).A-/&,,/6#<8$>!*D')H(.M-'I(0Q22S4.M.?W?).8 9646+E(4Q5>\@IjM<]>/N,-O,0T00T04V3*H$$?!8()*&1QkFHg;Mr?QzBVEAo13`%)Y)T"J!G$J-U!4_)Kt<=c2,G&"%+,. 1"3 ,--../-.-*#$ ,% /&5 $86%<"+C)*G)+J*-H)+D$.F$8J$EQ#\a+ääJ≤´cŒΩoœ±Yƒô0≈ò∆£»ß√õΩà ¿y ≈q ≈o Àvƒs …ÑÃöÕûÕí≈z ÃkÕ_ Œ[ À\ ≈_  uÀç…ö…ù≈ô¡ë ¡é ¿ç øê √ú¬¢¬ßø¶ø£¿£øü ºú ¿¢¡§¿§æ¢ æ¢ ¿£¿£Ω° Ω§æ•º£ Ω¶ø©ø©¿©ø®
+æßΩ®¡≠øÆ∫¶ØõØóÆîØïÆì´é´â™É§} •Å®â®å§å£é¶ì®ï©î®ê®è™ä®É•|
+ß|ÆÄ≠}új Æ|	™u£r ´ÑÆâ≠àßÇ •Ä ¨äπü≈Æ"…¥# ¥  ±ÃØÃ∞ÃØœ≠–¨‘´ÿ™Ÿ©!›ß)‹§-◊ó+◊ç*·î:ÈüJÓ•XÛ®eÙ¨r˜¥Ä˝Ωëˇ¡òˇƒùˇ¬õˇ¬ñˇ≈òˇ√ì˛±É˜§x˙®y˛Æ}˘¨xÒ•qÓ•rÎßv‚®z…òoûzX^I.94;B2AMAWd]´¥≥èèçåÉzíÜxK?/( %"%,7I{àõu}ê'-=--9#"(
+
+
+
+	  #  +9*'5($"#)+6%%0#+03,$QTK&+-@-:O<3I4!2 %&!+>O<*9&)+-4!>T?7J6^mX`iXcgYz}vwytFGBxxv=?</6.5@0.;))8#/<(2?-0;*$,
+&7%#9" 7'(%<"*B((@&$>#9#= *G)/I,3L/+B&"4+éëÜéãÑridgZRMA3;3&]\Z±¥πGJO16:FPQpzyntpCEB 
+ ,(7$.<+(9'"5"*=*,B-.D/+>+ 3 /2$?+K")L"3U2MkQA]GKdNB\C>X=GaDLfI9T5$=!5':%8//7!;%B&-J.;X<6P7.A-"0"+,.1 6!+C-'@+-I31L94K;'4*)/9?hk&êè3≠´>ππ?ΩΩ9√ø9»¿9—≈=«∫0‡ŒF…Ø'ªïÓƒ>ÿ∞*⁄¥-ÂΩ7«°ÒÃ@È¬9ﬂ∞,‰≠,÷îÃàŸöŸ†–üÁµ8ﬁ¢2…Ö €ê3◊î9›±NŸºXœ∑U–π[—∏\”µ]—¨T√öB((C$2U-+U%)U"(T#%Q%Q(U/Z%#K(M!6[//Y)-W'1],0\+0Z*/V)8[16:6S4%&>$7V4;_9;d<CmE@mD8c84]5*P)2T1;( ?V:%@QqL^Ç^róvoñwy†Épò}xûÖrô~wûÉwûÅuû|bèf:k<6e9Qx]ÑßèÜ≠émöqI{FQÇK:6364!:799Ae?JsGAo>KzDOÄHM}IDrA:e71X,0R-/N,1R33Q5.J35N97L9<O<4E55G98NB9MK6CLjtÄn{ÉZilàññcrk@UBJ`I'8%%2>4IZH:P9C\?4M0*='0 3,=+(%+0055779;#B"&H''I()L+*M,=^?$A%;U:-G,-722/12 :.K-;Z;?^>4R0.L*2Q1/N,(F$#<5'!". $5#!4 -/#;6R*;\-Cj3Ir89e*4a&0]",W'O$J+O3Y&:`-3Y&"C,%+#4"$7#!4 0/ 3#6"3523/2/-%!# !! !0(:$*-%8")A'+D'/C'0? 8B LN&ol7†òY¬∫o’…uﬁ…p’µR∆ù)√õƒ•≈ß	¬ù¡é ≈Ç ≈v ƒm Õsƒm »z Õî—ü
+–ñ√} »i …]  W ÃY ¿Q «f »Å…í«úƒõ¡ì ¡ë ƒë¬ì ƒõƒ†¬•¡¶æ¢ ø£æ† æ† ¿§¿§¿§æ¢ æ† ø°æ° Ω° Ω§æ•Ω¶æ®æ´æ™	¿©ø®º•
+Ω®¿¨æ≠∏ß±ùÆôÆñÆïÆì´é´ã¨ä£} £Ä©ä´è•ç¢ç§ëßî®î®ï•ç•à™á®Ä•{¶x	™zùm ´|ØÉ
+®Å ®Ü ¨å©á¶Å ¨á´â≠ë	∏°¬≠ …¥% ≤À≤À±Ã∞Õ≠Œ¨Õ´—≠‘∞’∞ŸØ÷•‘óŸñ!⁄ñ+÷ê.Ÿç9·ïJÓßg˚∏Å˝øé¸øì˚¿ñˇƒöˇ∆ôˇæë˘ØÇ˜©y˚Ø}˝∂~¸∫Ä˜∂|˜∂~ı∂ÄÒ∏ÉË¥Ç◊®~´ác[G,<7#*0";E<ÄÖíìãvpbyr`rmY-*
+#""'&+,*+
+	
+
+""*% 1,=+"))!,,7&*5%*5'.0+ #]`W	)%7J77M8(>)/ -%*CVB1@-%$(3 8N90F/>P8@N7T]J|Ñudj^46+891)4$/<*)6".<%+9"&3/:)(,$5#"8!0G--/)@&(@&$<")A'/G-0H.,D*&?"#: !5 2"/}á~ÀÀ…¥®™zhfq]RîÜyWSPñóôLMQ7;<&1-%0*/6/AF@TVU 
+&$0"%3$&4%#4$%6$%6$#1 %'&=!.J$-N#)L$HjI]ybYu_TmWUoTE_B@]?6S4/J)%> !9#8$9527<$C$+J+:Y:.K-2J0/B. ,$--5 %='*F/2O96R<=VC,>2$1''$/!+3;@hi%ôò<≥ØCπµ:¡º<…≈@–…D—»?“≈;ŸÃ@‡’GﬂŒBπï÷¨&‚∫4—©#Ì≈?÷¨$◊ß!„±.›®(‰≠.Á≠/„ß+·£(Ÿù%÷ü*ÎπH‰¥H’£@’ûDÿ°N–£RÀ•T–´[€¥eŸÆ_ƒïE¿â7∏~, ";1Q,)P#&R&R#O&R/W%/O&*
++-A(25N0&A"4Q2:1J,#7#
+$>R9(.H-1P02V20X3-U2#H&<7;5!GTB/KeBVvOLrIcådoóujëtwöÇÜ©ìyüàpñ}}§âÅ™àO~R:i?AhKvöÄå±èT}SJyC?i7278";#<#<#<#@!+P'HtCM~GI|AI}=K?PÜHMÉGQÖGHw@?f9KoI6W:)G/@YD;R@TiXM_O.@0&8*&;4HZ\UaoS\myÖëàñüqàaps3D<(%PZQ[lZ.D-OhK8Q4':$&**.44!;  :!; 9"<9899; ?#B $C#)H(2Q26U6-L,1P. @5102/.4"<%B$*E&5L06M17P30I,"9/)"!"0'8& 6!5 0.+ 75Q+9]/Cj5Bm5An38e*1]"5^&1W$,P /P!*K:2* "*%6&#4"#6"#6",-"5!&<% 6#: 6"9 75!41*!$#!#$-%))7&&3+0B>!XH$Ür@∞ö^Õ∫u⁄Õ~ﬂœz‡¬j–™E∆ù!≈ü¬§√ßƒ°ƒò∆é«Çƒo Àl …f ¬h Õá—óœï≈Ç √i ∆_  [ Œ[∆R ƒ\ …v »ä«ö≈ù ¡ï √ï√ì¡ì ¬ô¬û ≈•¬ß¿§¿§¿£ø¢ æ¢ ø£ø£æ† πò æù Ωü æ¢Ω§Ω•Ω•æ®ª®º™æ™¿©π†Ω•ª™ª¨∏ß∞ú´ï≠ï¨ë™ç™ã ≠ç≠å£Ç°~ ©á®ä§ã°å•í®ïßï®ñßî®ê™ç©à©Å†rßw•x´É	±é™ç™ç´é®Ü ßÖ ™ä®ã©é≠ñ
+π§¡Æ!»±# ≤…∞Ã∞Œ≤ÃØÀ©	Ã™
+œ≠“≤—≥”∞–¶—†”ù—ëœÖŸç-Â¢KÎ¨_Òµv¯øàˇÀôˇÕüˇ¡ñˆ≥àˆØÅ¸πÑ˛¿á¸¿Ñ˙øÉ˜ª˜∂|ı≤{≤yÍÆx‚®x«ñmãgGC-")*$IIAffZbcSNQ<MW>;D/
+	
+	
+
+
+//-	
+	
+
+		',#4!3E/)$1 +),7'1<,,9(+7)+7+ ,"			 &ad[ !+&;(3K5-C.&9%(0AT@/=,$+8N9/F,(?#2I/8L3CU?GVC,7' "(3#9E1:F0-;"/=$*9"*7#4C0$5"!4 *B(6N4)A'*B(+C)*D'-F)/G-0F/@S?1B/$3 $3/=$;J-@N5]g^ƒ»«Œ»Ãå~~p_WÑxlrrh[^WUVQ*,')0('1('!!043				&",!(3%%1##/!!/ "$$'>!0O&7[/>^9TsS]z^[uZB[>2M.1L+,G&)D#'B$=$>%?!;97<<!@ )H(.M-0M.-G**@)!2 -2"8!'?'1M48V<;XB4O<)>-,>0*:-.<%6>km,ïî8™¶8≈ºG¡∑;…æ>œ≈AŸ”K”ÀBœ√9◊Ã>ﬂ⁄H‡÷CŸø4∫ïÊæ:’´%‚ª2Ò¡;…âÕá„£(Ê¨/Á±5ÛºE‰®8‹ù6◊ò9ŸùE“ùM”£W€¨d‡∂n·πs‰∫r·ØhŒîJ≈É5æu&∑k∂f8P85,-M&&M %O#M(O .U&0P'&
+
+
+# "'*"(8G2)"92O1<`</U00U3&I)< ;"(B)!6#EP@0>' 4E`=TwOYÇXLuMU}[Ä§äà´ì~°âÅ•ãá´ë~•ÜkòqErK:aDlêtâÆåXÅW8b077 8!:&?!&?&?(C$>9c5L{EQÖGKÇAIÄ?MÑCQàGQàGNÖBBv8@l9U{R2S4cÅinÖs\q`tâx7L92G6)?25JCI]^]iyò£µéö™´π∆oåsÑåÑîî+:5'VdUJ]I3K1=T:*-$5#,?,2H38R9.K/,K,&E%648:<;9:=!@#B .M..M.9X8,N+*N( C82..-,+2635I.as[oÅi@R:*'" "'0"8# 6!4!4/('39W1Cg;Bj8Dl8;f0?j2;c.:_,1R#3T%<[//K%3.#'.2)<((;%01"5!!7 (>'$:#(?%8%>  9"9#: !4+!   !%' 0a@!íh>æì^÷∞o„«}Í’ÑÊ–z€∑Y û3«ü«¢√•√¶√°«û»ñ»äƒt Àl Ãg «e –~œäŒëÕç {Ào Ãe –aÀW ≈X ÕvŒäÀô…°√ó¡ì ∆ì¡í ¿î øò ƒ¢¡§ æ¢ ¡•¿£Ω† Ω† ¿£¡§Ωü ∑ñ ¿üΩüΩ° º£ª£º§º¶∫ßº®Ω©
+∫¶	∫°æ¶ª™∫´∂ßÆö´í≠ì≠ê©â ®à ©â™å®äßÖ§Ö´ç•å•é¶ë¶ì¶î•ñ¶ó®ì™í´éÆã¶|ß|©Ä
+Øå¨ê	©è™ë™è ®à•Ö ßäßå¶åßê∞õª®ƒØ"∆±"…± ±Ã≤Õ±À≠ ™	…©Œ±ŒµŒµ–∞Õ©“¶“ù“é◊í⁄ú/·ßDÈ±\ÛΩs˚«ãˇ«ñ¸øì˙ªê˝¿ëˇ«íˇ»è˙¬á˜ºÇ¯∫Å˙±|˘≠{˜∞|Ò´xË§uÿôp©tTQ+%	##-/!07%?M6N[G
+
+	
+	**(#"						
+	 &!/ 2*='$3 -+&2$7B2EP@7B2 ,('3)+5*!)	
+
+				!'dg^&) #"3#4J51I3%;&!4!&4%"(;(9O:%1#'#:M95L2#;!'?%1I/5M34K1:K8;I8$0" ,'4#BO;LXB-9!/=$@O8#2&8"$5""8#-E+.H-'A(+E*.H-/G-+D'6M3awb|è{lyhlwfkwc\hPfqSYcJITF∑º∂–ŒœÄzzypgàÇtBD66:+¶¶öddX*-"(0#($	
+'(&%!%/.G)5U,Gj@XzU[zZLiK:T7.I*(C$'B!'B!&A#>$>$>$@ >=<>? ?#B")G%1O-*E&+D'+A*)$#4!4,D,1N24R86S=1L93J82G40C-0@Ya%åé:£°4π≥9ƒ∫> º?–æ@–¬?‘ÃE÷–D ¡4Õ∆7›‹FﬁÿDÂ“E»´#–®$‰∏3‘™"ı√>ﬁô ∆{‰ù+Æ>ÿû2€°=“í8«Ü4œçC“ìP·ßhÒæÚ¬ÇÛ√ÅÌºy·´e—éH¬t,∑a∂[∏]
+ºbIrJFlC1T,"E%K%K)O 1Q(6Q./	 
+#!-/A)/)=!50M.1W0/X.-V.*P+!C""A"+H,(>)<I7*9&(>Y:RuMJqETTsõy{†ÅÄ•Ü¢ÑmêpMpP|§ÇW~_U|_V}`Å®âqôtIsE6
+4$:# 74$=&A +F%(H!+U%@q:KÅCPÜHH~BEx=MÄESáIMÅC0c(KzDFoC;\=fÇkYn_h}n^uaB[E1M7&A2=WN3HIáî§Çè¢≠ª»éú©çù™ãú¶ì•©Ñîì$ #:G=HZJD\D4J3(+#6#)@,3L9=YC?]E4U83W1)N%<88="@#A< @@!C *I*0O06W80S2)M)A=510-.-,0.&:2D*@P64C,#!, 3 5  6!320))68S48W52T/:]5:_4Dj98^+,Q4V$<_)=_,3R&:2*2'?%+B($;!.0#9"'=&"8!(>'&=#'>"!:'A$#= %>!%=#0)!'%#*?
+t;£^7√}Lÿö_‚±oÎ≈|Ò“ÇË…o”¶Aƒì»ü«¢	≈£√°ƒú …úÀôŒî Å »q —oœj –r –~ –é—ó–ê  »l œg ] ƒ\ “y—àÃòÃüƒî¿ç ∆è√é ƒë ƒòƒ†¿† Ω† ¿§ø¢ Ω† æû ¿† ¬¢øü ºõ ¿ü¿¢º† Ω§æ•æ¶Ω•ª•ªßº®	ªß
+∫•
+ºßª™π©µ•±ù
+®è ´é≠ê©â©â®á©ã	´å®â
+°Ñ®å¶ç£ã§è¶ì§ï•ò•ò™ó¨ó™í≠ê™Ü§ßÉ≠ã¨ë´î´ï´í¶â •Ö ¶â®ç¶åßç™ì≤ùΩ™¡Æ!≈∞»≤…±…∞ ∞»¨ ≠ ≠ ±Ã≥œ≥ÃÆÀß	–§Œö	–ò—ù’¢%‹®8‡™JÈ™c±{˙¡îˇÕ£ˇ–†˚…ò¸ƒë˝¡ç˛ºà˚≥Åˆüt¯üw˙ß}˙®Ä†{·ïu√}c|H32
+"%-3%*. 
+
+'&"
+
+	
+
+
+	
+$"0!2"5!,'%3$BPA?L;S^N`k]&$+#.5-*1)'
+
+		#%+]`U#&
+-0C/;Q:,B+"3 &-(6))2G46K8"3D2@V?4)?(,B+-E+4L2/G1.F07M83F2(9&ET?cp^*6".<%<K4+:%&8".!4 )A+(B)(D-,E/)B,.F./F,+B(<R;OeNetaivb~ätxÇiÅámkoXafRw}o∞≥¨ÅÇ|y{pSUG+2 6;'õöÜÆ´ö/0"*0"". ,
+	
+	"&%'>$0N,6Y1GlATvQDcA4Q36S7.K-;U8OiLC\>*C#(A!'A%@$B!A"B>@A$C!(G%%B#&D"(F$+F',E(%8"(!7"0J1/L08V<?[E7RA8O?2H15I&Q`)Ñç:úü6µ≥<¬∫=”»Jœ¿A“Ω>‹…HŸ—Jÿ’H”Œ>–À9⁄÷A›◊CÊ⁄J‡…=√õÎ∫9Ÿ≠(·∞/Á´3–åŸê*Ï°F√w)…Ä;‚û_ÔÆtÛ∂‚¶p‡°nÍ©sÚ¥yÍ´h÷íIÃÄ4¬j ∏V∫T
+ºVªZ	º`<l<=k<4[.(N%K FA=+! !&," +#2/A)+?#/D%#7&?!3U01W.4Z3/U.(L('I(7T6!
+ 7D3"/*KeHHlFR{QS{VqôvU{VSyRfädX|V_ÑboóuáÆèBkKcåjè∑îDmC:!;"8!"8!&<%%=#(B%+F'/O*KtHL|JK}HWâVTÉUVÑVKvHJvEHtAMyFQ}LPwKIhHNfNWl[qÜuNhOC_F,I3-J85OD>TRÄêùÑë°±ø áï†_l|ü≠∫{åîUdg[ii#/+(3/'!(!?QE>UA0,+28#.I8HeSBbKNpU;d<(Q'A7:;"='B!'E!"BAC%G&0R1,O/5X71U1$H"=952...-.032&6+ !!,!4!!7"#9$4 31-'.1J-B_@FeE>]=9Y4Be;?c58Y*1S!=`*:_)4V$!@)C 1J-0H.%=#552)<&$:#'=&'=&(?%)@$%>!%?",F)$>!(B%&>$-"#$ #$0#M-{C(©Y4ÃqDﬂäTÓ¢hÛ≥sÛøvÒƒs‚∂WÃö+¬ë∆û»§»§ƒù ¡î ∆î ÀôœóœâŒ{—qœk Õl —y Œâ ◊ö”ô
+∆Ç ƒo —n—f¡Y Àk –~Àé Õõ≈ë ¬ã √ã ¿à ¬ç √î √ú ¬† ¿£¬¶ø£æ° øü ¿† ¿† øü ºõ øûø°ø£º£æ•Ω•Ω•π¢∏§º®	ª©∫ßπ¶ª™ª´∑ß≥û™è´ã®à™ä´ã™â©àßà	™ã°Ñ£Ö	ßã£ä¶é¶ì¶ó•ò¶ô®ó•í®ì©è¨ç¶Ö§Ñ¶â©é´î
+®ì™î®çßäßã®é®é©è¶è´ñ	µ¢Ω™¡Æ#ƒØ «±…±«∞∆Æ»¨ Æ ÆÃ≥ŒµÃ∞…¨
+Àß	…ûÕû–¢œ¢“§”û*–è5ŸñRÔµÉˇœ§ˇ’¶˝Œ†˝≈ñ¸ºé˚∑ä˚¨ÉıósÓåiˆúy˝§ÇÛözÊët⁄èr±u]X3##	"#'( )(#					-)&	"!/ 1 1"/%1#- bpcKVFFQAlwg*2%
+	$&0'+5,*1)&!(+ TWL#))8%=P:2E/#6 (*.</,0H22G4#&4%GZG&)(9&.D--E+/H2+G0/I02J24G1P_Llwf)4#/<(.=(&8" 1"5"*<,,A.-D0'@+E^IiÅkKaL7J4.B))@&.E+L^HVeNO]DdnSdhOHL3NS<@I4s~nîüër}o+3$'08='Äj¢†ãNO?/6&$3 2.,'			%!+ %0"&)?(0M.-P(-R'4W/7Y6NlP^zaRnU]w\XpV=V9.G)(C (B%@!?#C&F!"B@@%D"3R0-J+*H&,J(*H&+D&"5"5",F-+G.3O6>ZD8Q>=TB7K/@R"}äBùßDÆ≥=Ωæ?ƒº=À¿@◊≈G≈∞3“ø>‹“L€ÿKﬁ‹K⁄ÿE÷“=›◊Cﬁ”CÍ’H◊±,„¥2Â∏7Ï∫?Â©9ÎßDΩs∞b¬s:‹ì`Á•uÙ∂á˝¡è¸øâ¸∑Ä‰ù_÷åKÀ~6«t&ºa∑SøU	¡W	¿Zæ`	≈j8h82`1'Q!'O&N#KA1##&	.4*,2( .2D,(< /B&"1#/F*0N,7[51W.,U+/U.=Z;#$*5'*5'
+%6&:V=JoMOxPjïjJuHNzIUObå\0Z,XÉXrüxO|UR~Zç∑ì*O-:":""8#05 36%?&'F'FjFPyQXÅ_eåokéxÄ°ådÅkB`FTrVwñvTvQ^~YWpP]tW_sZau\NhKMjL*H.0M7/G9%:5gv}áï†™π¿ï£¨P\lï†≤èù™wÖéJW]=KNyÑà.<=7GD>RG(=,'+"5!":$#<'1L;6SAEfSPtZ>hD*T,C889"="=%C!(G%"D D $F#,N+-P/-S./U0(N)&J&'I$.L*90.../02 4"6. )$2!#4!%8$$7#03 3/,+"9;V5A_=A`>2Q/7U3;Y3<]24X(<a-:a*4Y&3T)-H%73$9&10%8$+>**@)'=&-D*'>$,E($= 'A$.H+'D&'A&&<%"3!
+
+ ""2%S3âQ0≥h@ÃtF÷zG‚ãUÒ°fˆ™nÚ¨gÁ•QŸû8Ãô∆ô≈ùƒ†≈ù ∆õ ƒí ∆í ÀòŒñ—çÃ} Õo –o “u “z Œ ’å	“ê≈ «r —p–h√V …_ –rÕÑ–ñƒã √å …ë¿à ¬â ¬é ≈ö ƒ¢¬•æ• æ•¿§æ† æ† æ† Ωüºô ∫ó ºûø£º¢º§º§ª£∏°∏§º®	∫®
+∏•∏ßπ™∂ßµ•¥ü´é¶Ñ ¢Ä ©á≠ê´ç•Ç§Ä©ä§Ñ	†Ä•Ö¢Ñ§ã•í¶ò¶ô¶ô®ö¶î©î¶é´é¶â©ç´è®êßë®ì©íßç™è©èßç©è®ë•é¶è≠ó∂£º®!¿≠#√Æ!∆∞«Ø…∞«≠ Æ…≠…∞Ã≥Ã≥ÀØÃ¨«†À†Œ•œ¶–¶”°Ãå»Ö.ﬂ°d˝«òˇ‘¶˝Œ¢˝¬ö˚∑í¸¥éˇÆâ˚öyÚén˝ü}˝£ÄÛñuÏñuÍ†}œîrÜ\D9			
+
+		-*%'.''1)!(! "!-)"0)6%6<0:@6",$dneDO?FQ@FQ@=H839/	
+!)'/$'-#		),!BE:'-!'6E07I3"4,%  .!(9'4J30C-	+HYI#"0-@,*B,-F0.F..D-3D1FUBuÄo0;*.;),;(&7$*=*3H9i~oK]M5H5>UAÅòÑó≠ònÅm=L93E/)@$/F*'9#8G2DR8anRPY<BK.<F+:H/XkUÇïÅEVC&5"&2;C.TV@tv`IQ:/;%'9!3J0(;%$7#"5!!2 '	
+%( +,E(/M'/O&2U-WyX]{aeÅjazda{bXpV=V9/J))G#(D"@?!@#B"1P0'F&#B"/N,:\76U3>];6T21N/1J,-A(# " # +(>)*C-/H2/H21I3DWA=M(lz<íüG¶≤D∫√F« Iƒø=”≈H‹ L‘¿C⁄»H€—MﬁÿNﬁ€L›€J‹÷D⁄“?€œ=Ë’H„√<“´(„∑:Â≤?‡û>√{)¥i%»ÄFﬂùk¯ªé¯æê˘ΩãÌØv‰†_’çAŒÉ0«y$ƒpΩ^πTªVø[»f¬d
+¿g	∆r(V'"P#M&N$K"J&L-N!&>!
+!&)"#&$' "+.'(+$
+!./>)++'$"5-H).M+/Q.4S3,D*'$+#,#9R??aFX}[_ä_FtEBp?Eo=UOQ{M;f9VÄXqõuhílPuS49 $<$ 6!2/1 8 89!E!;a<QvW}†àqëÇjÜzwéÑkÅurây_xcRnUXrU`wZ[pQShIUmMKfEMkI?`A2P8)B//D;HXXÇèïëû§KX`t}éåó©ôß¥ú≠µVej9FLràN]d\nnDYR).01#;%'@+6SA=\JAbOLrYOxV<f@)O&?478:;>&H#&H#'I&(J'-Q-'M(0V1-S..Q08Z98V47./..13 4 2+'
+&%3"'8%&9%)<(5$;!!83!9!992P*9Y0>a9>a9/O*#C.Q';_17]*2Y$#I<50!7""4$-"3 )<($:%1G0&<%1H.'?%*C&!;)C&-G**G).F,($
+ ! J/ÉT6∏sJ◊ÖUËë\ÓóaÌõcÔûfÓô`‰ëM÷â1—èœûÀ¢»°«†∆ûÀûÃôÕóÕöœó–èœÖ œv —t ÷|—y »o œ{“Ö“ÖœzÀo —j≈Y …X œh œ{‘é
+»à …êÃî	¿à ∆ç Àî∆õƒ†¬•æ• æ•æ¢ º† º† æ¢Ω°Ωö ∫ó Ωúæ°ª°ª£∫¢∑ü∫£π•ª©	∑ß	∑ß∏©µ¶¥•¥§≥û¶â §Ç ßÖ Æé¨ê¨ê	©à¢~™à§Ñ	¢	§Ñ¢Ñ¢â
+§ë¶ò¶ô•õ¶ô¶ò©ñ®ì©ë©ë™í™ì©í¨ñ´ï™ï§ç¶åßç¶è¶èßê¶è†ä ®í	Øú∏§º®!¿≠"ƒØ ≈Ø»∞«Æ∆¨»Ø»Ø ≥À¥ ± ÆÀß	À§…£Œß
+–ß”¢“ó∆Ö!÷óR˘¡êˇ”¶˝–ß¸ƒü˚ªòˇπòˇ±é˚ú|˝ö{ˇ•É˚£˘°}Ù¢|Ô®~›¢x¨{[Z7!(
+
+		
+
+			
+"(% ) !+"!+ !-&3"'4#+ .%1#ILCJMF%+)U^YKVHU`O?J9MXGOUI
+*-$4:. (!,&5 1-%$%"$1D.+>( (#/#%/& 
+%$7$/E0/E00F/+<)0?,sÄn5@00<.-9+7E4FWGi{mî¶ñÜóÖk|i[n[táth{hizh{âx/>+$;!0G+,)8#8F-Q`CT_AQ^@?M3<N4>Q;CYD%8$"3 4C0'(07?'0<$+:# 4,C)(?%(@&&>$#9"!4#2+#30L&0P'4V1eáfcfa}f^wa^x_@X>1K.+I'(H#'E!A#C#B (G(JhL?\@)F(+J*GfDJiG9X8?^>0M..I*)@&) %& 1 5"$<&(@*-D(8K+Rb1çõN•±M±æJ¬ÕMŒ”RŒŒL“»L÷∆L·œS÷ƒFﬂ–O÷ÃF€”J·‹M÷œ@‹—A€œ?‰—FÏ—L”Ø4ÏΩK€°=µnØd!∫q:¡~Jﬂ£oÙΩáÌ∑{◊ù]»à>∆Ç/«~"∆wæiº^ø[æX√_»i¿c¡k≈v√y!M&R!#M#JFF!K+S4T%/ &+$/4-%"!$
+ +%2 !	
+"'5$-('/$		 *!!*92JeT`ÇjSuZMuRJtL8e:7`6DmE:b=0V1MsNLqO>a@%F'3831"5!#6"6!; +J*-O,<b9R{Q]Ü^pït]ggÉtÅñëáöñg}qqàxbzj]tb[s]@Y<KeBOiBHd<Fd><^;Xy\*F/)@0/@6+75/9;FOXel|ò°∞±ø»ó©≠_qsBQVjwÄAOX8JN#64+"1H6'A(6%=%*C.;XD?^L?`MGmTEnNAiD+Q(&I!7479<=#C'G".M++M,0S2)N,,N-9[::[<IgKGaD)'**+0/+,	*%6$(;%)?()?("9%>*F/N"?`1Ab36Z*Di6Kr=@h4Em9Bh75[*7[-/S%.R"-R,S*O,M :$;!.'8%+<)1D0'=&/E.*B*2J0*D)/I.$A%'D&1N02L/2I/
+	!###	4xO/ØuM—ä\‚îcÌ†l¯¨x˘≤|Ù©rÔô`‡âB“Ñ"—ë–§Œ™…•…£∆û Ã†Ãõ ó —ú“õ—ì–à “~—y ”~’} j  j —x◊Å‘…p œj œc Ã[  ^  j —|ÃÉÃåÕî	ƒç √ä …ï∆ô¬û ƒß¡®√®ø£Ω° æ¢º•Ω§Ωúªñ ªò øûΩ†πü π°∂û ∏°º®ª©∂¶	∂¶∑®∂ß≥•≥£∞û™è§á ßá ≠ê¨í	´ë	™å
+¢Ä§Ñ	¶Ü£Ä
+£É
+¶ä¶è•í¶ò£ô•õ¶úßõ®ó´ò´ò©ï≠ô©ñßì≠ó´ò™ó
+ßê•éßê¶ë®í¶ê§é¢åßë™ó±û∑§æ´!√≠#√ÆƒÆ«Ø«Æ≈≠∆Æ«Ø…±Õ¥ ÆÀ´ ®	…£ ¢À†–†”ù∆å ”ôP˚«ïˇÿÆˇ’ØˇÕ™ˇƒ¢ˇæõ˛≤ê˚¢Ç˝¢Éˇ©Ü˛Øà˝≤à˙≥ÖÓ¨zﬂ¢s¬àb}Q4B/*#
+
+
+
+
+
+
+
+	./)"'5&AO>;H7'4#,(4(LSL<B@3=?|Üá8B:T_Q=H8CK<)/%
+			
+'-#28,%0 "/)!0/+/- #+<)'8% $#$%%( ''8%.A-/B/6G5N\M;I<htj^j^al^lyhjwel{f^mV|ãtesbwÖvjxiZhYtÄr4B1.A+-D*'9#*/>'TbIXfLDR8DS<OaKUdQ.<+ 1!2EVC$$3&6$3 2-2(@&,F)0J-.G*(?#';"'9#"0#",C&3R)1T*@b?]~aa}da{bbzbc{a?X;,G(&E#%G")I"'J"'I$(J)>]>Xv\PlU5Q:+H*0M.2Q1.M-+J*.M-5P/0G+(&,)'#),/)A)-G$0FíRó•M¥¡W¿ÕW∆–S–ŸX“◊V‹ÿ[—≈KÊ”[€«NŸ√I‹«J⁄ÀJﬂ”M‹”H‚◊Jﬂ“Hÿ≈BÎ“T‹∑Eÿ¢B±n©]´^*ªsCŒåX‘õX—ôL î<¬ä+ƒÜ!∆É∆{æj∫[æZ¬]√`»j
+√j¬k≈t¡z¬Ç%O!$N  JFE G#O*U1X#/L $'  $	%- (
+!"
+'.&!'
+'2*->4Vq`?aI8ZAAfG[É`3]7G$9^<#H'7Z:,M."C$#A%!=$5#;%":"/./7*I)0R/3X/<c7NuIOuLX{ZiÜpxèÖzçã¢¥¥oÇ|Zne^qmâúñQgZ@XBQlKC_7E_8LhBKiGUrT'A&2H3) %hp{fm}ãï°éù¢ZllRbbP_bo|ÖÉêôë†ßpÇÑf{vOgY3O6#@$9 *F/<YEEePLmZOr\IpQ9a<,S''J 6046 9"=#A$B *I)?a@2V22V2'I&4V5A`AJgKIaI! "$%,)
+		
+#-;*,?)+B(*A')B$2N&:[,<a-Cj3Hq9Nw?Jv;Eq6Co4;f.9b*5\'-N;.R"5[(=d-@g0>c02S(";.&7$3D1.D--C,)A)0H.1K0.K/-J.,I--J,5O26N4*=)
+
+
+#)#/!+9('5$*)iJ.±ÅY⁄ùnÊ¢sÏ§tÓ®w˜±~¯µÅ˜ÆwÚú_›à8—âŒñÃ•
+À´«¶ƒ° …£À°Àù Ãú œù –õ œò –è “ÖŒ{ ”~ ›É	”n…b Àe “r⁄Ñ»r »h –k“hœe «b »i  w  Å∆Ü ≈ä ¿á √é ∆ò¿ú ƒßƒ©ƒ©æ• ¿§æ•Ωßº§æù∏ì ∑í ªö∫ù∑ü ª£±ö ∑†π•π¶
+µ¶∂ßµ®µ®≥•±°∞û´î©é©å™é©í®ê
+®ç
+®ã§á	®à§Ñú~§ã¶è¢ê
+•ó§ò¶ú•õ®ú•ó©ò¨õ´ô≠õ¨ö¨ò©ï™ò®ó™î
+®ìßí¶ì£ê£ê§é§é•í©ïÆò≥ùπ£æ´!¬≠ √ÆƒÆ∆±ƒØ≈Æ∆∞∆Æ»Ø…≠»™
+…©	 ¶Õ•ÃüŒû‘†Õô)ﬁ™^ˇ–úˇ€≥ˇ‹πˇ‘≤ˇÃ™ˇ¿ù˛µî¸¨ã˚®Ü¸±äˇ∫êˇΩç¸∫ÜÒ∞zÁ•qŒècóeBN45)!
+							
+,-(&%3":K82@/-:)"."".$BKF%.-FPRÉçé$-(GNF'-!(."%		
+	
+	%+"*)#0$3 %4&7$):',=+):*#1"+& ):'(7$	"#
+"%#&!, 1!4!3E5K[NWg\§±ßåòéltghpabkXbnX]mS[jS^l]o|s_lcãòëÄãÖ<I?3F30F/.A+1 24C,5D-$3L]Jl}k`l^$0$- 1!0 /!5 4 20+$:#/I,.K,3N/2M..G)+B%%<"!2&"4M05U.Cf>UwVeÉg^zaTnUWoWC[A5N1-H'+K&*L'0S+0R--O.@aB;Y=Yu\]ycTpZ7S:3P4;Y=8V:.L00O03P1/F,(,022,#((?%0J#Jc*†∂k∞¡cøÃ` ‘a√ÕSœÿ[÷⁄_‡ﬁg“…T‹»W„…X—≥C‡√Nﬁ»P·œQﬂ“O‰◊TÂ÷U’¡FÏŒ^‹≤P§g¨e%∂i5ørD∆ÇQ…ãNƒå7ƒé*¬å√äƒÖ√}ønΩc¬]¡Yø\√e∆m¬m≈t	∆~ƒÜ»ë'N""I F FEH$P,Y"1Y$2	
+ ##+*")-,2	17-		'%0(+;WA>^F@`I`ÇiEjI'L*4Y:;^@6Y9:[<%D%"?#%>(#:&#9$&<'30+3(F$0R-7]41Z00W+2W,KoIUsWÖúíñ®®ö¨ÆäúûäöôEUUL[bvÖåfywUm_5Q85"92F*H\@>R6,8G2%2) >FSNUgmvÖkxÅRbb9IHiwxcntî°™ëù©uÉå'.0DCPh[*F/=;;#2O;CbPHiXMpZIpQClD'P$(K!,	#.1!8#= $A"&H%.R,0T.+O)/S/3U2@_@2H3"$&%
+
+.;*/B.-D*+D'.I&=^/:a,Ho:ZÇMYÑNLy@Cp57e'5a$1Z-T)K*E"=/T!2Z%Cl2Aj0@i11W&831,?+*@)/G/*B(4L2/I,4Q3,I-/L01K.8Q4->+$	#0'6#)8%/@-->++:'+4#42ZC#ûyO–†pÂ≠|ÎÆÒ±ÉÙ±Ü˜≥Ü¯±ÉÙ´tÂïLÿé-œñ…†À©	ÀÆ∆©…™Ã´Õ™Õ¶œ•œ£Œ° –† ”û’îÕÉ –{ ◊x÷pŒa ÀY …] ◊|’Å t Àr —v”u…g  h ŒtÃy¿v ∆É ≈ä ƒê √ïøò ¡°√¶¬©æßø¶Ω¶æ®æ¶øû∂ì ∏î ªöºü∏†∏†≤õ ∂ü∏¶µ•µ¶∂ßµß≤ßØ§∞¢∞û¨ó
+´ë•à £Ü ´ë™í
+ßê®è£á	•âßãüÉ£á
+£å£ê•î¶òßö®õ©ù™ú´ù™õ™ò™ñ≠ö™ó©ó®ñ®ó™ôßñ
+•í¶ì•ì	§í°é¢å£è®ë´ìØó∂ûæß#æ´!¡Æ#¬∞ ƒ∞≈±¬Ø≈Æ≈≠∆¨«≠»¨»™»•	Õ¶Œ£	œ°”§’¶2Á∏h˛—öˇ€¥ˇ‹ºˇ÷∏ˇÀ≠ˇæ†˝∂ñ˚≤ë˚∂èˇƒóˇ»ò˚ºâÙ±|©sÌ¶p€óf´qKd?%D1"+)	
+
+
+	
+
+	"#)*%"!-'6#3D1+9(/;/=H@"-'ENI#.*EQQlvu"*-&!,1*
+
+		
+
+
+
+ ('/ !)"#2!3.!0%3"&7%-;*0>-3A0,:)+!#'")4&"4E5ÖóáÇíÖeuh|åÅåôèÄà}fj\_cRajUcr]ZkYëûó∞ººlwy©¥∏º≈ P\\8J>0F10H.&=# 4#5.?,"3 ARBwÖx?KA#.&!.'/?5$4)!2"#6  7 30.(@&)F'/N,4R04R01O-1L-+B&"5%  $"(@&;Z8W{UaÇcWuYNhMXpXc|fOhR7P31L++I%%H 3U0EgDMkOPlS8T;MfP^wd^yfFbLIgORr[RrZ@\EC_F9S8,B+")%6$"8#)?*'=( 1&.B)2M$qçP±Ã}ø”t»’lŒÿhÃ”a ÕZ⁄⁄hﬂ›n„ÿl÷øWÈ…b‡ΩW’¥IËŒ_ﬂ UﬂÃTﬁŒTÈŸ`ﬂ«YÿØS≠u(©h(≤i4ætCÃÜSŸò^»ç?≈ê&¿é«ë√à
+∆Å
+¬r¿d ƒaøZ æY ƒc»l≈pƒv	«Åœí¬êﬂ±7&L##I GGDI%T.[$1Y%;  ("/"/,@'KdGÖ¢Éwís.  ,2(		&0'%%>(B`HAaJbÑk@eD*R/?dE/R4?`C.L04%=%(?+&=)*@+%;$6%=%5:,L%.S(0Y-3^14^.Dk>LrI^`ä¢ïÑôîbwr3FB<LKLY_iuÉÜî°ÑñörâÅ;[D6U66(%5CQ8\hPFQ@8C; +-xÄçhoÅãî£Öìúm|FVVçêtÖèõßo}àÑíùÅíôìí|ìâ">'%C'/M1)I1#C.;ZHIjWNqYOwU6_7%L 'G '		)*7"=!@(J%-O*.S**L'2O0+ $&',-"0*
+	
+,7)0C//G-.I*7W0;a.Al6OzEQ|GHt?>n44d&/],X)R(O&I,G'D.S /W"5^&Kt:Do7.V"82/!4 -C,,D,1I/4N30M/5R4/L00M16N4:M7		"-+:');%):',=*,?+.=(49"H? Ük@∏ê]’¶rÂ±Í∂ÜÓ∏äÚπé±ÜÒ≠~È¢dÿë9”ñ#À°…©ÀÆ
+Ã±
+Ã± ØŒ≤	œ∞Õ¨Õ®Ã• “®“®“•÷üŒã Œ| …n –l ’iœ]  Z œo ÿÑ”ÉŒÄŒ~Œz «h «f Ãm …r √t …Ñ ë≈ñ≈ôªì ªó √£¬©Ω¶ º•æ®æ®Ωßæ†∏ó πó ªú∫†∫°∂ü∂ü≤ù¥°≥£µ¶¥ß¥©≤ß∞•±£∞†¨ô©í™é®å™ê™î¶í¶í•å°à	©ê•å°à
+•å§ë§ì§ñ®ößö©ú´û´ù®ôßï©ñ≠ò´ò≠õ´ô™ò©ò¶ï	•î®ñ®ñ¶î
+£ê°é•ë®ë®ã≠ê∂õ∫£æ™%ø≠#¬±#¡± √≤¿Ø¬Æ√¨ƒ¨∆¨√©ƒ¶
+«¶»§À¢Õ°œ¢÷©2Á∏f˝Ãîˇ“¨ˇŒ≥ˇÀ≥˛ƒ¨˝Ω¢˚∫ö˛æöˇ…úˇ“°ˇ–õ¸øâÌ™sÔ®pÛ™s„úhº}RsD(L1;7+)/%		
+	
+
+
+
+			./*#$2!"3 ):'&4#*8+NXP'1)%0(&1)/:4<E@%*$"%+0)
+
+
+#""%'0!-4=,''%4! 2)+,*.!2 1#1 )6%$!&!		% ++7)-sÑtsÖuÇìÉnosÖw£≥¶t~s}ÉuW[L]dR`m[hxk∑√√∆—◊Zgpú®¥¬Ãÿuà@PM4H=3J8)?*)<(!4 ':&/B/.hvi$0&!,$(72ë†õ.;2%3&2!411 7$? "@%E (H#,J&0N,6Q01J,'>$&7$*!!+" ," ," *!#-$ ,3M29[8CgAGjIFgHWtXfÄggÄke~hB[>0K**H$&H#/Q,JlK^|b^zcPlVVr\^yhYtcMjVC`LHhSXxcEaKLeO>X?4J3!$0$"5" 6!":$%;&$5"+ &8 %>ë≠p∫’Ü∆€ÄÃ⁄x–ÿq‘⁄p∆≈[ÿ’j€÷n„◊qŸ¡_·¿a‡πZ◊±PÓŒiﬁ∆Z„œ^Ë‘cÔÿn“±P§p$§d$ºu=«ÄL÷ê_Í®tÈ´nÀì@≈í≈ì≈å	¿≈uæf ≈e¡] ƒ`Àh
+«k¿k ƒv	Œá…ä¬å‘ß*‡π8)R*&O%%P#"MIK&W)X!4Z+/ (&5%9ZuR]}VmíivùqÅ¶{$B 	 % % 		"$2#/=W>@^FZ}_7a;2\41Y4-P/9W;"<#*%;&*B,'A(-E-*B(!; -G,&@#(F$-P&3Z-8c59g6Fw@K|ER~Mcâbsì{vì}IgMC\F@QIÇêìñ¢Æî¢Ø£∂ºñØ©BdL4W77
+#7>.hpa:F<>JH~áåáíèô•õ©¥|äìdu|n}ÑRahyâñK[hgxÄáôõoÉÅMeX+G1@^D4T<AcK2T<<]HFgRMqWNvT8a9(M$1
+
+)4"=&F!$G'G )D#&!*!0.. 3'=&1D./A)$
+$-@,/L.;[6LqELvFP|IP|KMyFDs<5e+2b$/]/W*P%L'L(J'L,S.V!7_+Go:?j2=c07,*!2/E.*B(3K12L12O15R42O3*D+'=(,:)	#+#4!&9%(;'-@,0C-5A)>:lZ4¨åYÃ•j‹±zÈæâÏ¬êÔ≈ïÚ√ïÒªåÌÆx€ôO–ñ*Œ†À™∆≠…ÆÃ±À≥À≥	Œ≥
+œµ
+Ã∞Õ≠Ã™–≠“≠—ßŒò –í’ç…w  l ÿs“fÀa Õk ’”ÜÃÜ  Ü œÜ»q ¿d ∆g «p «{«áÀò«õ≈ú∫ì æó √†√ßø®ª§ ª•Ω®ΩßΩ£∑ö ∑ö ∫†πü∑û∂ûµù≥ûµ¢¥£¥•≥¶≥®∞•±£∞¢∞†≠ößí¶èßê®ëßëßïßî¶è°ä¶è•éùÑ£å•í•î¶òßôßõ™û™†©úßï¶ìÆõØú´ò≠ö´õ™ö™ó§ë©ò
+™ô©ó®ñ•ì	ßî
+®î™é£Å©Ö¥óπ¢º™$æÆ%¬≥&¿± ¡±√¥¬Ø¡≠¬Æ≈Æ≈´√¶
+≈ß»•»°Õ°Õ†’§-Ë≤\˘æÑ˛øú˚Ω¶˝æ¨˝æ¨¸æ•˛√£ˇÀ°ˇ‘¢ˇÿ¢ˇ‘õ˝¬äÌ´qÚ¨qÙ¨rÊùhÃà[íZ9I%0)39-(0%				
+%*#! +$0"$2!0/)+-7,#-"!+ )&!+ (0# &&""	$*!,(4<-#0#2.!2./ 1&4# .*"!$'&!
+
+	$%1#(6'$5#ctb9J8draQbPShW|ëÄÑïÖyÜuÉå{R[JNYICOEÑéêáëõS_mâï•ô¢≥t}å_pzj{ÇScc,;4(:*$7#0,?,.@0FWG/.#<MG∏«ƒZe_*6*!2/,3'B#*H&-M(;[4,J$*H")D!,G&0I+*C&'>$$7#& .!,:-+9,(6)%1%)*&<'7T61S..S*0U,=a=``hÑmoàsd}h;U:0K,+I%*L'.P/;^>Yya]zdWt`JgU[xfZvgWtb?\J6VAPpYVs_<XB:V=7M6$(!4 #9""8!'=&*<&*9&"/ +$"&ü∏¡€ë«⁄à—‡Ö”ﬁ~◊›{––n—Ài‡ÿv„÷vÂ–s◊π_„æf›µ]·Ω_„∆bÊ—fÛﬁuŸ∑]üp ¢e$µo4ÀÇKœàTÊ§rˇ¡éı∫ÄŒïFÕò&Àí≈Å√t √h ∆f≈c …gÀi∆i¬p–Ñ–äƒÉº
+Ÿ•+‰º9·º7GqIHsHLzL8f5%Q M*[#,X#7"!	&4LaBIe=lêdkífà±Öcç]pöhFl;:
+	-2,
+
+		$0$*$:%9S:Yz]5]8:c;0S2>#=$(/(>')C*(E)*G+.H+.H+9:+K$.T%5_-Am:?p9Fy>Cy=IzBP~M[ÑZPvM9^2Dd?_vfê††guÄ•µ¬¢∑∫mãÖ©çAgB4S1-
+$,8.<IBirqemp¢¨∂ñ¢Æqäl}ánârÉçWiuvàí*=C2FE>UM9QC-F1@\E=_GDgQ=^IAcKIlTNrVLtQ?e@+M((
+	 
+!09 >=3!	 )/'>$-F)&A""=)F'5P1/F)+% ".+E*DcAKpDKuCJtBTÄMYÖTWÉPSÇK6f*/_!%S%M%K#J&M)O*P6^*Ai5:d2LvDJu=?e2"<)$,,?)/F,4L20H.0J/9Q77O7." #'-!4 (;'-@,0C/3E/6?"NAìxIƒ°g›µwË¿É…êÛŒôÙÃòı óÚ¡áË≠i◊ûD–£&Œ™…∞»±	∆Æ…ÆÀ≥Ã¥Õ≤	Õ≥ÀØÕ±“≥
+”¥—∞	 £ …ñ ‘õ◊ô
+œá»r œo –k œj Õm Õw ÀÅ œçœí—í…~Ωi ≈n  u…z√Ä «ê»ö∆öΩî Ωë ¡ô√•ø¶º•º¶ºß º¶º§πü∂ú∫†µú∂ù∂û±ú±ú≥üµ§µ¶µ®≤ß≥•≥•∞¢∞†Æõ•í£ç•è¶ê§ë¶î©ó¶í†å	£éßíûáúá§ì•óßô®úßõßù©°©ü©õ©óÆú¨ô¨ô¨õ™ú™ù´ö™ô©ö©ö¶ñ•ì	¶ï	•ì	ßì©çüx•~±î∏¢∫® ªÆ$¡±&ø≥#¡≥¬µ√≥¬∞¿Æø´ƒ´≈´ƒß∆•
+≈†…†
+…ü“¢$·¶JÏ´k˙µéˇ∫°˝∫ß˙Ω™ˇ«¨ˇ–≠ˇ”ßˇ◊£ˇÿüˇ—ñ˙ΩÑÒ¨s˘≥xıØtÌ¢k◊è_´mHT(!#&2:-.6+	$$)"'/$,7)/:,*7&#1 -#1 $1 %2!&1!7B2:E5*(%2 +6%!)	
+	 ! ./)894 ""*%% ("0+%/*00--*""'('
+	!+9*)<)$:%':&"3 $2!.)>-Yn[áöájxgsÄn~âyfqcR\Tu|Ç{Éêpyäëô¨çî¶QZi,:EPai≠ªæ6EB!1$2!4 3 4G4(:*0 /$\kfxÑÄ|Ü~.9+%4!.-4(A#'B!=+I%8V0@\63K+(?")B%&>$#: $7!&7%,=--=0,</*8+!/"'%3$'=(2L12Q/1T,2W,8\6_~_fÇkiÇmc|f9S6-J+/N,8W72S4BcH[{d[xdXucJgU\yg\ygc~oYvdLiUSpZVs]>ZD7Q82H3!"!4 !8$;!(?%.A+);%(7$(5##+!" ïÆu¬‹ì ›å“‡à’‡ÇŸﬂ⁄◊x“…j‡”sÁ◊xÊ—t›¬gÁ¡lÈøi”™PÂ√bÎ“mÈœn£z(õf ∞s4»ÜJ◊íY‹ôbﬁ†mıπÉÒ∑xÃí@Õî#ƒÑ√x¬l ¬b ø] »kÀpÀp…s’à”ç¿É¬ä‘ú%⁄®+·ª6‰ƒ;MzSSÇXL~MIyG%T "N*Y"4\*"=#!	"
+1; )Le;zök[Qwûqé∑èrõsWÄTê∫àcêU$K.	,.)
+$0"'=(=W<BaB2Q2!;"0-1,B+,F+(G(%F' ? #@!"=#>)G!.R&,T 3`)?o5H|>JÅ>IÄ=JÅ@RÜFNÇD;m07e'NuFYv`Éôóé†Æ¶∫≈ÄùôEhRMvNOyI>c7.
+
+)#$/<2^h`|ÇÄmv{wÅãnzàéõ´Åë†ö™∑è°´è£™PehF_YLgV6R<+B.AZEEdRDfUIlXLoYHkSHlPHmKHlH2Q/+
+"
+	%	*
+39+ 9/J)5S17Y47[79_8;a83Z.4Y-0U*+K$:0 :&A 3P1B_@FeC;`77^/Bk3Dp5Kv>_äTZÑRUMXÖN4d(,Z)W(U)S'P(Q(P+S8`.PzJS~PTÄOJu?7\)*B .'(#4!2E/*=''=&-+>* 1!"&*/%8%,A.2G41D0/>'>? pZ1´áSÃ§g›¥rÊø~Î√Ö»çÛ∆çÙ√àÎπt›™Q“§4œ´Ã≤…≤…≤
+…Æ»´À∞	Õ≤Õ±Ã∞ÀØœ≥
+—∂“∂–±	«° ∆ò —õ–ò”ëŒ| »j  j “rŒu  x  Å …ä ŒòÕô«åæy ≈v …u∆r √t ¡| ∆ã«ó¬î∫Ü πä ƒ°√ß¿ßº¶π£ ∏• ∫§∫¢∏†∏üµú∂ùµù≥û≥ù	≤û	≤°	µ¶µß≥®≤ß∞•∞¢±°≠ößí¶è•éßê™î
+®ñ¶ñßï£ëßî®ï¢èôÜ£ï•ò§ò•ú¶úßü©°©°©ü´û¨ù¨öÆöÆú≠ü´ü®õ®õ©ú®õ©ô¶ñ®ô®ñ™ñ©çùx†|Æì¥†π©∫Ø"¿≥&¿µ%¡µ!¿µ¬µ¡≥¿∞ø≠¬Æƒ≠√©ƒ¶
+ƒ°∆° ¢—¢⁄°8Èß[˚≤Ö˛∑õ¸æ•ˇÀ±ˇÿπˇ‹πˇ◊¨˛“°ˇ”úˇÕì˙∏~®n¸∂z˙¥xÛ®o‹ïaΩ}Qh:! 
+.4*.3,
+
+
+	
+
+-5*19,(%%#! ("*'2"ITCAN<-:(*9&(:$*<&)8#)% &1#"*%"%<>;imp_cdchb.6+#(!/( &-$2!$2!"0#1"!-$$(+' .+@-.H/5O43J0*='(*$2%.?/ctbZkXTcP[hWo}pq|vÜçìöû™èï•®Ææv|ä9BK-;>"21{äÖbrh!1$ 1!"5"0 5"2/ DTJâîêw}y`h[3>-%4!+-"9$;4!:9R4:S37O/0B(&8"(;%)<(#6"':&.?--@--?/):*)7*#1$$2%#3&(:*(@*-G,2Q/3V.6X3a~bhÅkiÉjNhM3P11P.DcCXwXIgM_|fbkb}la|k`{jVs_\wdiÅqjÇrMhU]ycPlU=V@0F1-((;%"9$<"+C)-C,+A*)<(*;((5$$#!Äó_¡Ÿè…€á…÷z–⁄y‘Ÿs⁄÷r–«b–æ\ÊœoÂŒp‹øc”ÆSÈ¿d—¶GŸ±QÏÀj¡ûDòj´v0ªÜB…íQ“òY‰©oÛ∫ÖÙºÅ·•\“í8Àâ≈~æn √m ¿e …nÃvÕyÕ|	’àœÜ»áÃò"‚±:”ü%‘§$€π1·∆9QXN~TJ~NJ|G;l5"O.[$0T(2
+
+	@K-BP,EW-Lf7bÑQhé[U|M}¶zëªìeègdäaê∫àeñU%Q,	 
+ **)#6 '?'(#, .1B/4J3.H+-L-+M,0O-5S14O,:V03Q+/P%/U$3['=m3Fz:LÉ@NáBMÑ@LÉ?E5?w.?r-Q|G]fä£üì•±≠¡Ãë∞®;bGDmADo:Fm>< 
+!)!/ $4'2@3FRDhri:DE8CIü´πyÜóÇë§ê†ØcuÇóöOjeJh\MjT*F-%=';R@=\JAcRGjVMpXAeIGlK7]85W42O0$
+	%.$:%'?'(A$%>!"; :#="<">)G!2R+4Y.7`44_41_14`/4`+1]((S,S$4X,=^3?^5>^7:Z31S.;`5Bi:0[#:f':g&;g*[ÑLXÄLOzE;h1)Y,Z*X*X'S)U,U)T1\'7a1PzLTQKwD=j1(N6%4! - ,.!2,(%#$)+0!4 *=),B-,A.0B,8B)OK(ëvG¡öaÿ±p‰ºwÁ¿}Ë¡~Áª|Á∑wÁ±kﬂ©S’•7“™'Œ±Àµ…¥…≤
+ Ø
+…¨ ™À¨Œ≠œÆ	À¨ÀØÕ≤	œ¥Œ≤	 ßÀ°—†∆ì ÕêŒÑ»t …p ’}”ÅÀ~ ÀÇ …ä …óÀû ò…ê∆É¬v √o ≈q ¿q ¡| …ë≈íæÜ ∑É øó√¢ø£º§ª•∫§π£∏°µù ≥ö ≥ö ¥úµ†≥ü∞ú±†≤°	µ¶≥•≤ß≤ß±¶±¢ÆüÆõ®ì•é¶è¶è®ìßñ
+ßó•ï•ïßñßñ•î£í£ñ•õ§ö§ößü¶û™¢™¢™¢™†¨ü¨ù±ü!≠õ≠ü´ù™ü™ü®ùßú¶ô¶ôßö©ô™ï®å£Ä
+©â∞òµ£∂´∑Ø∫≤!øµ"¿∂ ø∂ø¥√∂¡≥øØ¿Æ¬Æ≈≠√©∆•
+«§
+ •Õ¢‘ù)„£LÙ´x˛∏ñˇ∆®ˇ‘∂ˇ€πˇ€∑ˇ”™ˇœüˇŒôˇ…ê˚¥|Úßn˙¥x˚≥xÛßmÊõdŒäYÉR*,'"' 
+	
+
+
+).''3;0#&!#+)2!EP?:E4)6$*9&*<&(;%'9#!."-)1" ( +%2!!.&3""/$,3,fjkÑâèOTXEKG.5- '%2!#1 *#"&4#,;(#2#0&2$!-)&(&"'-B18Q;C]D8R7-D*);%"!-!)-;,uáqYkSP_HN]Jiyl°≠©êóù∂∫≈∫º…®¨∏™Æ∫ãíú=HJ-<9ERK>KA$2%#1" 1.-1-!tÖ}àéåèîéNTF2>*/+!8#72/';"2F-.E)/C(,;&%2 (9'):(&7%):(0A/.A.*<,&7',:--;.,:-%5();-'<+71N/6X3>`;`}akÑnSkQ9S6.M+7V4SrSeÅhgÉljÖrkÜukÜukÉse~k>ZDWs]nÜv_xe=YBSoVUrV@X@5H4"%3",B+'@#)B%4M05M35M52H10C/.=*&!!ezAØƒwæÃt¬Ãk»ÕgŒÃe— `—√Z»≤L›ƒ_ﬂ∆a–≥O…£@ÁΩY‹≥J≈õ5ﬁ∂Vß~&¨|0¡ëIœ£\ÿ≠h›∞m€´mºÄÍ≥p÷òCÀä&ÀÉæq ∆r≈m  r–z	À|ÕÉ
+–à∆Å
+ƒÜ ìÂπ@⁄Æ3…óﬂØ/‹ª0›¬3IySGwMI}MJI>q6&V6a,3S*
+7@%EV,=U#?]']ÄJ_ÖRpójgçdÅ™ÇÇ≠ÇLwLnîkå∂ÜWàFLz:*I  	
+
+"*'2$$+'
+(#/!&7':M:1I1/I,2O14S15S/4R,5Q+2N(.I&+I%#A8[1Ep;K}@LÉBGÄ<D{8KÇ>KÖ;G6@u1O~H\aïØ¶û±∏¥«Œûº¥CiP<e;Dk<Be;0K*!&##(*<,)<)2D63B;%36ÉëûR_rÖî©õ¨ºVip\roVth7XCMkQ)F*#;#:S>@`KEfQEhRGkQCkH.W/#H(H#(@&!)(=,5L:6R<2P6-N1-N/)K($G#C!@ ?8>%E.Q'/T).U)0Z,4`/2a*1a'-]!-]!1^%4\(5V+,H"82%@JjALt@Jv;9h$6e:f'Eq6XÄKGr=Am8Eu;8i()[*[&T)U*V(U0]&7f2XÜUXÑQYÖP=j//U"4-&2$$0",)'#%!((-!2$7#(;'0C-5H47E,AD'j^8©ãWŒ®jﬁπuË√}Î∆ÇÎƒÍΩyÊ≤g‹£J—ò-—¢ œ©Õ±Ãµ…≤»±»ØÀ∞ ©»•œ©Ã¶ §…®ÀØŒ≥
+Œ¥	 ´ §Õ°«ñ  î Ãç »Ç  { œÄ –ÉÀÄ »Ç  ç  ò…û…û…ö»è¡~ øs ≈q ƒp ær √Ñ ê
+øÑ≥} Ωé √õΩüª°∫¢ π£ ∑° ∂ü¥õ±ñ ≤ó ∂ûµ¢¥§	≥£≤£
+±¢	≥¶≤ß≤®∞¶±ß∞§∞°Æûßî¢å®ë¶ë§ë®ó©ô•ï£í•í¶î£î§ó•õ•ù•ù¶ûßù®û®†´£´¢©ü©üÆ°!∞û ®ï¨õ≠ù´û©û©ûßú¶ö¶ö£ó™ô¶ë¢à¢Ö®è≠õ±¶µ≠∂∞π≥ºµ¿∑ø∂øµæ¥æ¥¿¥æÆ¬∞¬Æ¡®√§∆£	«§
+Õ§Œõ‹ù>Ï§i˛∂êˇ∆§ˇ—∞ˇ”Øˇœ©¸À£˛ÀûˇÃöˇƒé˜´w˘©tˇ∂}˚∞vÛ°gÏõcŸíZõg8C**%+/)4&
+
+
+	5=2 ++3(#)!&$-T]J<C1!(#.(7$(9&%6#&5""/(3"&1 #2&7$%6#'8%$5"+9*Ze_zÇÑnsy<AGHMP*0,$)1$($2! 1-.*9$1@+&3!%2 &1!&1#!,($" $,E2A]GKgQ;S=2%6#+ ,'=L9tÜlfy[XhKVfLao`≤ø∏¨≥πµπƒïò°≥µ¡∞∂ƒ¬ ◊°´¥alpKTS&/*$0$'5$$2!!2  33 0#çûîäêåwzsDL=)6$,/.B)"5.*+#4!-<))8%"/,!/ .<--;,*8)):**;+$5%#1"+9,2@3.</*8+*:-#5%30M.=a;W{WcÅggÉlWqV5R4-O,CeDcÅglàqmÜqlÖrkÑqjÇrd{ke~kOkUQmWeÅkRpX=[?9X8;X9=V9(;' /,D*(B%,F)/I,5M34L2/G-0F/,>(-%&J[$§µg≤¿_π¿V≈ƒZƒºQ¡∞D‘æQ…±CŒ≤D÷∫L–Ø>∆ú,—¶5‡ªH≈ü0∏ä*®v!¥Ö7ªëGÕ´a‚ƒ{Á ÑÁ≈~Óøy“õIœë,«É∆x≈qÃr»n Àt {–å‘îœèƒä∆ñÿØ1Êø@≈ô√ç”† ’∞$”∑'AoJL|RI}MH}GLD2_&>d5(			GR2<Q&?[*Z}G]ÖPcä]â≤àz¢}Å™Çw•wKvH`Ü]ä¥ÑaëSYáGMn? '#0"*-8*1B07M83M40J/,I-&C%,G&1J*%=%=!:4%3Dg=LvFKzD4e-Dv;PÑDRäCG8=q/KzDSxVa|kfxxë£•çßûMjV.P-3S,:2'+& #'<)/I0)B,5L<)<8ivÉé¢ë†∑ö´Ωáú°?XRHiX1S:,J.!> $>%@\E:ZC?aIIlTMtU@iA&M!'G /(-!2 ,?,4K75Q;5U>9[@;`A0U3)O*'M$"GEA>=@ C&K +P$/V)3]-/[(-Z#.[ -Z-Z+SC;*
+$77L-:R.Kj@Ms@Gs8<j)6e!Ft4XÑIT|GEp;RHK{A5f%'X#T$U'U1_!8e*Ap9Ap:HwAN}FHu<?j20T&0#1 ". $0",)&$'"(). 3%8$/A+1C-4F0<F-OL-~mB±í[œ©h€πr‚¿xÁ¬{Ë¡vÁ∏jﬁ´P◊°5”†!—§Õ©œØŒ≥Õ∂Ã∑Õ∂Ã≥Ã©»† Õ•»† »¢  © ÆŒ≥
+Œ∂À± ©«† »ú –ü—õÕêÕà ÕÉ Ã ŒÉÃà ç ñ∆ô ≈ö ƒô ≈íƒä¿z ¡t √q¡q ¿| ∆ä¡Ü≥} µÑ ¿ìæöºü∫†π°∑†∏°∑û≥ò≥ò∂û∂£≤§≥§	Ø¢≠†≥¶≤©≤®≤®∞¶Ø£±¢∞°™ôßë®í®ï
+®ó¶ñ•ï
+§îûç	¢çüã§ï£ñ•õ¶û§úßü®ü®†®†™¢™¢™†©üØ¢ ∞û ¨ô≠öØü¨†™ü™ü©û¶ùßûßû©õ•í°å•ê©ñ™û≠¶≤Æ¥∞∏≤º∑æ∑¿∑øµæ¥Ωµøµø±æÆ¿Æ¿©¿£	¿°√•	»§Àü÷ù2Î•`ˇ∑äˇ∆üˇÀßˇÃß˚ ¢˚ °ˇ ûˇ ô¸ΩäÌ§q˛Æ{ˇ∂~˘©nÚô_Óò_‡ò]≥~HT8923;$3@. +
+
+	
+'2$)5'"* "!%' % +;D3^gTOSB+/&*(6%1?.(7$'6!'4 (5# 1->.4D7+;."4$ASCiynvÇ~zÑÖs{~}ÇÜ9??)0(-5(*"/,+!03B-8G0%4# 
+  &?,EaKSn[4M8!4!')&"'S`NM]BTeEWhH?N1\jSçòä±∑∑Ø≤∑ÄÉà≤∂øΩ≈“£¨Ωr{äØ∑¬§´±CLK,6-'3% ./ 3 8",C1áúç|Ü}=E:-8(.+)<&#6 1&#!-!'1&$/!!, +&2$2@1)5)- *,+%3$.<//=0+9,+9,.</ 2"57T5CgAY}YhÜjfÇiQnP4S38Y:StWkápmÜslÖrg~lpâvlÖr^wd`ydWu]_}cLjRB`F;]<9X66T28Q4 1
+)<(3K14Q33P23P2(B',F+8R78P65H2(:$--,=î•W©µQ≤∏Jæ∫L∏´;¥û/–µDÃ±>πû)–≥=“≤9œ®/πë‹µ>Œ¶5™|©y$∑é>ƒ†RÕ≤c›∆xﬂ≈{„øsﬁ´XÃë3Ãäƒ{¿k «l…m ŒtÕ}–â◊ö–ôÕó ö”Æ,Ÿ∂4ÿ±0¬ï≈é»ë”¨ –∞IvON}SQÇSK}HDs<0X$:	$!('+(-",;J+:M-ZvP|†t[ÇVtösä≤çÑ¨áy£{löiWÖTZÉYÜ∞Çmúeiñ[Ho: 
+	". (!''-3>-2F-0J/5N81M62K5*C-#;%"5!
+$#4".
+	.F.8U7OqNA3]/YàRKÇ?H;7i,>j5PtNFbI/#(!*:0/A3#4!# 	"*,+/78Z9EfG9W?.D7Vaeîõ´ü´¡°≤ƒò±µ?]U8YF4V=!B%:%A(9U><\E<^FDhL?gEGpH+Q(*E$!/$7$-E/3O85V;2V:4[<8`>1Y6(Q)!J  GDC<>A?!H%O+U%-Y&+W$2](6^)/W"B!='<'7!/'5K^>Mh?TtETxHmì`\àM0^Cq3Iv;It>N{DRÇH5g()Z%V$U&W)W8e*MzAUÇKVÇM=j1Du44b$7[+'B+'+*!,*%(#$"&+02':&0C-1C-7I1AJ/WQ1ÜsHπô^‘Øi‡æv·¿s„ºq·¥c◊¶I÷£6”ß$—ßÃ£»¢À®ŒÆœ∏œΩœ∫Œ∂Ã©≈ö À°À•Õ¨Ã∞Ã±À∞Õµ
+Ã¥	Ã∞…®…£ üÃû–ö—í Ñ  } “Ö—ç ç≈å «ì≈ì ≈ñ¬í ƒë¡áø~ ¿s ¿p ¡y√É≈åπÖ ∂Ç ∫ã Ωïøû∫ù∏†π¢∂ü¥õ ≥ö ±ñ≤ö≥†≤§≤•Ø•≠£∞ß
+±®±®≤©≤ß≤§±£∞°¨ùßïßï®ò®ò•ò§ó•ò£êüáùÖ§í•ò•õ•ù•ù¶û®°®°ßü®¢©£™¢´£≠†Æú ´ó¨õ¨û´ü™¢©°®†®ü®üßû¶ù®úßö¶ö®ü®£©ßØÆ∂≥π¥ª∂Ω∂øπæµΩµª≥Ω≥¿≥ø±ø±¿Æ¿©ø•æ§	ƒ• •—†)‰£Q˚µzˇ¬òˇ∆°ˇÃ•ˇŒ¶ˇœ¶ˇŒ£ˇ∆ò¯∏à˜¥ÄˇªÜˇØyıöcÒêYÚó^Î•g≈ìXnQ';05:#3B-,9',7)&+7)(0% &$!#'")&3!JVBT]HZbM+2 %')7C58G4)8#&3!&3"+9,AQG`olYheHXNgyi`s`VhXZj_htp{ÉÖIRQ:D;'2$$1 !0+-0?*4C..%"$'$&=+EaKMiS3H7(+(%*!,FNAJV@BO3N[?HU7ZeEÅÜo∑∑≠¨¨™`de°™ØΩ∆’Ω»⁄al~GPapxÉ_hm8C=&4'+<,$7# 6 80H0JbLVgU'-+!2&8""5);%&
+$$.#/;/&2&* ((&*&4%)5'(4&'5&-;,(6)/ 6!3P27]6EkDiàiRpT8W73U4GhMcÉknâvoàutçzazgwé|mÜqOkTEcG@cCKnMOpQ=^?<^=2Q1.F,*=)%"6I38P89S81N02O30L35O68R7>V<3J0)=$!30- ~êFõ™E´≤BµØ?≤¢1Æí$¬¢1 ≠8ª°(»Ø1“∂8ÕÆ/∑ìƒô&…ù2ÆÉ$¥è6øüJ«≠Y’ºjÿΩnÿ≤g⁄©ZÕì2Õä! ~¿n ƒi «j ÀqŒ{‘ä”í◊û»ïŒ°"À¶$ ¨(—∞-«ûøé¬à
+Ãñ‘©œ´N{TO~TL~MNÄKHwA6&%&)-0.A%7G*2A":K+,@,B9R2eÉaû¬úú¬õ~£ÅÖ≠äbåfu£us§m@o9WÅSá±Éz¶s`çVPyA6
+ !	
+
+&1#!)&,-1"3<)3G,2L/0M17S:3O85M75H54B3 *+5*/=0&4'&2!9!9#HWÉPOÉCH|<3_*6
+0P+0%&+5*-8*$&"5! 6 73(B%3W34Z55V7/H3alhu~Öù´∂•∑¡Çúô@^R0Q<5W<=": (D-?\FDaKCeLEhJ@eCJsK.R,%@!&(0!7"&@'1O54W98]>9a?4^:4^8#L$G#J!F D; A"F&K ,S&.X('Q!-Y(1[)0Z(4\*8^-2S(-&)%0*6 3F(XsJVwHPtFZÄOTG1_!@n.;h-R}GWÉNGw=.^ $U%V(Y(Y-[.[ OzBfë[céX\âN@r-/[8/(%"'&!, ($"#"!+.%6#)<&0C-7I3=L5HQ6_V5ì~Qæ†b◊µm‚¬u‰ƒqﬂπdÿ≠N”•6“ß'“Æ—Æ»§ƒû …£œÆŒ∂Õ∏Õ∏Œ∂ ß¬ö »† —Æ
+“≥–¥Õ±ÀØÃ±Ã¥	 ≤ Æ…®»¢«ö Àó—î Ü …| À~ ÃÉ Ãâ≈Ö ≈ä √è ≈ñ≈óƒòƒñªÜ ∫v πn ∑o Ω{ ∆ç¿èæä≥Ç ∫ç ªï¥ï µõ ∏†µû ∂ù∑û≠í ≤ö±°±•±ß±ß∞®±©	≤©≤©∞ß±¶±¶∞§∞§™û¢í¶ñ¶ô¶ö¶õ¶õ¶õßó¶éüá§í•ò¶ú•ù¶û¶üß†ß†¶ü®¢©£´•≠• ≠£ Ø†#Æú ≠û≠°´¢´¢™¢®†©†ß†®°ß†®†ßü®†®¢ß§®®∞Ø≤±∑¥∫µº∑Ω∑ªµΩµª≥ª≥Ω≥æ±ø±¿∞¡Ø¿¨¡®¡¶ƒ¶Ã§!⁄†=Ó™c˙∂Ö˛æòˇ §ˇ–®ˇ—©ˇŒ£˛≈ò¸æèˇ¬êˇøäˇßsÒê[ÚçWıõ_ÒÆjŒ†bâi:I;7; 7F//>)2?-#+	! '3%$/!#%*# $) +&'4#AN<KWCP\F`jR@I4/6&"*&$/!>K96E2)6%'3%7D;m|ylykx~WfaQaTK^HSfPUfTM[NWb^NWT=G<"/"/%4!.=(.=&0?*)#$!"&$,(1 *'<+JcND`I2K6/*(!% +
+4;+5>)2<$/8PW8{dpo]vvlCLGéúù¨Ω«√”„ÆªÃß≥√°≠πcnr/<5+9,4E5%8$#7!8#;!7O5I_H9L8-+0!3(;%7I3&
+ '#-$$$$"$+ .++#1"*8)%1%+.< 4X2EkDcÇb?^?3U4EhHfÜnlâslàr`|fci]ycqäu`ycDbF<^=9_:NtOIkJ?^>>[<0J-(;%'5$)""#-3I22L10M12O36S7@\EE^H=W>4L2-C,&=#%9 "50gx4ñ§C¢™;Æ´:µ•4™èªú(≈´2√´-π¢  ≥/Ã¥0 ´,≠Ñ¥â ≤é-∑ò=√©R»≤]”∫j◊∑j€∞aŒñ? â!œÜ≈sƒl ÃqÀqŒy‘Ö◊í”ñ ìŒû «†√¢¬§ …¶$∏à
+¡â∑} œñ∆îƒñO}VL{QSÖTHzG;j6@!C/N.,K)0P+3Q-1O)SsLeÖ\^TQrEW{M?c5]ÇVbá\qónÇ™Öy°ã≥êÄ≠ÇnûjcïXK{=PzHå≥ÑÇ¨|tüjO{@	* " ! !#%(0!,3#78(8=)8H.7R34S1-O.4Q38P6=N;=I;:B75=23?1,8*($)+"3!#;!FjDQÄLI|A@q9)N#'(2H1(# &0%=K</E.%?$ : :!9'A$:\90T./Q0/I0ctdMZQVie=RKE]O9VB9YA,N3%F+;#)E/=ZDIfPAcH=`@/U0>g?8\8*D'4*1": &C'0N23T79\>7_<5`5(V($O$%N"'P$#J!E?#C%E'G "E-R'.U)(R$3]/4^.+U#/Y'7].%C.$#/>'YuO_ÉW^ÉWGq?>j-6d#6g%=m/TÄKS}KEr;7d)*X*X,]*[0^7e'Dp5_äRaéUPÄB>p+@i-,	)*'$"!)&"( &!  ! #.);%/A)4F.<K4BQ<JP6a[7öàXø¶f”µl€ølŸº`÷≥M—©8–©(“≠ –±—≥—±À©	»§«¶ ≠…±Àµ
+À≥	 ©√† À™–±œ∞
+Œ≠Œ≠Œ≠Ã≠À∞…±…± ≠ ©»ù¿å …å Œà  À} »z «| «Ä «á«ê ƒñ√ö√ú¡ú¿ñΩá∏v ∂n ∫s ∫Å ¬ç	ΩãØ} ∑É ªå∫ñ πú∑ûµú¥ö ∂ú∞ó µû≥£≥¶∞¶∞¶±ß∞®±®±®±®Ø•∞¶∞¶Ø§´†•ò§ó§ò®úßú¶õßúßõ¶ïûç£ñ•õ•ùß†¶°•û¶üßû•ú£ú®†´£¨• ¨£ ≠¢"™ü≠† ≠£¨¢≠§¨£´£©¢ß°ß¢®¢®¢™§©£•¢¶•¶¶∞Ø¥≥∑¥π∂π∂º∑ª∑ªµª≥ª≥Ω≥º≤Ω±æ∞ø∞æØ¿¨¿©¡®»ß“†/ﬁ†I©q¸πèˇ §ˇ”¨ˇ“´˛Œ¶˝ üˇ…öˇ∆îˇ≤¸öiıãWÔäR¯£cıπq—¶búxF\I!;>!;I00?(3@,)4$	&+!-(#-"!)#+ $,!!)%0 6E2ET?KXDNZD^kQR_ES\G;D3&,&.+8';I8*6(COC;HA4BCgu~sÇâvÖÇO_RQ`Km{d8E1$1+6(?I>2=-$1!.#2,:#0=)!.$$$"   #%-"!)! " %:'G`J=Y@2K5%:'$$## 690),#/3xzbjlT_dP?OBFZXvçì∂…◊∫ Ÿ¨∫«®∑æö™™n~t,!2 $7#&:!1%1G2:R:*@+.,!2$6 1D.);%%
+
+	
+"(*,,+!-!"." .++&@'6X5PtNdÉc<[<EfGaÇepçwuë{b~eJhLHiLiámmâpSoV@bA=a=:^8EiEGfF=W:5L2+>(,:)-9+%1%")&&" &%6#1I/0M/1P1:X<JhLF_IJcMG`JE_F3K5&>&"8!#7%:Rd&î¢Jù¶=ß™9∞©4Æõ%®í¡≠0√∞/≥ü√≠&«≥, ≥1¥î™à¥î1∫†C«ØYÀ¥dœµj◊∂i÷™S≈ç,Àâ≈z∆p∆n «q Œz◊à‘äÕá ä–ö √ó√ù¿ù√ûæëºÑ±s ∫~«åøÇ∫} KyRPUM~OOÅN?o;>l;6_3@g;JsGV}PUzO\ÅV\ÖY^á[gëc_âYaã[^àZfêbÅ™~vüw}•Äoóuà≤åx¶w]éVNÅ<At/Iv?\ÜV|¶vw£nKw:#H "##$'/6&>?1<A-K^B_}YNsH8a55Z1-K)1H.,;(-8*08-0;-*6(.9+#/!'5((6)+9*/B.4S1T{O2\,6[/)('9L8&<%/&	
+	
+,/G/2O3(E):3< <[;>`=.P-(E'J`IATANcT":*FbL/M58Y>*K0<ZB:#*F0<YCEeMAdF;_;$J#*P)6Z67$:##5!4!:-J,0M13R35V7>d?2]2/]/%P%-V,(Q%'N"*J!$C#A&B&A$?+I%<\74Y0,S'-W)+W&.X&/V'+N&7'(7$UoLZ{POtIEo?Am27e$2d9j)SÄIS}KIv?Dq6<j*1_-_._8f&P}BDo7\âPUÇG6d&3_"0U"(&$!!"'$*$"(&#$$$"("/)6"6C/2?+=H7IM6dZ6¢é\…∞n’∫k’∫_”∂P–Ø>À©-Õ´#“¥"‘∂ “µ‘≥‘±—≠Àß	 ™	ÀÆ
+Ã¥À≥Ã¨	 ©ÕÆÕÆ≈§ ¡û »•À®≈§ ≈¶ …Æ»∞À∞ŒÆÃ§¬ê ¿Ü …á …Ö ÀÖ…{ øp √x «Ñ∆ç ƒï¿ó¿õ¿ü¬üƒóΩá∏x ∏x Æw πá∫ä≥Å µ~ ¥ ªíºù∑ù¥õ ≤ô ¥õ ≥ú∂°≥•±•∞¶∞¶≠§Øß±©	∞ß
+∞ßØ®ÆßØß´£™¢ßú§ô°ò§õ¶ù•ú¶ûßûßõ°ó•õ§ú•ù¶üß¢¶°¶ü§ù§õùï¶ûßü™§≠¶!Æ•"≠§#≠§#≠§!¨§¨§¨£¨§™£ß°©§®£®¢©£ß§¶£•§¶•Æ≠¥≥∑¥∏µ∏µ∫∑ª∑∑≥π¥∏∞∫≤ª±∫±ªØΩ±ΩØº≠Ω´ø®√ß °!“ù5Ê£\˙∏ÑˇÕ§ˇ÷Øˇ’∞ˇ‘≠ˇ‘™ˇŒ†ˇªåÙ¢r¯îbÒåTÛóX˚Æhˆæq÷¨d´ÑMgN%@? :G-9G04C.-:("**!, +NXM@H;2:-!)#. 4A/AP=^kZT_Ngs]WcKkwaKTC7=/28*%0"6B4+7)HTJ>JFestÄéóapuIXSM[LQ^Jfr\2>(".'2!@K:$/+)#2)7 +)4$ +"$&##%$% ($1QjT8T;5Q80H22)!)3*
+&-3)"' !@H0LU:NZBM_O<SKD\^ü∂æ§µøUclEUUCTNCUG1D1&9%/B,+B(-.D/5M531"3!$5"0#5/*&	
+  &&' ,!-('( 8"8W7[[SrR>]>Yz]kåqoãt\x_LkL>`?:]<QrS^|`LkLCeB>b>=_<;Z:OjK8O5$7!!2 %3$)5'",!%+!*  -#%#+2,D,1P11S2>_@QoUMfPH_KC\FAZD.G1'A(&@'*C%,BCVéùLõ•B§®9¨©4≤¶0¢íª¨-ø±.¥°µ°¬∞(ƒ∞-µò ®ä±ï1ª¢Eæ®R»Ø_◊∫nﬁ∏gÀö=»ç%»Çºo ∆r ÀwœÄ	⁄ê—ã»Ñ	»àŒì«ñ∂éΩóΩó∫é±}∏{∞o …ãæÄµs ¡|S[O}VRÇXRÉTFxCIzCGv@TÄMTÄMUÄR_à\\Ö]ZÉ[]áajím`àcoôsjîngëièπìô¡ûé∂ìê∫ñ{¶{t£mZçKBx-Bx-Aq5^äWà¥ÅmúeQ?,S  )*$*+%(."7;-8A,>V6[SRÅMLFBq;4^.7U1.+:'&1#'2$'2$'/"#. ,8*"0!)7(0A/2F-1H+)'%'(*='0J//L.A^B)C*-C.%8%1 .0#<&/K41M6(D.%A*NlP>_@OqP,K+7Q4:R8TlV'C-;XB0P80P8*H05Q::#5Q;?]EHiL<_>)N%)N#-R'5W2.$6 9H3$6(?#(C$)C&7Q4DcD1T35^67a9.Y./X.&L#%J!*H"&B*E")C *B"*? *=.C$-H'3U0+U'/[*1]*(R"A6 &8P.RqGHkAGm>Cn8;i)2a7f"Q}BUÄHEp8Mz?O}?2c!-_,]<i.[ÜPUÅN[áRIv=3\$@"=*"!##) &&')+ -*!"#+"+*. =8$fS2™ì_œ∑o’ªd“µO–≤@Œ∞6ŒØ0Õ±,”µ/”≥*–¨ Õß‘´÷Æ’≠“≠œÆÀ≤…∞»´…©Ã¨	 ™»•æõ ≈¢ «§√ù ≈¢ »©«´»≠ÀÆÃ© ü¬é ƒå ÕïÃè∆Å ¡w ¿w  Ö∆ãƒè√ïæó ¡ûæõøöøï∏â ∏Ü ±Å ¥Ü ªê∂àµ~ Øz πã∏î∏õµû≥ú ±ù ≥°¥§∞§Ø¶±•∞ß∞¶±©±©	∞™Ø©Ø©Ø®Æ©¨§™¢©û®ù£ö§ú•û•ûß†¶ü¶ü•ü¶†£üßüßü¶†¶†•ü£ùûñóè
+ûñ•ù™¢´£≠§!≠§#Ø¶%Æ•"Æ¶!¨§¨•´§©¢™£®£©§©§ß°¶£¶£ß§®•ØÆ≤±∂≥π¥∫µª∑ª∏∏µ∑≤∂±µ∞π±∫∞∏Æª≤º∞º≠ª©º§¿¶ƒ§ ¢)ÿ°DÏ≤i˝»îˇ”©ˇŸ≥ˇ›∂ˇÿØˇ…†˘≤Ü¯¶v˘õg˜ù_˙≠g¯∫m¿n‹∞eªèRwX*C>>H/>L53B-,;(&1!"##$'T_QJRC:B3"*'(!-!zÑ|hrir}o^iXeraS^N9?306*-5&.9)3?18D:<HDvÇÇÉëîIWW2?5<J9*7%/:)2>*4=**3 ,7&*(,'6!*%+6()5'&!'',,%$+'7O98T;1N20J14/#4$#4$@NA$0$& *!)!%	
+&-?%/A)=P:7L93I<.DAmÄÑí£™`nqGSO8F90F/2J01J-0I,/H+-F)%=#*B(.D-!4.?-5F4)7&. 1/,*"
+	
+
+
+ %"-!#,A^@UwVBaBPoPXvZdÇfgÑhNkM?a>>b<:^8@d@EgFEgFDcC9X8?\>>V<?V<+>(1"5")7("0!+#'!.$&2&+%*-$<$0O04V5AbCJhNFbKJcMF]I7P:*C-&B)*F-/I,0H&8LÅëHó¢D£©?™™8¨ß2´°(´†$ªÆ,∫©'≠ö∫®"ø™*¨ë©ç ≤ñ3∫°D¡©QÃ≤]·ºk”§L»é* àæuÀ~ÕÉ
+ÕÜ
+—åÕå…â…éÀóÕü%¥åªò¿öªë±}Øt ≤søÄ…áµw ∞r …åNzWUÅ]SÄYRÅUSÉSXàVdía^äYXÉUS~Shêkuù{qòylìthèpcäk|£ÑÉ¨äkïov†xô¡ûÜÆãuüw`é]eïYXãFCy+;q%<l.N}F}¨vnùf_çO<	
+#$)*$$%,(7 2F*5Q+YPSÜMOáHLÇDM~FGn? @6O1+?&%4!)6$&3!0=+0?,!2'8&->+.=("#&+,!7 +H*'I(2T3+L-4Q58R97P;8Q>:Q?4K9/H3+G1+F3B]JQmW:X>háhQpP(E&-G*HbG.J1.L45U=3O8=W>4L4&>(>ZDA_GAdD4X4%H 'J 'G" ;+/AP;CR;2F+0G+6M1AZ=>[<7V6<`<AjB8a7"K!0U,*L'%@&@+F#,F#/G%2G(.= (8%9-K).U),X'4`-7a1+P%1QfG[wOjã``ÑVRzF9e*6c"3b@l-Iu:Co4SDQ?2d6e!5c"Cn6fë\açZdê[RD5^&85( #%   (&#.'3(5!#0&	)"/#s]6∂úaŒµe–∂UÃ±@Œ∞4“µ5”∂4‘π6’∏6’∑5‘±/“¨'—©#–¶–¶—®œ´“≥–≥Ã∞À≠ ≠»®Ã®	 ¶ ©À™»•…¶»ß≈®∆´ Æ…™À•«ö ∆ó Ãü ò√ä ¿Ç ¿Ä Ãéƒâ ¡à ¬ç¬î¿ñªñ æõæõºñªï∑é∑éΩî∏ç∞z Æx ∞ ±à ∂ó∂ù¥†≥°±°≤§±•∞ß∞ß±®±©Æ©Ø©	∞™
+∞™±´Ø™Æ©¨¶™¢•ù§õ•ù¶ûßü¶ü®°™£®°ß°§†•°ß†®†¶†•ü•ü§ûùñìå
+îçûóßü™¢´¢¨£ ¨•#≠¶"≠•≠•≠¶™£™£ß¢®£®£ß°®¢¶£•¢•¢®•ØÆ≤±µ≤∏≥∏≥∫∂∏µ∑¥µ∞
+µ∞
+µ∞∂±∑Ø∏Æ∑ÆªØΩÆ∫®
+∑¢	º§æ•¬°Õ¢1⁄®OÔº{ˇœ†ˇŸØˇ⁄≤˝Õ•˙√öˇºí˛∞Ä¯¶n˚≠m˚Ωrˆ√rÔ¬o·∂h öZäf4H>AG-BP93E/+:%!. 
+&-8*<G9CK<08)&1#() %/'X^\hnjPZQEOD\h\oyp_f^DIB:B5,4%4?//;-&1)GRLFQM0;3"0%4!*9&#0 ,+7#.:&+7#%2 #0#2%4+()"-,9(1>-%2!*(+'5$!/ .*+* &7%/I0,I-6P57'$,5F4;I8 ,&0%$,!
+	/:*:L68O54J3,B-*=*"7(/&G[Y°∞≥ëü†Q\T-:)':$&?")B%,E(.G*1J-3K15L2:M7@Q>bs`wÖt1?.!022/2*
+
+
+#.6'4<-+LiMIhIJiJmåm^{_IfJDaCA`A7Y8:\9>`?IkJBcF=[?=Z>4N3(@("5!'8%"3 /1!2"#1"%1%&#*!-! ,*)-,D,3R37Y8?`CB`FPlURkUE]G4M7)E,,H//M15R4=V8@W+pÅ=ìüI†ß@¶®:©®4Ø©1¶ö µ¶)ª©)≥†≠öπ§%•ä™ç%∞î3æ§G»ØUŒ∞X…ùD√ç-«áΩv√x÷åœã“ìÃí…êÀîÕöÃû$æñ∑ìæö¿öπå©r ∫|∂t¬Ä±m ´j æÑŒòT}]V]]Öb\Ñ_WÅYZÑ^rúxaâfjípsõygéqfåsë≤ùÇ£éwöÇiêukíuÖÆåtütoömíªììºî≠~]åUWàF_ìHNÖ4Bx*@r-gïWw§mmöcZÉI	) !!!"),%/2)
+&4);#1(C$8X3+N$)M!+O!6^,PÇGRàJQáINÑFGy<?n7NvD0T(/J'8Q11I)*A$-A&.B'-D*9L6'6#)  (%2!04&E&"D#"C$(I*.M.B_CEaHD]HH]LEZK@WE<TD4L>OjYTmZYr]oàrnäq;X:%B$,E(0J/*F-9U<3I2ew_M_G)<&EaJJjR@cC*N*&F! ;$
+),!3,;&4C,-?'-?%EY>@W;QlM;Y7;]89^3>e8"I=a;+J(";*C#+G!,K",L#7S-9O+/B"(;&?6[21\.3_.9e4/V*-	;M3RlG_~RoìcOuDEm9TG=i,9g)6b%Bn3VÇEFu17f 9f!Dn/gèZeç[ZÜQWáMCt3?h.;1&%')
+
+ &(&"*&1 (5!%3$0"&!,,>$;S3AP1'!	Q> òÅO≈≠gŒ∑ZÃ¥FÀ≤4–µ0’π4’π4‘π4‘π6÷∫<◊ª>◊∑<’±7“™0Œ¢)Ãû$œ§$–™#“Ø!—≥“µœ≤∆™«ß ™	»´»´…™∆ß«®ƒß≈™«¨…≠ ´…¶…£»•»¢∆õ«ö∆ó∆í√ã ºÄ πz ΩÇ æä æë ºóºòºöºöπóπó∫ñµå Æ} ≤ ¥É´ ¥ë∂õ¥†µ£≤£Ø° Ø£Ø¶ÆßØ®Æ©∞´	Æ®Ø´±´∞™Ø™Ø™Æ©´•¶†§ù¶û¶†¶üß†©°¶ü®°ß°¶¢ß£®°®°ß°¶†•ü£ùòìãÜäÑ
+ïè°ö¶û©¢™£≠§!Æ¶!≠ß¨¶≠¶´§©§´¶ß¢ß°ß°¶†§†¢°§°ß§≠¨∞Ø≥≤∂≥∑≤∏¥π¥∑≤µ∞
+¥Ø	¥Øµ∞µ∞∑Ø∑≠ªØª≠π©¥§	∑£∫§º°≈§#Œ•9Â¥g˝…èˇ—§˛Õ•˘≈ùˇ∆õˇ¡î¯∞~¯±y¸ª{ˆ¬wˆ…xÔ≈q„∏i”¢]ôr;N>DG,AO61C++:#!.
+%-"R\QJUGLTE%-&1#7A8LVNIOKLPOOTP4;4*4,OZRfqku~}CIG180*2%1<+/:)$/6A12:-)4$$1$3,;$.=&*9"#2'6,;&=J8=J8*7#'4 $2!. +#.)'4#2@/1@-$5#2(9''8()7(%3$-)#&"3!*@++E*1K.*@) "#,8G4AL;*2#$,! " &1#1>--<'0B,1B/.=*"3!1!$8-%:3L\[/>;'2*#/!#1 #6 #7%<"(?%1E,2D.0B,;J5ap]hwdan\KXF7I3*A'$>#%?$*D)*@)$5"
+
+
+	'!-'")9S:DbFHgHPoPLkL@_@?\@A]D7U=4R:GcMMfQKdQAXF1H68M:2E2&'+-+ . .#1","),!/  , )//G/9V8;\=GhKStYWs]G`K8P8.H/*G+7U9B`DHeIB\AD]6\n0éõIû§@•ß9©®4Æß2¨ù&•í∑§$∏£#Øò∞ñ£ÑÆé+≠ê2æ°E—≥[”∞V¿é/ å'«Äºq »}ÀÖ	œêœôÕõÀöÕûÕ¢"øñªì∏íπíøï±Ç∑Ä∏{πu∏p©_ ∫w∆ë úYfuúÅ§Öxù~]Çc`áj¢äyúÑyùÉyùÉoï|bÖoì¥°ì¥°É¶éwûÉmîwlñrnúmsülÑ≠ÅåµâÄØ{WâJOÅ8LÅ1D{(G~-Hz1kúZ\âNpùbNw;2$ !$' 25,$#&32E)7O+3O'/R(Ah;Q}JKzDJw@MxBKv@RÇFTàHUåKPâEIÇ>LÉ@LÄ@;k/Ai5Ag6@d4,P"9X.'F2P*8Q1#5)"#/!)?(#@"%D$%G& B!%G&%D$%B$5*,,*+*B4E]O`wglÉqã§èzñD`G.K-E^A0J-%B&2N52H1OaKiw`>P8?W?>[?*I)(G%1J*.
++ 1 1&8";J5-<'0B*BV=LcINhMQnPOnL6Y16[01V+?a<)G%'>!.E(-H%*J#,O%3S*7Q,1F%2G()B"1S.6_3;g64`/2W,4
+
+ =Q5SmFRqEMqCEk:ië]Ju?<g/Do7Jr=XHIs4Cm-Gq2YÄGbàWdåZWÑKFv8Bp0=f.$?/&'&$	* - ,(#"-,8$,:!.>#-3F*/C'(@ ;U2;T-Vb<A4ànIø•lœ∂fÕ¥O…∞9À≥-–π/‘∫2“∑2–µ0—∂3”∫;◊æ@◊∫B’∂AŸ¥A€≤@€∞=€≤<◊∞7”∞0—¥,—µ&–≤ Ã≠«¶…®«©	¬•≈®√¶≈®ƒß≈™ƒ¨∆´√®√§ ∆• ∆¶≈•√°«£»ü≈ò≈íøÖ ∑v ∏w ¿Ü¬éæî∂í ∑ì ªú∫ù∫ùπó±ã ≠Å ¥Ö¥Ö™Ä ∞ã ∑ôµû≥°±°±¢±§ Ø¶Æß≠®≠®Æ©Æ™	Ø´
+Ø©	∞™∞´Ø™≠™´ß®¢§û£ù•ü¶ü¶üßü®°©¢ß°®¢ß£ß°ß°¶†•ü£ùùôïêÜÅ	|yâÜôì£ú®°©¢≠• ≠•¨¶¨¶≠¶¨•™•©§ß¢¶†¶ü°öüõ°ü¢û¶£≠´∞Ø±∞≥∞µ≤∑≥∑≥∂±≥Æ≥Æ≥Æ
+≤≠≥Æµ≠∂¨∑≠∏´π´µ¶∏ßπ•∫§æ§∆£+÷ßKÏ∑q˜¿äˇ∆õ˛…ùˇ…õ˝øê˜∏É˝¬Ü¸«Éı |ÙŒ{Ó∆qÂªiÿ®`§z@WAIE*AN40B*,>&'6!"-$!&	%,$OWL<D7:B3(!-!*6,<E@bhhptuswv495"($KVRpz{zÇÖ\dfGMI9A63>.0;*(3">G41:'+4!(4 *7#*8!,;$.=&/>',;$#2&5"9F43@,1@+.<%(7 %2 /&&'6!.=(.@*)<(+>+1D1->,*;)"0*$0 .A.(>''?%E\B.!)%2!-:(=I5 )#"%1#2?.(5$!2O`MAP=<J9(6%!2">PDCWL/C:&7/)"-'9#,?).@*-<'+:%3B/N]JWfQ~çxtÅoL[F>U96S46U54S48U98P8)	
+
+
+)*$""#%(6 2L37Q81N2;X<>[?B^GHdNE`MD_NTl^Vl_OcXBVK,A21C53A2&+,-*-*"&'*(%.0F/3P44S4?`CNlREaK9R<0J11K0/L0A_CWu[OmSKgND\:G\$àòMó°@¢¶8¶¶4´¶0≠û)ùàÆô±ô∞óßä°Ä±è.ªú?∆ßLœ≠SÃ§E«ê+ÀàΩvƒ|∆ÄœêÕó…ôÃ† ü…ûøì≠ÉΩîπê∏èºç´yπÇµzªw
+®a ≥m ¬ÜøêÃßY{jÄ£èã¨ôõº©ã¨ôoí~öª™í≥†çÆôåØóÅ®çhètgärî∑üwûÉpózz£Édëjdì_pùfw°oqõiÑ±xfóUMÇ4@w#LÜ1A{'Ey.\èJN>jõZ[äF2W# #),%"%!',:#9N-5T*3Y&Cn9Eq<8i1H{@PÜHQÖGSÖF6h)L~?RÜDVçJUéIQäENá@JÑ:;s,Bw3@s0At1Gz7?r04e$:g,;_1.'%4L23R2(J'&H%#E"#B"$A"%?"2 $4'/?2, 2F:F\O<SC[m]mo]vaTpZC\F]w\rçn:W8%D%0N4(@*1D0AP;WeNYiO@S70H(/D%6D*:F."1!2#9$#9$$7!2D.<K67H5PfQTmXPiV]yccÅgJlKEgB7Z2?]9$?,@%;O4%> .I(0P+4T/5P-.H%5N.4O0.M+5[4;f9+T(?0+Ke@Jk@Ek:OwEGn?@g:Bg;@d8?`3Lm>Dh8Jn>câZpïioôg?p/Ar08d),P 8+&%
+		
+!*+7))6%#0($&2<L1UmI97X+9Z-5V+<Y-DW*_`6ÖmG∂îg÷∂y÷∫gÀØAÀ∞/À¥*‘Ω1‘æ4—ª2‘∫2”∏3‘π6ÿΩ<ŸΩ@ÿªC€ªD€∫F€ºH›ΩL‹æN€ΩK÷πC—±6Õ™*œ©$À§ §»•≈¢«§ƒ§¬¢≈®≈™≈™√™ø§ ¿† √£ ¬¢√£¬¢√°ƒ†∆ùƒñæâ ¿Ñ πz ª| ºÉ æè∂ç ¥ã πñ∏ù∂ù∂ò∞ç Æá ¥äµé™É ®Å ≥ê¥õ≥ü±ù ≠õ ≥§±•Æ•Æ¶∞®Øß≠®∞≠
+∞≠
+Ø´≥Æ∞´Æ®¨¶ß£§ü§ù•ûß†ß†¶ü¶üß†®£ß¢®¢®†¶†§°£üûöôîèéÄqs|{ãàöñ¢ù¶¢™£¨¶¨¶¨¶¨•©¢©¢®°¶û°õüòöíôìõóùô•üÆ©±≠≥∞¥±µ≤∂¥µ≤≥∞±Æ∞≠±¨≤≠	≥´
+¥¨µ´µ´∂¨∑™∂©∏©π™π®ª¶¡¢# û5◊†MË™mˇƒêˇ–û˝Œö˙≈è¸»é˝–ç˙”àˆ—ÅÚŒzÌ«rËæl›´b≥ÜKfJ"I@#AI15G1,>&+:%'2$"*%  &%"* *)$/'CKMrw{glpswzRTS@EHìö†zÅâ}ÑäekkBHD9C:AMA/<+6C1,9''4"*%0%-$-(4@,/<('6# /(7$/>)+=%,;$/A)4G15H2/A)+:#*9"-<%-<%+=%.@*/B,-@,-@,.,+/B/-@-,?+&7$3@.)"!.@M9#0 -$!!"&2&&2$'#01?.3D2J]J:K9->.#1" .!%5(:O@=TD5L<0@3	
+	>L;=N</@-9J7(9&/>+2A,FX@j|fp{jQ^LI]BD_>;Z86X78[=:X@&=)
+
+	
+#!))"#/$5"-##&*/21"9%0I4?XCG`MKfUOj[Sk^UjaWkbAUJ0B41C3.<-(*&%$"! "'&#':&5O45T5HfJD`G;U<4N55R69V:8V:EcISs[SqYUqZF_?C[)|êKì†Fú£9£®4©ß0™ü)°é®ê≤ñØì†ÅüyØã-ºõ<≈§E ¶F¬ï0Àë%æ}	¡≈Ö	ŒìÕòÀõ»ú…°Õ¢"¬ë≥Å™}
+æì"ºë!∫åÆz¨w≥|∏∞r©l ∫Éæè∫ñ”¥(kê~Ñ¶ïfÜwZzkeÖvdÑuîµ§~üåtóÄ§à}§Ösö{R{[cålsú|\Öcsü{^ã`dì_oúeá≤|è∫ÇbêRm°Y^ïBIÉ,:v;v"Aw+?r-bïRbìRXÜE4
+" ( ('.8P.<]0Iq<@p4J|?OÉEH>Bz9LÑCOàDRâE;p,Cx4SàDTãGWèHPä@Kà;D~17q$=w*>x+<v*<v*:w)>v-Ev56[(0##)'$1(JdK9[:,P*$H"$F!"A$B +D'."ô™òåûéUj[`viC[M8NAcshZl`7M@MeW=TDLcOUmS.H-/K21O7$=(-->+ES<zÑlT^C@O07F)5=%MW?+:%':&'=()A))?()<&M^KcvbtãwOhU^yjláxeÇl_}c^Ä_LlG2P,%>2F-3E/&2J0=Z<=\=1P0.K,.G)&?!%?"9X67]45[26 3E+Gc=Bf:Af:<a67Z2/Q,2R+Ge?KiCDd=KnDjècsùmdëZGx6Cq00V#</*&& 
+
+ '3%/=,*9&$3 0?*%Jb@[zP3Y(4\'9a,7]*=W(T\-ÑwK∂ìi◊≠}ÊƒÖﬁ¿jœ≤<Ã±&—∏'÷¿.ÿ√4’¬5◊¡7’ø5÷æ8◊ø;Ÿ¿AÿæC⁄ºB◊πA‘πD◊æJ€¡S⁄¬TŸøQ”µE—¨9—©0À§%À£«†»¢…£»£»§»¶ƒ§∆¶≈®¬•¬¢¬¢¡ü ¬¢¬†¬†æö Ωï ƒò¿ê ≈çøÖ π} µz µÄ ªã≥à ≥é ∑öµú¥ô≥ï¥ë¥ë±ë∞ê®Ñ Øè ≤ö∞û ±ù ¨ö Ø° ∞§ Ø¶Æ¶≠•∞®Æ´≠™Ø¨	∞¨∞´Ø™Ø™´ß©•¶°§ù•û¶ü¶ü¶ü¶°ß¢ß¢®£¶°®°¶†¢üûúùôíéááÄÄnpkm{zçäöñ¢ù¶¢´•™§™§´§©¢®°¶ü£õõîîéèäèçîèóí¢õ©§Ø´∞¨±Æ≤≤≥±≤Ø≥∞∞≠Æ´Ø™≤≠	¥¨≥´
+≥©
+≥©
+µ´¥™
+¥™µ´∑™π´µ£º¢ƒù&Õõ:‚¶]ˇ¡Ñˇ—óˇœï˛Õì˝œë˚÷è˜◊äÛ‘ÇÓÀwÌ«rÁΩkﬁ™aøèQzX+C3=A(/>'(7 '6!*+!.#0! #"%/'*#?KIhqvt{ÉPUY>BCUWTAGGÑåéÉàåchl\bbJPNS^XQ\T=I=.:,7D3)6$,$/$*"%,CJ8,3!+4!(5!&5 &5 5G/(7 %7)<&)=$*<$.@&6F,6F,1A'(: (:"2F-2I/':$,,*=)/B.&9&:K9>K:'2"' !#)AN:'6! /#4"+<,4F6>PBK[NGUD&4#$2!3D21B0,?,&8(&7'(6'*&'8&6K89N;:M:+$*#1@-8I63D1=P<.A+,>(*<&E\Bbu_õ¶ñzÖuQcKBY=IfG1P12S87W?;VC2G6.#!#()("/&5"4E2:P;)?*!4 (&&),**0!8&%:)0G5:S@BZJIaTTka]riAUJ1C51C3/=.'	
+
+! %%#!"*4N19X9OlPXt[GaF3P48W8=\=B`DEcIIiQIgOGcJ;T4A[.oÖEéûFò£;û•5¶•/™°,®ïüÇ¨å™ã§É©Ü ≥ë0∫ú:»®EÃ¢>ƒë(¿ÑæÄÕí—õ–†œ£…°…¢Ãß%…†$ºä™x	≤Ñøì&∂ä∂Ü©sÆv	±|∫Ü≤{πÖªè
+∂ê¬•“ª1géyy†ãÖßñrìÇ_pStcVucSu]T{\XÇ^VÄZ\Ü^P}TDqHRV[ä`Zâ[SÉQLxCnôc™r{©k`ìPNÑ8KÖ0IÖ+>z":u!<t)PÖAq¢akóZ:_)' % ("* 72P,PvGTÅJSÖHRÜFNÇBNÖBQäELÖ@KÇ>MÜASåGNá@Dy3SàBSãBTåANá8GÇ2?x+4n!<w'3n:t'>x,C}1I~8Dq8*J!-&*+?HGéùñ_zgJkN6Z4)N%%G"$D)G#5N0"3 _v\MeKG`JHcRH`SXmfl|{HXX2FENba?TM5I>;K@1C59OB.I8&B,-F0-C.+:%LT?çëzQW=>G,6;$FP8;J3'=&*B*+C+,D,3I2exd[nZg~jHaNVn`mÖwdnmâshÜj]|\2Q180B,)8% 1!G\KKdOB`H2P64Q5-E+&=!';"-F(?_:9\43Q-"
+
+		 45P-0N*,L'2R+3S,:X28V04R01Q,Af:^âTYâOGw9Fr3El3#?4-%&)*+2C13F0-D*YtU=Ad:>e6<f42_(3^(5Z'CU%nc6£ÑXœ§yÈΩåÌ ä‚ƒj”∫<—π%‘Ω"Ÿ¬&€».‹À5€À8Ÿ ;ÿÀ?ÿ»Aÿ√C◊æ?ÿª=◊∑<ÿºA‹ƒJ‹≈Q⁄∆S÷¬Q’øP◊πK—ØA“Æ<“Æ6»†'¬ô∆öÃüÕ°»ü≈ú«û…¢≈°¬û √°¡ù ¡ü ¡ùøõ æñ ∂å ªé ∆ó	√îøéªÖ ∑Ä Øu ∑Ç∫è≤é µñ ∑úµö≥ò≥ò±ò ∞ò ±ô¨í ≠ïÆõØü¥¢Ø† Ø£ Æ• Æ• ÆßÆß≠®≠™≠¨Ø¨	Æ™Ø¨Ø¨Ø¨≠™™¶¶†£û•†¶°¶°¶†•ü¶°•†¶°¶°¶°ß°¢ü†úôîçàÅzzkkbelk|zçäôï£û¶¢¶£¶£®£ß¢•ü§ûúïèãáÑÇÇÜÜâáîé†ô™£Ø©Æ™≠™±Æ≥∞≥Ø±¨
+Æ´≠™Æ©∞´≤™	≤™	±©	±©	¥¨≥´≤©µ¨µ´π¨∫©∫•ºü√û,◊§KÓ¥k˛¡Ç˛√á˚…å¸”ë˙⁄ëı⁄ã‘ÄÌÕxÌ…uËΩn·≠d…ñWêf6K398*6 #2.$'(. /'6#-(&#%%",+^ik3>@eptyÉåwÄáUZ]173DKC&.#DLAeldz{z|{sut9?;KVRalfXc[:D;=H:.;*+8$/;'&2"+38$9<)=:)98&-5 '5#29H3=J6,9%5C,$3./!3%8%8$8&:1H,2I-%<" 4"60B,);% 1+9(7D3/<+#. !, ,*("/4C0+<))-@-BYGE^KCZH;P=9N;4G3/B.(;'):(*;)&7'/=.1?0'(%2 .=(6E0;M7-A(/A':M1.B&&:*<$0D+2I/*B(*B(3K11I1qÑpéúãò§ñbp_DWC=S<2J2*C.2K8>WDA\IC^K5P=6&/ 0"!1$,,#1 1B0?TAC\IC\I5N;,C/&;(#4"*%&&'+,.1 !8&&?,AYKQi\McWDZM@UF7I92E2+9*		
+""  03M0<[;JgKE_F8T;5R6;\=GhIGeIDbFA_C<Z>6S56P-E^4^s8ãöGò¢?ù£5§£/©¢.¨õ'û§Å¶Ö®à∞ë%ºü7√™E–∞KΩê)≈è"π~…è–†œ•Œ®À©#…®#…´) ®*øô¥á¨~ªë#æï)µâµÖ∞z®oÆ{∑Ü≥É¥áµç¥í
+–∏0–æ6R`[Üjjê{çØüÉ£ñÉ£î|õãeáoOxV<i@AoAFtEKyHHxF>n>QÅQHxDL}F>j5gí\sûfâ∑wn¢Z[îEIÖ/Là.GÜ->y%C{2XçIw®geéT ? 	$#/$4,D$7S-=a5Dl:RÅJRÜHPáFOÜCRâFSäGSåGSåENÜ?JÇ;Ná@QãAD|3NÉ;Rà=Sâ=NÉ5At'0bJ~4<u&*e=w*D~2F~5Bu36`.3S.#!'0/Çéåò¨£ç®óqëy?bA/S-*I''F$0N,,F)0C/-pâlEbD5S9:WC8OGsáÜ8GL0>GTfppÇåObfasu2@AK[[autJc],G80L6'@*2E1>G4_bOäåvRV=DJ0CM4;K1,C),C)-E+2J2G_Gg}hbzdD]G=VAG_ORjZbzjwígÉj^}^9X8&@#*='5D1GUFJ\LE^K=ZD7W?5S93M2.E++?$';2M,B]:<W6/	,:N32K-#@!'E#8S28S02M,,G&+F'*H$;_1Dl7Do7Bn3 E#@0 2 1$(#/!) 	
+&(#6"LdJ6S4RtO>e95_18b25a.2^)2Y$9U$S[*î|N¬ôm‚≥áı«ïı–å‰«i⁄ø<ÿ¡&ÿ¿ ‘º’¡ ⁄ ,€—4‹“<‹‘A€–B€ÀD÷¬?◊º;€æ@‹¿C›√Hﬂ«M‹«P€«TŸ√SŸøQ‘∏K÷∏HŸπHÿ¥B—™5»ú!√î≈ï≈î«ì	 ó
+Ãú
+ ú∆ö«û¿ô æö øõ øöæñπè ¥Ö ƒï¿ì∫ê Ωêªâµ~ ¨v Ωè∏íµñ πû≥ö Æó ≥ú±ú±û∞ùØöØõ¨úÆ†∞° ∞£ ±•Ø¶Ø¶∞©≠®Æ©≠™Æ´¨©Æ™	Ø¨∞≠¨¨¨´¨¶®¢¢ùß¢•†•†§°§°¶°•†•†§üß¢¶†£üúôëçÉÄxvvwhlad`arrÅÄëêùô§ü£ü•°§°•ü§ûüöîéáÑ~xy|}ÑÅêãûñ•û´¶´¶´ß∞¨Ø¨∞™Æ®¨ß©¶¨ßÆ©±©∞®∞®Ø©	Ø©	∞™∞™≤¨µ¨∑¨ª¨ª©∫§¿§)À°=÷¢N‰®`Úπv¯Àà˚Ÿí˜›êÛ‹åÒ◊ÉÔ—{ÔÀwÏæpÂ¨e÷ú]•q?V381*4"0-* -+"1*!2$5"!0!.(')!1;=itzT_cept|Üà|ÅÑRTQ;>52:+1<+1:)4:,be^qsnrtqEKIBKHP[WYb]Zd\1;0#.)6$.<%/=&/9!16 ;:&LE3KF338"(4)6"0=)@M99E/4@*"00 43#7"6#7#:$;#:%< ,@%+?$)=$);#$3  .#0'4#'" !)$5".A-'4EaKPlVBYE6N8-E/(@*&<')<)7H64B1,$2#*(4?.&21:%6B*7E+;J-4E#:N+0H&$<$8+?&+C)'A$)F(9V:+E,RgTfwgêûëyÖ{TaWP`S2D6EYN7LC&<0/G9<YECcLDaM>YF7O?,C3&;,'9)'9)(=*/H36Q>C`LNkWNjTLcOOeP>O< .'*-./1! 5"$9&(?+;QDJ`S4J=5L<DYH=RA-@-0>/
+			
+		%/G->[<?\@7S:B^E9V:>_@IkJDcDNmN@_@5T43P15P-@Y1J_'ÑïGîü?ú¢8¢†/•û*©ö%®äòt¶Ñ≠è!¥ö,º§8¡¶?≈¢<ºå πÅ¡ãÃõœ®À™ÀÆ$»¨%…¨*…¨,ƒ¢&πï≥ã∑çΩî(∏è#ºê#Æ~±|§p¥Ö∞Ñ±â∞ä´âæ¢”ø8Œæ7IzMUÉ^T|beäyòπ∞üæ∂õπ≠â™óy¢ÇXÖ\IwHAp<;j49h2:i5Ds?Ap:?n8?n8Q}Hkò]x¶fcóO]ìETé9A}%7s8sG}2]êMmû]PyA9)*&44J&6V'7^)9e*;h-?o1Bu3G{9Cz7IÄ?MÑCNÖBMÜBIÇ=NÜ=Oá<Oâ=Má;GÅ4E~1Fz/9h :e6]+ONw5:p%2o!>x+F~5Ex6<i26]00R-(E)";%4%(9/qÖ|ï´ürä|b~h`~dYw[,K,'F'.K/+E,-D0C[E$A%*H,*H.<YE2ICpÉátÖçeuÑfyànÅíUfvô´π[kz~êûáö®î´±<WP+G8.J4;S=O`N4=,bdOÇÑlR[>IV86I+/C'?S83J.0H.OiN\v]a}fQmV?XB3L7F]KnÜviÑqeÅh^}^;Z:5R3.E+,?)>Q;I\HMeOHdMB`H7U;8U9/I,.G))@##:)@$1E,"1	
+	 9M4@[<8W7+J*'D&8+B&%9 /C(/C'#=Gg8Ce3Ii:/K#/(+!0"0'%" "!+0%=#[zZLqHAh<5_15_/9c34^.1Y'9Y(FV'mi9≥îe÷™{Îºê˘Œôˆ‘åÊ…e‹¿9‹¬'‹√!Ÿ¿ÿ√⁄Ã%⁄—*€”0›◊9‹’>Ÿ—@ÿÀAÿ≈B⁄√C◊π=Ÿπ>€ΩC›¿HﬁƒM€¬L⁄¡M÷øK’æJ÷øK◊ΩL◊ºI—±:œß.ƒñ¬å¡É
+√ÅÀåŒî í»òƒõ¡úæõ ¡ú¡ú∫ê µÑ ¬é¡îºîøöøñ∏Ü§o Æ} ∏éπõ∑û¥ùÆó ±ü±ü∞ù≠ö Øö±úÆöÆûØ°Ø£Ø¶∞ßÆßÆ©≠®Æ©Æ©≠™≠™Æ´Æ¨∞≠≠≠≠¨Ø©™§§ü¶°•¢£†¢ü£†§ü§ü¶ü•û§û¢üûúòòäà}{pplpbi\dW^glswÅÇíé ûô!†õ£ü¢ûüõùòôìâÜ~{wwvuxwÄ|äÉôíüòß°®£¶§•£´ß¨•™£
+™§®¢¨§Øß≠®Æ©Æ®Æ™	´ß¨®	Ø®≤´¥≠∂≠µ™∏©∏¶π°#Ωù0…°A‘°NÏºp˙÷å¯ﬁëı‡ëﬁåÔŸÑÔ”ÃxÏΩoÁ´c‡ú_∏vBm>:+).&4#2 -!.-!/'.$5#+ ,!,#+.80HQV`irPZ\AJGfkdNPEQOCUVH,0/8%/8%*3"8>4dibcgfQWWLUT;DAISKHRI+5**)**7#.:$.3==%HC0JG448!*4'5-;$/=&.<#%3!1 4 7#:&= #:$;%<"9#7"6"9!862-)'%0 " "'1,B+1,F-8Q;4N5,B+(>''?'8N9EXE@N?P\N9E7&3"*'"/@K:+4!,4<A*LP7V[=FQ/<M)/E!#;!5&:!(?%'?%)F*?\@.H/4K7L^PÇèÖzÖÅ†©¶áêè-99tÜàßπªP^_)85*>2.G49TAIfTGcTIeWC_P5P?*C05!0;%*J3EeNOkUC\GG_IM`L4E2,)-.1$7$*?,)?*G_IJaQ@UF9N?8M>BWF:O>/B/&4%
+	
+
+	
+	
+		 1G0;X:7T6EbFXuY<Y;:W8<[9Cb@LkI9[81P./N,7U1A[6;Q {åEíúCõ†:¢†1ß†+©ö#¨ìóy£Ö™é!π°5æ¶:√§:¡ò.Ωâ∏Å
+ õÀ§À¨ …Æ# ∞(À∞-ÃØ1¬†%ªôªò ∑ñ#Ωô)∏í%≤â∑å∞Ç¨|∞Å∞áÆá±å≥ì
+¥ö…≥*Œæ7…ª6DqF?lEFmR]Çpâ≠°ê±®í≤ßô∫©ã≤ócêiWÖWRÇNM|FDs=<h3=j31`)3b+:f1;h1UÇImõ]où\q£Zk†RSä9D{(;r!H~2föRVáF1W$%?&8 '9-E%7X)8a)Bn3;k-Ew8VäH@u1:o)H}9KÇ?D{:@x7KÑ@JÜ@KÑ=?w,7q%?y,FÅ1D}.Bx*;n#4]@b%@\"Lk/Iv1MÅ7E{0;n)3c'.Y$'N"*N*6U64R83N;.I:C[NZrego`yffjYr\LeO3L62K6AXD+B.ÄôÑYu^&D,3P:8SD0GAXkoê¢¨>P^3EYASiáóÆÅë®Åë®âõ±ÖöØ¢π«úö/K?<TD6K8"4$!"'qu^zÉfFS5AR26K,2F*3G,,E(KeJ]y`NlR6T:&B)1J4HaLSlY_{edÄgMjL =1L-1J-5L08L1:N5BXAD\FB^G@^FB^E=Z<=X99R2*A$%9)	
+	/B,B\?=_>5W44V51N07%%';N2@V0 9+@#5(%(!- ,"
+!%!2 .D/+H)LnIAh;5_/0\+3_.9c34[,4X*@Z+X_,êÉO«¶s‚∂ÖÒ«ó˘–òÛœÉ‚¡Z’µ,“¥◊ºÿ¡⁄»›œ$€”&€’)‹◊1€ÿ5⁄’9›÷@ﬁ”E›ÀEŸæ=”¥7’µ:ÿµ=Ÿ∂@÷µAÿ∑CŸºG÷ΩG◊¡J’¿K÷¿I÷ªFŸ∏DÿØ;“†- ë¬Éº{Ω}ª ¡â…ò«ù∆û	∆°
+√ûΩì∏á ∏Ñ ∫â ¿ñ¿ùøùºìØÉ ™~ Øä ∑úµû¥ùØò ±û≤üØú ≠ò Æô Øö≠ô¨úÆ¢Ø£Ø¶Æ•≠¶ ≠®¨ßØ™∞´Æ©≠®≠™Ø´
+Ø¨∞≠Ø¨≠©™¶¶°£°§°£†§°£û§ü£û§ù§ù£ù¢ûùöñïÖÉyzmmbg\dWaS][cglwwáÉ îê"ôîûöûõöññíëã|xkjmlsrrp}zÜÉóëïè£ú£†•¢§°®£§ú§ù¶ü¶ü™°´•¨ß≠®≠©´ß¨®	Æ©Æ©Æß±™∑≠∑´¥®¥§∂£"ª¢,ƒ•;Ã§E‰ºeÙÿÖ¯‚èÛ·çÒﬂãÚŸÖÒ“ÒÀxÎ∫kÍ™cÂõ\ƒyBåR$I1+)&/&5"!.(5$#1 ,%(0-)$5<4\eb]fokuPY^CLItviGF4MG7KH7.3.:$.:$*6"19,]d\ousciiKQQ$(2'%0"(3#*("/-9%6;$BD.214316.8 (4*8!/=$,:!+; )< (< '>!)@#&?!(A#)B$)@#(?"%<!8#:#:"9*A%-?)#2$%$""06L5BXA/G/(@*)?(-A(0G-NeK_u`Zk[Q_RWaV;F80>-&7%!/+%1)2*36;%GI1adGblJIW42H$ 8!5';"(?%%?$*G+KiO,E/#:&?SGwàÇú¶®ú£©°¶™JSXfw∫À”≤∫≈2;@'6/"9) ;(,I7<XJGfWFeUCbPD_N9TA-I2.L4BcHRsX\z`^zc`xbe{f9G6%&+.2*=*8M:,D.IaKShWNcTH]NLaRN`RFXH8I7'3%
+
+
+	/A)5N17T8B_CA[@<V;9V76T2<Z8?];9X63R00O-8V4;U28O!hx7çôEóõ:†û1§ü*ßõ%™ï"ûÑ†Ñ¨ë(ª§:¡¶;øö0øê$≤
+≈îÃ¶ÃØ#À±&»≤)»±-À≤3»®-™áºò ∂ì∫ö)ªõ,≥ç"µã¨Å¥â±áµç≤ä∞ã	≥ë≥ò≥ùÕª3Õº8…ª8;!(I.OsW\ÇiqñÑÉßôÑ§óã´ú{ûàaàiJwPCqCEsBCr>O~HKzC>n42_&1\$+V0[#4_'Bk1Jt5O|;Gt1@o)H{0OÑ6gõPJv9%K1O--J+.P-2W,8b08d/Eo=Dp=cè\`ëYPÑB?t.H}5Dy3<s0IÅ@LÖAHÑ>Az5/h!C{2MÖ:Oà9JÖ3HÉ/;q#-Z;\#D]&Ja+Us7bÜFP{6Iv3<h-J G6"?#?XCA\I3P>0O?GcTGbO@WCYoZVkX[p_EZK:O@wå}8O?Wn\[taLdTXoeCZT1GDf|zf{ÄXjvvÖökyì¨º’Äê©âõ≥åû∂™æ÷Ø∆÷íÆ± ;4* 	 1<+CL7}Éiox[@O01F%+?#0G+/H+MgLa}d[y_HiL,J.$A%7Q8NgQqçthÖi<V9&?".G*>W96O1=Q59L0AS;NaKE^HMiRYu\WtXWtVGeCB]:,D$$6	
+	
+	 .@Z?;^=8^94Z52V24V30N,83 "!!,)4&&0%!+ ((
+
+#+!7"MgL<\7Af:9`12\*.X&2\*7a12X)6V'I[+qo<±ùh’¥ÅÍ¬èıœû˘“ôÓ≈vŸ∞Gœ®‘≤Ÿ¿›»›Õ ›“"‹’$›◊'€ÿ)€ÿ+‹ÿ/›ÿ4ﬂ⁄>·◊D‹ÃAÿ¡=◊ª>—Æ8Õ¢1 ö+÷¶7ŸÆ=Ÿ∂>⁄æCÿ¿D”æA“Ω@‘º@◊∫Bÿ∏Aÿ±:”¶1Œô%√à∫yø}ΩÇΩá∆ó«û¬ôªí∏à ∑É ±{ πà øöæ†Ω†πú∂ò≤ó ≥ö≥õ∞ó ∞ó Æô ±ú≠ò ¨ó Æô ≠ö Æû´ù ≠°≠§¨£ Æ• ÆßÆß≠© ≠© ∞©≠®¨ß™ßÆ™	Ø¨Æ´Ø¨Æ™™¶•£†û¢ü£†§û¢ú£ù¢ú¢õ§ù¢úüõöóìëÅÄrsegaeY`T]OYQZZ_ijwuàÑ íé óíóíëåéàÑokb`ddfhoqwwÇÉíê!íçûô£ü£†¢ú•†üò
+°ô¢ö£ô§ù©£¨¶™¶´ß´ß¨¶
+Æ©¨ß≠®Ø®µ´∂™¥•±§≤¢∏¶(ª§0≈¶<“±PÂ oı›ÖÙ‡äÚ‹áÒ’ÇÕ{Ô≈qÔ∫jÚØh„òWœD¨j8Y52$
+'*'4"&3")7&%4!-$)* -'/ (.$LRPv}ÉÖéùxÑîÜêöAIL=>6PM<MF3FD/-70@&1A'0?(3>.BLCeki:@@!#"$#. *5%+6&)"-&1!3<++2 ;C.27!(-.63=%3=%3?'4B)0>%-="/B$.A#)< $;%> (A#*E$'@"%> '@"$;%< %< %>!(?#.B)'9#%!!#-2A.&4#%#):'4H-6M0I`FawbfxhQaV[g]=I="3!&9%/@-%7!!.!.'4 .<%:D,LU:`iLSa@9L,$9!5#: %>!$A#/M3MkS&>(!6%*?6vààÑéòù•≤åìôZdfYhoµ√Œπ¬”Yan.<=&:19QAF_LAYK9QDC^OKhV>[I8XC;]D8Z??`CLmNBaB?\>IaIFYF#/!(+/$6&)>+2J4G`KZqaYobUi]L^REUHFWG;I8/;-
+
+
+
+	.#*$+56J18P86P78R98T;8R77Q4<U8;T76P32M.1L+9T39Q15J!FXàîHñö<ûõ0£ù+ßú)ßí'ï|†Ö±ò1æß=Ω°6∏ç$æå¥É
+–®$ÃØ# µ&»µ*∆¥.«¥3 ≤6∫ò™Ü∏ï≥íπô*∂î)µå#¨ÄÆÇ≤â≤é∂í≥èÆãÆç≠ë	º®!Õº8Ãª9 ∏84!"?)>bFYÄc`ÜoiãzcÉvtîÖÅ¢èã≤ónóueègfëdWÖTQÄLIxACs9>n23a#.Z)U(T-V+R,Q'M0W^àIZâAN}7'N"B+J*-O.0V-0[-6e13b.Cn@WÇUiîgbê_RÑGCx2MÉ8KÄ8Fz8IAF|>Bx:3j)Cz6JÇ;JÑ8JÑ7IÑ4Mã87p#+Y5[ 1N;WLj.Y|<jëN>g%=d+Mt?PvEBe;+9 '@-A\KD`QC`N?ZG4M7CYDGZGVhZQcW<NBnÄt;RB8O?Vl_[piô≠ÆÑôúYno[ps/AKeuÑú´¿¢∞ ê†πóß¿ûØ…†≤ öÆ∆Åò¶0LM6-+9,5F46E.<D,u~a[iH7H&.A#:N2:S6<V;WqVZw[GfG5T5,F+=W<E_FMiPJdI(B%-E+1J-;V7;V52J*<O3GW=WiQOgOEaHNjQTqUZyZYwUEc?7P00D(.		
+#<R;>_@;a<3[62X12X36Z61S.0O-4N1/$$)!-%/$ *" #* 3 8DcA=`6<b39a/0[&-X#0[&2\*0V%:V&P\,çÜOƒØv„≈èœö¯◊§¯‘ñÏƒo‡∂Fﬁ∑+‚¿ ·…!·œ#ﬁ—"€—!€‘!‹◊#›ÿ&€Ÿ&ﬁÿ(‹Ÿ,€ÿ1›Ÿ8ﬂ’?‡—Bﬁ C⁄Ω?ÿ±<–¢2Ãú.Œ†0–©2—±6‘ª=‘Ω=”æ?“Ω>”ª?‘∫A“∏?‘¥=ŸÆ;◊•2—ò%œî ≈çªàºç∑ãºê	√ïøè	øç∑Ä ± ∫ñ ª°∫§∏§µ°≤û±ú≥õÆî ¨í ´ñ ±úØö≠ò ´ñ ∞ùÆ†≠°≠°Æ§Æ•Æ• ¨• Ø®¨ß¨® Ø®∞©™•®¢¨¶≠®¨©Ø¨Æ™´ß¶§¢¢†ù°û£ù°õ†ö°õüô†ö†ôõññêåâuufi^b]bU^Q[KVHQTY]_hi|{!àÜ!ãâçâÖÅÑzwec^_]^adnq"psÖÖ!çãëåöî†õûöóì°õöî
+öìõíúî°öß†™¶´ß´ß™¶¨¶
+ÆßÆ©≠®Ø®µ´≤¶≥ß≤¶Ø§≤¶ µ¶'º•1√®=“∂SËŒqÙ⁄ÉÚÿÅÒ”}ÒÕyÒ«sÙøoÙÆf‡ëO€äK«ÄJsF9"+)!,"/"0$3 -#$( -,4%:@6PVVyÇâwÉìÅåûam{qzÅ-0)>?-><'?A)1>"-@$/B&5E+*5%
+!,.9)'2!)*:B319*&.7"5>)#-,61;#0:"+51=%)7-="2E'7G*,?!)=!%<'B!)D#%@!&A"+D&.G)4M08Q4<U87P34H/);%( !+'4#
+'2A*;O48O3E[D\n^EUJCPF(6)#6#$:%$7#.@*7F1:I25G/=O7@O8>L3BO5BO3:J/)< 3"9&?""?#4T<NkU"9'!2(4GCÖóõ°™πô°Æàëñ`km[hnõ®±ãî•s|ãMZ`=MJ\rfe|lg}p`vi=TD6O<@]I9[B1T6+N.0R1<[;7T54N34L62C1+5*) #1$//2&=)>UATkYWn^[oc`rfBOE$0$6B4,7)
+
+
+yiGRD-.>K/2E/ 7#(A,5N89R<7Q82H1':$.4-F)1J,/C'&:$6~ãFëñ<ùõ4°ù/¶ö,öÇò|¢Ü"∫ü6¡©=ºú-ºë!≤É«üŒØ#Õ∏'ÕΩ,…π.»∏1…∂6≈≠1∑ó∂ìΩû)Ωü-æ¢4∑ñ+ºì*©~∑ç∂éØå±è´á©Ü≠ä
+Æí√Ø,…ª8 ∏8∆¥4%E.)M3:aBXÅaY}ckåwâ®òì≥§í≥¢è≤úáÆë~¶ÉrõqVÅSQ}LNzGQÅGK{=PÉAHz56h!5d.\*S+M ?!=7V*Fl30W  ?"=$>!'F&1V-1[+6e1@p<QNJxIeêcaç\_éWWâJG|4LÑ=8l,,]%5c27e4@q9Au5D}8C5?|/IÜ9Oå?*b*[2^!?i)P}8Hx.<l"Ox2níRkâS]{IQq?Ln<LpB'G"!);//C8;SED`JB`F5Q88Q;LaR_qeO_TfxjLcS4J=>SLOcbãû•{èöjÄã8KYAPcñ¢∏ó¶Ωõ´¬î§ªö™¡ô©¬ò™¿í©πC\c4.(@2,A.001F31I34H/1?&FP5|ÉdajKHV5PcECZ=2L/0J-3M0-F)*C&-D*-D*6P77Q8@X>4N3/I03P43R39V7(A#7K/:L2?Q9D\BC]DJfMJgKGdFEbC?];B`>6O/*># 
+	8K5@]?>b>6_74Z16\33Y23Y25[66Z6@_=-H)"
+
+$!5$;!*%3"#1 ". %+!$"1,@'8V4:]3=c4:`/5[*0X&,T 0X$1\'/T ?W%Xa,£ò`÷¬áÈ’öÙ€¢˜⁄¢Û“çËƒc‰æC‡æ)‡√!‡…!‡–#ﬁ—"›‘!‹’"ﬂÿ%ﬂÿ'›ÿ&‡Ÿ(›ÿ&›◊)‹ÿ.‹◊1›’5ﬂ÷=ﬁœB‹«G’ªBœÆ=“¨=—≠;—≤=’π>’Ω?÷ø?”ª=”∑:’π>—π?À≥9œ±7’≥8÷Ø8’Æ5”¨3Œ®-«ü#≥á
+∞~∫Ñƒí»ò¡ë∫ë∫ù∫§∑•¥•≥§±°∞ù∞õ Øö´ñ Æô≠ôÆõ≠ù™ö ≠ü≠°≠°Ø£≠£Æ•Æ¶≠•Æß¨ß¨ß´¶ ≠®™¢¶† ©£´¶
+¨©™©≠™¨®®¶•¢úõùôúòüòûóüòùñôïòìñëèâÖÅrsdi[aT]PXNW"LV"JRRV#UX^aps&|{!ÇÖÅÅ~{pn]^WYY[eh#ps$psëè+åàëãîèúóôïòîöñêåñêóëöì†ö§ü®¢´•™¶©§¨•≠¶≠¶¨ß∞©±™±ß≥©≠•≠•Æ•µ®%π©/ª§2Ωù6’≥RÍ»nÛ‘zÛ’{Ú“{ÒÀvÙøqÙ©eﬂåJ‰ìR€ïZôe5J*-%"))!.$3 +!%,*$%,73bmqyÖì{Üòr~ékv|7A808#27 5>#7F)2B%1@#5A)%
+
+
+&1#0;+$1!,!,IRA(4 #0#1*6 *6/;#2?%AI2-5(4*8*: /?$6E(5E(*=%=&A )G%3N/5P16Q28S4;U8:T7<V;9Q7*=' 1*##! (/;-'0?*/C*1D.7E4ESDBPA9L9:R<IaK7J6'8%0D+;O4=Q65I00C--?),;&(7 6E0,;& 2#9"$<"">%7W@GfT"6+8GDzàãò¢´´≥æir{]iiGUUm{~ëõ§Üéõ:DPëûßjy|[njcwlktdvj,>01)C*;Z;BdA2T/6X51N/*D)&>(&;*4F6O[O& &/6./90/;/&4'0"7$1I3AXDOfTVk\\n`@MC""
+	
+
+		;5§ëVóÑBC9GI$N\E2G6#8)1H6F_LAZE<N>-;.%!/"5*='%8!3	ds8ãîAôõ:£õ6¢ê,èrù|©â&æü3øü.∫ó!æï¡õÀØ Ã∏#Œ¿+Ã¿.Àª0…π2…∂5æ©*™åπù"ø©1ø™5ø®8¥ò*πó+≥ç ¥è≥êµíÆä§zß}¨Ñ
+Øç∆±2«∏7»π8≈∂54[@9`CClLYÇbaÜgxúÄÄ°åÑ•íÉ•î¢åtò~míqgêhWÄTeêbnögt°hx©hq§_húRTâ9I~.9l!-Z$I#B(BXtKOq>6X&7Q,%<":  =/R(0W(3_*Ap:?n:=k:S~Paã]bé[]çSRáAF~7;o1#R&O%5^40_+?r7D}96r*;w/EÅ9;t-"W5h&K~<VãCOà;HÉ1Ax'Hx.Ow8]{IÉûqç™~lã_JmC=[9#6#(8-1B8QgZD`J4R:/M5*F/:QAPbT[k^Zl^Tk[0H:@UNtàáxçíeyÇPfs$7Hgràú¶ø´∫—õ¨¿¶∑Àó®∫ó®∫ì¶µñ≠µÑûù(.&<'0F14K7-F0&>(0F/,>&4A'NT8ÄÖgdkLHU7CW;!82I,8O27N27O58O5<R;C\FPiSVpUGaF-J.5S78Y:8W7-J+)B$1E,9M4AY?B\A?Y>C`DEbDC`A@]>5R31L+3L.-&4%@X>?^<8\63Y02Y-0Y-0Y/0Y15[6;a<Ae?9X6.G**$3*<&@W=8Q31L+JhF'B#9R55L0)3B-!("3 .G*JjC=b6<b18^+8^-1W&-U!/W#/W#3U"?Skp8≥ßk›…åÏ‹ûı·§˜€úÏÀ~·ºQ·º7ﬁΩ$⁄ø‹∆ﬂŒ ‹œ ›“ ﬂ‘$·÷&‡’%‡’%‡’%ﬂ’%ﬁ◊&ﬂÿ(ﬁÿ*€◊-⁄◊2⁄’9ÿ–?ŸÀFÿ¬HŸæIÿªF◊∫D’ªB“∫<–∏:Õ±3»®-’µ<ÿªC—π?–∂;œµ:Œ≤7ÃØ7—≥;’µ<”±6Õß,øë∑Ö
+∑á≥á∑ã¿ô¿¢Ω§	ªß∂ß¥•≤§≤¢±û≤üØúÆö®ó ™ôØ†≠û≠†™† ™† ≠£¨¢Øß¨§¨§Øß≠®¨ß¨ß´¶ ≠••ü §û©§
+©¶ß¶≠™™¶®¶•§úöôñôîöïõîõîòìîèëåêãäÑ{mo`f Z`$SZ$PW$QY*OW(HP!OU)RV$V[#bg$qr$xx zy|{usfdY[SVYZ gi(ru&yyìë-ãáéàèäóëóíóîóîèãìè
+óêóë†ôüô•û´•	´¶
+™•	´¶¨•¨•≠¶Ø™Ø™Ø®≠¶´¶´•¨•≤© ¥ß%≤û%µï&¡ú4ÿµQÎ…hˆ’xı”zıÕxÛªnÓ°[„éMÏùZ‰û`≤{CZ5/##%'+"/,'!.%2+&"#0'HVVanwiwÇtÇç\jk1?0-;"/<"0=!4C&:I,9F*5?'"*)4&$/"-,5"HQ>$-*6+ (*/:@&58@<#715/40644469?C(:C&9H)9N/=V6;V7:U68S46Q2:T78R58R7;S9)<&%4!*%%"!%)"0+8' ,;(/A+&8"$2!XfWTeS`s`Xo[qàtuàu5H4*>%+B&2I/&<%!7" 3,-+./#9"/E.'@*;XD?[MSfbó•¶°´¥{Éé≠≥øbiqHTR`oléúùô£¨™¥¿¨µƒ∞∫∆ù™≤iyxk|tjzo7I; 3 0F/.H-/N.,K)1Q,3R25O43K5&;*&;,:L@Ue[BMG0967@?PZYDNM4?7*8+#5%'<)-D0<S?H]LN`P<J= *!
+				e],¨ôLƒÆYÄo)VPenQYjZ2B5);/F]KQhVM]P*6,##6#:M:+?&):DT#ÑêDñô@°ñ:ärír¢%™à$∏ñ(∂ìΩõæú»¨Œ∫#œ¬(Õ¬,Ã¡1Àæ4»∫5∆≥2æ©)Øñ√´/¿∞7¡≤;ø´8∫†/∏ò)∫ô(™ãπô"¥ë™É≠Ä≤É°w≤è≈∞3≈∂7«∏7≈∏6BjODlQDmOV~\`àcaäbkîriêsvôÉxõÖqó~póxsõvoòloôisùkÖ∞zÄÆpo°ZdôI_ó@Vé5JÄ,:m ?"GFl3líYHn50P0I!+> #7 9-M&0V'-X#4`+6b-IuB^â[]àZlògnùfJ;Av0&V&R!.W/0Y1/],Ev>MÑAHÅ:<u.#Z U/b:n,RäCNã>Lâ9Lá5KÑ3E{0Fv8Bg;HgEC`A3M28Q;<SC>RG?SH6L?3K;.I8*E2$@*%>)/H53J8;M=L^N>UC6O<6N@9PF;ULCYWM_iWgw}àú§Ø≈éö∞WfyOao{çô~èôqÑä`vs6MC!8(%:'$*$9&%='.-'9#5C,8B)JP4âåqbhL:H.&5E+?S8F^DLfKJbLD]GMfQUqZ`}aRoQ;Z;6W87Y86Y88Z7$C#(?%5H2BZ@>V<8P6:T7MhIB]>9R52K-4O06Q20F/)&3I47T63U23U03X//X,0Y-0Y/4]5:b=9_:0V1.R.<[;.K,EbCLkIKmHKpEEi=Cg;Af:8]1@e9#FEe@-F)
+#0&9#+F'<_5:a2:b0:b.6^,6^,+S!1Y'/W%3S!BPÜáN¬¥w„œêÓﬂûı‚†¯ŸñÎ≈p‚πEﬁ∑+⁄∂‹Ω‡»‡ÃﬂŒ ‡–"ﬂœ"·œ#‡Œ"„—%„—%·—$‚’'·◊(ﬁ◊'€ÿ)Ÿ◊*Ÿ◊-ÿ‘3Ÿ“;⁄ÕA⁄…Gÿ√F’øG◊æG”ªA”ª=ÃÆ2Õ¶/÷≠9Ÿ¥?‘¥=‘∂>“µ=ÃØ9ƒ•0√†,Õ™6“≤;Œ∞6Ã™.À®*∆°∫ì±Å±Ç πè¿ùΩ¢π§	µ•≤§≤§≤§≤£±¢±°®ó ®ó ∞°Ø¢´°™†´£´£≠•Æ¶´¶´¶¨ß≠®≠© ¨ß´¶ ™•ß°üú °û§£
+†ü©•©®ßß£•ü†ññïëìèñêìçòêîéåàÜÉÄ}trbc!Z](RU(OQ)NP(OT+OV,LS)MR*LQ(MU$W_$hk&or#ux!twut"aaVUTT"[[%fh)qt'ÄÄ&óï1áÑäÜâÜëåîêîèìéèä
+èäêâóêúîòë£ù	®£™•´¶´¶©§©§
+™•	Æ©Æ©≠ß	¨¶©§®•
+´•±®¥® Æõ±ïºô% ¶6€∂LÎƒeÙÀs˘ xı∫lÁôQÌòUÚ®aÁ¶bƒéPlF4$
+23#09(&+!,(4  -"1.)+);+6J?]plvâánÅO`V<N82E)/?"3C&;J+7D(<F-+4&	
+	#'-4;);C./7 .6'+)'/)G="N=!O4W3[2[2Z6 V7"R9#N<&PD,JI-?H+=P2;T6:U67Q47Q4;V75P10I,,C)*<&%4!,%&#&2A,1@+)8#"4%4!%2!+#(6%/>+.<H:gufQbR|é~ìááõèf{j8K80C/2213 1-%2 &1! -1!7 6L5%;&?WIKbZí°§∞Ω≈±ª≈°©¥ª¡Õ†ßØNYUhtp•≥∂≥¡ ¢∞Ωæ ⁄º≈‘u~ánzxiyoKYL05O4PoO:Y9:Y9.M./L05O6>V@AVE;PA+=/BSKeutbqvJXcÜî°¥¬œ_luBKP:EA/<3'7*"4$(=,1F3OdQIZJ6B6		
+"$" Éy>≤ûH«∞Pµ§J|r*qvMeq[BNB+;02D4TfVLZM$.%-@-BWD?R>3B+(7wÇ@ìîFòÖ8Öfós§$¨â#∑ñ%ºü!ªü√™À∑ Œ¡%Õƒ)Œƒ/À√4…¿5≈π3∆µ3º©(∞ùƒ≤6ƒ∂;√¥=Ω™4Ω¶2∂ò&µó%∞ï ∫ù%µïØà≥Ñ´y¢x¿ù%ƒØ2ƒµ6∆π7¡∑4ErSEpRJsULuSWÅY\áZUÇY^àdlìxÅ§åÑ´êå≥î~¶Åvüuy¢v©{Ç¨zs†ggôRbóEUç2Oä,NÜ+G})8g!Fs2ZáDZáD?g(B'@*=$8 9+I#Bh9-U!-X"8e.Eq>VÅSR}P\áZO~J?s1F{7:l1#R5`3DoBCr>@t6F}9KÑ=JÇ;1i"5j$:o).fIÉ9Kâ<Kä;IÜ6HÄ5LÄ>O~J\Å`bÇm`{jNe[cwu[mmEYZväà^xmTo`Oj[Sk]JcP6O</G7DZM<QBCUE>S@<S?C\I9QC;SF9MKDU_{àôäï©|áùnzíâò´'9ERekGY[GZV*@4'>,*A-!6#!6#!6#2H31I3'=("5!%6#4A-2>(:B*VZAy}bPX@#	3@&EU;F_BIcHNfPG_I^waE_FKeHKhI:Y96X78Z98[::]<9[:3M2<T:8P62L/0J-5P1<Y:5P15N03L.0K,/J+/H+%=#!81I/3N/2Q/3S,.S**S'0[.3\21Z0.V1-U04Z55[6=`?CgCTxT?e>;d:;e7?f7Ah99c15a.6b-4`-9`1@c;&.!%4!*@)%B#4Y.4^,7b-5`+8`,0X&)Q3[)0V'3OITóíX ∫|Â–èÌ€ôÚ€ïÙ–Ñ‰π[ÿØ1Ÿ±ﬁ∫‡¡·∆ﬂ«‡ ‡ ›≈ﬁ∆ﬁ√„»!‡≈‹ƒﬂ !‡–#·’'ﬂÿ(€ÿ'Ÿ÷'Ÿ’+Ÿ‘0◊—5◊Õ:“¿8—Ω:÷æ@◊ΩB◊æ?÷π;“´4—¶3—®4Œ©4À™6–±<“≥?Õ¨9≈†.¬û, ≠7∆¨3≈´0Õ±4Õ∞2Ã™,≈ú∏ç´É ≠â ≤ì¥ö∑¢	≤ü±°±¢∞°±¢±¢±¢±¢	±§
+¨°´†≠£´¢´£¨§´¶´¶¨ß¨ß≠®´ß ´¶ ´¶™•ß£üúöñ ûùùú§†ß•ßß§¶§•õõîìçãèäèäìçìéäàÉÅokOL@>:876<;FE&PQ/RV1OV-LR.MS-JS(T\)_e'jm&mp!ps"pq%^]MKRQ#ZZ&gi*qr&ââ1ïí1áÑâÖäÜåáèäéäâÖäÜàÑÅ| íã	ñè
+öì¢ú
+ß°ß°©£®§™ß®£	®£™•	™¶´•®§ß£©¶¨®Æ®Æ¶ßö≤úΩ† √£*«£1’ÆIËª^˘¬oÙ≤dÁóN¯•_˘±gÌØfÿ°^ÅX"?,1/+2 #0)*%0)6"%7!%7%7$6 *=)9N;I^OQeYTiZNcPL`E6K,0C%3D$0? #-3;$$+ &
+	.0@>'?9E:J9R;gE,W>îfLùgKïU:îL3êD,çB+âG/ÜL4ÇP9Q:uK3fD+ZF-SI.NM/HM/CL/BO3CS6BU92D*'9!%7!#2,#0'3%#0*9$1@)*9"*9$&5 "1+* +"-+#1 #2"/]i[esdcsf~êÇxä~PdX+?3"7(..+ 3 ,?,'8&%2 *5$%0 ,!3!4/B,#8%;QDñ©•|ãí|àî¿…ÿ™≤øÆ≤ΩºøƒLSL;F>åöõ∆’‹´ª»Æ∫ ßØºéïù_he^j^'5&&9#6S4Ac@LkKDcD7S:,H1<U@AZG;RB@WG(>17LCxãèïß≥oÄíãõ≤óßæàó™ìü´p{Å3AB0?<(70,>24I8NeQTfVGUH&
+!
+2-ëÑ@¨ô:«≤Eƒ≤F©ûBääN~Ñben[@L@-;,5F67E8+7-#;P?BYECXE:I6"-U^)ëéKÜm*êl"õu$£!∞è$ºü'ª£¡¨≈µÕ¿"Œ≈(À∆*Õ≈2Ã≈6∆ø3ƒ∫4«π6πß'ª©+√µ8√∏<¡µ;Ω≠4ºß0∫°-∂õ&∑û'º¢)∑ô!∂è≠~¶w©Ç√ß,ƒ∞3√∂4¬∏5¬∏4?nJBqMFqSEqPGtMJwLJxJTTgèm~•ÜÅ©á~¶Étúyâ±éäØçïΩòéπéã∫Üw™e`óDTå1Oà)HÉ%C~"=w#F.Wå>q§YJw4E"<1 78%D3W)-U!1\&;h/>m7WÇUfêhkòocìcTäPG~=JÅ@*^ 9j2J{CPÑDOàCLà>Là>IÉ9C}3<y+?|.@}08t*BÄ3GÖ:HÑ<Bx:VÑU^Édmå}Ü°úã££wãíí§≤{åûì¶∑òÆª]wx7RK;UJ=XI/J;3K=.C<L_YDUK>P@5J7/E0<Q@EYMJ[U3ADÄåúçòÆò§∫tÉön~óoÄîSeq6JK8KECWK$;))@,!9#4L45O6.H//H21J4*B,$:%):'-:(,7&5>+@H1^dJåíxAG+6@%IW=H\A>V<NdOSiRL`G1H,=U5LfC8S05S19X95V78Y:CdE@^BFcGB_C@]?8W84S38W76U36Q03N-/J))D%&?!"9#7,@$4I(5O*2P*1T*1X,/X,3Y01W.2X31W24Y7<a?AfE?dBRwUFnI9c;2]26_37a39e41]*2a+0_)0\)3Z-$D<W6* 4*A'4R08]14^,5`+3_*4_*.Y$&P1Y'2V&7O^a(•õ]“ø{ÂŒàÏ’ë“âÏølﬁØGŸØ%€∑€ª›æ›¡›¡‰≈·¬›º⁄∑‹∂ﬁ∏Ÿ≤‹∂‹Ω‹ƒﬂÕ#·’)ﬁ◊'ﬁÿ(‹÷&⁄‘(◊–(ÿœ,÷∆+–º)”∑/◊ª6ÿ¿<€øA‘±9 £.À§/“™8–¨:Ã®6Œ™:–™;Ã®6∆•2»Æ7«Æ7≈¨5»Ø8…±7À±6«™,≈ß%¿£∂ô±ê≠å ≥î∂ö
+∂†≥ü
+™ô¨ù∞°±§Æ£	≠¢™°´†¨°™†≠£¨§´¶´¶¨ß¨ß≠¶ Æß≠•¨§ß¢ ¶†¢ùúñ úòùõûú	¢¢§ß£ß§•††êëååäâãäåâèåäâÄ}XR3, *$)")"-(50DB)PQ1MS/JP,NV1MU.RY-Z^+`d'il%mo$ij&\\ LION"[[)ln/tu)ëè8ìé2É}ÖÄàÑÉÄâÜÜÉÄ}|	}z{v åà
+îç	ôì	†õ£û§ü•†§û
+•üß°ß¢
+¶£¶¢¶†•†¶°®•
+©®´™´ß´£¥•Ω™ ∫£!Ω°&…•5‹ØJÁ¨R·ùJÁòM¸Æd¯µg≤g‚™`ók.L5A<7<&5@/'2!%&*"1$6(:"*>%,C)8O5QgPTkQQhNLcG?W78P.0E$2E%=J,1;".6!"!#+
+    H?gU1yW2öjDØsNªrO¬kOƒbGºV=∂L2∑G/πJ/ºP4√^B»mN wYŒ~c…|bºjR≠`FõX>áN3vG-iD)aG,YI/JF+9=$2;&*7#'6#%6#-;*6D38F57E40?,'6#,$1 1>-"/&"&&*,!0-<)\jY]k\|åcsf;K>);- 4)3G<API;H?$4',%6$&4#%2 3>-$-.:&4B+%4':$#8%DXL¢≤Ø¶≥ºπ≈’¡Ãﬁú£≥YX`ûúùHIA/7,Vb`øŒ”´πƒº»÷•´πéëòPRMEN="4:S61N/,K+5R6:V=<XB4O<B_MA^LA\M?ZK9UF<XLKceî®≥§µ…©π“}èß]oÖÑïßÄë°yäöm}ä7DJ*967L=\sa\n`L\O0>1(2)
+	 "	<4úéC≤ü8œ∫C«¥;ªØA™§PëêXÇáiowhBLA,:-,=-):**/D[G:Q?BWDEVD:D+<>ÄvAÖh,éh!†z'•É!¥ñ$ø®&∫®ƒ∑«ΩÃƒ#Ã»'À»+Œ»4Ã«5ƒø0∆ø3ƒ∑4ª¨+ø≤2≈∫<∆º@≈ª?√∏<ø±6ºß0µü(Ω©0æ¶,ªõ$Øà™Ä
+¨Ö±ì¿´,¬∞0√∂4¡∑3¬∏2:hC=kF?kHEqMBqEDtDRÇPZàYaãckìpuùz}•ÇÜ´äû√§òΩûïΩõç∫èt•n]íLRå8Pã1KÜ(IÑ&A~!;z!A|(\ìBWã@RÅ;D9#<"@.N%,P"/U"-X 1^#;h-9f/S~Psûslôpnùo^îZIÅBAx5+_<m5IzBJ~@IÄ=GÄ;?{11k!2l 2q BÅ0Kà:JÜ<EÅ9?x4Dx:N|KW]dÖtò≤ØÅöûâ¢©î´πãù≥ãú∂Ñò±î©ºú¥ækÖÑb}tYuf1L;Xpbexrë§ûãüìYn];Q<0F17I9HXMetqHU[ÇçüvÇòõ™Ωö´ΩÇìßÇì•GX`H[Y9J@:L<#8%":$*B*=W>3P40N4(D+">%(B)+C+1D03B/&3!0;*;D/@H0\bHÑàmNT8ER6EU:?S8?R<FZAQeJOdE=U5C]:5P-5S11O33T75V98Y:6W8:[<DcDJiIEgFAcB3U2.P-+I',G&%@#> 95"71D$=Q..G *I (K!&M!*Q%,R).T+,R++Q,1V46[94Y8<a?JrOLtOHrL4^60[04_16b14`-1`,2a-/[(5_/-T%/R( ;!:*C&3N-:]35]+3^)0]&0[%.Y#(S/W#6W(8Oqr6∂¨g‘√}ÂœÜÓ”åÏ»z‚¥VﬁØ9ﬁ∏%‰√ „¬‚√·¬›æ⁄π€ºﬂæﬂæ·¿ﬂºﬂπ„¿‰≈›≈‹  ‡“'›”$⁄”#⁄”"Ÿ“!ÿ—!Ÿœ"ŸÃ%÷ƒ$’ª&‘π*÷ø3⁄¬:€æ>◊∑<’≤:◊¥>’¥AÃ´: ¶6»§4Ã´8Œ±<À∞;À≤<…Æ;≈¨8ƒ≠9¡´3ª°&¿ß(ƒÆ'¡™ ªû≤ê´å §à ¨ë≤ú
+™ñ´öØ¢≠¢¨£¨£™°©û™ü™ü¨¢´£¨§´¶´¶≠®Æß≠¶ ´£ ´£ß°¶†¶üùóòìôóóîúö	°£•ß£•£§ïñçéããääãâäààÜÑÇkh@;) '%%)!2-CC'MP1GL,KR0KQ-NU,RX*^a,gi*hk(gg)[Z$KHOK%\\*mm/xy-óï@ãÖ-xÉ~ÜÇÇ~ÑÇÅww	yvywÅ~	éäìè
+úñûòüö†öùóûòùóùò	úóûöüõúñõïùô¢°	¶•™©™ßÆ©±ß∑®µ£∑ûøú&‘•9ﬁ§AŸñ=·îD¯™_˜≤dÒ≤eÂ©`≤ÄAtX)WJ*`bJ@I6(# $',"4(<#8L3G[@^rWL`DMdGBZ:+C#>V4?T34G'7D(0:!")"!  (*/"$,#H9nW5ô{UΩñmøäbætOædAªW3ºL'ΩB!√B#ÀJ*”Q1‹W8ﬁ\<‚eEÌvTÌ\ÌÖbËÑd‚}_·y^ﬂz^ÿy]«mS±`EûW;èV9}N4hB+E)6$:/41-0,0+2"*3"(3#"/$"!-))-BQ>^l[4B35C6)9.,</>PBSg\Çïè´π∫vÇÇ?LE#0&,#1$(3%08),3#8@+EO7&4)<& 5"HZL™∫∑¨π¬±∫Àπ¡‘µ∏«[V\ëåà:<1-5(6A9≠ºπåóõƒÀ”∑∑øûöõc_T.0:J0@Y< :#="(D+9U>A\I?ZGA^LB_MD_N?ZK=YJ;WKVnnäû©ÆΩ‘¢∞ÀUfÄuáü¨¿Ÿìß¿ì§æ¢≥«u~çGRV2F;TiX_qcK]O8H;(4(	
+
+   HA°ëCÆó-’ΩAÃπ8¿∞6∑™B¢ôJÜÑT}Åhck\7C7$5%!4!&9&0C0DZEMdP9P<CXEJ[IFP8DD qc4ág.ìk#ùx ™â º§(Ω´!¿≤«Ω…ƒ"Ã…&ÕÀ)Õ /Õ…4…ƒ4√æ.«¡5¬∏4¡∂6¬∑9»ø@≈Ω@ƒº?¬∏<¿µ9º¨3æ´3Ω™1π£)∑î´Ñ©ÖÆè∏°!øÆ,¿≥0¬µ2¡∑1¬∏23[66`:3`73c33f.6i0<o6DvAKyK`äbnñs{†Åè±òí¥õç≤ìà≤åjöhPÑDHÄ5HÉ/DÉ(AÄ%<x>z$B})B}+^îFm°VHv5A	B0S+5])0]"+X/].\4b"2_$2_(=i8R}Ogïg\åZbò\G~=Au5O:f5<f82^-6e/0b'T+c9s&5r$DÅ3IÜ9GÉ9F}::l1=g7MqMZ|dZzm^xyiÖâfÉânäïó´√≠æÿç°πzè¢lÇêe~ÉdÇzBaQ9U?Zs`_sg}ëÖvãzTlVQiQAWBFYFWg\funsÉÉÇíüeuÖsÖèwâìéû´}ãñXekP_\GWL3E5(=*7!/G/4N5+E,&B).L29W;"?#*D+1I32E1,9'*6"5>)=G/'/ciOâçrKT7FS5BU7;M3?S8DX<ayY=U55N.6P3<Y=<Z@<]B;^@;^>;\=;Z:7V66U3.P-$F#%I%C"A"=7047#;)?/E(A'F&I&M!'N")N%'L#&L%&L%.T/,R-0S2KpNMuPNvQJtNBlF6_53\05`2:e71\.5a05_/8b20Z(.U&*J!#A+F'-H)4W/6].4_*2_(-X"+V +S,S4T#;RÉÖD¿∏p÷ Ä‰“ÜÓ“à‰¿j‹≤Bﬂµ/‚ø'Â≈"‚ø‹π‹π‹Ω‹øﬂ» ‰œ$‰”%·–"·Õ ‡À ‚Õ"·œ#ﬁŒ#›œ$ﬁ“&‹–"◊Ã◊ÃŸ–◊–÷œÿŒÿ ÿ¬’æ ÷æ&Ÿ√1Ÿƒ7€≈>◊¿@’ΩC—∏BŒ≥@Ã¨;ƒ§3Œ±<Œ≥> Ø:≈™7«©7√®5∆≠9¿©5µö%ª°*¡Æ.¿Æ(ø© π¢∏ü´í©é ØñØò
+∞ûÆ†¨°	¨£´¢≠¢´†©û®ü©£´•	¨§¨§≠•≠•Øß¨§≠§™¢§û §û£ûûòíç òìòíïí†ù§£•§£°úõëëååâàäáâÜàÜÅÅww^^94+#&#!'!64HH.FJ/HM/GJ+IM*SU-Z]._b)cg*fg.YW&IEMI$a_/nl1ÑÇ7óïBÅz)wqz{~{ÖÇvtnopn	qpÖÑêåóíöìõïöîïëèäíççàãÜèäîê
+íééäëçïíüù¢°•§´®Æ©≤´∑´µ£≤ö∞é∆ú$“û0”ï2€ë:ÁöJÓ•Vı∞cÍß`∆èOéh9[G$WS:<A-$"!#'!/6H2SgNYmT?S8BY=-D("9I`CEY=9I,'5%/%.'/).)-/3CEa`(É{=ßìT√üaŒó^÷çZÃqE¿T0Ω@"¡; ƒ:»=–D!⁄R,‡_5„d9‰e:Âf;ÎmDÈnDÊoEËrLÂpM‚qOÈ{ZÎÄ`Á~`Â~_ﬁy[⁄{]—w\√mT´VAç>-o,^)M(B(:'3'+(%'$% ,
+"*+1@-SbO:E5+6('5( 0%5E8QfWBXLVkd¨ª¿´∏¿\fhYcbT`\?KG0949>7CG949%KS<&2+>(4!<N@ñ•†∏¬À√ ⁄∞∂∆∫∫∆f`bif_(. ;F6VaSàíáY`X®©£¥¨©çÄx|mZH@)6>'2D.5K6@WCD]H@[H:UB4O<1N:1N:4O<;SCH_OJ_VnÇÉïß≥§≥ ®∂—ó•¿≠ºŸ¨Ω€†±œåùª•µŒáê°`kqDSN=MBFXJPbT?QC2@3	
+ PI†èA¢á “¥<“∫6«≥.∏§+≥°=ùîO~|S\aK9E73A0':&&9#5K4H`HE]E7P:AYCBUA@J1VR,}i7Üb&öp$õw∂ô$º®#ø≥¡∏∆¡»≈ ÃÀ%ÀÀ+ÃÃ0Õ…4»√3¬ø0√¿5¡∫5≈æ<ƒº=≈¿@ƒøA≈øC¡π=¿∂;ºÆ4æÆ5¡Æ5ª•+≥êÆä≠éÆï∫ß&æ∞-ø≥-¿∂0ƒ∏0ƒ∏0!B#/S/BkADrA:p42j+2h,0e-=m=^ãbmïsí∂ú£≈≠óª°â∞ërütiúdn•aRå?Kâ4FÖ,5s9t E~/^ñKG6[ëFaïMEs39+R%2\,.^"+^-`-`4e$7g+5b+Am:;g68f5>l;IyE\êRRÜFM|E5%K"$H"$M!(T!3e(@w3Bz/=w*=w+B2GÉ9=v/#WG@3O9c~u~öõå§Æë´∏ï±Ω_zãZnáù±Ãû≤ áú±Äí¶ù≥æ\vsLhZG`MSjVTiZ^sdZq_:Q=CZHZo^\n`và|j{si{{ó©≥Äí†as}I\c`q{ÜîùfsyGUU8G@8J<-B19P<2J4&@'0J18T;3Q52Q2"A"%B$,D,2E//>)'3/8#:B+3;#06ÅÖjw}a>K/>N32D*3G,>R7PdHDX<5I-3K14N54R:6W<;\A8Y<3R3-J+&E%#E"%G$&J&$H$"D#$A"826: ;">'A";)C,K",O'-R)*P'-R)-Q+.R,0V/0V14Z55Y5=c>OuNKtLKsNGqK>i>3^13^15`37b42\.:d66`07a/,V$0V'+K".I(-H'/O(6[/3^)/\%-X",T-T/Q4RGZ"ëîQ≈Ωt÷ÕÄÂ‘ÜÍŒ{›ªY·ª>„¿.ﬂ¡#⁄Ω‘≥◊∂ﬁø‰… Á–(Â’(‚ÿ(‡Ÿ&·ÿ%·◊'·◊'·◊(·’'‚÷(ﬁ‘'ﬁ‘'›—#◊Ã◊Œ⁄—ÿ“’—◊Œ‘…÷∆”æ”Ω‘¿#’¡*÷ƒ2’¬8“ø<“Ω@“πB“∏A Ø:Ã≥=À¥@Õ∂B»Ø;≈™7¡¶3≈¨8√™6ø§3ª†+º®-∫©'∫® ∑¶πßπ•∑û±ò´ñ≠õ	Ø°Æ£´¢¨£¨£´¢´¢©£™§´•	≠§´£´£´£´£´£´£®† §û°ú°õüôîè ïèôì	ñêñì†ù§££°†ùñîäâÖÜ ÑÇâÜ%áÑ#ÇÇ"x|knSP0**#'! +(@?*AC+DG,GG-LM.RT/VY.[]+be0ff2VS&KG$OK(d`1to5ëçCóíArksl{wurÄ|{roll
+igts	áÑêåóíóìïêëéÖÅÉÅ
+Å~yvyvÇÄ	ÉÅÇÅÅÄáÜèèìëóî†ü	©¶Ø™≥¨∂¨¥•¨ñßâ∏í¬ì…ì&‘í1÷è3›ì<Ë†NË†TÿòX∞~IvU,ZJ063 ./!%  !!&(6%TcN;M70B,,@'$;!6M3XlQ^nSAP3/:+5/6)/89YU%àF≠û]≈≠gœ´aŒôS«Ä>¡d)ºNæ?ƒ:–;◊=!€B"·K(‰P*‰W,Ác3Âf3„c2„c2‡`/›_/·b5Áj>ÈkCÁkGÈsOÓyVÈwUﬂnLﬁmM‰uW„z\·y^€qY dN≥T@¢Q<ëM8~F/h8"X/D%.*-5*#/!""#$#1 &7$*;(<K8S`OEPBMWLlyoRbW(:,"7(#7++@9|ãéò•≠fotAKM<HHYeeíõöQWSRUJ,/BJ3*6(:$!4!<N@Ñìå»—÷¡»–πº≈∞Ø¥^YV..$%0 5D1CP>FQ@5>-TWFõïáéÇrs]rjSejVq~mGXH:L<1F7-D43J:6M=7O?<UB9QABYIK`QJ[Qzçâï¶≠∞¿–∂≈‹æÃÊ¥√‡¶µ‘ì£ƒî•√£≥ÃxÅí`kqR^ZTdYJ\NHZJM_O/?2	
+			 QLßóI°Ñ «§0Œ±/À±(√®#±ö&ØûDôëRÅ\KT?=L7.?,1!8/E.4L44L6:P;@R<EK/l`8|b/Ñ^ëhßÜπ°#º≠ ª≤ƒø«ƒ « Ã 'ÀÀ+ÃÀ2 »5ƒ¡2ƒ√5√¡8≈¡<«¬B≈¬A≈¡C∆¬D≈øC¡ª?ø∑;∂™0ΩØ5æÆ4∂¢'µô∫ú ∞óÆõ∫©%Ω±+Ω¥+ø∂-ƒ∏0ƒ∏02< %I%.Y,;q74n17n47l6>p?bëgrõ}¶Ã≥£∆Æíπû}ßÉÇ±Ék°gXëLQã>GÖ2<z%:u#<t)UäFx™mhö]yÆjPÖA=j/>	-W%0[&0`",_6h+;m2NHM{J<j<gïgXÜXO}N<k7;l5<o4OÅFMtG' ?.P-Co>I}?F8DÅ4B1DÅ35o%@y2GÄ9G~;?o53
+-#64xåóôÆ√öÆ«û≥–ßº◊†µ–¶π◊∞ƒﬂæ“Ívã†åúµó®∫ex]qo]sfQhVG[OJ^RD\N7OBH[Ugzt[of^rg[ofYmk{çôrÖñduáevÜl~å{åñXisyàè[kk-A8:O@=T@:Q=8Q;6R;1O53P13R0!A&D"%>!':$6E0:F23;#;A%RY:_fGluZS]D,8 4B+2A,-?)0B,9H1?M4.<"/A)3J09S:7S:1K2*D)*B((B%*I*&H'*L)&J&%G&#B#53="B?=>"A$@9(F"0P+1U//U.1W04Z56Z66Z66[97]8:`;FlEJpINtMDmEEoGDnF9f;/]/-[-5c4/Z,5`23_.6b/0Z(0X&*N""=-H'0N(5Y-3]+.Z%-X#*R-S 3S!9QVd)ùùWÀ¬w€œÉ‰”Å‰ m›øO·ƒ:‡∆+⁄¬ €ƒ‹√‹ƒ›«‡Œ"·‘&„Ÿ)‡ﬁ)ﬁ‹'ﬂ⁄(ﬂ⁄(‡€)ﬂ⁄(‡Ÿ(‹’%‹‘'ﬁ÷)€‘$Ÿ“"ÿ— ÿ—ÿ‘’—◊Œ◊Ã”√–æ‘ø”Ω–∫—Ω ”Ω)“Ω.—æ4‘¿=“Ω>Õπ>Õ∏A ∂CÃ∏E ∂C«∞>¬´7¬´7æ®1¿•2∫†)∂°$∂•#∂®#∂©µ§∂§∂•±†
+¨õÆüÆ†≠¢
+¨£¨£¨£©£©£©£™§©£©£©£´£™¢ß°ß°®¢•ü¢õùóôìôîòìñêëçïëíéóìûù†°°°öö åãÉÉÖÜ(áá-Üá*ÉÑ'wzoqab @>(")"' # 76">@*@B*DD,DD(KL,TT.ZY-a`0ge5WT)MH(RN+fb3zv9õóMåá6slvovqrnÅ|wspkkhkg|yÜÑêåñììêããÄww|{vthhno	su
+uuxxzyÇÅÖÖ~} âá °ú™§∞´≥¨¥≠≤®ÆûØò¥îµåºã“ù+Ÿù/÷ì+Ÿê2‹è=ﬂóOÃéSíb4Y8G5!LC4$"!#$#(#0(5$.=*(:$2F-OcJhz`mz`JT2DK"HO^a(~=•ùTæ≠]ÕÆ\—¢R“éGÀs4ƒY%¿E¬<«9–>◊CﬁJ"·N#„R%ÍY,ËW*ÂW)„W&„Y(„Y*‚Z*„]*Êd2Êf5Ái9Íg=Êb;ËfBÌmJÁlJ‚jHÂnNÁtU‰wXÈÄbÂ~_·}]·}]ÿwVŒqO¿gEØZ;†O2ç?(z3b$A):<.-9%&8"+:%+:%+=',>()<&(;';J7[hWal^~ä~ÉïâÑòåzå~SeW%7)&8,:KE}ããLXX(23*66'33akl>GFOTM6<.6=+-9#,;&!4!@RB7G<åóìõüûííêïîè74-"%4!+>(0D+=Q8;M3<L2emVw{dfhRX[FKSDgsgr~rP\P6B8BND3@62?62B8<MC:NB<PD5G9K]OsÉxhwtlÖ∏ÀŸî£∏°± µ≈ﬂ±¬ﬁ≠æ⁄´ª‘XarKVZ=NFG\KUhU=P<=P=(9'!
+	
+	
+ NL¶ôJ¶à(¬ú-÷¥6ÀÆ&ÀØ'º° ≠ì%®ñ@âÑL`fBBP71B/#4!1&9%.A-0C/*='>L3HI*s`6Éb,åföu®éº™"º∞æ∏≈¿«ƒ «" »&»»*À 2«≈2¬¡1«∆8ƒ¬9»≈B…≈Gƒ√D√¬C≈ƒE≈¡D¬º@¿∑>πØ6º∞6πÆ2ª≠0ª¨+∏ß%±°≤§π≠%ª≤)Ω¥)¿∑,√∑-ƒ∏.16<5`38m57q65l54i5NÄOeîhfèoÇ™èê∑úÜØèÅÆÖhögRàJLÖ>IÉ7@z-Pà=PÖ=Cw5Hz=nùgy®qyÆjI|9>#K/Z%2_&/_!7i*5g,J{Daëacíf\â`nõrnùobí`J{D^êUVàKSÇK!F%0EgDEt@By6;x+>},;z+FÉ64k'<s2G~;J~@=i48)+0etáüÆÀí£¡ô¨Ã£∂‘Æ¡ﬂ¨øﬂãûºªœËFXpn|ó}å£åúqÉá]rkG]QBVKYmbF]U5KHrÑàÉíôTffK`[mÇ{fzyRdpwàö~è£ï¶∏¢¥¬û∞ºì•±ê°©áôùEXV?SJJ`S3L90K89TA2N8/I./J+(C ,F#.C$,?#1A'@L4]gLjsVZaB=F)+5".* -%2 '6#%4!*7#,8"*8'6%7!&9%-1<N830-J,.O0*L+*L+'F'34%@!"A#E ><> D!A;4/M+5W65X76[96[9:]<=`@?bA8];@fASyRSwQOuNNwOFpH>h@;h=9g90^//].3a2/Z,4`/0\)4^,/Z%0V'-K%-H%+F#2R)3[)0[&-X#)Q*P3Q<Pfn2©•^“≈wﬁÕ„Œu›¿Xﬁ¡Cﬁ∆0‹∆#‹…$ﬂŒ&‚“'‡–%‹œ!›—#ﬁ◊&·‹*ﬂﬂ)ﬂﬂ)ﬁ‹)ﬁ‹'‹⁄%ﬂ›(ﬂ⁄(›ÿ&‹÷(‹÷(€’%Ÿ‘"Ÿ‘"◊“÷œ‘Œ“«÷…‘ƒ”√”¡Œºœ∫Œ∏“ªŒ∑Œ∏&–ª,œº2Õπ6–∏<œπAŒªC…π@…∂@»≥>≈∞9æ®1∫°+π†)∑¢%πß'∂™$∂™ ∞°Ø°≤§±§
+Ø¢±§
+Æ°©û®ü≠§	´•	™•	™¶©•©£™§™•	®§ß°•ü§û§û•û£ú°õùóñëìçïèñí
+çâèãçàåâìîùûüüõõññ(ÑÑ ÇÇ(ÅÑ-ÜÜ0ÄÉ,z}&qs ik"VU2-%( '$1.:9$8:">>&@@&EF'LL*TR+_\3da8WS-MJ+VQ1jh8ÉÅDúòQÄz.um$pjnkrpzvtoicf`uqÇãÜíéíéäà~
+tv	prklccdggjnrmo
+or	z{{}tv	ts âÜ°õ©£Ø™µ∞¥≠≤®∞¢≤ùØî´Üπê«úœü#“ô%◊ó-€ï6⁄í>ŒäA™n2r?]4eF12&"#"#""#&3!,;$M]BXhKp~[zÇ[ei7z{?†ùX∑∞`¬∞\Œ¨U‘¢M“è>»r)¿TøA«9Œ8◊<‹B ﬂE!‚J!ÂS$ËX&ÁW%‰T"‚R ÂU#ËX&„V!‰X%Ê_(Êd*‰h,Âm1Áp6Êj6⁄Z+‹[1Âe>·g@‚lFÊrM‡rM›wO‰ÑZ‚ÖZ›ÇUŸ~Q÷{L◊|M“|M’ÇV◊ÑZÕyTΩjJ§T={8%I ^I6A?*6>'.;''9#':$#9"":"'=(SdRbpaoyn_k_\nbuâ}sá{cug4D7%5('7,:J@lyräïëêõóÖéã|ÇÄkplILE14)37(/8%)6"&7$@S@)9,+!+2*14+35*0%<"&=#.E)4M0<S6>Q3>L2AM5@L8?M>O]Pgqfkujhogdkc:D;/;1/:2S`W>ND@PEDTGWeV]hZPZQDPNâñúù©µNZjoèÑïßçû≤≠ΩÕnxÇ?KK:L@>S@EXB>Q;3F2 1#
+	
+		
+ PO¶ôK±è6¶}ÿ≤7“≠(…®≈® ∂ô©í(óå=ml6R\:8G0+:%-/!2):'%4?I.VT.xa/åi'¢Ä)†Ñ≤üº∞¿∂ ¡º √¡√¡√¡!≈¬%≈ƒ+»»2√√1ƒ√5»«;≈∆>»»F»«H≈ƒF¡¬Cƒ≈Fƒ√E√øD¿∫@¿∑@æµ<ª≥6æ∂7Ω¥1∂¨(´¢¥´ ∫±&ª≤'æµ(¿∑*√∏+ƒπ,56!E8c56k33j1,`/0b1I{FZäZaégu°Äé∑óä∂íÇ≤ÇRÖJ;r.@z0>x.Ax4jö^{´qWÜOcí[äπÉÜ∂zNÉ;@r-3 (N,Y"0`".aCv4Fx=SÉOcëciñm\Ü`pùrkõklùf\êRTàFaìTFs<9: =!,P,;j4Cz6B|/A~.4q$8t.,b$(^$@v:K~E4`+D0(',9I©µÕ£≥Ãö¨ƒê•∫ÅïÆ/?``oê†ØÃyá¢hsèï°ªçúØèü¨lÄTib`unSha:NLI\bÄê†õ®ª{âñct{àõôk}}ES`áîßí°¥ú≠øÑñ§G[f>R[K^etÖå]oq[mmF[T8PC2M>4KA_tk_qear_`sW[lJ]mI[kGfwUWfG>K-(5,(')'*,,)'*"1.-#=H7%2"6/I,.M.2Q2-L-66'B#(C"%E $D@A>B E C4:2O18W86Y99\<AdF?bDBeEFiIFiHMpOLrMHpKHrLHuLEpE=h;7e74b3,W)1],.Z)0\+-W%3]+.Y$2Z(2U+)G!,F#/M'1W(4_*,W"*R(N1OARty9≥´`—¿nﬂ∆r€ø^÷∏@›¿4›…,€Õ&ﬁ“(·◊*·⁄*ﬂÿ(›÷&ﬂÿ(ﬁÿ(ﬂ›*ﬂﬂ)ﬂﬂ)ﬁ‹'ﬁ‹'ﬁŸ%ﬂ⁄&›€(‹⁄'ﬁŸ'⁄’#⁄”"Ÿ“!ÿ—’Œ◊Œ“«—¡œæŒΩ”√—ƒ–√—¡—¡—º»≤∆ÆÀ≤Õ≥Õ±"Œ≠*–≥3Õ∏9…∑9»µ<«¥<≈≤:¿´4π£,∏§+πß+∏©(∑©$µ®≥§∞¢≠¢
+¨°´°≠£≠†´°¨§¨¶™•	©§™•	®§©£ß°ß¢¶°¶°£ûüö ùò úñ úñ°õ	ùñôíéà äÜêã	èäåáÜÇÉâà	ììòòôóúö)êé)ÇÉ&~+ÄÅ1}~.wx(mp!ff\\ CA'#%.'*%/-99!68 8:"<<$@@$GF'PM,YW1`^8YV3NM1YX9mk;çãPíçKyu.rk%lemjsptomhc^hd|xÉÅåáëåàÖzx	pq	no`bVYXZ]`bffkfimqqukocerqÖÅúò©§Ø™∞´≤´∞ßØ°
+Øû
+©ê ´é∫õøû∆†–•#◊¶-⁄¢3◊ô2—å/¡z*°ZçG|>^,E%4#
+!$('"*%27D*doOV^5vzGññV´©\ª∑^ƒ∑W…ØP”§J⁄è>—n*√N¬=∆8Õ9‘:Ÿ?ﬂEﬂF·H‚N ÊV$ÂU!‚P‚P‚P·O‡PﬂT›V‹\⁄c÷g›u,„}5›q0◊g(÷a+⁄f3‹l:€o>ﬁxG‡ÇOﬁãU·î\€ìY⁄îX÷íU“íT”ôYŸ¶e›±rﬁ≤u‹©r’òi…{U±^@ã>$z=(T16)%)"02!8$(A+5N8OfTnÄrq}qs}rUbXGYMPdXOcWBRG-;.&4''5(<J=tÄtá|x{pããÅ~|p[WL;7,86)(+.:&,;&3B/!/'#. "-#.$.$8':$'=&&>$6O28O29M1<P52E/-@,6I6SaPXdVjreltgisho{oamadpd]i_>H=BM?V^OÖâ{PPDGG?NMI•ß¶BGJ>HI7EF/ACKZ]cnp8E>4E56I35G1/A+$5"0+%
+	
+	FCßñN¨â7ßy–°/”¶%Ã¶ΩúΩü≤ò•ì-yr$TW*DN3/=&!0),#2"0?D$f_3Äh(òz$Æó'´ò∑≠ª¥¡ª¡æ!∫∫µ∂∑∂∑∂ ºø*¡√1¡¿2≈ƒ8»…?»»B»»F∆«H√√IºæC¿¬Gæ¿EøøEøΩDø∫D¡ªC¿∫>ø∫<Ω∂4µÆ)Øß ∂Æ%π≤&ª¥&Ωµ&ø∑(¿∏'¡π(*O$C G-Y($T !Q!N#$Q&KyHbêacêi{ßÑÉØé]äcQÅMOÉEBy5@x1<s0OÅFnöià≥Öiïds¢lz¨qcïVCt2@2'K,Y 2e#1d!Dw5Bt9YäScëcdëfaécdíc]éVNÄCFz8I|:8h,!L>:7CBq;?v3>x.?y/0g#4h*"RL0`,HwC(R"!F7'&3;\hvO\lYky]o{O`p"0KsÄ†ñ°Ω¢Æ»≤ªÿ≤ΩŸüÆ≈∏…ŸÇïõVjivãÜJ_Z@RTlzÖhsât~ó}àúÑêûxáåbtxP^kß¥«û≠¬®∑ £¥ƒQdsEXfFZeObiTgmtáãqáÖ>UM<SI5KHrÜÑ\liCSH<N65H(8I%=R+AW17M))>/*&,#0 +)*'',#2 / /("!"-7D0);#%=#,F+)F*5 8)A'-H),J('G"#C@?A@D#F"B/71N2=[?9Z=@aDGhKCfH=`@CfFCfEDjEKsN@mF;h?CnAEpB7e66d55a0-Y(+W&+W$0Z(,V$,V$,V$0T(90H(0I)1U)2Z(.V"+S(M1MIXÄÉ@∑Æ_”øhﬂ¡g‘≥Jÿ∫6ﬁ∆.›Œ)ﬂ‘*ﬁÿ*ﬁ€,ﬂ‹+ﬂ›*‡›,‡›,‡›,ﬂﬁ+‡‡*ﬁﬁ&ﬁŸ%‹ÿ!‹ÿ!›Ÿ"›÷#‹’"⁄” Ÿ–ÿÕ÷À÷Õ’Ã‘…“≈”¬’¡œæ”√“≈—ƒœ¬–¿ŒºÃ∑…∞»Æ…Øæü	Ωó»°Ã´*ÃØ1À±6»∞4«±7≈±6ƒ∞5¬∞4æØ0ºÆ+π´$±§±¢∞•≠£¨£™°™¢™† ™† ´°™¢©§©§
+ß¢®£¶†¶ü•†£û•†•†°õôì ñê ñè óêõîïçåÖÄ| Éãá	âÖÑ{y ÇÄâáìíñîõô(òñ/àá*~}*~1xy-su*jl!bd[[ML96&!*#4.;7:888 8:$79#:8BA%IF'SP/[X7VS4NL3[Z;qp@ïìXÖÅBup0qi(ibmimjkef`b_ljzxÇåâáÑzwolgg_`TUTWRUQW[_^cbghkae\`be
+no	Åõóß•∞≠∞´Ø®Ø¶∞•±¢≤û	≤ú
+∑ù
+º†ƒ¶Ã®“™&‘§(’û*œè%ŒÖ&Õ|+Ωm(®]#ïS#zFS/<'
+,"	%#%&#&"&(+15@D!qsD}}A©•\∫≤]≈∂WÀµO“¨G◊ö? u%øO¿=…7”9›> ‹<⁄<·C„G·H·J·O„VﬁV⁄TÿW÷Y—XŒZŒ`‘k€x%‰ã1Èò<Ï°DÓ£HÓûIÌòHÌíIÈéHËëLÌöXÓü]Ô©d±lÎ≤kË≤jÍπmË∏l„∫k‡øp‹√qÿ≈vŸ∆z⁄øx€≤t⁄ùgÀÅTπeA£S8v9&F!*!)1"!2 &?*/L6@]GzïÑáõètÄvÑéÖwÑz<MC<PGzéÖfupERK/;1&2&'5&IUGck^w{mrseom`yuj_[PA=2,-%.BO;!/*8!$(5# .#1  -&-"5"5!"8#$<$<T:;T73L/3K1.F.-C.(>)2C1>J<ai\Z`TS^PepbFQC\gYOUIORG@B4VWGrpc{wk<4)H@5VRI45--2+'1)+$,' +'*""0-?)1C-);%#5%6#$1 )	
+
+
+#%<9°êK¨à:πä.¿ç ÃöŒ§Õ®Ωú∫û¨ìõå-ge*S[48E+$3 *)/"0>Atk0åu%Æï.¥¢"≤®∑≤æ∫¿ªµ≤®®™¨¨´™©∂π*ªæ1¿¡5«≈<…«@À»E»ƒF∆¡IΩ∑E≠™7∏∑AΩæG¿øI¡¿JøΩF¬ΩG¡ºDΩ∏@∫µ=≥≠3∞´)∑±)∏∞'ª¥&æ∂%æ∂#æ∂#¿∏%3_,2^+%Q$NI#J"D#-P/U~Vpöté∑óä≥ï~ßárüvo°lWçQAw9=p5JzFbêax¢|â≥çióiÄ±z\ëMOÇ?,W!+ 
+(,M"1_!8m'Av2I};Hz=NHbê_gïfoûjQÉHDw4MÄ;UÜEN{@HB964AEt@Bx:9p-Au5(W FF F$J!#I %K"$F!#= ' $$*+&66/==:GM-5Hñ†πÆªŒìû¥t{ó{Ñ°µ√›∂«€®∫»ZotÑõï@UPKZ_^gvv|í{ÅôzÄòçï®õßµ{ãòeuÖ∫…ﬁbqààñ∞∞¿◊ïßΩè°πò≠¿lÇçAX^9QSUjkAWT8OI=SPE[YRghg~xAZG9V8)E+J!;[4?_:/O*#>40+"0#0"1+**.!0.& .-<)$5"$6 !4"5!7  8 1#=$,F+0J--J,+H)%D" B><"B"B?!D#F"B.10M1:X<:[>?`CCdG=^?>`?MqMS{VNxPMwOFqF9d79d6>l=Bp?:h95c2-\((T!)S!(R +U#-U#,R#6-);#.I&1U)/U$(P&K0MKZâåGø¥b’æa‘≤P“±=Ÿ√2›œ.›’,‡⁄,ﬂ‹-ﬂﬁ.‡ﬂ-‚·/ﬂﬁ+ﬂﬁ+ﬂ‡,ﬁﬂ)ﬂﬂ'ﬁ›#€’€“›‘›‘€–ŸÕÿÃ‘»’∆’∆‘«‘«“≈”ƒ“¡”ø—ø—ø–¿–¿ÕΩÕºÃªÕ∏Ã∑À¥«Ø¿¢πé¥Ç ∏ÇÀó û#∆†#∆´(ƒ∞-¬±/ø±.ΩØ,∫Æ(π´&≤•Ø¢∞§≠£™°©°®† ™†©ü ´°©ü ©†ß°¶†§ù¢ù¢ú¢ú°õ°ù°ùüöõññêëãëãïé	éáÇ| |zyy}}ÉÉÄ}zwzwÇÅäàêéíêóñ,íí2~~&{|.ww-oq(ik"abXYLKC@40& 
+?9_Z:=97576!46 53;9 CB$LK,VS4OK.NL3]];{{IóïZ}y<vp4oi+hc!ibibe^b^a`nnxvÅÇvsjicbXZPRMNKOJNLSU[\b^aX[OS	]`gjstÖÖ	ùõ®ßÆ´∞¨Æ®
+Æ®
+∞ß
+±ß
+≥§µ¢µ†π†º°¬¢Ãß”ß$◊£)◊ú(’í'”â(ÀÄ%∆Ä*¬Å1¥u.ìXo9W+A#	0)"+&6+G:n`/üíN∫Æ\¡¥T»µLŒØC⁄¶A‘Ü1¡T¿>∆9Œ;€FﬂG‡Dﬁ@‡@ﬂA‰H‡HﬁKﬁOŸT“X“e”t◊Ö!›ñ*Ê®7Í∂@ÔæHÔ¬K»OÚŒVÛ–\Ùœ]˜ÕaÛ«^˘«d¸ k˝Ão˘ pÙ∆nÒ≈nÎ≈pÊ¬l‚¿iﬁæg€¿e€ƒgÿ…j◊Õn÷ÕrŸœvŸ y◊¿t◊µn÷®j’ódÀÅZ≤^D{6&A$20!);%+G0=]FZzeÑüêò¨°q~ulxnsÉxsÑ|oÅÅïß©ÜìôT_abnj&3*'3%)5'.:,~â{îöéäçÇÇÉ}ëêãB?6""#'4 4D*GW<(6#0.0!/(-"5!45 $<&,D,2J4-E/(@*&>(%;&-@,/=.1;0DJ@AG;-3'5=0;C6@F:MN@IF5A9&OG2^[JdaRA;-E>.PI7XRBAA5	%*;(-@*':$':$'8%#0&
+ $70îÇD≠å?ºè4¨{Ÿ¶0 õ∆õ≈ûºö¥ó§è$Ö}2Z\*LZ98J2#7"93K'?P#WXêÖ6®í-∂¢)¥©µ∞π∑æºøº#úö	óïüü££ïï∑π4∫º5√ƒ<»∆?…≈@ÕƒEÃΩF√≥B´ö2úè'∂ØDΩπK¿æM√¬N¿øI√¿K¬ºJæ∑L¨§Bíç'òò ±±+∏≤(º¥%º∂"º∂"ø∑$ø∑$LM$Q K?>/+G.Å§ÉÖ≠äeåoÄßäé∑ïá¥ãRÑQBw?GwChòhlôn]äaá¥çÇØÑÄ∞~`ëYBt58e*7(	-.L&7c(=p-F{5XèKNÇ@TÜGeó\XâQTÜIGw9Es2:f'2[#)Q"G@774#B"S}OHyB%T,[%F@>#E"&H%$H$#G!&H%(E&": #!.$&6,)6-)55+5AdlÅHSgKUnAJi}Ü• ÿÛÖó≠≠¿—Ñòüwéà@SMNW^èï•ñõØbg}§®√¢®¿≠∏ÃØæ—áñ©§µ«\kÇn|ñ•≥Œ•¥—¢≥œ§∫“†∑«Meo?V\`x|avyEZ[I^_=RU;SWA[X5QC,J2+J*-O*:\9Ac@9X6%@6-/"3!$5" 21.--+%	.:,1?.$5"*"5!)<(%8$*$='+G.-J,+H**G)%D$#E  CAA"B%F#C C!F$G#>12,I-6S78W8DaE?\@A^@KjJRvRJpIDmEKvKNyLCn@4b32`/8f7=k::i52^+%O'N'Q*R +Q"!?
+22Q(,R#'M%J6QJXéêEƒ∏b–∏TÀ©;’∑5ﬁœ4ﬁ◊.ﬂ‹/‡ﬂ/ﬁ›-‡ﬂ-„‚0‚·.·‡-‡‡*ﬂ‡*ﬁﬁ&ﬁ›#ﬂŸ!ﬁ”›—ﬂ–›Ã€≈⁄√⁄≈÷ø€¡€¡⁄¬◊ø÷æ÷æÿº’πÿπ’∏’∏“∑œ∑Œ∏À∑
+ µ
+»≥
+…¥ µÀØ •¡í∂Ä ≥y µæé¬õ≈§#¬ß&æ™'∫ß$º¨%∫™#¥ß¥ß±•Ø•¨£™¢™¢™¢©ü ®û ®û¶ù•õ¢õüôúïóíïèñìõïôñôì	ôì	ñè
+êâãÑ åáåÜ
+Ç~xv {ztryy{y
+wuyw}{ÉÄàÜãâéç#óó5ää2yz,ww/lm'ef"]_UVNMA>@<#0,GB$LG)-)1/76"65!4297 B@'JI-PL1JF+ML0b_<äàUêéSyt:tn4ke)d^ d_`[[V\Wderuzz~{onee]^UVNOMMFIDGFKLROUTZLPHMRU[_ehxzèê°†©®≠™Ø´≠©Æ®≤™
+≥©≥¶
+¥§∂°π¢æ§	ø†
+ƒüÕ£—†œô è∆Ü ä“ò-’ú5œì3∫y%¢_âLo>U/F)	D)S5Çc4≥òU«ÆZ ≤P–¥I÷≠C◊ú8Õt ΩL≈;—9‹@‰K"ÂN!€D⁄AﬁB›B‹F‹MÿPÿY÷a‹pËä(Ó†4Û¥@æAÍ√@Ê B„ÕC‡ÕBﬁÃBﬁ—G·”L‚‘Q·“S›…N›«P€¬N‹¬SÿæP‘πN–∏N◊¿Xÿ¬]—ΩZ‘¡[◊ƒ^◊»a€ŒfŸ“h‘œg–Ãh—Õlœ»m—≈o‘√s⁄øxﬂµy€õmÕrS°L7].=01@);YAFfQÅûåÇùévä[k`O\RXh]nyÉíóî¢≠ãò°]hnq}{GTK%3&&4%$2#@NAjvhs}rmtlÇÖ|D@4*(!(#02B(CS8HV<-;"$3-"1#4!(;'#6"&<')?**B,&>(#:&"9%+D/C\G=S>0C/6D50:/2:/28. =H:OWHPQ?KD1`Q:VJ2A>+BC112 =<(EC.A>+%'
+	
+		(6'->,.?,*;(%3"( ""#,' Çr7®Ü>±Ö.ØÁ∏D÷¨& °¬õ¿öµí´êúç2ih'KV,7L-(A#=Y3D_2N`&zv,ßò9≤û+∂§±©∂≥∫ªººæπ'èâêåõñ ìååÜ¶¢'æ∫=»√E…¡B≈∫>¬±;æß7±ñ-¢Ü#°â)∞û:ø≤J«∫Q»ºN»ºNŒΩS¥†?zeP? C: }zµµ/∫¥(π≥!º∂"º∂ ¿∏%¿∏%I"O#P#K8/++B0vïv^Å`dâjz°Çä¥écêeRÇRBqCoôsÄ™Üx¢~zß~ÉµÇ[éU_ëTeï[C+&$)";9_.?m/Dy3Oá<KÅ6Tä?JÄ5I}5L<VÇECh5# 3"? !@ ;853!> :\9$H"!DD!DA>>!A$F!%G$*L)+M**G(.( 2"#5'%7+%41%2;0;O;Da~â©äî∑¨π€ø–Ï]qâxçûï¨≤VkdBQJ^ahàáïù†±©∞√ôûª©∞Ã±ª‘≠º—ªÀ€wàò]ldpàîüª∞Ω›ú¨Õ£∏’™¿◊ñ¶OerDZexéôau~dw~l}ÖXkr-BE.DA*E6-I0-J++H)$>!%< +#%//E0)A)": #: "6"4-
+%# !  ,$>O<$;!.H/-K/*I*,K+'F$%G"%H #H$I'M%L$J$I#HD E#C:/17+C):P9+A*"40D+8R5MlLMqKHqGGrEGrDItFCn@:e74_16b15_/2Y*(O &M'N'N&I!"	 '/J'(L &L%I5PJVñîG»π\»∞DÕ±3€≈3›’2‹‹.›‡1ﬂ‚1·‡0·‡.‚·/‚·.··+ﬁﬁ&ﬂ›&›Ÿ"ﬁ’‡‘ ‡œ·À·≈‡¿‚ª‚ª‡ªﬂ∫‡πﬂ∏‹µ›∂‹µ›≥‹Æ€®⁄§ÿ¢
+◊¶”©	“Ø“≥ÕµÀµ
+ ¥	 µ µ…¥ ±…™«°ºé≤} ≥x ∂{ªÑΩéΩóπõª£¥°±¢∞§≤®Ø¶≠§	¨§´£©°©°¶ù£ö†ñùíôëïéêåâÜ~ |zâÑéäåá	åáéâ	åá	Ñ~É}ÜÅ	ÉÅÅ~}	sqonrqrp	trsrvs
+|yÜÉÖÉçç+ïï;ÖÜ6uu+lm)bb$[\ QTKL @@;9 *(&$"
+#!42#54"4153::"A?(KF2GB,KG,b`:èåWàÑGtm6qj3e`&`\`\XTTPZYdemptrlja`ZZXYLMHHCB?AACJNIPEL=D<AINRW[`gm|Äîî¢†©¶¨ßÆ™≠©
+Ø©≤©≥©∂ßπ¶∫•
+ª§Ω£ºùΩô«ûÀ†Àö óÕõ ”•+‘¨3’Æ7–¢2∆ì*æÅ$∂x%©k"ò[äKÜJùg)»ôQŒ¨S“≤O÷±I€ßAﬁë7«aæ?»9”@‡H‰K‡I€H€HﬂIﬁH‹K◊P—\’q‹á‚õ%Î≠2Ì∏8Íæ9Ì«@Â»>ﬂ»:€…9Ÿ 9‹Õ@‡”G„÷J‡‘J‡‘L‰ÿR„÷T„‘W„–W‰œX‚ÕX›…V›ÃX·“]ﬂ÷aﬁ’`‹”^ŸŒZÿÃ\÷ Z‘ [—À]–Ã`œÃcœÀh‘Õr÷Œ{›ÕÇ„«à·Ø|⁄äe∂bFz=(Q5 CO7C`JxïÉÑüê\tdI^O_ob`pcFSJ[jgxÜèhvÉdp|O\bGVS>ND.>1#1"!/ (6'2C18I76A38<-aZGHA.#($0'6!&8 BR7CS85D-%4$2!):(':'$7$"5!5 4  7##8'-B1Un[SlYQfS7J73A0,8*!+ ')7&IVB]bK]Y@rdJYO4@B*CM5AM7,8".7"%.($				%(4(&2&%%&7$+>*'8%//,,,td0¢}9≥Ü3∑å-œ™8·ƒ<’∑#≈†¿ô∫í±é°ã%Åz*:C0F1P'Dc7Hc.Yf!ûì9±ú/¥°!±¢Ø©µµ∫∫ΩΩ!±´!Åy Äu	ìá!ëíÅ¶ò+√∂F√±A…µEÕµGœ≥Hœ¨F…¶B ¶F«§H¿ûD¿°D¡£A≈•BÕ©I§z$n> \/ L+ Öq∂≠8∫∂.ºµ'∫¥"Ω∑#Ωπ$øπ#øπ#N"R'T!G3&'"4(7T8bÖdxù|îΩõÉ∞áO|QQQ^ã`É≠ÖÜ∞àzß|Ä∞Ädó\H|>YÜM.T#	'&!#"(+I%8^-Fv8I|7LÄ6RÜ<Hz1L~9Ht5,S0
+ 5$>%"?#!>" :57!;  :1#>$B %D""D!C!C$D!C#E %I#(L&/O* 9,/0" 2$!2,#29*7JÉé¨£∞”•≥÷∞¿·•π‘ìßøñ≠Ωvçì>QKIVMWZ_wvÑõ°ØjqÑFLf¨≥œ∏ƒ‹Zgz∞¿œdtÅUetIViÅã§®±Œ∑≈‚´º÷®º‘wåüàõ¨vâò{ëüLboM_kvÜì|åônÄäg|ÅOhd5R@$@)1(!&$%+>+8P:3O60M1+E('@#'>!BV=.$
+
+"!-@,2J0/L0*I*.M-+K&)L$'L!*O#)Q*R ,W"-X#(R -U#-U#,S$,S&!D<00.(-&(4&D"8\6EnDGrEAl?:e7=h:DoAFqDCnA?i;=g97a1.X(1[+,X',S'6	 *E"&J#I%I4ON[ôóD∆¥R≈Ø8‘æ4ﬂ—3›€1ﬁ·2ﬂ‚3‡„4‚‚2·‡.‡ﬂ-·ﬂ,‡€'‚Ÿ&‰’$‚Œ!‚»‰√‰æ„∑„Æ€¢ŸòŸóŸúﬁ°
+ﬁû	◊ñ÷ï⁄ô⁄ô”ê—ä ‘à “Ñ —Ö “ã ”í◊û	ÿß‘¨—∞œ≤œ¥À¥ µ»≤∆∞»´∆¢«ó∫É™m ©l ™v ØÅ	∞à¥ëµó≤õ∞ù±£Æ£¨£™°™¢ß°¶†£ùõî îå ëà çÜàÉÜÇ}{ssqphe mj}y~z|Ñ~Ç|
+{uzw|{~
+~|vskijhll
+olpmmj	pm{y{{ÇÉ%ìì9îìA|}1kj)__#XY UU!MMBA<8,'  $#.+64%414196#>;(E@-B=)HD)jfAéãXxs;mf2le1a\%]X ZURMPN]\hinpkjb`VUPPGJDF@?:;@AEHFLDJ9?7=BIKPV\afqvÑáòï§ü™•≠®Æ©Ø´Æ®
+±®¥ß¥§	≥û∏°ª¢ª°æüæú√ù
+«û—£÷®!◊¨)’Æ+”∞.Œ¨.Ã¶+»û(Àõ,œò1Œî3«á/Ωz+∏v(øÖ3…ò<À°=“ß?‘ö6’à,¬Xø>Õ8ÿ;ﬁFﬂKŸF€JÂUÊZﬂU’R÷_ﬁuËë(Í£-Ê∞,Êª0‰¡3‹¿0›√2‡ 8·Õ:„”?„ÿB‰⁄E‰ŸIÁ‹NÊ€M‰ŸL„ÿKÍﬁTËﬁXÂ€XËŸZ·“U‚œV·ŒUﬂÃS›œT‹“VŸœS◊ÕR“∆N–√P”√R–√S‘»Z◊œbÿ—gŸ—n€“u‹—›œÜ·…âÂ∫ÖÂús»uUñN6nA,RT<b{eå§î{ìÖWn^Wn^qÉwO`Vq}ydruzÜíqådqz=KN,;42B5:L<-?/"3#"3!%8$0C-CR?CK6XV?QO8&+ -!0#54F,?Q7AP9*;("3! 1!020%;&;R>8O;,>.-B3G_OE]MCZH1D1!2 !/ "0#+9,(-@-7I3?I1CF+RL2JF+9A)0@&&8  3 /,+*$
+
+
+			 ()A'/G-7O51G02H1&617e[*öy6µå<∆°F∏ò+·∆A◊Ω,—Æ¡õ∏é≤å§âùê4DJ
+Pd3Oo@Pn:Th)}Ç2¥•>∑°)∂£ ©ûüö
+Æ≠ππæ∫#ßüÇv uf í ¨î4∑û:»≤LÕ∏O’æVŸæW◊∫Tÿ∂R÷∞MŸ±O€µT◊≥U⁄µZ⁄µZ‘±S≈°C«õB∫ä8Øx7ög(äd∑úC¡≠=¬∞2√≤.øØ&¿≥'¿µ'¬∑'¡π&S$V(UB	%<Y=jêkÅ´át†|KyRGtKfìhÑ≤Éy™s^ëV\êRiù]VäH3c'B
+%	#$67\0Ju?Dp5Q}BNw?!G@44'
+6%?&"?#!>"#= !:#= #= &?".4%@!&F!$F!%G"$H"$G%J!%J!$I 'L!*M%'@#&-.! 2$2)"3;Sbw™ªŸ¶π⁄§∑ÿ∏ÀÈì©¡Äó©{ëûH]bI\XDSN?GJÜäï{ÅëyÄìu}î©¥ •≤√KXh{áìdr}^n{YgtV^qáç£Ø∫Œãò´åùrÇíÅë°~èü[q;Q_6IWFXfetáuÜòyåùòüxïë(D62$"/D17P;2P80Q6.L0+J*,K);X9.H-&	!#"%0-E/+H,)H),N+,L',O%,Q%*R )T(S*U+V +V )V+X!,Y".Z%3]-'L %E92/'%-/J+@c;El@FqDFqDItGGuGHsFEpC;f;6a62]27b4<g9=k:Bp?@p<?m<$K*M%" *H"&G#G*K4OWc¢ûE√≤H ∑7ŸÀ7·Ÿ8ﬁ›3ﬂ‚3··3··3‚‚2·‡.‡ﬂ-‚€+‡”$‰Ã"Âø‚≤‚¶ﬁöﬁí	‹âŸÄ Ÿ{ Ÿw ◊u ÿv €y Ÿu Ÿt ‹y›}›’w ‘o ‘l ‘o ÿs “o ‘v ÷~ ◊à’í◊ü◊¨—≠œØ Æ«∞≈Ø∆Æ≈®ƒ†Ωì	ªå∑á±Ñ®z §s £r ¨Äµç±ì±õ≠û™ü	®ü©†®† ßû§õùì çÖ áÄ Å} {y {xvtopkm
+cb[[ZXb`	kjpmxtwtqnonutxwxwqo
+iffced
+ffggjjqmutzz àà0îí?éã>ol)][ XX$WV _[f`"VM9/ TK
+Éy;cW%% '";9*96'52!63":4$?9)=8%B>#tpKÅ}Nke3jb4g_1[U%WQ!QNROWSdaom"ij\\UUFF?A<=8:9:=>BDBG@E8=8:>AFKQV_chkuvÜÜôï•ü´•Æ©Ø®Ø©∞™
+≤™
+≥¶
+≤ü±ö ∏üΩ£ª°æ°¬§¬üƒü	Ã§“®‘©“® Ã§  £" §'À©-—Æ6–≠9Œ®9 °7»ù7»ú9»û8»ù5»ô1…ã(»r¡U¡>œ>÷>⁄A‹E◊F€OÎa Ëb’V	—_	€yÂï$‰§(È¥2‰π/ﬁπ,›Ω,·√1‡∆3‡ 6„œ:‚Œ9‰”=‰ŸA‰›F‰‹I‚⁄IÊ€MË›OË›OË›PÁﬁS‰⁄T„’R‚”R·œO›…L‹ƒHÿ¿F”ΩC“ºB“ºE–ªF—ªKŸ√T÷æRŒ∑M–ΩT’√]÷√d€«p‹«xﬁ∆Ä‹æÄ›Ø{·ùpÕ}Z∞\BçO8ÄqZ}ãt{é{wé~zêÉöØ¶°∂±äúúô¶¨ëûßxÑííû™û©Økwu$4)(:*>UA_vbk|j!/%6#*<&:L4?M48@),4 +(+!2+=',?)%8$0&8(+<,):(!2 !4 '?)KdO\ubEWI.@40F99P@5J9.A./,)>-;P?-B11F50C0/@-4A-:D,PU>:?(5C,/A+ 3!4 0-*.&	
+
+
+			#"(4.H+-J+6P56P5;U:4H,6@SOéw3µñD«¨S∏ù6 ¨2€æ4◊π' ßºì∞à™ä•ì-or%Wi-Rn;Ws9oz.•†B∫¶3∏£#∑©$ôëêåüûµ≥ Ω∏(®õ°çπ¢:ŒµQ’∑U“µQÿøZÿ¡[ÿ¡[Ÿ¿[ÿªW’µP÷≥MŸ∂NŸ∏Q◊∑Tÿ∑V⁄º\⁄æ]‘∏W’∂Y’±Y‘Æ]œ©X»£R∆¢Jøú8Ωò.¬ú/√ü-«ß.≈¨+≈≥+ƒ¥)U%[,Y"2
+;X<^Ñ_iñkXáYPQxßyÑ≤ÉfïaI}?G{9LÄ>>q/.^ D&# 2)G%-P&'M)M@749"=38'C*$A% =!9$>!$>!(B%)B%1$5%C!(H#%G"&K")N%)N%+P'-R)/R*2Q/5!*3!9+2GHg}ä´¡÷£ª”©æŸ¥…‰tä¢xç¢jÄébv}tÜàK[[S]fu|å|Ñóï†∂û™¿ï§∑ù≠º_pzn{Ñboxarzgu~WajFOXbjudlwltÅr|àáï¢fvÖzãõfyàpÉíSfu\mÅ}é¢wåù~ñ†úö&B6-$&4%6K85N82R:1S8.O2)L+,P,.R,0R1'D& 6&%$#%'#9$,F-'F'*L),O',O%/S%*R (S(U(U)T)V)V)Y*Z )Y3_*8b2(M"!A65."$&),?)KfGJlGJpGIrFFqDBm@@k>>i<@i?Aj@>h@<g<9d7=h:EsBCsA@r=EwB9h4Eo?>*K #G!E+L7Pck"ß¢F√¥A—¡:‹”:ﬂ‹7›ﬂ4ﬁ‡4·ﬂ4‡ﬁ1‰·4‰ﬁ0Â€.Â–'‚¡ﬂ±‹õ	’á ‘{ ‘t ÷q ÷m ÿj ·o „q‚p ‡n ﬂl ‹f ﬂh ﬂj ⁄j ﬁs›q€h ﬁi ‚o‚o›j ⁄i ’i “m …q ÕÉ —í–ú
+Àú…†À®»¨«´ƒß¿°	æõ	Ωòªïºñµéµá©zùn ùp ùu ¶Ö™í¨õ™ú©û®üßû•öùì éÜ Ä{ xx st ssmndfaebd^_SS	QQ	UUWUa_fdkjonnnoosptquonjb`^]]\^]c`lirqxw%àÖ4ñìFÅ~9_] UTRPàÅ9¥¨[üîDwk©ú@∫ØUôã@9. " 40$;8)85&71!82":4&72A<{VyrHe^2e\5]U.WO(TM#NJRO]Xie%he"[ZRQGE?=<<5667;;>>AC?D6:8:=?FHSW^beijl	xxäâöî
+ß°≠ßÆ©∞©∞™Ø©	±©	µ®≥£¥üº£	Ω§
+ª°æ°¬§√¢	ƒü«ù	…üÃüÃ° †À• œ¨*œ≤2–∑9Ã¥8«≠4»´5Õ∞;Œ±<ÕÆ:Œ™8À†0»ç'«r¬X M’M‘H÷I€N‰Z‰_÷W
+“Y€mÎé&Ì¢+Ê∞*ﬂ∂(‹∏&‹æ*ﬂƒ/‡«/‡∆1„À5‰–9ﬂŒ6Ÿ≈.€Ã3ﬂ‘:‡Ÿ@Ê‹GÂŸIÂ‘H·–D›ŒAﬂœD›–D€ŒD⁄…E€»G‹≈E⁄æ@ÿ∏?◊∑>÷∂?◊∏C÷πD‘πH◊ΩN⁄¿R◊ºQ’ΩSŸƒ[‹…cŸ∆g›…p‹ x‹∆{‹¿·ΩÉ‚Æ|€öpÃÄ`®fL™äqàÇlÜç{zãylÅrbzlnà}ú≤Ø≤¡∆†¨∏èú¨£ØΩçòû[gcARB'=($=';T?ata#4"$5"'9#.B'/A'(7 )8#%3"-!0&7$$5#2AVEsàwdvfk|l{âx0A.!4&>&B^GfÇlcxi=OA*?01F72G6#6#-+16M9=TB2I51F30C/5G1=L7?M65D-3E/3F0#6"!4 1.+1 -%		
+
+		#%-!;'D%'F&*G+0M10M12K.5D#CFâz5¥†J√≠W…±Oæ†2⁄∏<÷∑)—≠ ù±Ö ¨Ü•ç!àÑ-[gUk-`q-°†F±£6¥ü º®!µ©!ãÑ ÖÄáÇ¨¶π∞'Ã∫>“ªI◊ºQﬁæY›ªW‹∫V€æX’∫SÿΩV⁄øX‹ºW ©B◊∂Mÿ∑N÷µL—±J‘¥O’πU÷æZ’Ω[‘º\◊Ω`Ÿ∫_ÿπ_‹∫aﬂºbŸ∞V—§G”§H«ô9øï/√ü1≈®3∆¨5X']._'7
+9"8#$ %B&lêjRÅKMDdñ[cïZWâNGy<<n18j-8g0$P F-		&'"8!*D'.L*'E!=648%C!%E :!> *G+&C'%B&;"?!'D%,I*)F(!9	%$;+F%)I$,O',Q(/T+$F!.M++H)1.*'3'F'=`B<_KIjaläåÅù®Ü†±{ë©wã¶{å¶ì•π†≥¬wâìbrdqÑcmÜâî∞û¨«©π“úÆ¬úØΩPblbqx\iqaryhwzQ][:EAIRQTY]OTZ{Çåeoyâó§èûuÜñ^qÄ}í£Éñß]sÅzëôc|y:TG2 ,.
+)AVC=YB8X@4V;.Q3,O.-Q-/U.1W0-Q-'D%6'$#&/$<&&C'*L+)M',Q&*P!,T"+S)T)V+X.[ +X*W(X*Z3c)Am8-W) B#B ;!<31J,,()*#: ;V7EdBGmFHsHFsHHqGJsIGpFAj@=f>8c86a4GrDJvEDrA<n9Cu@Aq=Cr>>h6.V$"H$E)I:Okm"¨§B∆∏>÷…<›◊;ﬂ‹7‡ﬂ7‡ﬂ5‡‹2ﬂŸ-„€0Êÿ/ËÃ*Â∫‰¶‚î⁄z“i ÷f ⁄g ﬁm‡p⁄g ›j ‹i ‡m „u„sﬁg ‰k·jﬂo‰x	‡vﬂo‚o‰q‡k‡f‡eﬁc÷b –g “t “|À{ ƒy »Ö ŒôÕ°«ü
+¡ú¬û
+¿ùΩò	ªó∑ò≤ï∑ñ≥í¨àûv ëc ïh £|™ã™î
+™ú¶ù£ù•úùïêä ÉÄ uv lpjmdh_c^c	]aZ]XZPQLLJJ
+LKRNYVcakjecgbngofrkgd[YUR[V`Yb^dalj yu+éä@íêFrq.SQTPõî<≈ºWæ≥I≤¶8ƒπF¬∂H≠ü<XL# 1+@=.>;,74#41 60"6/MG'áXsiEdZ6\T0UO+PJ&NI#OJ QMa^'ca(ROLHFC>:<7844567==??::898:>@GITU\_bfhlorÅÅ	ëé†ö™§Æ©Æ©∞™∞™Ø´
+±´µ´µ®µ•
+ª®Ω¶º£Ω£¡¢	ƒ°	¬ö√ï√ì√îÕ¢”Æ"’≥+’∑1”∏3—∫8œ∏8Õ¥6Õ≥8œµ:Õµ9À≥7»Æ5…´3Õ£3 ì,ÕÑ(Õs% aÕX‘YÂf!ﬂ`ÕS◊e‰~ÁçÁõ!‡§‚≥%ﬂπ&›ª&·ƒ+„ 0„ 0ﬁ≈-€√+ﬂÃ2‚“7·“7‡”7‡◊:‰ŸAÊ÷C„Ã@Ÿº4◊∫2€¡9ﬁ»?ﬁÀA‡ÕC· F·∆E⁄∏<◊±6ÿ±:Ÿ≤=€≥A€∑E⁄∫IŸæK⁄¿O◊¿P›…X„”b·’eﬁ”g‹”n€“s⁄”yÿ–}›—á‡—åÂÕëÂ¡çﬁ©ºÑaßs[´àtÅvdZbMG[BLiMGeIMjVwçä®π¡†≠æï°±¶≥ªVe`QgRCZ>%=%+A,,?+.1$7!&=#,C'(<#+>()<(&9%$5""3!"0!*`rbsàunÄpwàxxÜu6G4"5&>$2P6UqZf}kZo^-?/1C3-?//,,&%6&=R?@WC6M97M85K4;Q:6I38K5.D-6I3"3 !21.,.&5 '
+
+	
+	
+
+!',"? ,K+*L+$B&*F-*F-3K17J.6?{4≠°KΩØWÀ∏Z≈ßG—≠?◊Æ.Œ†—†Ωç™Å¨é öç/kmT_v{'≈¥L∏û%¨îæ´∫≠#ãÇ Ç|{t †ïÕª?ÿ¡M€¡R⁄æS›æT€πN⁄∏M›ºQ”¥HÿπMÿ∑L‹∫O…§:⁄µK⁄µM’∞H–´Cœ¨F÷∂O÷ΩV’æX’ΩYÿæ]’ª^”µ[ÿ∫b‹ºe◊≥[⁄≤[ﬁ±^ÿ©Yÿ©Y◊™W…úGÃ£K!^'_ (Y"$M!1S2@^B<Y=))F*xöu`ãVQÅEEr9OE=o4/a&,[$'S&R"I=
+!#'&%='.F05 $:%%=%+C).H+/J+'B#!< ;:$C!.P+*O$&K""D!+J+(F*%C' >"'F'(J)*L+(G(2&%<"$? *H&$C!/M+<)1*,-"5!$<"1U18`;8a?=eJChWGgbZr||ë§ê™Äë´ò™¿õÆøWjx^ohwéftèüÆÕ¶∑’•π“ë¶π|èùI[eSbi^kqcruXgdFSJ=I?-3/KOPlotw{Ñ^gpéö¶HUfrÅîgyç_tÖràñf}ÉVol5M@.,.#0
+	$3J6?]C>_D9\>3V8,O.-S.0V/2X//U.+J(!;1 !+$:%*D).M.)M')P$+U%)S!*U (S+W",Y"/\#-]!'W(X)Y2b&6f,.])!K?&H#<^9$GAa:Gg@7$=($)3A\=PrMItIItIIrHMsJLsGIrHHnE@i?<g:ItFFqC@n?;k9Bt?@r=Bs<Fu?-X#%K)J,H4C
+vs$∞•<Ã¬?€—>‹÷:ﬂ‹9‡ﬂ9‚ﬂ8‚Ÿ2‰÷/È–.Ë¡&‡®€ì	ÿÑ €x ‹n Ÿd ›c ﬁd€f ﬂkﬁkﬁnﬁn‚t‰y‡p ‹e „i‚k‰qÁxÊwﬂnŸf Ÿf ‹g ÿ\ “R ‘T ‘Y ◊b⁄m◊nÃj  l »s ∆√Ñ¿àºà øî∏í≥é Øè ≥ñ
+≤óØï≥ò∞ì≠ã•|†uõr ïs õÉ §î¶õßû•úüòîè ÜÉ ww jl af^bafae^bWZQRQRPRLMFE@?	EBMKYXa^_ZWOUK\Sd_^ZWQWQWQWQXR\Xgb zw0ääBääDfe%RNüñ7…øPƒπC¡µ; øC√∑=≠°1qe& ("B?0C@1;8)60 4. 3-f`<wPlb?_T6VM0PG*KB%JA"PH$YR([W(OKFAA;<794827387<===775599>>EGQRZ]_bgjrw}Äääöó¶°™§≠®Æ©≤¨±´±≠¥Æµ¨∂¨∑™π©º©º•
+Ω£¿°¡û¡ò¿ê √ê ∆ò †”∞"÷∫+÷ª0—∑.Ã¥.Õµ1Œ≥2Õ≤1Ã≥2 ≥1»±1»∞2«Ø3À≠5Œ©7“°8”ó7÷å3’*÷u$œj…c€vËá(‡äﬁî⁄úﬁ©›≥!‹∏"‹∫#ﬂ¬)‹√(ﬁ≈*‚…/„ 0‰œ4‚œ3Ê÷9Ê÷;‰‘9Á—=Á >„ø7„∏5ËΩ:Ë√?Â≈>›¡9‘∏0“¥0œÆ-œ©.—≠3”±6“≤9÷≥?‘µA◊∫Eﬁ≈Q‹≈S⁄≈R⁄…Wﬁ—^›”b‹÷hﬂ⁄t·ﬁ}ﬂﬁÅﬂﬂá·‡çﬂ›ê›ÿî„’òÂ«ì›∞Ü¡àjì\Gb?,@0 +34K/0M/EbL^tq•∑¡§±ƒmxåü≠∏uÖÑTfV6I3,$7#/B.%8$#6"!4$;!*A'.E+*@)%;&"5!(9&?M<O[M"0#PbRhzj~èwàxWeT4E2+<)*@)5O65Q8;R>5J7)<)#6# 1!. .) )-B/?XCBYE9P<6N89Q;4L67O9.F.1G2$5#0//--1(
+
+	
+
+
+	%4-D(,I*-O.,O/)J-+I/0L52L32F-2>mn,£ùI∑∞V…∫_—∑`—™Kÿ§4‘öÀì«ì≠ÄÆç°è+ãÖ'hg¶û;ª¢,∏ö≤õ¿∞∏≠ëá}r ëÑƒØ:◊æH€¿M€ΩM›øQ‹ºOŸ∏G⁄∂FŸ∑I”±C◊∑Hÿ∂HŸ≥D¡ô*ÿ≤Gÿ±H÷≠CÀ¢8Œß>‘≥H—∂K“ªQ”ºV”∫V—∑X‘∑[◊π_‘¥]‘∞Z⁄¥_⁄¨_⁄¨a·≤lËπsÂ∂rÈºx(g (c#$R!#I .Q09\;GmHB7LiKDg?,Q%,S&9c5!O +Y*(V%%Q %L"E*-$='1O58Y<5V75T52Q2,K+)H('D%!>$?  >#C"G'N".X*'S"-W'(Q%&L'%F'#D'#D'(K+*O-*M,*L+1 (*01(*%+/15 8"< -Q->g=7d94c9;dDEgV`zyáö®~ê§ô´¡öØ¿âü≠PdofxÑqÄìzà¢ú≠…´ø⁄•π“ÜõÆväïTgn^owgtz\hf:E=BNB%/& _cfv~Ås|É_ireq}kxãrÅòqÅöÇî®c|É 96-C6#6#%$
+%*?,3O6;\A?aF9^?9^?0U3,P,0V/3Y0/T+4S1#= )<(!1-C,-G*)I$)N#*T$*V#(T*V!)U .Z%2^)4c,&X&X+] .`%5f.=n7>n:,['*T$Ak;Ak;Dn>LsD=g5Iq?Ci:-H%*&-?)PiKRrMIoFCl@Cj>Dk?Bi<>e8<a6Bk??j<@n?@mBAoA8h8=m;CsACs?Ds=9e05]))K&><F
+áÅ+ºØ?—«Aÿ—;€÷:‡‹;‡ﬂ9‚›7Â÷1Ë ,‰∞ﬂï⁄~Ÿq ◊o ⁄p ‚sﬁm›i›i›i›l€j ‡q·w·y‡wŸk Ÿd ﬂh·j›fŸa ‹d€eŸe ﬂl⁄e ‘W ‘T €^‹`‘[ ‘]–Y œ_ “kÕo  sæm ∫m øz¡ãªê∫ì∑ì∂ñ∞î™é±ñÆñ≠ï¨ë´é£ÜúÅ ó üâ ¶ñ®ù¶†°úöîèâ{ qo ee`aZ\Z^
+_b[^QS
+QRSVRTMNCC;=<;A@KILH;39.>3F=SK\RUNRKSLSLVO\Whd'ut3áÜCÄ}:^[±´I»¿Q≈∫D¬∂<Œ√G√∑=Æ°/~r( $=:+EB3B<.93%1+3.{wRtoIZQ4KA(F:$?28+>2M?$SH(KCE?@;;6:582;5<6<8986566=:@ACELOSUZ^^bmqÄÖÜèéùôß¢®§¨ßØ™±´∞™±≠≤Æ¥Æ∑Æ∏´∏©π®∏£
+ª¢¡§
+¡û¡ò¡ë «îÃû…°œ≠’∑#’ª*—∏*Œ≤*Ã∞(ÕØ)ÕØ)À≠'ÀØ(»∞*»±/ ≥3Õ¥6—≥;–¨:”´<‘®=◊¢<Ÿû:ÿò4Ÿì1◊ç*–Ü‘ç·°#‰¨%‚±$‚∏&€∑!€π"ﬁ¡(·«,‰ -‰«-‰«-„ 0ÂÃ2ÁŒ6ÍÃ8È∆6Áæ2·±+⁄£"‘õ’û÷ß%‘©&”´'—´&“™'—´,“∞4ÿøAﬁÃLﬁœN‡ŒPﬁÃP‚ÕVÂ“Z„–Z€ T›ŒYﬁ—^‹–`‹‘iﬁ€tﬂﬂ}‹‚Ç›‰Ö€·á⁄ﬂã⁄‹ë‡›ö‰⁄ùÊÀñﬁ™Çº{_Å>.G#'9NGï®Æ®∏«•±…tÄòN]pó•Æ'10 %++<),?)$7#-':$':$-A()<&)<O<ì§íäòáuÅsUcVpÄsêÄgxh4B37H8.<-(6'#1"!4!'=(-B/+@--B/4G36G5"0!*8+#'>*+G0]vchÄpCZH5J78M:4K73K5-E/#8%!4!42.0!5$6 #
+			
+"08P66U62S4/R2/R4)J/.L4.G1.A+.<PTöôI¥ØTƒª`“¿l‘≤[«å(€ì$Õá ä∫á
+¨á•ì'õê'ûí&ø´8¿°"µòæ≠º≥∏∞öéùâ—∏D’∏C⁄ªF›ºI⁄πF⁄ªG€∫F◊¥@€∏B⁄πE◊∂Bÿ∑D◊¥@€∞=¡î!‹≤Bÿ∞A÷¨@Ã£7–™?ÿ∏K–∂H‘æO“∫Pœ≥OŒ≤Q“≥V÷µXœ¨R÷±X€≥\—¢T‹¨b·µn‹¥o„æzÈ∆Ñ-j' W#N!#H&0U34\7JuJ=f<1.;!@'K%2[3!K#,W,'R%"L E6		-%>(5V;8]>3X73X73X61V4.T/,P,$F#=%E "B&L,V$0_+.^*+\%2c,.\+&Q$B "E'(K-(K+,Q/,O.0O01!$%"##$+0/!9!'A(;"<C:c79g69i7;i;<dBFbSsâáè¢©£µ¡õØ∏tâézèíj}ÉJZiàó™Åì´Åï≠}ë©îß}ëúVjqduantZea9C8:B7?CFáèëfpr(/5!)4yÅñxÑúyàüï£{óò6TH 8"	
+$6&2K5>\B@cEAdF=bC8]<6[9.T/-S,1W.2W.FeC?Y</"+!9&C$*M#-T%,X#(W!*V!+W"/[&3b,4c-.]&&X-a#5g,<n3>o8GxA@q:)X"7f0?n8M|HM|HGv@Gv@QÄIGq?9W3! ))=$5P1<^9Ci@GmDHoCFm@Dk<MrFCl@DrD@oACpEIvK7e69i7EuCEuC>m9Eq<Fq<6X%1ELSñç0»πD‘À@⁄’=ﬂ⁄@‚‹>Â›<Á’5Ê≈*ﬂ®ÿâ”p ÷c ﬂhﬂl⁄k ŸjŸj÷e Ÿe ›i€j’f ÿl ﬁv‡x·vﬂq›h ﬂh·gﬁa◊W ·d‚gﬁi‡l·k·d
+›]ﬁ^⁄\”U –T ŒP “X’d–eÀb«bø^ øi√|¿Ü	Ωä
+∑ä	∂ç∂ëÆç
+©ç©ë®í®ï©ñ™î©ì
+•í¶ì•ïßú¶†£û†ôñèÖÄ sp mkfg
+]_X[
+\_]`WYVZVYPUMQKNCF;<89=;<7+$
+-"/"1%>3LCSKQKMGPHTLUMYTfa'yu6ãàE}z+¢û;«¡S«ºF√∑=Ã¡E…ΩG¥®:ui'  
+41"B>2B<.:4&2-B>%Ç~Yhd?A: 6+A4#;+3#=,C2A3D:!A: ;5;59393=7<6734076;;A?FEJLPTY\`djny|ÇÇÅÄ
+ìèûö£ù™¶≠®Ø™±¨±≠∞¨¥∞µØ∑Æ∑≠¥ßµ¶∑£Ω§
+¿£	¿ùæñ ¿ê ¿ê »ö °Ã©–≥‘∫%÷Ω,÷ª,”∏+‘∑+–≥'œ∞$Œ±'œ≥+œ¥/Œ≥0œ≥5–≤6œ±7—≥9”≥<÷≥?÷±>Ÿ∞>Ÿ´;ÿ§6◊ü0’û'⁄ß(⁄®%›≠%‚∑*‰º)Á¡.Ëƒ.Ê≈,ﬁø&·¿'‰¬+Á≈.„¡,‹∏&⁄¥%ÿØ!œ° òÃó◊• ﬁ≠*ﬁ¥.‹∂/›π1€π3·º8‡ø<‡«F‰”Q‚⁄U„‹W·◊Tﬁ—Q€ÃOﬁŒT‹ŒT€ÕS›”Z›“\◊Õ\ÿ–c⁄◊n€ﬁw‹‚~€„Ä⁄„ÜŸ‚â⁄·ë‹‡ñ›‹ô·—ñ„∑à—èm¨VEg+Sbe®∏≈¢±∆ö¶¿îüªäô∞vÉì!'& +3A0$5"%6#<M:+:'->+,>('8%^o_éúãêüån{jeradraváuUfTPaOarbp~o*4)!+ !2"#6#+@-6K87J7(;(#1"+)9,+;. #4$,D.7P:tå|bzjXo]OdQI^K4I62I5/H3-D0+B.(>)&<''=&&<%,C)1"
+
+			/I.6U63T57Z<2T9,M2*H00I31D01@!:AíîK≤ÆU≈ºa—¬oﬁΩl¿Ç+Ã}–~ÀÄ¿Ñ±á¨ó$§ó$√Æ7»Ø0¥óº¢æ±ªµ∏Æπ© Œ¥;‹ªH€∏D⁄µ@›∏C⁄∑A‹πAﬁªC’≥8Ÿ∑<ÿµ=◊¥<⁄∑A’Æ7“•.¬ì⁄≠:’´;’´=–®9“¨=÷¥FÕ≤A–∂G’πNÀÆF“≤Oÿ∂U–¨NÀ§IŸ∞X‘ßR–°QﬂØcﬁ≤i÷ÆhÈ¬„º{8n4F&K*+M20U4=gAFuG?m?%-8#B#*N*(Q)"K#1Z0'Q# G @
+$#	!;")G++N05Z;2Y:5Z;1V72W81Y71Y60X3.W/*Q%>2Z&-Z!/_#0a).a(3f-8k27h00_+GC!(K**M,+P./Q04!$"('#%'* 3 4!9!#@$&C'=!=B2[/;j66g07h17c2BdANgQRf]ë°†åüôYmd_shFYUWfmdtÅj{çsÑòuÜöãúÆzçõ`t}ar|Vej^jf.8-+1' )+*$('""[`sáúãö≠á†ß{úï;^J/L0$
+
+	
+	"0#1H48V>?`E>aC?bD>cB;`?3[8.V1+Q*0V-1V->\8SlN 2"'+!;&E#-R&.X&,X#+X!*Y#.]'6e13b.+Z$-]#2d'6h+4g.9j3@q::i3+Z#-]#:j0Ar:GxAHxDHxDL}FFw?7^/%=#!&0/L.KmJIoHBkA<f8;e5U|MS}OGtIBqEFsHFsH:h9<j;EsBHvE9g6KzFHt?Gm4>RQU†ó0Õ¬Dÿ—B›ÿ>‡€?Â€>Ê“5Êæ)‡†ŸÉ÷n ÷b ÿ` ﬁf€g‘b ’c◊b‘] ”] ÿb €g €j ‹mﬁo›nﬁp‚r„pﬂe ŸZ €Y›Z Âf	ÊjﬂhﬂjÊnﬂ]	◊RÿS’R“Q —S —R’XÕR¡E øB øDºG¿U¡dªiµm¥u≤yØ|ÆÖ	®á©é	®í®ñßó®óßò	§ò¶ö¶ú•û¶°§°¢ùùóêâ~z olgg``[_\_Z^TXRXTZQVKOEJBDBC>?=;72,$."0$+*"4-IC!TM!PHPEPEQETIZR!hc+~z:çä=áÑ%∂≤F»øJ∆ºA»æCÀ¿MÆ¢@SI+"!1+>8*@:.<6&2-`[>{wRfb??7".">0#?/"7%>,A0 ;.>3!=5";5:495:6:6737395989:>>FHKKTWbeouy|~ÅÇÅÜÑîêúò†ù•£´ß≠™±Æ≥Æ¥∞≥Ø¥ÆµØ∑Æ∂¨∂©π•ø¶¡§æúøó√ñƒî≈ï…ù	 •Œ∞—∏‘º$÷æ*÷Ω,’º,”∏)‘∏(—µ&–≥'œ≤*–Ø*Œ≠*–≠-“Ø/”∞0Œ¨.ŒØ2—≤5”¥7’≥8‘∞8÷Ø8’±7◊±6‘®-‘ß(›Ø(‰∂,Ê∑)·≥"‡∂"ﬂ∑"‡∏#„ª&Êº*·∑'‹Ø"ﬁ≥&ﬁ∏)‹π)·¡0·≈5‡∆5ﬂ∆6‹«8‡Õ@·–B‚”FÊ‘J„”H„◊OÂ‹S‚⁄Qﬂ’O€ÕHÿ«E’∆E÷…I÷ÀMŸœS€’Y›Ÿ^€÷`ÿ’b⁄ÿk‹€q⁄›tÿﬂx€‚Ç€·á⁄ﬂãÿ‹èÿÿí›“í„øã€†x«pUê=-?
+!ú≠µÆΩ–¶¥Œù®∆ñ°øô•øbm $""!,(5$CP?+AN=4A06D3/=.N\Mkzg`oXgu\drXFV<PbHH\CPcMsÑqü¨öFL>7?2P^O@RBTgTqÑqm~nBPA"0##3&&;*)>--?//A1,B-OfRjÅotãyawb[qZpÉo*?,6$8%7$6!52010D+'9#% 
+		+%;$,K,6W82U52U77Y>1R7*H0*C--B/1A&,8ÉàFØ™V¿∑\–¡lÿπiŒïH |* mÀo
+¬x∫á≥ò#≥£*Œ∂8Œ≥.ª¢ø´øµ¿∂ √≥(‘Ω=”¥?›∫F‹∑B⁄≥<‹µ<Ÿ≤9€π=‹∫>÷∞5◊±6Ÿ≥6’±6ÿ±8œß.Õû(—†*◊®6Õ¢1”´:’Ø@’±AœÆ=–∞?“¥B”≥F—ÆFœ≠I–¨KÀ£DÕüG”£N–ùJ‘•S·≥e€≠b›ÆfÍµs—öY0^0C.R65Y?3Z;>kDBvF/^0!E-!; 3Q55X7D$J#/U,+R%C2,&C$*L+%H'1V43[91X92Y<1X;1X;1X9/X61[5/Z/+W&J0`&6h)4h&1d)/b'8n28n28k01d++Y*B%I%*L+*L+-J.' #*$(%%).!4!%;&&>&"?##B#!@ > B!!E!-T(4`/9h29h1;f1@d8KfEbua^o_fwgZl\QcUfzql~Ç9IVzåö~èü~è°Ñïßí•≥pÑègyÉxáåami)3*"$!$&!%'3`hsUdk`yvJmY9`A8W5'
+
+ &9&9R<EcICdG@cC<_??dB;c@5]8/W2-V.,U+0U,;[4"=PdI*-2%B#,O'.U&,X#,X#,Y"0_)5d.3c/(Y"*[#/a&3e(9k.=p8Dt@JyEKzF<i2'W3e*Ew<At;Ex@K|E>o82a+!F(&"/$7!E]CVsUIkJBhA;e75_/PzJKvHFsHGtKDqHHuJ=k=9g8BpAGuFAo@GuDEt>Hl/BQcb≥©:÷…F›“B·÷@„÷<‰Ã4›∑$÷õ’◊o ⁄f‹fŸcŸd‘_ œZ —\ ”^‘_ ÷aŸc‹hﬁo‹mÿg ◊f €k ›m‹i ‹e ⁄^ ŸX ⁄Y ﬁ]‹` ﬁd‹dÿ] –K ‘J÷N“M €Z	ŸZ	—R J ≈F æ? ª9 ª9 ∫> æLøYπ\ ∂b µgØg≠nØ|ØÜ
+Øé¨î©ïßï¶ï	ßò	•õ§ù¶ü	§ü•†•¢£ûüôïèáÇurjh``X\W[X\TZRXQVIOEJFKCEABAB???:5/-$1(,"!"	82ME RI OFH?I<L@PGYQ oj2ÜÉ<èã2•†8≈æJ»æCÃ¬G…øNãÄ$:/ +%'!2+:3#<6(;5%=9 toRpkKXS6.'&5):,!7&@."=-</<3$;4$:3 :5:5:67373<8;:;;::?>JJNQ]`nszÉÜÖÜÜÜãâíéñìûö¢ü¶§®ß≠©∞≠≥Ø≥ØµØµØµØ∑Æπ¨∏ßª£¿¢¿û	øó¬ï¬î¿ê «ôÕ§Õ™–≥‘ª!◊ø'’¿)÷æ*‘∫'“∂$‘∂$“≥%“±&”Ø'–´&Œ©$ ®" ®" ™#À≠)Õ±,—∂1–µ2Õ±3”∑:’º>ÿº?◊µ:ÿ∞6’™*ÿ©%ÿ§›©‡±#Â∏'ÂΩ(„ª&›µ"⁄±!€≤$„Ω.Á«4‡∆1ﬂÃ2„“:ﬂ—:ﬁ”=ﬂ”?·◊D‡ÿGﬁ÷G‡ÿIﬁ◊Iﬁ◊I‚€M€‘HÿœF€ÕF›œJﬂ“O‚ÿT„⁄Y‡ÿY‡€]ﬂ€^ﬁÿ`›ÿc›◊g⁄÷jŸ÷k◊ÿp◊‹x÷€}’€É‘Ÿáÿ⁄èﬁ◊ì‚…ê·ÆŸÇd©R>W-ôß∞©∂«Øæ’ù®ƒö•¡õ•æíõ¨&/4#,)&!+6(5@2(4&
+*6*@L@dpdZdYP[MTaOYgPYgM[jMQaFUgM`rZhzdzâtàîÄAJ9,4%<J9CVCH[HSdRn|mo{oFRH:H;0B2;P=ataCVCsÜr]s^lÅnÜõàg}hcyb]s^AVCBWF>UC<UB<U@3L6'?'32$7! /#
+
+
+	$-E+7V77Z93V6.Q30R75V;1O7,E/,A.0B(*9jr7®£RºÆU≈µ^–µdÈπo Ö:Õq…jπj∑~Ωú(ø©/…Æ-¿¶µ°¡≤ƒ∑ÃΩ,◊¿>ŸΩB–≠7‡πD›µ<›µ;€±8◊Ø3ﬁ∏;›∑:‘¨0◊∞1’Æ/“´,ÿ∞4”©0“§,’¶0—¢.Œ°.”™8Õ®6“≠;Œ™8Œ≠:”≤Aœ´=œ™@–≠EÃ¶C‘©J“£I—öGœòF◊ßS‹≠[‘•Uﬁ™_ﬁüZÕäF@$ G*5\A1Y>:fEAqI?sCBqC(Q).8$B&%H'(N''M$%L 'L B=%E%J!&L%"H#4Y77\;3Z;2Y<1X=4[>2Y:0Y71[5-[-)Y%+\$1c&2f&1e%6j,1d)4j.9p6:p66l21d, N"F  ?#=") !*/''&(* 1 35(E'-O.&H%"D!#B"$F#*N(.T+*Q%(O"8b29`16V/Hb?QdHWiOew]cv`g{oqÖÉuàèi|äç†ØÉñ•ê†çûÆõÆΩí†Åìù:INãâ#-%.3-CMD" CXGAcB<c7/S'=1L+<U8)1J-*E&0K,&@#=Z<AbC>a@=b@9_:9a<5_90Z40Z2+V+,U+4Y.5H_B9M216$D3X,-W%(W!*Y#0_)8g01`)'X +\$3e*:m2;n3>q6@r=DtBIwF@l;'R*W 6f,<n1Cv;>t85i+1a'1Y'#A(!)6$*9$)=$,B+.F.4N3@_=:d63_,IuDJuGFsHP}TDqHN{RErG<j<@n@GrEItGDp?Iv?Gg(R]ÖÄ$¬∑C€ FﬂÃ?‚…8‚ø/ﬂ≤%⁄û◊â’t÷l Ÿl€n	’g“dœ\ ÕZ ‘_“` Ÿiﬁn⁄iŸh ⁄k ◊k ÿi ÷e ⁄i €k ‹i ‡m‡m‹g €^ÿX ’X ÿ\ ⁄_”S œE ‘G ’K ÷Q‹Y’TŒL –P—W
+…Q∆L«N¬Q¡V¡]∫\∏_µa≤c∞h¨k¨wØÖ´â®çßê©ì
+¶ï¶ößù¶ü	•†§ü£†•†¢úüò	ëä|whf ^^VYTXQWORLQMSIOGLEIDHCFAB@@@<<7/(*#*"%
+)$A;HBIC!C=C:D;H>QH![T&up6èå?§üA√ºJ ¬F…¡D√πFti=2 5-	.(6.;4!93#:5"MI.|x[\X?0+(/%1$7) ;/#>5&>6);5%94!:5!94737576=:??==>@MKaagklqzÇÜ}ÄÉÑàâèèëíììõòùõ†ü££®ß¨´±¨¥ÆµØ∑±µØ∑Ø∂¨∫™Ω•ºû
+øõ	¡ô≈ô∆ò∆ñ≈ñÀü
+Œ•–´’∂÷Ω#◊ø'’ª&‘∂"‘µ◊µ ’µ$‘¥%—Æ Ã®À™À¨ ≠!…¨ »¨$Õ±)Œ¥+Œ¥,Œ≥.–∏4”º:‘Ω;÷Ω>ŸΩ?Ÿ∑9◊Æ0◊§'ﬁß&‡Ø&ﬂµ#‡ª%ﬂΩ&›æ(ﬁ¿,ﬂ≈0„À5‚Õ6ﬂœ4·”5·‘6·‘8·÷>·÷@‚÷D‚÷D‡’E‚◊I‡ÿIﬂ◊F‚⁄K·ÿKﬂ÷K‡‘Lﬂ÷M·ŸR‡ŸT‡ŸW‡ÿYﬂ◊[ﬁ‘[‹–Zﬁ—^⁄–]⁄–a‘Ã_œÀ`—œh—÷r‘Ÿ}◊›áÿ‹è€ÿë‹ÃéﬁµÅ⁄åh∂`Id"8"irw§∞º≥¿—ß≥Àó£ªô•ªñ¢∞%,2(%* ,):*4E51?0(*!-:3LWQ`g`W]SZcRYeQJXABQ:QbOao^@L>:E5EN;HT>KXD+:%):'.A-<R;h{eÇè~ÖêÇ~àÄvÄw[iXds^jydSbMgyaMaHG^DXnWZp[=R?3H70E42G4/F20G3-F00J17Q6#9""5.%	
+
+
+
+	37V77Y87Z:5X:0Q61O52P8-I3*B,3G.,=OU%§õPµ§LΩ©R‘ºf‡øp◊£W‘Ö6“z!√s∫zƒú*Œ¥9À∞/±öº≠≈∏…∑%÷¿7€øAﬁæE—≠5‚∫A‹≤9‹∞5Ÿ´1⁄¨2›¥8⁄≤6◊Æ0÷≠-–®%“™'’Æ-–©*‘®-’ß/Õü'œ†*÷¨6Ã£/”´9“≠:–Ø<Ã´:Ã¶9Ã¶;“∞E‘ØG÷¨J“°E»ê;ŒîB⁄¶R–†KÕùH‡ßVÿìHŸåF)J5,O9<cH0[=@nJ?oGBvF8i:&Q&?"@$,J.,O..T-%N"&P""GA$D&I$M!!L!"J%0U30U3/W52Y:2[=5^>:d@6c<3b6/_--`(.a(3i+5k-3j)5i+-c'=s93j09o5@v<>t:5d0=''
+$."3!*+)').5"<!1P16Y8.R.'K'&E%)K(6Z4.T++P%+P%)N",P$?[3YqMLb>K^>j}_pÇltÖ{{ççxãíâù®Ñö•~íùé†¨Åì°Åí¢xâôÉïü*9>dnm9?;	
+	!T`V%)6M0>a7;c1:`/;_1=a54W/(H!:Z3:Z35U0:C]@@bA8\84Z5;a::c;3]5/\5/\5-X--V*/V)'J *C#VmP$;!<(H3[)-Y$)X!-\&5d-0_()X!-_$0b'3f+6i.9l1;n5<n9@p>,W)F"M0[#;k/<p0;o/0d$4h(6c*(H!+8&+='+?&)<&%;$&>&#@!3]/>m9JvELwJItIJwNKxQKxQGtK9f;?j=FqDMxKDp?QzBJd#ig§î4œ∏F€æ>€∂1ÿ¨%÷†◊ñ‹êﬁÖ€v
+⁄o◊m’kŒb À] ÀZ “_’`“` ÷iŸn◊f ⁄i‚s·u‚s‹k›l›mﬂo„sÂw„s‹e‹a‹e„l‡h◊\ ‘Q ‹T€WÿU◊V“Q –N‘V	ŒT∆Q W \ƒZøY¿^∏Z ¥[ ±\ ∞_∞d®c †f ¶w§~£Ñ¶ã§åûã ¢ìßùß†
+•†£†¶£¶°£û†öñêÖÅsqji^`PTJP
+KMHLHMEMCJDH@C=@?@BB@=<93-% & '!!0)MF):45173=7?8D:LA!SK$c])}y0ùò<øπG»¿C∆ø=æµ<uNB D=@9>6E<8283hdGokP83 #*!8.%@8-?7*=7+;5'96%63 728495;8>;@>DFOP]\jiqtuz~ÅÉÖÜâääããäãâäççíëîîïïôö°°™©Æ©¥ÆµØµØ≥≠µ≠∂¨π™∫•πû	Ωô¡ôƒò…õ…õ…öÀú úœ£“≠ÿπ ◊Ω"÷∏"’∂ ‘≤’≥“≥–∞—Æœ¨ŒÆœ±Ã∞ À∞!Õ∞$Ã±$Ã≥%Ã≤'À¥*–∏0—π3”ª5’Ω9◊º;Ÿ∫=ÿ±8€™3’£(⁄´'„∫,‰¡/‰∆0‰…2ÊŒ6‰—7·—6›Œ5›Œ3‡“4‡”5·‘8‡”9ﬁ–;›œ;‰÷B‚÷D„◊G‚◊G„ŸF‚◊G„ÿJﬂ‘G€“G€”J⁄◊Lÿ‘L÷“M◊œPÿÕQ’«M‘≈N”ƒO”»R” U’ÀZ”Õ_‘”g◊⁄s◊›{ÿﬁÑ◊‹äÿÿé€–é·æà‡òrΩiOx.!D)"#;BHR\ehqÄàî¢ìü´Wbh'&(&8(;M=7I9%2(%)%=IGfqsÑåécgf`c\X^POXGZgU`q_wázë°ñzÉ~=D<,4%5C,4F.)@&*>%5-C,j}gvÖr`l^FME[bZT_QZeTdq]FU>?Q9;O4;S9LdLvãx6K:=RA5L:7L9$:% 6!32331&"*!
+0.H-8W8;\=8[;5V92P6.L4+I1/K4-F00F/*<"<DêÜA¨öFº©Mœ∫_⁄¿l‚πi„°SÀ}*»yøz≈ó'«ß.ø§!≥û¬µ≈∏Ãµ)ÿª9€ª@ﬁ∫@÷Æ4‡∑;‹Æ4⁄™.÷§'÷¶(€Æ1Ÿ≠0ÿØ/ÿ≠+’™(◊¨*”™*–ß)—•*–¢(—†)’§-◊™3Ã¢,“©5—©7“≠:Ã®6Ã£7Õß:œ™?œ®?Õù; ì8«â4“îA’üIÕõD’°KÿõHœÅ7Œw03VB3YB7_D:fE;iDDtJ@qBBtC;i;=#D%(G(+O+(Q'!K J!GB?%J#MI$N&'O*#K&(P+*R//Y54^8=j?=o>?t>*`&&\ ,b(0g-3k,1g)5h-/e);p8:q87n5Av>?r9!K'
+#,"1+++)-6&@%(E)5S79\<3V5.Q0)H(1P.0T.,S'+R%.T%2X'?`1TmC^tM<U.Jb>WjNÖñÉÅéÖáììÑìòù∞∂wåçQfgYlprÖåsÖìrÉìÑñ†=LO%$#	MZQ$4)'2"8O32P*<a58`.6^*9_.<b3)N"3Z-8]17\02R+%.F,;Z:6Z47]61W.1W.4]51^7.[43^3-X+*T&/T)!?>W9QiI'A2V(-X#,[%+\%5f.-^&&W(Z._'5f.9l3>q8>t:Av>EuANzIKwF&P,W!2_$4f'4i%0e!4i%<l.3[)1
+
+#. +<*-@,,B++A**B*+H)El@MyHKvIHsHOyQLvPMyUGsOHuN;f;CnAAl?KyJLvDPs;Vf'{k∫ó;‘©@Ÿ¶1⁄ü'◊ïŸå€à◊Ä◊{÷t‘o–jŒcÀ] œ^ “a‘c“` “` ⁄p€qÿg ﬂl·rﬁr€l ⁄j ‹l ⁄j ·q‰tÊv›m ÿh ﬁn›q‚vﬁrŸj ÷` ◊^ÿ\”U ”U ‘V“SÀM ¬G ≈N Ã`ŒjæYªWπU ∂V ∑`≤_ ≠^ ¨b´jßo•xßÅ¶á®ç
+®ê§ë¶ö®û	ß°•¢	£†££•¢	£üüôöî
+éâ	}zwtlkZ\	NRGLDIEJAH>D>DAD?A<<<<;;;::6)'#%F?#lcB0*
+&"1,>6PE'WK%]S qj"¢ù?√æIƒ¿;¿º4∑≥-õí{r	voiaLBTI<3C>!vqTD@'+&"FA;HA7A;/>7-<6*52!307295;7@;EBJJPQ[^fgnptxuz|ÅÉÇÑ}ÄÅyzstxzÇÇÇÉâä
+íîüû©ß≠©≤≠µ∞¥∞≥≠≥≠¥´π¨ª™øßºú	Ωó¬ò…ù…õ õ ò»ñÀúŒ¢‘Ø⁄π ⁄ª%Ÿ∫$÷∑◊∏’∂—≤‘µ—≤—±–≤œ±Œ≤ œ∞!ÀØ  ± Àµ$—∑,—∑.—µ-Œ±)Œ¨'”∞0”∞2‘≠4Ÿ∞:ÿ∞7Ÿ≤3‚º5È…:‰∆0‚«0· /‡À0⁄«+‡–5‚‘6ﬁŒ3€À0ﬁŒ3ﬁœ6‡—:‚“>„”?·”>‚÷B‡‘@ﬁŒ=ﬁŒ=›Ã>÷…<Ÿ–C‹÷J‹ŸL⁄◊LŸ’OŸ“PÿÕO÷»K÷»M◊ÀQŸ—UŸ”YŸ‘^’‘^’’e”÷k÷€w÷€}÷⁄ÖŸ⁄å⁄–ã€ºÉ⁄ôoΩnPâ<*Z =$$!%%#-,/:6,%* '*<.?TE?P@*8+
+.<?çö¢©≤ªõ†¶ÄÇgidhnb]hXS`OdtgqÖzì¶¢º«…S]\/=0*=')B%-H)3L.&=!+A,:O<AR?:H7'9F5K\IH\CG_EIaI]u_d{g9N;?TA?TA:M:$7$ 3/-. 2"3 '"$7#'>$/"93'$%;&8U97V76W8:[>9Z?3Q7/M5-I2*F/.J3/H3+A,6Aok.´úKª®L…≤T’Ωe‚ømÍ≤g«Ç4ŒÅ%œá!ƒê#ªî≥ñº™¬µ≈∂œ≥+◊∂5ÿ¥9€≥9’¨0‡≥4‹Ø0◊ß'ÿß&÷•$Ÿ©)÷©(⁄Ø-’™(’®'’®'œ¢#Œ°$—†'œú&÷£-Œù&—•,—ß/…ü)Œ•1÷Æ<«ü.À¢6—®>–ß;«õ2«è.«á-…É-–é8”õD–úFÿ†Mœå>—y2“q-;aJ:bH:cE:hD>nHBuJAsBCsC/]/;!@ 'F'(L($M#IHF F9(M!$M!"M &Q&&P((R**T,)S-,V.0^06h36k3:r5(`!V*a'+b(.d&-c%/b'.a(:o9<s<D{D:q87m3 L6
+ (-/++./5!9&C',J.5S7AbC;^=2U4+H)=,N))N%.S';_/Bc4Li;XoE[pG;T,B\5SkK}èyÑêÑëúîò§†åùóVj_>RIDWUyãè~êútÜíì¶¨.<=" $% !"
+=J@:J=	#58S2;^48^/:`/6\-8\.9_00V'6].4[,1V*#C+7*I'3X/1W..W-/X.2[13`91^73`5.Y,*T&-T(#E ,J(WpP@\61X).Z%,]&0a*/`((Y!*[#._'6g/9l3;n5:p6<q9As>GuDEo?-T%F,W3a#.c-e3h"6i'4_)=
+	!-!,:+3D22E1-C./I,V{RUÄSPzROyQMwQOySOxVNwULvP;e=EpE@n@LzKQyGSn7ej*åo#¬ê7œò3”ì'ÿê!ŸâÿÇ‘z—u—r—pœlÀe _ Õ\ ‘a÷f÷f’c ⁄i‡v	‹rŸh ÿg ‹mÿl Ÿk ﬂq·vﬁsﬂoﬂlﬁk ﬁk ‚rÂwﬁs‡w‹t›s€oÿh€g◊`’\÷\”YÕT»O «U Àd h¿]¿^Ω[ºaøk	∂hµi≠h¨o∞{∞É©É™à
+©çÆó¨ô™û
+®°
+®£ß§•§•§•§£ü†õ	ôìçâÅywqqehVZMRGMEJBF;A:@?A>>;;;;;;:9:920&##.&PI-PI,$	2*]R$j_)_V{s ≥ÆH√ΩCæ∫4ª∏-π∂+¥≠)≤©0¿∏IØßDÉy$j`H?^V(ZR-("540PMHIE<HA9D=5;4*74%63 83:4>9EANLSRY[dhkn!qs mposvxttttoomooqprtwz|Ñáíîúû¢°¶§≠©≥∞¥Ø≤Æ¥ÆµØµ¨∑≠ª¨¿¨¿•æúΩòƒõ û	»õÃùœù”°Õûœ¢⁄±‹∑!›ª$€º#€º#ÿª!ÿπ ‘µ‘≤‘≤“∞Õ≠…© ¨Ã∞ Œ¥!—∑&”∑(“≥'“∞(—≠%—´&Ã•$Œ®+”Ø5÷≥;⁄∑?€∑=€∏6‡¡3ﬁ√.·».· .‡À0‚œ3·—4‚“5‚“7‚“7‰’:ÊŸ=ÊŸ?„÷<ﬂ‘:·÷>„ÿ@‹—;ﬁŒ;„”BÂ‘FÊ◊J„‹N‚ﬂP‡ﬂOﬂﬁP‡‹T‡ŸT›‘Qﬁ”S€“SŸ–Q’ÕP—ÕP“–U‘‘\“”^”’g‘◊p”◊v”÷}ÿ’ÑÿŒáﬁ¿Ñ‰•yœÄa†O<h(F*,#  %",!+02E20E2?VD?TC7H8#1$ *,fr~~äñ•≠∏y~ÑÑÜÖjmfrzmÜëÅZgVL\O;NHïßß≈œÿZei1A6-C,6P38V4=V8;R6(;'.A.*=)3D1/;-
+	$)7&)<(/E.AYCE]G>V@=U?@XB>T?7J7#6#0,,.*! 
+ 	.G*2M,)D#"=8.%#-1N2:X</P33T9;YA6T<-K3(D-+G0-F1-F1,C17F)HKõìJ¥£I√´KÀ∞W€∏dÂ¥h‹ùN„ö>Ÿî-≈è"¥å∏ûøØ¿≤√≤À≠'’Ø0Ÿ±5⁄±3ÿ´,‹¨,ﬂÆ.Ÿ®'⁄•%ÿ£#ÿ•%◊¶&Ÿ©)◊™)‘§$÷¶(’£(‘¢'‘ù(Àî’°+…ñ Œ¢)œ•,Àû) †*‘´9≈õ+Ã†5—•:œ£8Œö4—í3∫t≈'Ãä3—ôB–òC÷óH∆z/Ãm)œh&BjP@kO8eD=lH=oI>sG?sC7g7F8;<"D#JHHG%M6'J 'M$%N$'Q)-W/0]4/\3/^41`24f14j.-e&.f%+b!R%[+a%-a#+_!,_$7j1Av@@uACyE@w@B|AFvD)H)"119$D>20&-';"(@&-J,3R34S4<[;BfB8Z7*E&4+F%1O)Ab7Dd5Eb4Pi?VkBVkDD_4Fb9UpMiÄcoÅg~åurÄi`nWBP92A.<IBÄêêÉñú|ëñï©™$!! ! &2(HYI+-6&D 3V.9^2<`06Z*&E.J$6U,7X-7[/9]18X13.3P15Y32[11\1,W,)T'-X-/\1-Z10]4/\1+V),U)+P')I$1O+JjA0Z(0_)1`*,]&(Y"(Y"(Y"-^'1d,8k3;n5<q9>s=<l:)S#CB!I*U+\.c.f0e1^#,P$/
+
+	
+&$.# 1%=#\~[YÇZWÅ[Q~WP|XPzVPzVR|XQ{UFpHBoD@n@JxJV{H[j3vh)†r%≈Ö-Œå+Œâ!œÇ‘É”|–x–s	ÕmÃi bÃaÕ_ –]’b◊g÷f Ÿhﬁmﬂp⁄k ÿi ›nﬁr◊k ‹s ÁÄ
+ÁÉ‡w‹i €d ÿ^ Ÿb ‚o‡p⁄g ‹k÷j ‹t€u◊qÿm◊g‘_’`“a…Z »Y »\«`ø[ ¿] øaæd¡m
+ªl∏m∂q	∞p∞wØ|´¶Ä©Ñ¶à´ë™ö	©ü	´¶™•©¶¶¶
+ßß¶••§°†
+ùöîíÖÑ}}qtfj]bU[RWMQHMDHCF?@998876:9:988441/2-8192(%*" ld%¨¶R≤´Pñë-õî*º∑Bƒº=ºµ0ªµ-¬ª6≈æ<∆æA«øC∆ΩFΩ≥D°ò1~toeA6 & CB>OLGLGCLE?JA<B92=7+<7$=7@9HCQMVU\\ \_bebceg`cdeegffjjijqs{}~Åwz{äçòö††§£©ßØ´≥∞≤Ø≥Ø¥ÆµØ∑Æ∑≠ªÆæ≠¿™¿•¡†√û…†Ã†	Œ°
+—§‘ß“£Œú‘¢⁄Æ›µ€∫!⁄º Ÿ∫!”¥”≤”Ø—≠Àß»§Õ™—± ‘∂$“∂$”µ#”Æ!–©—´"–™#Ã§Œß$“Ø/Ÿ∑;€∏B€∏Bﬁ∫B◊¥6Ÿπ0ËÃ:Êœ4·œ/‚–2·—3‰“4ﬂœ1‹Ã/ﬁ–2„Ÿ:Êﬁ>ÁﬁA‰ﬁ@‚ﬁ?Ê‚CÊﬂF‰›FÂ€FÊ⁄H‚÷F‡’G‚›N·‡P‡ﬂOﬁ›Mﬂ‹O€◊O›÷Q›÷R÷“M”ŒL‘ÃM’œS‘“W‘‘Z”–[—Õ_—Œe—œk“Œu’Œ~ŸÀÑÂ√ÜÈ©{“Ça•P<n*D&.%%"#+,0,C);S;AZDAZG8O=8J:1A6(66Åéñçñ•}ÖíÜçïY__x}vai\S[LÉé}vÅpQ]OHWRî¢•ïù™dmv3E99O89R58Q3RfK_qW2A.->++A*1G01?.$
+&$0"'%.?,AWB<T<8R99R<@XB0F1#6"/+*) 3+H*(G%(H!-K%-K%$B80$  ","?#;Y?<ZB0N6.K53P:4P9.G1)B,.E11H4,A.1A&9Byx8∞†Kº¢E…ßP”™X‰µg÷ûKﬁú<·°7√êºóΩ´ø¥√µ «≤#“±.’Æ/◊Æ.ŸÆ.€´+‹´*Ÿ¶&◊¢"‹¢$÷ü Ÿ£%÷£&”°$ÿ¶)’•'”£'”ü'—ö%ŒìÃë“õ&–ü(Œ§+—©/≈õ%Œ°,–•4«ú,Àõ/Õö/»ò,—ú6Ãã-∏r∆É*”ì;–ó@…å;œÜ9øi ∆c Àb!ItX?lM<kI=oJ<qG>sG;o?)W);45=D$KIHM#O?=#I &O%1\15b74c75d87h;6h57m17n-/h$+d *c#Z#W'[&Z*\*\!6i0;m8G|F>u>E|C<v;Bt?'
+ .9R4KnDFn<NyDR}G-S 4X**I +/<-O.6Y8=_>:^:<`:EgB0L&,D 5K$>U)Hb2Ic3Sm@awPQe@Lb<Jf=Cb8UtKcYOeAK_<CT2=N,<K*9G-2C3_shyêàråÉbwn$* %?P>(;%%> 5U02U+0T(%I,M"*F&*E"/M'+K"1P'4S**H$,
+66X5:`97b7:d<9c;4^6-W/2\42_60]62_61\//X,)N#A"B/T(/[(0a*.]'$S$S'X!,]&1d,6i1<o7<q9>s;EuCGuFLsD*N !E(N'S+\/d /f"/b )V#F+	
+
+
+
+(6%LdJY{ZS{VXÑ`NzVQ}YO{WPzVQyVVÄZFpH@mBAoAEsE\zHgh/Üj)≠u(»Ö,Ãä)Œâ"œÖ‘É“}‘{“uÃj»`–e—bœ^ Œ[ ◊eŸi÷i ÷g ⁄iÿg ◊h ﬁr·u‡t÷j ÿl ‚y‚~‚{›j ◊` Ÿ_ ·j‡pÿj ÷c €g Ÿj ‡v‹v÷p’jœ_ Œ[ —`œdœh gÃi«c¬^ «f¡eøgµa ´] ≥jµs±s∞w±~ÆÇ™É™Ö´é¶è®ö®°™•	¨ß™ß
+©©®®•¶£§°°ùúïíää|sxkp`eU[TYQVORINIKFD?=;8764365977575 94 ;6"83 %#		'!of/ÆßO√ºQ≈æLƒæF√ΩC∆¡C≈æ:ø∏3¡∫5∆ø:»¡?∆Ω<Ω¥1∏Ø,≈º=≈ΩA¡µE±•C|q"F=(# "#FEANJGNIEOGDOFAKB;D>2B=*C=%ID$QN%VT$WV TSWWYYVVXYWXXZ^_ghoouvy{y{x{uxx|ÉÜéêóóöò†ù©§Ø´±Æ≥±µ±µØ∏ÆπÆΩØæØ¡∞¡¨ƒ©√¢≈†…¢	…ûŒ°‘•⁄®÷£–ú–û	◊©‹µ›∫ ﬂº$€∏ ⁄µŸ¥Ÿ±÷Æ◊ØÿØ◊±"’Ø ”≠—® ü üœ•—™!‘¨&‘≠*–≠-œ≠2Õ≠6Õ¨8”∞<—Æ6‘±/Ê«9ÂÕ5Â—2Â”3Â”3„—1ﬂœ1·”4Ë€=Êﬁ=„›=‰€>„›?Ê‡DÊ‡DËﬂFÁ›GÁ›J„ÿH·‘G‡’H„ﬁO·ﬁOﬁ›Mﬁ€L€’I⁄“I›÷QﬂÿSﬁ◊S‹”R›“V›—Wÿ“XŸ‘^”ÃZœ«Z” a‘Ãj‘ q’»y◊¿z‘¨oœã\ºiGïA)e#>$)%%%$*,1+D'1N0>ZAA]F8Q<0E4BSCWg]o~Å≥¡ Öèõèò°òù†zÅz{Éxbm]AL<\gWîüéù©õwÉÖêñryâzÇçDSL;P=-C.<R;]oWjydJVB(5!-D*2J21B0(!*"- %0=L7AW@:T;9R<;S=-@,1.+0+'71S.1V+1T*1U)0P'+I##</%"+5L2>X=>ZA:X@8T=2N8)E/.J33L6.F0,E/-F0/G1,C'3EZb)®ùN≤òA»§N–£PﬁØ_›¶SÕé1‚•;œû%¡üøØøµ√¥#»≤(”∞0”™,÷´+ÿ®(Ÿ¶'Ÿ§$÷ü◊û⁄†"ÿ°"Ÿ¶'◊§'œú—û!ÿ¶)“†%÷ü(Õí’ñ$œê”ö&”†*Ã¢)Õ•+√ô#Ãü,œ°1 ö,…ï(∆ê&«í(—ò1»Ü(Ωw â/‘î<»ä7 á6«x+ºa»g"–m)IvY<kK>mK<nI8mC8l>7i8/Z-318 B(O#'Q!I L$U&U!<7&L%:c9:h:8g97f88i:;l==o:9o15n*0i%-f",e +d #W R#U(Z*\!/b':m44i1G}CAw=D|?D$( 9SsLS~IOCLÄBQÖETáEPÉAJz<?l5$K%L 5^4AkCJtL;e=FpHHmBDa3:R L_(Vh.ew=\o8hzPrÜaeyVWmIOkCPoENjA`|S>Y00M!.M!/L 9R(BX24K.-G,*G+1N24N3"(+ 5@0);%4K12K.0K(8[18\.7[-0. 7#<-K).Q'0T(-I#6*8+K&.R,=c>AiD?gB?gDBjGBjG?iE9c?5a=:g@9d9/X,'L!@D/V)0\).])'S&R)U +Z$-^'0c+3f.7l4:o7?q<Ao@GpD=b6%I$H&N'S,\-a(_0b'7f/4`-:_43N/.	" 3XuWU{VUWQ}YSÅ]KyUQ[QzXVÄ\V~YKuM8e:FqDGnA`tCwh/ïl*∫Å2Àã1Ãç,Àå%œà ”Ñ—{‘x–nÀdÃ`—b—_Ã[ —_ €k‹q‘j ”f ŸjŸj ⁄nﬁrﬁr›qﬂpﬁn€k ‡u‰y·r÷f ‹l „u‚y›v Ÿm ⁄k €j ‹m’j –c —_ ŒX ÃY –b—kÀlÕsÀq j j»jΩa ∂\ ≤[ ∞a µl¥r∞rØv∞|¨{ßÄ ®à ´í´ö≠¢´ß™®´©	©©	™™
+©©•¶ü¢õùñóçéÉÑvyptkoafU[PWQUKNHJHIGE@=;8958462847383:5!:5"93#1.#! IBØßVø∏Næ∏>∫≤5ø∑8≈Ω>ƒø=∆ø;√º7¬º4ƒΩ8»ø>»Ω=∑≠*®ûµ´'ª≤/ø¥4¿∂=π≠?†ñ5mf2,  +,&CB=IHCKGDGB>IB<JC9GA5LG4KG,IF%KI"JIKIMKNLQNTR[YZ[^`ijonjmpquurrmnoqtv	x{ÑÜííúö§°´¶Ø´±∞µ≤∂±µØµ™πÆπÆΩØ¿∞¿Ø¬≠¡ß√•	»£
+…†Õûœù”†	€®€®◊£÷§Ÿ™›±ﬂ∂‹µ⁄±◊ÆÿØŸ≠Ÿ´Ÿ©ÿ£÷û—ôÀìÀó”§‘©÷¨$—¶#∆ù≈ü" ®-œØ8”¥?‘∑B÷µA◊∞7Ÿ¥0Ê»4Ë–2Á—0‰–/‰“0‚‘3Á€;Èﬂ?Á›=Á›>Âÿ>ËŸBÍŸEÎ÷EÍ’DÎ÷GÊ’G‚”F·‘H‰ŸLÊﬂQ·‹M‡ŸK‡◊L›—Kﬁ–M‡”P‡”QﬂÕOﬁ O‡«Q⁄√O‹ÀY‹œ]ŸÀ^”∆]“≈_’∆g◊«p◊¡u”≤o”üf‘á[æhEïE*^$;(&($*!,1+D'2Q13T5B`F=VA*A-FXHmzpâïìâòüò§∞Ñèïïü†ü•°yÄxâîÜq|nPZO=I=ñ¢îÇéÇ}âáÑèïáîãìûkwwEUKDVJM_Om{jÖíÄXaP1>**A'3M45J7 2"'"-#+$24&.7$?R<;S;6N82J4&9&-,/59X87Y46[22Y-4[/4Y.1V+0S))I"";-%!#.D-A[@9U<7S<7S<4P9.J3(A+)A+-G.-I0*F-*F-+H*6R*Tf2ïîQ•íEºóFœ†N€´Yﬁ™W÷òA‚ßCŸ´3»®!¿∞øµ"¡≤%»≤+”∞0—®*’•'Ÿ¶'ÿû!◊ú⁄ü€¢‘ùŸ§$€™*’§$—õ–ö’¢#–ö’ö"ÀäœåÕå”ò$ ñ œ£(À£)…ü)À†-Õù.Àó*…ê%¿Ü≈è%œñ/√~ºuÕã4Ãä4¬{)«|+√p"√lƒm œw->mM6eE<kI;mH9lC:n@,\,<-1>)M)*T&)U K$S([ 'Z"69@;a<@k@;j<<m>;m<@rA;p8<t35n)1j&,e!(a,c!UK"O!Q(X2d'/b'5k/8n2Dz>7m12^-,*+F%Z~RMzANÇBPáFLÖATåEPàAOÜBK?IxAGs@BpAFuIGuNErIKrFPr@]v<|ëNì£Zñ§Wó§\óßhÅífyçj}êrg|[XtLPoEMj>PmA/J)F,K6U)<W*Id9C_7(F "B+J!1L)&
+! !#&$-AN:5I.)@#)B$4O,;\18\.9Z/'C!5';"&?"3Q/5X05U,4N+(@ $?/O(,Q(2X/=c>>fA?gBAfD@eC?gECkI?hF;gD;gC=g?3\0*O$? E.U(.X('S "N'S(T*Y#/`)4g/6k3=r:@r=DtB@j<@:!E F$L(U-],` 5i+:m4<m6<m6>j95Z1&C$' 
+	&4=\<\Ç]S}UO{WRÄ\P~ZN|XT}[QyVRzUR{S7`6IpDKj>go>Åd,¢o-¿Ö5Ãå2Õå.Àá$…~»t…l g
+ cÀ_Õ_Õ^À\ œa ÷iŸn◊qÿo⁄p€o⁄n€o‹r€oŸj ﬂl€f ◊d Ÿj ﬁr›q◊k ‡r‚w‡|ﬂ|€v ◊m ◊h Ÿj ÿk”f“_–[ –_–eŒm∆n Ãx v¡f º_ æb √j¡iπe∫k∫q≥o¨n Øv™w®z ÆâØîÆù	Ø¢Æ®
+Æ™	≠´	≠´	¨¨´´©©•¶††òôéèÉÑ{}lpad_bZ^UZSWQTLNFHDEGCA=;8?;>::695514/4/72:4$=9-<8,'% ph)¿∑ZΩ∂Bµ≠.∞ß&ø∂3«¿<∆ø;¬ª6¡∫5∏±,≥™'º±3≈∫<∆ª;øµ2Ω≥/πØ)∑≠'∏Æ+æ≥5æ≥?≠£Axp'.&33+@?:DC>FC>D?;F?9KD:LH<NK8IE,FC$GD!HFJGMJLGLHWQ`[#`_ff om"mloovw{{~|ÑÇÉÖáäçéììõú§¢©®≠´ØÆ≥≤∏µµ∞∑∞π∞∏≠πÆ∫Øø±¿±¡Æ≈Æ≈´ © ¶
+À†–°	ÀôÕú÷•‹¶€•€•€ß⁄´ÿ´ÿ©÷ßŸß’£“õ
+–ó–í	»ä å–î“ú”§œ§Ã¢»ù °#Œ™/“≤7’∏@÷ΩF÷ΩIŸªIŸ¥A÷Æ2Â¬4Ê«.ÊÃ-Î”3È’4È◊7Î€=Í‹=Î€=Îÿ<Î”?Í–?ÍÀ?‚¿8‚¿:ÌÕFÔ”LÓ‘LÏ‘NÍ”OÁ’MÁ◊NÁ◊PÊ’Qﬁ…Iﬁ…Jﬂ Mﬂ«K‹øG⁄πE›πIﬁ∫L⁄ªO⁄¬VŸƒ[÷√\⁄»d⁄«iÿƒn‘∫m–≠iŸßl‡òh…zQ¢V4k18%*,%..(?#4Q25W6<]>8V<6O9':'gwjUa]@NQr~äï°≠ÉåëãñíäîåÅçÅ|à|r~tÇçÖâîågsifsjÖììéõ£ù§¥ÄáóäêÉèèjytuÖ{ëùìr|q^eUDP<*A'4N56O<3J:/)#.&)-34$53$&*3B-9O84J5,B-"3!**%=#1P08\67]44]14[//V*2Y-1V--P('E! 9-%)-E+<V=9U>0L3/K22K5.G1)A)#=$'D(+I-,J0/P1Cb@SlBÇãT†ïU¥íK öNÀñJﬂ§X‹ùM‡£Fÿ¶3…ß"¿Ø#æ±$¿Æ&À≥/œ¨.“¶)–û!Ÿ¢$“î÷ñŸù›¢ ÿ° ”°◊¶%”¢!“ú–ö’ü!œò‘ò ŒãÕáœåŒëœò#Œ†(Ã¢)Ã£-À†-…ô*¿äŒë&»â…é&–í-ºs√xÀÖ/√*ºt"»{+¬o«r"≈r"Œ{+@oM7fD9kF;mH=pG0c81`2.Y,49&G(.T-0\++Z$L(Y!)_!']#E73*I*<b=@mB=n?>rA?t@:q74o+3o)3l(.g#'^(],^MH!L&V-_"0d&2h*Ay:>v7:p4#O$
++0N*YNIy?Dx8K?MÑCUâISäINÑFOÖITáLTÖN=n?CsKBpLGoJVsEó¨q§¥iøÕu∑«d•∂PñßIñ®\ÇñeÅîtxãmavW\xRNnELk?A^2.D3$99O+4M#C^1A^22Q%$E#B/I$+$!$ 39+-9%3C)FZ?0G*#:&?/K#;Z0-I!6$<#:2*E$9T1'@ 23/M'0U**Q%-T(-S**P)+Q*/U.2X14\7;c>=gC7c?;iD<i@;d:+P%3
+@-R')P!%O&R&U+Z$/`)7j1:m4:m5=p8?o;Bn=;`4#G C$H H'R/_!2e#2f&2f(6i.9l3;n6<l8BpAKtJFhE1L- 4!0"		'$8(E&QtSYÅ\S}YT~ZU[R|XS{XS{XOwRRxQDi>Kh<Wh<pj:íg2¨o.√Ç2Œà0–Ö* y«lƒ`«]À]À]Ã\Œ_Ã_Œf‘o“m’q‘p”m Ÿpÿoÿl ◊k ›s›qŸe ÷` ’] ”] ÷j ⁄r ·y€s⁄k €m ‹u „É·Ö◊y ◊o ◊k ÿm’j“fÀ_ Ãb Ãg  k Õv–|≈q æf º` æg ƒr¡p∏kπl∂m™f •g ™u´}≠à±î
+≤û∞£	≠§	¨®	Ø´
+Æ¨
+Ø≠Ø≠´´™©¶•¢†öòéèvymodgY\[\TTOPILIKJLEFDEIE A<96?;?;=9<8:64/3.0-52#>:.C?3=9-0+um.æµXæ∑C¥Ø/±™(≈æ:≈æ9∫¥,Ø©!Æ¶!§õóçùë≠°+√µ;…æB«º<√∫7º≤.Æ§!©õ µ©3∫¨A¢ñ@C7%.(85,>;4C@9C@9C>8G@:KD<LH<LI8GB.F@&FA#IE LH"MJ!OL#SO"XR"`[$a\"fa!mi"olrpsqtp{xÑÉááçéíîïñôö†û•§¨´∞Æ¥≥πµ∏≤π≤∫∞πØ∏¨∫Æª∞ø±¬±ƒØ∆≠…¨ÕØŒÆ—™‘©’©÷•’ü	÷û€°›£›•‹§⁄£ÿ†÷ô
+—ìÀå Àå Ãåœë”ö”ûŒüÃûÕ°Œ£ Œ¶#Œ´+—¥4“π;‘æD‘¡I÷≈Q⁄√Q·ΩM◊Ø6‰Ω2Ì»2ÔŒ3“4Ò‘8Î—6Ï“7Ï—8Ïœ6È 4Á¬5ÁΩ5Íª9Ï∫=Ìª@Û√GÙ«JƒGÌ¡FÓ∆LÏ…KÎÃMÎŒPÏ–SÎÕSÈÀQÁ…Q„¿L·∑GﬁØC€™A÷•>“ßA’ØJ’∏R”ºVÿ¬_Ÿ≈fÿ¬lÿøo◊ºu‹πyﬂ´q”ë_µjBÅB#=$+*!-)@$4O06U5;\=7U96S57O5RcQãöìâòùï£∞õ§µáèúryyÑÄrv~éÉ´∫≥ÜíéalhâîêOZT_kiíü•¢Æ∫≠∏ îü±ïû≠©¥∫s}íûöß∞Ø^d`Z`T[gS,@'5O67R?>YH2G8/#1 #/+0DF1;:&"%!.3F20C/)<(/'+5O2:\96Z45[4.W/-V,/U,/T+,N),L'&A  7,% ((?%4N56R94N5,F-(B)+E,.F.*B*!;"">%,M0BcFUsYVoRuÜbñïi°ÜQ∞~Cøz?ÕÉD»Ç<„¢N‹®:¡õªß ∫™!ø´(…¨,–©*”£%–ùÿü‘ì”è◊òŸûŸ¢!Ÿß$’§!‘£"Õú”†!”†!≈é—ïÕåœâ—ãÀã–ó&Õú%Œ¢)…†*…†, ö+¡ãÃç#≈Ö…à"Œä'πj z# ,ªs!øw#»}*…x'¿m¿kÀv%;kE9iC9kE9kE-`7;kAFsH.W/7@!,O.2[30^-+\%O*]"-c'-`''P$028"D#8a9GrG8g9GwG-_*1i(1j%1j&)`(]$X-_ EAG#P'Y(\7n-5m,?u79j3-%,.L(LtBSÇKZéPLÄBLÄ@RÜHXåNTäNNÑHYçOTáNAvB=nA>hDCf<wåTºÃÖ«”}…’qµ«Y£∂Jü≥Rè§YÅîgzér}ëvyês\xRKlAMl@C`48N*/@ "2>N1DX36O%C`4+J!@!@%?(!-)2!!)'(6-?%.B';R5.B'#7)A6P+72'A/I&*D!.7.#:;[61V+*Q%*S'(Q'(N%(N%*P'*S).W/1[33`95c<7e>6c:=h=4Y.670P'+O#(P+U#*V!,[%/`)6i1<o7;l5(X$"QHBB$H$J#N,Y.a/b /c#.b$0c(1d+2g/3h2:j8?m>;f91W./O**C#$6*$,@'A^?RuTXÄ[YÅ^V~[PzVXÇ^RwUX}[SvUUuPRmDWh<ÖW†åZ¨wA∑p0¡x+ƒv!ƒn√g≈a»`	œaœ_Õ]Ã]Œa—f”m—nÃj ’q◊s—m “n ’oÿp◊m Ÿo÷j ÷e ◊c €gﬂn·wÂÄ„~
+›uŸj Ÿk ‹u ›}ﬂÉ‹Ä⁄r‘j ’j ÷m◊q”nÕk Ãk ÕnÕs…u∆r ƒm¡j ¡oæp∂m µo ¥n ≤n ±qµ|	≥Ç	Æá´ã¨ñ±¢Ø¶	Ø©∞¨±≠±≠≤∞∞Æ∞≠¨´ß•†üññàâz}mp`cWXXXUUQRRRKMGHCDAAEBD?C> C?"C?"A= ?; <872504.41";7+?8.@:.E>"f]"±™R¬ªIπ±2∏Ø0∆Ω<√∫7≤©&ûïâ}ouf sd |jñÖ≤¢3¥®0æ≥7√∏8∑¨,å~àx§ñ-èÄ+B5 6+91;5'<8-?;2@<3A=4HA9HA7GA5F@0C<*E?)HC&ID$LH%MI#PL&SP%UQ!WQYRZT`Yd`hejhsrÄ}ÉÇáÖåçíîñóùû§°•£™©ÆÆ≥±∑≥π≥∏≤∫∞∏Æ∏¨∫ÆªØ¿≤¬±√Øƒ≠«Æ ∞Õ±—±‘∞◊±ŸÆ⁄´◊£’ù
+÷û◊ü⁄¢⁄¢Ÿü‹ü⁄úŸö⁄ù⁄ü◊ü“°“•”™‘≠$”´%’Ø*‘±/‘∑5”º<“ø?œøE“√L“∆P÷¬O€∑I’¶2Á≤0Ú∫/ÔΩ*Óø)Ó¿,Ï¿,Ô¡0Óø1Ó¡2√6æ7Óπ7Ôµ8Ó≥;Î∞:Ë≠9Â™4‚ß1Ê™8Ï≥BÈ¥@Á∏DÁºIÊΩI·πGﬂ∫GﬁªG›∫Fﬂ∑FﬂµG·≤H⁄ÆEÿØF⁄∑O÷ªR‘øV÷≈]÷ƒb÷¡fÿ¬o÷¿tŸºx‹µt÷üg¡vLéL*E%,')64M/:W8;Z:7U95S73R2A[>sÑrö¶¢èû•ï£∞°®∏bhtltw^hgUd]Ñïçó®¢©∏µÅãäãïîJTU{ÜàøÃ’¥¿–Ø∫–≈Õ‚∑æŒÅäì^ik~ää¬…œ~ÉáZ_[^h]1B25L8<YGA^LF^P,A2#4"#0/7 =B+14&#&7$):'"3 '&).H-EdB@d>AgB;c>8a97]61U1+M*(G%#>6,#!+1D.4L44N53M4/I0,F-&@'&>&'A(*D+&B)StYzöÇç®ïXo]UkT[fHwiDëlBûc7∏uAµu8ŸûN‰±F…£(«∞,øØ(ƒ≠-ƒ•&Õ§&—† “ù⁄ü€ó–ã“ì÷ú‘û—ü“†◊¶%÷•%“†#—ûÃî’ô!—êÃÜ…ÇÀàŒí"Àò#∆ô"«ù%≈õ%∆ñ'ƒé" ã"∏uƒÄ≈}ºm¬p»{)Ωu#¬{) Ç.»z(∑d¿i…o!7g?9iA4g<,_49iA>kD5[6.8#F&0U3?iA2b.2c+"S-^&/b)K//67:#B 1S.;"D!'L!0`&/c!+_*^&Z$X&X?8	@ L%U-_ /c!7n+Bu:7a3)
+"%(C"V{OWÑM[èQVäLKAJ~>YãN]èRTÜI\êNTàH>t:5e35Z/Ea0ÆΩx«”Œ‹}∏…c¨¡Z£ª[ç¶U]u;äû{åûàzêyiÇeZvPIh<>_27V,0H$*?.>#5E(4E%*@%?!=98 : 4&6-;$4@,%1 -#2)=".B'3E-)9'9,@$160K(4R,8T,$@65!:+F%2Q/+M(+Q**S+)R*3]5:d<:d<6c:4a82_60_50^70^77d;:e:7`4#H;/N%+K"+O#+P$-W'2^)3d-5h08h4:h71],%Q$O#K!GC#I&R'X,_+_2f&/b'0c*2e-1f02g3;k;<k=ApDCpEClB3W1+I'!8)!';"OiLX|XWÄXV~YV~YQ{WPzVZ^RsT^x[duUr|Wòôoº¥É∫úf≥u<ºk,¬j"¿c¿\ƒ_…eÀhœfÕ_Õa—fœg–jœiÀf Œi ÿsÿt–o “q ÷uÿw◊s‘j ”f ”f ÷l ⁄p‡x‚·~‹w€s ﬁp ›o ›t›xﬁ~›z⁄pŸj÷i÷m€z	’wÕo Àl œnÀl »n «q ∆r≈u¡tΩt∑t º~∏}≤|¥Ä≤Ç∞à∞é≠íØõ≤•≥´∞≠
+≤∞≥±≥±¥±≤∞Ø≠©®üûìïáã{~nseh]aX[VVWVSTPPON KI CDBBC@FBE@ D?!FC$D@#?; =8";4!94!71!;5'<6*=6,@9/F>'TJ¢ôJ√∏Lº≤6ø¥8«º>¡∂6•ô}ojY iTgQhRlV
+s]
+Ålí®ó%æ∞6ƒ∂;´ú'}ofW ^PJ=	H;?3>5$>6)?7,=7+>8,B90E?3HB4IC3KD2JB/KD*KD(JE'KG$QO(RQ%WS$]W%a\$d`!id mi lmrt!yy!ÅÄ#ÇÄÑÉÜÜêëôö†°ß§ß•©™ ØÆ ≥∞!∑≤"π≥!π≥ª±∫∞∫Æº≠º≠¿∞¿∞√≤≈∞∆Æ…ØÃ∞”≥÷∂ÿ∏‹∫›π⁄≥⁄Ø€Æ€≠Ÿ™Ÿ•‘†◊†ÿ§ÿ•÷¶“§”©÷∞€∏(Ÿ∫+÷π-’∏.÷∫2’Ω7’¡<’¬A”ƒE÷»M’…Q”»R€∆SﬁµI–ó&⁄éÂíÊïÂôÊúÂùﬂñﬂöÏ≠*Û∏6Ùπ7Ï±3Î™2Ê•/‰•1Êß5ﬂ†.›ô*ﬂñ-ﬂñ-⁄ì+Ÿñ-›£8ﬁ©?›≠?·πH‚¡M„…R‰ÀT‰ÀU‡≈PŸæK◊¿N€«VÿÀX◊ÕZ◊Õ^’»`ÿ≈f÷¿j–ªl÷ºrÿ∑t◊¶l»}SñO/I *4A'<U8;X:>]>2Q22Q26U5B_A|é~ù©•ö•©ù¶Øòü©Åàês{~nxy]lictnûÆ´èûõÅãåÜêíÄâéû®±éö¶¡Ãﬁπø◊ìòÆ^fqfqu{âäÅèíëô¶{Åèkr|V]cBNL3G>>ZK5TDGaTF\O*<,$2!%2%1%3%2!0-/*$!%1,I+>`=HnIFlGCiDAgB<_>7Y83R0,I*$;!/'"  #/-@*.D-.E+*B(+C+,D,'A(!;"";%%A*Çûàï∞üwçÄVl_iÇoãûäîúÑ°öÄöÅcûxS©{GŸ©]ﬂ≥Jœ´0Õπ6ŒΩ9»≥3∆©+Ã†%–û!–ö⁄° ”í—ç÷ö◊ü‘õœò”û—û”°$”°$Œö »ê—ñ…äÀÑ«Ä»Ö»å…ñ#«ò"»õ$√î «ï&ƒã ∆Ö∞kƒÄ∆Ä≈zΩo∆y)πp!¬~+…Ç0≈x(∑d√h≈h"4d:0a4+[1.]3+W3!F%04!B%,Q02\83`52d/7j1,[%2^+4^0A(398!<!<!<,".1W&6c(1c$'[#V#U'W L4>I$T+];o/>n2?i72$#(.I*UzOUÅLJ}BDz<KÅCK?M@YâKXãIXãFRáCAw9&W1U%Qj1√—ÇÃ◊yƒ”nµ∆`¨¬`áüK^{9Oi<zårö´ò}ì~QkNNjB@_37V*/N$)C,D$)<$4#31&;72343$8+=#2A*0?($33E-1H,-D(0B(.>$%72D*30I)3Q-#A,J$+G!0K(1L+.L**I'*L))M)-S.1Y40X33]77a9<f>:g@9f=7d;7d;6c<9c=9c;:c9:`70U*+I#,H"(F"&F.S*@j<?n:;l54d0-]+*X'+W&0\')T%P%M=&L'T#V'[)]-a#*]".a(3f.6h39k8ApBBqEFuIHwK?lA1Z0-O,+F')@&,0:S6[}XV|SV|W[É^\ÑaV{YUtUb{]aqTÉçk©´É…≈ïŒøà≤éR∞l/æf&¬f√b¬]Ãh—oÕl…e«`Œh–m“oœnÃi–k—g÷m”n—p “r”t ÷yŸx÷l ◊j‹qÁ~‚z€v€v‹w„|·z›t ⁄q ’n ⁄u ⁄w ÷q ”d “a –c ÷mÿw‘v‘vŒoÕk  i «k …q≈t¿s øvæy¿Ç	¬äªà	∑áØÑ≤å≥í≤ñ±õ≤°	¥ß	≤™	≤Ø
+≥≤¥≥¥≥≥∞≤Ø≠´üûçéÄÇmqbf\`UYSTPPTTTSQPMMJHFECAGEEAF@E?E?ID&FB%@<!=7!;4!:3!=6&@:,A:0@91>7-?9#H<ôçE¡¥Lº∞6¬¥9…ª>Ω∞0öãp` hViUePgRnWr\t_|iÇt°î"º∞:∑™7ûê'n`cU]PREJ=E:?4<4!?8%B;(HA/KD2KF3MH4PH5OG2RH/RK/NI,RM-WU/\[/`\-f`,je-nj+pk)sq'qr&prxx"}~!Ä}ÉÅÑÉãåôôúù¢¢••™´#ÆØ%≥≤&∏µ&π¥%∫¥"∫≤∫∞ªØº≠º≠æ≠æØ¡±≈±∆Æ Øœ±—≥‘∂⁄æ€ø‹æ‹ª€∑ﬁ∑‹¥€∞›∞‹≠€¨›Ø‹≤⁄≤Ÿ¥⁄∂"Ÿπ&Ÿª)ŸΩ-’∫+‘π.‘∫1’ø8÷√@’ƒB”ƒE”«M’ÀRÿÃV›»UÂΩL€¢.‹ê„êÈòÎùÁüÍ§Í§ È¶#ÍÆ*‰Æ*„±.Á¥4Á±3Ê∞6Ì∂?ÒΩGÒΩGÒ∫F≤CÔØCÌ≠CÔ∞F∑NÏπNÊªKÁ√QËŒWÂ”W·”V·”X·—W‡–Wﬂ–Y›—YÿœX÷—[’–[‘Ã_–√]ŒΩa–¿k÷√v÷æv÷≠o«~QûU5Z+*$.9Q7D^C6S70O0<[<:Y9@]AQcSÅéÖó¢ûìõùfnqxÅÜq|Çò£ßvÅÉFTTiwwm|ywÉÅçóôó†ßt~àn|â¡Ãﬁø≈€[`sV_fp~~yàãÜìõö°±òù∞Éâôñú®py~4BBE_T(D59TEMeWCXI$6&/ /!3$6 2C0&5"+& ",6S5IhIHkJEhGDgF@cB=_>6U30M.%=#2,&"!"%-)<&2E/,B+'?'#;##=$&@'$=' 9$gÄmç•ïcylg}p|ïÇiÇmdzeu~iïät°ài£}N„∑p‚∑O◊≥9œ∏8‘¡@«≤3«©-…†$–û!œúŸ†ÕåÃã’ô’ú”òÃìÀïÃôÃô—ù#Œö"œò!–ò! ç—ç …ÑÀå"Ãí$…ñ#…ö$»ñ#ªâ…ï'≈å!≈Ä≠eÀÜ! Ü#Ωtøu ¡v%¡x)¿y'¬z(¡r#∫d¬eΩ\-^1,[/.[2(P-2*,7,O/5]87d;7f8;m8<m6.U&&F	"""3"<<!? >6'"5+Q1^#-`-]$T$T!M>=H&V-`2b&&L/	$&'9RwNQ}HOÇGPÜHQáIPÑDL=M~<_íMTà@TâC>u2,^!7^'Tp3≥≈o√œkøŒe£¥Ndwbx0Up=WqNzçwï®îé¶åc~]\xOIi:Ii:?^49T1)B" 5&9(;,.276%
+,2!8'>"1H,-D(9R53N/9T59R40D(,>$8L0$<<V1.L(9:)G%,I*+H)*G(*I)+Q,/Y30Z25_70X32Z50Y11Y46^;9a>7`87`88^9;a<<b=;a<8\8-O,2M,&A"#@",N-:`98f73c32b0.^,2b06f4.]))X!&S#P+S!>'M*W%Y$X#W&X*\!2e,1d,6h56e78e:8e:9h<;j>6d62[10R/-J+6N4 70)@#?]9UxP[[X|XWzY_|]gw\s|_ù£Å∫¡ï»—ö—“ñ«∏wßÄ=¥o,¬k$√lƒk∆lÃqœr…k	«gÕkœnÕnœp—u”t“mŒa –c —h “n —q “t ‹}€zŸq›r‡u‚wﬂs⁄nŸm ﬂv‰}ﬂ{ﬂ{ﬁ{›}‡Äÿu ”k ‘c ”a ’hﬁs	”m◊s⁄z
+Àl Àh ŒmÃp«q∆tæq øwø}¿Ü¿ä∑Ü∞Ö±ã¥ï¥ö≥û≥£µ©	∂¨∑Ø¥±µ≤µ¥¥≥≥∞Æ¨
+¶¶
+óóäå}Äps_b	]^WXYXVTSQSPQNOMMIIGHEMH ME!KALBI@HA$ID'D>$B<&?7$?6%?8(C=1E>6E@:FB9F?,OCâ|8Ω∞Hª≠2¡≥6∆π7±ß#ïâ|oqa
+o_l[mZo\scthukyqÉz§ö)∑¨9≠°3|rj_j\cW^PVIQG#OF'QK+PK-SL/XQ4\U9]V:\U9\U9[T8YR6XS6ZU7`\9da8fd3li2rp5ut4yv3}z3{x+zw&}}'ÅÅ'áÑ'çã'ìí(öö*°°)££'•¶&©™(¨Æ'Ø±)≤µ*¥µ)∑∂*∫µ&∫≥$º±!∫Ø!π¨∫™º¨!ø∞#¬±#≈∞√´≈®ÕØ–≤‘∏’ºŸ¿⁄æÿ∫Ÿ∂ŸµŸ±ŸÆ⁄±‹≥‹≥›µ›∏"Ÿµ◊µ ⁄∏#Ÿπ&ÿ∏'ÿπ*’∂(‘∑-÷∫2‘º4“ª7—æ>’√G’∆O◊ÀU€ÃYﬁ«S‚æDÂ∏7Íµ+È± Î¥#Òø,Ó¬-Ò»2Ô«2Ë¬/Í«7Á»:Î–CÔ’JÒ◊NÒ◊OÛ÷TÒ÷UÒ⁄XÛ‹\Ò’WÓœRÚ–UÛœWÕYÏÀWÍÕUÎ”YÁÿYÂ⁄Z„ÿXﬁ”Uﬂ—V‡“Xﬂ–YŸÕW”»R“ÃT”—Z“œ\— _”Àf“Àp”…t”¬t’ØnÀáXûW7S$"'.9O:B[E.L2:[>BcD?\@3M4)<(7E4S_QNZPCROapu|äïö¶≤yÉå?HMXcep|zeonWa`KVX[hnÑíüï°±§´æIQ^O]]buq~êê°Æ∂ñû´•´ª™∞ºïú¶≤π¡ITVFYS-E7!9)9TAKfUAYI#6#,,/$3 ,%!/*B*4Q5:\;?c=<`:1U/3U0-L*)C&"9/)%$"$,$7#+>**@)'?'$<$#;#7!":$%>(1J5AZE2K89R=KgPHdKLeH]jNrhMÉfFòm@⁄©f◊©GÀ¶1œ≥6’¿A∆Æ2…´/Ã§(–† ÃöÿüÃåœé—ï–ï“ïŒîÕóÕô»î»îœõ#Ãò"ÃìÀê…â∆àÕï( ñ&…ó$ƒí≈ë!ªÖƒê#…è$…Å≤f…É!Àá&ªq¬x#¡v%Ωu#¿x$æs Ωj∏^«f"ºY-Z/-W/0X3B"12"@(:\A@hFAnGDsI<m>@uADtBC  ,$;!"=#> :'3>0K_CBa7=h2@p41c&,^#&XN"JG)W-`/d H1)!'.9O:;V7Ef;RyBXÖDVáEWäEVâDYãFQÉ>SÖ>XåBWçBJ9Bs29b*Mm.å¢M≤ƒ`ö´Ai{`tax4,G:U4UlRax^Äô|]xURnEHe7?^20P')G#-H'9S03M(,D "7/$7&:2 23D17M64M0-F)'@")D%#B" B!A+J(:U47N14L,.F$0J'-H'#@!-G*'D&$C#&E#>#E"-U04^63`76`80Z41Y41W00V1/T2,Q/.T/$J#&J&@=C%G$'F$-J+)D%-J.7X9:c;0^0,[-*[,7f83c37g70`,)X!'V(R (M!*H"(I,Y +])]%Y&X(Y!/`(2b.8f7=h=?iA?iA<i>>mA;h=/Y1-P/-J,5O4&>$!8+B%6T0NnG[{Va]_xX]pRx`†°Å¬ƒúÕ‘†œŸö‘’ë∆Øk∞Å;æy.ƒq#ƒo«sÀx v∆n
+≈iÀnŒq	Ão…m  s —z—v–p —h Õb –j ÷tÿw◊v÷u ’p ’m ‘j œd œb —b ’d ÿh Ÿk ﬁu ›yﬂ|·~‹|‚ﬂwﬁrﬂi÷` ÷fÿk’j“i ÷qœmÀh Õl…oƒp ∆v¬wøxº{ºÇ∑Ñ∫ã	∑è	∂ïπù∂û∞†¥¶∑Æ∑Ø∂±∂≥∑∂µ¥µ¥±Ø´®§£ñóâä{~qseh_`YYZYZXYWWTVSVSSPPLOKPIRF RE"PF"RJ&MG'MF*LF,GA)G?*H@-I@1LD7KD:HD;JF:IC-QEâz7µ®B≤§)ª≠0√∂4Ø•!ôèãÄxmtiqhrfthunupuqwswsÑòë&ïé&pih_i^l_(nb.mb5h_8f^:jdBmhHtnNwqQ{rUxqTvoRvoRrkOqjNniLojLsnNwsNxuHzxEÅ~GÄ~C}@ÑÄ@ÑÄ9Å}3}0Ä-ÜÑ-ãä-ìì1òö/ûû.°¢+£•*ß©*¨Ø,∞¥,≤¥,≥∂+∂µ)∏µ(∫µ&ª≤%∫±$∫Æ$π¨"ªÆ"Ω∞$¡≤%≈≤%∆∞ƒ©…¨–¥”∫÷ΩÿøŸ¿€ø Ÿª€∫Ÿµ’±ÿ¥ÿµÿ∑ÿ∑’∂÷π ÷∏"Ÿª%ÿ∫&◊π'÷∑(–¥%‘π.Ÿø6‘æ5“æ9’¬Bÿ…L÷ TÿÀXﬁ Y⁄¡J›∫:Î¡7Ô≈1Ô√,Ò»0Ó…0ÏŒ2Ï‘6Ì÷8Ì÷;Ô⁄CÚﬁIÒﬂMÒ·PÓﬂNÎ‹MË÷NÈ€TÎ‚YÏ‰]Ì·[Ï€WÏ◊WÈ—SÎ”WÔ◊]ÌŸ\È⁄Y„ŸVÂ‹[‚ŸXﬁ”U€ÕR◊…O’∆O’…S’ T◊ŒW“–YœŒXœÀ]Õ aŒÀj‘Õsÿ…x€∏tÃàWïP/D	  )JbL-I25S9GhKCaE3M4 8  8 -C,9L9Vh\ÅîêÅîöoèrêáèúr{Çs}isrcnjalh<HFXcgï¢´Öéùóû∞NXb/?>I\VpÇÑ¡–◊°©∂ñú¨yç™∞ºéíùlsyFUP<PD"9%";&;XFIdS;R@2+*'%"72Q10T.4X2.S*1S.2Q/)D%"; 4,&#$%&+1$:%'?%(@&&>&#;# 8" 8"$<&)B,&?)%?&+E,4K/2B%]^?ÄgIÆÉa™tFÿü\‚∞O·∂C’≥8’π;ÀØ4…©. §%–•#Œù“ù∆ã–ìœí–ïŒìÕì–òœò!Ãì ìÃó#Õò$Õñ"»èœì%ƒà—ô,»î&»ñ%√ë æà¡ã≈è%≈á ƒzµføy»É$∫pøu ¬w&∏pΩu Ωs¿m∂Z≈_πO+Q,B!08(M.=fFKwTO}XJzTI{UK~UK~SKO;k;0
+ )"6 7+		.@*MhGOvIJ{DDw?:m44g.P'W*Z%V+^+c.`!#J
+)+1I3A]DIfHJf>VrAoçMzöQsòJeé@]â>_çE^çE\éE\èD`ìHdñMWÖD=e3Ad.`1á†Bã†;ñ™Gè•RuéJPn<,L%;Y7PkLVoOPjGHb;@\4Aa:DfA?a<Ad<<]21R'*I">':,<"+9"#03>.-:)$3 );%#:8,K+FiHEmHAkC6_51W..L*3L,0D(';+D'#="":"!; )H(-O*'I&9)O(4]33^34^6-W14^82Z5)O*.T/,P,,R-+O+*L)'F$ B%I#$H"&H#'F$!@*L)>b>5^4/\1BpI@nG:i?@oC6f6.^**[#-Y$,R),
+3J.#=,T -]!0b%)]0a)._(0a*/],8a5CiB<b;?h@=j?9j=<k?<f@5X8+I-/L0/I.%>!+F%PnJ\zTbzXl}]wÄcåëq≠Øä« üœ’•–Ÿ†—⁄ó’—ä¡üX∞x.øx*√s√t»z…{»v«o∆m oÃrÀqŒw”Ä‘ÅÃv —x◊y÷x”zÿ}Ÿw“l “g –e —d ”f ‘g –c ’f Ÿj €m €m ﬂv ·z‰}ﬂw€q‰u	ﬂnﬂi◊[ŒR ”] ÿf÷f—d ‘j–iÃf»g ƒl »wÀ~
+¡xΩxƒÉæÇπÉæèªî	µï∑ù
+∂°µß	∏¨∑Øµ≤∂¥∂µ∑∂∂µµ≥≤∞®ßüüëíÑÑvylqjoikde^_^]^\^YWUTRXSVPXR VNYM#]Q)]U.XS-XR0UO/RM/OJ-PJ2PJ4TL9RK9PJ:PJ:MG7NG-XK!ñáD±§>Æ†&∑©.¿≥3∞¶"†ñèáystsrrsqrpssvvrrssososstlj_\_WUKMBKCRL*VM0QJ.PJ0PJ0VN7[P:_W@g_HleKmgMohLrkNniLniLsnPytTztPzRÅ~QÇÄOÇÄMÑÅJÉÅFáÉDÇÅ@ÅÅ;ÖÜ:ãç:êê:ìî6ñó1öú/ü¢/•¶.™≠,Ø≤-±≥,≥∂+∑∂*∑∂(∏µ&∏≥$∫≥'π∞%∂≠"πÆ!∫Ø"æ±%√¥'∆¥$…±…∞Ã≤’ª÷Ωÿø⁄¿!›≈%›≈%ﬁƒ%ﬂ√$‹ø#›¿$⁄¿#ÿæ!⁄¬$ÿø$⁄¡'€¬*Ÿø*‘∫%‘∫'—∏'‘ª+÷¡4◊ƒ9ÿ»=ÿ CŸÃJÿÕOŸŒX€Œ[„ÃZﬁ¿HÁø;Û∆9ı…5Ò≈.Î¿&È¬'Ê +Á—0Â—2Ê‘6Ë’;Á”<Ë‘AÁ—@Â–?Ê—BÂœFÈ◊OÈ€TÏ‡XÎ›VÌ⁄WÓ◊WÓ’VÒŸ[Ì⁄ZÎ›ZË€X‰⁄W‚◊W·÷X‡“W›ÕT€ T€ÃUÿÃTŸœVÿ“Z’–Z—Œ[–Ã`Œ…a–Ãi” o÷¡p÷ÆiºvEÄ;3 .;*7P:*H,<]>B`D6P773(F*2P8nâzí©£yíèiÄÜ}é†q}ìõ•±wÄáu}mvuU^[gpkDOKQ[\ò°®óü™íô©cmw$440CAfxz¬”⁄∑√œ´¥√ìö¨éî§éêúDIMKVRFVI)?*7!='?ZGOjW/H5/+!"#" 8,K+2V05Y33W10R-.N)'E#)B$%9 .'$%$"%*!4 $;!$<"$;!#: %;$'=&%=%$<$$='&@''=&-: 61gL/§mO÷ênÃÉV÷ëN”ô6€®3€≤6ÿµ5À¨/«®+À•&Ã§!Ã†Ãõ ï—òœñŒïœïÃí–î çÃéÃê  í#Àñ& ï%Œñ'Œë&…ä Ãè%≈ã «ë$√è"Ωá¬å"∆è(ƒÑ ær∑h¡x¬{ºpæq!ƒw'∑læx ¬{#∆x%≤WøU∂D=($G);bCDrNDvPGySFyPEwQG{TFzSJUI}O<k?>d=/L-'
+#$		!8S4KqHO}LRÇPQÅMCt=3d,6e.0`$)\'\&`+b)X">%D$EbDPnLYuLwè[û¥s≠ƒv≤ t¥ŒsÆÕp}°IWÅ-VÇ5SÉ9[éCVâ>\åBYÜCXÇP`áRgå>dá+a{ lÜ/påB^}ATxHNsJMrI3S.5N.8P0Ga>Ca=QsRjçl]Å[QvK>d5-Q!&J#?':,:#*3"
++%7'@#2Q1DiGJrMHuL<i>8c8:\73N/(?#.B'-D*664.M++M()N%/T+.T+/X.-V,.X00Z46^9.V1'M(+O))M')M))K(*I'+K&'L#&K"%J!'L##E %G"0T.3Y05^6EoGJvRDrNGuPApF4c59i70a*/[*A'$8(@ +Q /\#/a&/b'4g/5e1=l89e4;a8?c=9_8>g?9f;9h<8g;0Z2'H)(F*/L01N0)F'*E$C[9fwUmvW~Åb•§Üƒ¡ûŒœ£–‘°œ◊ûŒ◊ñŒ÷çÀ¬u±á=Æo"øw%√wƒx∆{ |«u sÕq
+Àp»n Ãu“}”É’Ö
+’Ä	‘~“|÷Ä÷Ä—vœk Œe ’h ⁄oﬁt⁄r÷n ÿp ﬂw‰z
+Âz·v‰v‚wﬂtŸm ÿg ›i÷^ ’Z ◊\ ⁄_ŸcŸdÿf—a Õ_ Œb —kÃl tƒu ∆{¡zºy«â∫Ä∫á∫éªñ
+ºûπ°∂£	π´∏Æ∂±µ≤¥≤µ∂µ∂∂∑∂∑≤≤™©¢¢óòåçÇÖ|qupsoqhibba^^Z]YZV\Xa\"b\"aZ$f\+g_1ha5d_5a\6`Z6]Y6[V8[W:\V<_W@`XA^XB[W>XT;[U5bV,yn0ìà/°î,±°0ø±7≥®*ßù$äÉurpsosnrptqvpuornrimhmfi^`UTSNKB:1,'
+% 
+' (!+&+&.'2)4+6/<5"A;%A;#@: @<!B>#C?$C?"GB$JF#JH"NL#SR&VT$XT$XU ZW ``$ee%hi#mp#rv"uxÄÇâå!íï"úû!§ß$¨Æ'∞≥(≥µ&∂µ%∂≥$∏µ&π≥'∏±%∂≠"∏Ø"∏Ø"æ≥&¡¥(∆∑(…µ À¥À≤œµ“∂ÿº€¡$›≈'‹ƒ&⁄¬$€æ"‹ø%‹¬'€¡&⁄¿%€¡&‹√)€¬*⁄¿+€¡.›√0€√/ﬁ≈5‹≈7‹«:€»>⁄ AŸÕGŸÃJÿÕQ€œWﬁœZ‡«Q”¥7‘≠$⁄∞ÿ≥◊¥Ÿ∂ﬂ√$·À*·“/ÂŸ7Áﬁ;È‹>‰’:„œ:‚Œ;‰–=Ë÷FÎÿKÏ⁄PÈ‹RÏﬁWÈŸR‰“LÊœMÂŒLÊ—QÏ€WÎﬂYÍ‡\Èﬂ\Á‹\Â◊ZÁ◊]Â“Z„–X‡“X⁄ŒTÿŒU‘ŒT”ŒX”–[”—b–Õb–Ãhœ∆g”øiŒ¶`∑o=t2. &$AP;)C*7V7BaB1N29 3(E);^>?cGfávMkaOlhgÄÖö´ø{áùäì¢ãîùÄàãfll)2/W`[jsnENMâëîv}Öàëöàìô0>>#32L^^πÀœì°™∂øŒö£¥Éäúîö¶Öåí[dcN[R':'#;#!:%&B,FcQMhW";(."
+	'*!7")?(,F+1P0=a=>b>:^:6X58X3-K)+F%*>#"4,&##&'&)/5!8!8$8$;!&>$+C))C*)A)-A&7=!N9ÑV5≤iI—~V“ÇOŸëI„•B›©3“¢$–•#À•&…¶&Õ®&œ®%Õ£ÃùÕòœò ìÕñ—ó»åÃç»â…ÜÃå"Õì'–ö- î'…ê%«ä √Ñ≈ÑøÇ¡à¬å"øà!¬à$…ã(¬~πmΩnƒy¡w ¡t"øp!ºo!¥i∏u«Ñ)ƒx$ØTπL≥?@4a:<jE;mH<sK=tLBvOFxRDvQDvQG{UH|ULVM}SN|N<b9* 
+	/0K,@c;LsFJtFQ{KPxFDl:.T#C?r0/i*f$`(^ )Y%6_7Aa<Pi?áúd∞¬xæŒv¬—t√”pΩ–e±…[†ºN|ü7V~(UÑ6RÖ:NÄ7N|1Jw2MxBR~C]ä7ZÖ+AfIl*V{GXSQzRT~XKvKJpG)D#.KfG<Y;pêxsï|gçhRyM4Z),P $C$>(: )4#6<.
+
+#!0)@&5R4IlKPuSKuODnF9b:7[7,I*'>"/C*3G,$8 7(,K)&K"#J%L +Q()R*,U-/Y12Z55]8-S,-Q+,N+(G%'F&(G%&H%'K%$J!'N"'L#)N%(K#.Q)1V-4Z1GpHHrLHtQCoLTÇ^8fA9f=@oA8h85`59'4:T1#G1\&.`%2e,0e/:l9>l;FpBJoD<a88a95b98f85c45c44]3%G&'D(+H,0M./M+*B 8A"YU8â{a©ö}≈Ωô–Õ¢–“†Õ“òŒ’íœ’ã–’ÉÀøk∞É2≥r"¿z$ƒ{≈{∆z x∆pÀo
+Õp	Àq…rœz–}œ|÷É÷Å
+“|Œx—x’z“rŒh ‘k ÷n Ÿt›|⁄}ﬂá	ÁéÊàÊÉÍÅ‡uﬁk ﬂlÿh ’d ’` ”\ ‘W ’Z ‹fﬁj⁄f◊b÷a—\ ÃY …[ ÃdÃmÃv»y«|¿{¬Ñ	ƒçΩá	Ωåºí
+æöΩü∫¢
+∏®ªØ∏∞µØ∑≥∑µ∑∏∂∑∂∑µµ¥≥±∞®®ü†îïçéÑÜz|yzssnlifgdhdjffbjfni%mj'ok+oj0ql5ol9lj:kg:kf<jf@ieBidDfaAkdGleHlgGmjIqmJwsM{tJ{sBÄv;Ät*úç0∂®=≥¶3¶õ(Åyokkmhminknlplpijgjce_c[\RRJGKG?92,(#! +'0*/)1+;5)A;-D>.DA.ED0FE0KK3JJ0KJ,KJ+LL*II%KK%LJ!JGMIQOUU!^_&ac$cf#hl"ilnrwyÉéíú¢¶™"Æ±$≤¥#≥≥!¥≤!≥± ∂∞$∑∞$∏Ø$∑Æ#∏Ø"º≥&ø¥'√∑'«∑# ∑Ã≥œ≤—∞◊∂⁄º ›¿$‹ø#⁄Ω!Ÿ∏Ÿµÿ∂!€∏&Ÿµ!ÿ¥ Ÿ∂$‹π)€ª,€º-‹¿1€¿1›¬7‹¡6€ø7€¡9⁄√?€»G€…KŸ…O‹ÀUﬂÃSŸ¬B“∂.“≤‹Ω$‡»*‡Ã+‰’4Á€7‰ﬂ9‰„;‰Â?ÂÊ@Ê„>„ﬁ<Â€>Ê€CË›GËﬁIÊ⁄H„÷I‰◊K‰◊M„”L‚“KÂ’NÊ÷OÊ’QÊÿSÊ⁄T„ŸS„ŸUÊ‹YËŸXÊ‘V„œT‰–U·—W⁄œS’ÀP—…MŒ»N—œX—“]–”b—”h”Õk”¬hŒßZπt;ÖF;$AE*;N2)C&+H*.K-934R6>_@GlJ@hFHlPBeQNldÉõü•µ≈Ñè•co•ØªÉäîbjm&,,=FCpyvcmlÇäç.8:7BDGVS2A:-%$73™ººhvyô£¨ü©µÜí†êú™ï°≠íõ¢Vb`7I;3H5+B.";&+H6Pm[B]N 6)
+
+	$/D18T;7U97T84Q54S4AcBEgF<^=<^=:Y70N*,G$(?"!3,"$'('$"%)2&9#'>$&=!'@#'A$*D)0I,/D%:;pP)£h>∫lE‘ÇR”áIŸóC‘ö/’°'ﬁ≠,œ†–•"Õ•" £ Õ•!Ã¢–† ìÃì…íÕñÀëÕëÕéƒÅ áÀä"Àë%Œñ) ë&ƒâ!≈Ö!Ω|≈Å¬É¡Ü ¡à!ºÇøÄ¡zπnπi¿p∆z$ºrªnΩp"µfªpªz »á+¡t"µZøT¥B,Y.3b86kA5lD6oF;tK<pI<nI>pKCuPJ|WMZRÅ]QÅYJ{N1_1=
+"
+	
+	!2: C E&K-R&:2	8(NAv21n!4r%2p%*f '].\-;_1e}IØø~ƒ‘|“‡~”·œﬁw≈◊i∏ÕX®¿FëÆ:Fk@lAr#8kDs%;i Bn/P9_ë8N$Ak!Fo3KwFHuLN{T?lC4c57`4$D7UrS:Y:zöÇyõÄSyR7^1.O$)E9-69.-.& ,$:#5R6AbCAfE9a>2Z5'P(%I#'F$*C&3J.3G,)="641S.-R)'N"!H)O&1W.5^6.W//U0/S/-O,,N))H&&D"%B#"A)K&'L#%L &M!*O&)N%*M%(M$8^55^4?iCFrNDpMHtQ?kG;hA=jAAnCApB6`80.1J,:V0?0X$/^'4g.3h48j9?m?QzNHmBEl@?j?;j>:h:5c42`/-W)&H%8W7:W8<W4?U/IU1^W:ÉoT¥ù~Œ∫ó‘Ãû÷’ü‘’õ“◊î”◊ç“’Ñ‘◊Ä’≈m¥Ü1∂u!√Ä)∆#∆|…{≈q∆m	Àm	Œnœu‘}
+ÿÖ‘Å	–{“|—x—v◊|	◊y÷x’u‘p„{‚z	‹w„Ä	ÁâÂåﬂÉ›zﬁu›qŸi ⁄g ‹l ﬂp‚s„pﬂjŸc ﬂk„t€o◊h “b Œ` Œb Œb Àc Àj»n œ{	«z√{√Å	√á¡å¿èºê∑è	∏ó∫û∫•∏™∏Æπ±∏¥∏µ∫∑∫∫∏∏∏∫∂∏µ∂≥≥ÆÆ¢£ôôèèããÇÑÄ{{{xyvwsxt{v"yt"ur#vs&us)wt/vu4wu:ut<yxBzxEywFvsFxuLvrMxtQ|vTÇ|\ÖÇaÉÄ_zwTtpMfaAXR0NF"F;bTîÖ4¶ó:òç1me^Z___`^_`abdbc^_ZZXXRRNLGDB;>92,)$ ",()%*#2.#<8-B>2EB3GE6FG5KM8LN6SS7VW7[[9\\8\]5]\0^[._]-b`-aa+ef,ej*or-tx,w|*ÄÖ+ãç*ïó)†§)™≠(∞¥+≤µ(µ∑&∂∏&∂∂$∑µ$µ≤#µØ#µÆ ∂≠ ∏Ø"ª≤%Ω¥'¡∂(≈∑#»∑Õ¥—¥“±’≤◊∂€∫!Ÿ∏⁄∑€∂ ⁄≤Ÿ≥"€µ&⁄¥%Ÿ≥$€¥(Ÿ¥(ÿ≥'Ÿµ+ÿπ-Ÿº2ÿª3◊ª4ÿ∫4÷∫5ÿø>€∆G›…N› QﬁÀRﬂÃLË“HÎ’AÓ◊<Ô€:Ì‡<Í·<Ë„?Â‰>ÊË?„ÈA‰ÍB‰ÍBÂÊ@‰‚?Ê‚CÈ‰JÍÁNË‰MÊ‡LÈ·PÍ·TÈ‡UËﬂVÍ·XÎ„ZÎ„ZÏ„ZÏ‰[Î„\ÎÂ]ÈÂ_È‚]‰⁄W‡—P‹ L€ÃM⁄œQŸ—RŸ—T÷—S÷“U‘‘Z‘’^”÷cœ—d“œh÷≈i“≠]¬ÄCéQ"O<QX65H((C$'A$ :49V7FhGEjHBgEKpOHlPHiTmàÅÅïúô¶∑áí¶xÉïyÖï†®µt{É7<?066Xa^eplWa`1<8-<5):0&8,!3') vâÉzààvÅÉû©Ø©≥ºéö¶ó§≠áêïS_[7L=)A+#:&#:&'B/7TBSo`8PC	
+"(A+;\?8[;?]A1O34R6=^?DeF?^>>]=8W50N*(C 81&!'))*&#$#'0&:!.E+2K.2L/1K.2J*7H$QL"íj9≤p<»zIŒ}E√{1‚£F€£6”ü%„Æ,€©$‘£ –°À† üÃ†œùÃí∆ã»é–òÀëÀé à«ÇÀá"Õå&»â »ã!…é&»ä%≈É"«É"æx≈É"∆à%øÑ ¬Ü$√Ç&Ωo∏f∫j≈y#√y$≥h∏iªl!∞aªp∏vΩz#Ωp ª_ΩR∂D+Z.0`60e;6mE4kC2iB<rNEyUGyTI{VN~XJyUL{YQÄ\MÄWNRHsH(L(,
+
+	(:""@-Q#(N/U""J@%#-,P">s/4s$4s$:x+;y.8q-3d,6]&mÖIÆ¿vπ n∏»e≤¬`ªÀiºœf≥ X¶æDï±8eâLxCt<m?nEt$Kz*Yã6_í3OÇ#Ds"?m%;k-1`*)W&'U&&T#)U$=4T-@c;4Y0W}VU{T6]00T(0(!	
+*+%9:2""%-(=*.G12N52P4/R4/T2/W24]54Z1)K&(E&=V8@W:0G*!;0O/8^7.W-+R&$K&K 5Z/3Y0+Q*)K**I)+I'%C! ;:<#B &I!'J )N#+P%+P',Q('I$3W1DnF>kDCoLKwTHtSGsPJtLP{PFqDBpAFtF9b:*(B%5S-4U(9+S!+Z#0a*5g26f6ErGLwLDoABm?GuG>l>BqC9i90`,-Y(%L =`6MmDPiA\b<ukGô^Ωü{”ºí÷»ó÷‘ô‘◊î“”ç—“Ü”“Ä‘‘~’‘x‘√g¥Ü0∫|'∆É,…Ç(∆|«w…qÀm	Œn—r‘zŸÑ€ã÷Ü“}“w–n‘o◊s€z‚Ñ⁄|‹{‰‚y€p ﬁr‚v›r Ÿk ‹f◊_ ‹b ﬁi ‡r‚y‚{ﬂw‹p›q›s‰|	‡{”n Ãf ”o “t”z’{	—z” y∆wƒy≈Ä¿ÇΩÇ¿ã¿êøîπì∑óπ†Ω©∫≠π∞∑±ª∂∫∑∫π ªªªª∫ª∏π∏π¥∑Ø±ß©†°îïççãåãåäãääççãààÑ Ñ!{ ~|'|+Ç2ÇÄ6ÅÄ=ÉÉCÜÜJãäQèéUåçTééZêè_ëéeçâdÑ_yvWhdIWU<IG0@;(4.+%& '!	4*SFj[$`TVMTMTNRMLGNKKLLLGGFDECGCG@NDA80'$2.#,($ &",%92(@<0DA2IF7JI7IK6NN6RQ5RQ2\Z4[\0_a0_b-cd+ee)gg'lm)qs*tx+{~-}Å*Éá(êì,ù†-¶®-≠∞-±≥+¥∑,µ∑(∑π(∂∏&µ∑(π∏*∂µ%µ≤#∂Ø ¥¨∑¨πÆ Ω≤%¿µ(≈∂'∆¥" ¥ –µ‘µÿ∂‹∫#⁄∂ ⁄≤⁄∞‹Ø €±!Ÿ≥$€∂'€∂)€∂)⁄µ)Ÿ¥(ÿ≤)€µ.⁄∏2‹ª6Ÿª5ŸΩ8⁄ø<Ÿ¬B‹«Jﬁ OﬂÃS‡ŒRﬂÃK‚—EÎ›FÎﬂ?Îﬂ=Í·<Ë„=ËÂ>ÊÂ?ÊÂ?ÊÁAÂÊ@ÊÈDÁÍEËÎFÁÈFÍÍLÌÌQÏÌSÌÓUÓÌWÔÌZÓÌ]ÓaÔdÏÔbÏÔbÎÓaÈÍ`ÁË^ËÈ]ÈÏaÁÎbÊË`‰‡Z‰€X„⁄Y„⁄Yﬁ€X⁄‹WŸ⁄X◊⁄W◊ÿY÷÷Z”‘\—“]––`“Õe÷«j÷≥b∆âJëW%XEQY42F#)D%": 3!A<_7IoHFlGDgFQtVDdOPl`Äíñyáîò•∂åüÖí•s~ê®±¿}Üèfkq2886?:FQI2>4*8+(:,%:)&;((=,*A13G;QbX?LEáíé¨µ¥´∞¥éñò\eb@PC>X?,I-,F-%>(*C-%A+<YGRm^/E9* 
+2L3;\=6Y9@aD2P44R6;Z;BaB8W7@`;3S./M)&D"+F%4K. 2(,-+*&#%##&/,?)4L27O55O29N-AL"j^,•w<æz=∆z>ŒÄ>Œä5„•B‹§5‡©2€°$Œï÷ü–ûœûÃõ ô ïÃå∆Ü ê î…ë«äÀá…Å…É!«Å»Ñ≈Å à'∆Ñ#¡|∆Ä!øu√|"ø}¡Ç#√Ü)ø|%∑f≤]∫l¬w$ªs!∑k∂d∑c≠^∫n Ωv$∑o∏fæ` ≥H±A#R&)Z-0e95lB=qJ<pJ8nJ8nJ>rNBtOJyUR^TÉcVÖeVÜ`L|R/`1$O$#@!3,	#AZ:,R#!LG>e0'O'K&	"3R(?r/6s%:y*;y,?{3?x4?s5En4azAù∞p¶πh°µ^û±_∑Àv∏Õrì®Aâû'ä§)eá[ÖTÉ%RÉ*UÇ-Iv!N&L}"[é1OÅ(SÇ4ZáBTÇB@m4'Q!*T&)S#-U#*P!?d88^/2Y*MwI9c33['(I!
+AD=06*.9)=K:DUC=R?0G3$<&8T;EfGKpNGpHAlA8a7)O&'I&.K,AZ<IbD!;BaA=c<5^4,U)%L!F,P$&K !E#@!;879;$C!?&I!)L"+O#/T)(M$+P''K%.T/9c=CqLKyUIuTNzYClJBlFP{PQ|OBpA@n@=f<18KlACg7C!G'Q/[(5c27e6CnC;f;@n?@n??j=3^13^15c5.\+-Y&>b4Jg;UlBemDÅxQ©ëk¬•}–µà”√è“Œë–÷êœ÷â–”ÑÕœ|œœy“—u”ŒpÃ∑Zµá/¿Ç+»Ö, Å%»y…uŒqœo–p
+œs’~ÿÖ’Ö
+“Ç⁄Å€{’jœb ‘j €uﬁ}
+ÿy÷u ﬁy›t⁄l ⁄g ﬁk ‡mﬁgÿ[ ‘W ’Z ‹g ›s‹w€xÿu ÷q ›x⁄zÿz ⁄~÷|’x÷}ÿÑÿà–{Àx œÄ	ŒÇ
+«z∆~ ä»åΩÉæà
+øèºîºóªûæßΩ≠πÆ∂∞ª∂ºπºª#ºª#Ωº#Ωæ"Ωæ$∫ª!∂∫µ∏≤µ ¨Æ•¶ü†††ü†ûüúùöúñóìíêé!ëç)êç.ëê6íë>óïHöóPñóUóôZóò^óò_îó^çê[ÅÉRz{OpnHfcB\X=TR9LJ5C@/51%%!",%8-?4G:KBKCTJYOMEKDDC89..
+3095D<UJ_S#XKA7' @<1'!!"(!0)=7+EA5IF7MJ9NM9LL4LK/NK,RP*TU)Z\*Z]&_c(hj)lm'oq&ux'y}(}Ä%Ñâ%èë&ôú'£•(´≠(∞±)¥µ)¥∂'¥∂%∑∑%∑∑%∂µ%∏∑'∂µ%∂¥#∑±¥¨≤ßµ©∫≠!ø≤&√¥'ƒ±$ ¥#–∏$“∑"”µ!÷∑!◊µ €≤"⁄≠ ⁄≠ ‹±$›∑(ﬁπ*ﬁª-‹∏,‹∏,ﬁ∏/€µ.€µ0›ª6ﬁΩ:‡ø>›¿@›ƒFﬂ MﬂÃS‡ÕU‡ÕT› J›ÀAÂ’A‰⁄;‚€5‚€3‡‹3ﬁ€4‡ﬂ7Â‰>‰„=Â‚?„‡=Â„AÁÂEÈÁGÈÊIÁ‰IËÂLÈËPÁÊNÈ‰RÊ‰SÊËWËÎ\ËÔaÍÛdÎÙeËÒdÁÓbÁÓbËÔcËÔcÁÓdÊÍa‰‚[„ﬂZ‚€Y›ÿV‹‹X€ﬁYŸ‹W÷ŸV”‘TœÕRÕ»P”ŒY”Õ_’…cÿ√h÷±a∆ÜHêY#aP$FN'2E%'@"3;#G4[,@g;EkDAcBRpX1K>nÑÇèù¶Ñê†ô¶πåüçôØàï®ìú´Üçó_djGKLLSL8B7*6(%6$"3# 3 !7"$<&!:$(@*(=*0 BPCÇåÉçîçSZSR\Q/@-C]@,K+/I.)C*/G1&=):'>YFRjZ&=-&8**!
+	.5R4:]<4Y8=^A4U:4R69X9;X9:X6>^72R+3Q-2P.5S15N0'; 10.-+)''%%%(."5$:#%;$1B"GM!Äq:ØÑ@¬É<—àD∆|1÷î6—í)◊õ-—î!÷ì Â£+◊úÕñÃôÃõ ô«ë»á¡~	 é…ë ëƒÜ¿|»Äƒ|øy√{ƒ|øy¡{ºu∆|#√y"ªsΩz!¬Ç(æÅ(πu ±^≤\∏k∫s!≤nªq&Ø_Ø_∑k æw)øw+∑m"µ`¨O®Gø['!O!&U'*^..c56nA9pH=tME{WMÅ]M~^N}]N|_Mz]M|\M|ZK{UJ{L:h:#G#3P1,F+)%($	4<\3-X#K#N,RLq>.M#(
+1K&>l,=u*=w-8t,C|8HÄABx<6b-D`7Tk?ò_qãNa}Be@Wk#gz öÆ=ì¨6MoHqIuO|!Yà*@oHuP~&Cs3a6c"En4Mx@Bj6'G/*K0T$-RDj73Y(2Z(Bm88c.;c.#D	692KSF>K91@-'6#"1!
+/G/KmLLuMGqIAlA=h=.W-&J$'F$*E&D_@1J-GdF<b;3\0.X*(O E#G$G@45:#C&K'N!@ C$I'L!0U*.U)-S*)O&&J$"H#3\:MyVBnMJvUS|\;dDFrOJxSAoHApD;f86]0$F!0P+OsGW{K)J#DA3X,5\/8a58c69d7;f94_2;d:)O&*P'>d;7a3>d5Pi?dpJusMÑvS°ábÀØá◊≈ï◊Œó””ï“◊îœ⁄éœÿâ–’ÅÕ—zÀ–t—“t◊Œo ±Tπá.»Ü/…Ñ' ~ »t»nÕo—p‘t÷|⁄Ö◊Ñ–}÷Å
+›⁄tÿf÷` ⁄iﬂp€q⁄r Ÿv‡}·y⁄k ÷c ⁄g €h Ÿe Ÿb €e‹h⁄n⁄u›zŸv ◊w Ÿy ⁄|€’} ’Éÿâÿâ–Å◊á
+ÿÖÕr Ào ÃwÃ}«|ƒÄ≈Ö
+≈ã¿â∏Ö∫ä
+¿ïºöº¢ø≠º∞π≤∫¥º∏!øª$æΩ'ææ(ºΩ$æø%æø&ªæ%ªº#∫ª"∏∏"µµ!±≥!≠Ø©™®©ß®°£ü¢†¢#†°*û°0†°9°£@ü¢Gü°Mü†TòôUèëRÖàOÄÖOy}JuxIqsKgiDbcD`^G[XEURAHF731%# %!,&.(4->5NE`UfY"THKB>:-,""
+$#/+71PHeY'`T$K?3+& ,%#")"-$A9.GA5IC5JG6OL9NL5NL3NM/NM.KM&NQ&UY'\a'ch(il%or%w{'~Å&áâ$ëì%õõ#§•%´´'ÆØ%¥≥%¥≥#∂∂$∑∑%∏∂#∑µ"∑µ"∏∂#∏∂#∑≤ µØ¥¨∞¶≥ß∏ßΩ¨ ¬∞&¬Ø$≈Æ"Õ∑&–∫(’Ω)‘∫'œ±Œ©–ß–•÷≠÷≤ ÿµ%◊¥&⁄∂*›π-›π/‹∏0›ª5ﬁΩ:‹ª:ﬁº@ﬁ¿Dﬂ≈L‡ÀT·–Z·–Z·ÕR⁄«DÂ’DÊŸ=‚ÿ8‚Ÿ4„⁄3‰›5·‹6„ﬁ:Â‡:Áﬂ<Âﬂ?ËﬂBË›CË›EÌﬂJÌﬂKÈ€GÎ›IÎﬂMÌ·QÌ‡SÎ‚UÏÈZÎÓ_ÎÚdÈÙgÍıhÎÛiÈÒgÈfÂÏbÁÓdÁÓdÊÍbÊ„^Á‡^ﬂ⁄Xﬂ⁄X›⁄W€€W◊◊SœÃK”ÀN’ÀR’ T÷…W‘√Y“ºY—±Z–†Tæz=çTYK<F!/?"8!?$G#K(P7^/<a69X81M7#:2âõüèù™õ®ªü¨øâï´ë†µéõ¨îú©~ÇãLPS\`_Y^WGOD)5'#1"- *!4 +C)(E&)H&-J+!;0D+>M:1<,6A1MXG%4G`B+F%'A$/G/6L7(>)(5D\D69 8":"": 4S39[86Y82W68Y<:[@4R66U67V44T/:Z3.N'3S.1P.3R02M.3.321.-,++)('())"() èÄEµìK«îE’ìG¡{&’è/ÀÜ’ë$Âù1÷É»w∑u ’ûÃù…û»õ…ñ åø~
+Àå»ç ë ≈âºw¬z¬z∆Ä ≈|¡w¡x≈z∑k¬v Ωq¥lº|$¡É,ø~*≤k≠[µc∏o ∑s"±n∑t&Æfµm#º}.æÄ3ªy/∏o+¶RûH™[∫o,!R#&X'&\++a0,d54kA7nF<pJ?sODuUIwZKy]O{`P}`N|_M|ZL|R9g9#L$(L(1P08S45.+,5S--S$)U ,Y"3^)'M"F<*
+/5\'<l.:n.T5h/@s;9n6!O >=X9TsJVvGFc5Sl5{èGΩÕt™ºNù¥?nãTyOwKvN{CrKwP{)9d&P(O&L,P -N!(5%B,N-O<a--S 5])?j54_)Ai45Y)&	!"!	%IRA-9% -,,# /3G,EdBMsLIsKFqFEpE?h>'M$+O)1P.(C$:S68R54X2.W++U%*Q""HCC#C4!<+K".T%.X&,X%$KB"G(M"*Q%+R&,U+-S*(L&#G#>fDHqQKtTR{[AjJ?hHJuWMzYCqLApF%N",S&.S(,O%:^2<]0+J .M$-L#.N%0S+3X-3]/3^07`4!G6Z4)K& @NlFYsL`rJlrLÄxSôÖb±ïp∆¶}”ªãÿŒì—“ê—‘èŒ‘äœ÷à–’É–‘–”z“”v’–t÷≈i¡üEøâ1Ãã1ÀÖ&«{∆rŒt–r”u÷y÷{⁄Ö€ÜŸÇ⁄Å◊w‘n◊gŸe €g ‡oﬂpŸo ﬂ|‰Å⁄r‘j Ÿj ‹mﬁo‹mÿi Ÿmÿp÷r Ÿzÿ{◊{ ÿ|·Ö
+‹Ç⁄}€Ç
+€âŸä÷â	–Å”ÄŒx o  n ∆p ≈v »Ç∆Ü
+¬Ü
+¿Ü	¬åªä
+∏ã
+ªîªûΩ®æØª≥ ªµ!º∑%Ω∏&º∫'øΩ*øø+øø)ææ(Ω¿'Ω¿'ºΩ$ªª%ª∫$∏∏"∂∂"∞≤ ±±Æ∞Æ∞!´Æ#™¨'®™-¢•0¢§7ü¢;ôù>íó=äè;ÇÜ:{Ä=y}@v{CyÄL|ÇT{}VbcC@@(5274%C@1IF51.$!3.E>"UK'^ReX!E::22,!!*&C;i^0^R":.,$&  $!*&*#%  ' +"=4+H@5KE7OI9QN;NL7NL5NN4OO3PQ1PU-SY+X]%_d$fi"lo tx!Ñà'ëì&ùû'§£$™™$±Ø&µ¥(∂≥$∑µ$∑µ$∏∂#π∑$∑µ"π¥"∑≤ ∂≤∑±∂Æ∑≠¥•µ•µ†≥ú∫§ƒÆ%≈Æ$«∞$Œ∑)“º+ÿø/⁄æ/‹ª.€∂)€¥(ﬁ∏)ﬁª+ﬁæ-‹ª.€∫-⁄π,€∫/⁄∏0‹º5ﬂ¡;‡√Aﬂ¬B·≈H‡»LﬂÀN·—W‚”TﬂÃI‹À?‚‘=‚ÿ8·Ÿ6‡Ÿ3Â‹5Êﬂ9Ë·;Áﬂ<„‹6Â‹9Â‹?Ë›CÈ‹B‡—:‹ 8„Œ?Á“CÎ÷IÓ€N›R›SÙ‚ZÚÈ^ÌbÛhÌÒhÎÔfÌÒiÏhÈÎdÁÈaÈÈcÈÈcÊ„`‚ŸXﬂ‘T·÷V‚ŸZﬂ÷Wﬁ’V€–R⁄ÃQÿ≈M÷¡L“ΩJ—ªLÕ∂NÃ∞O◊±\–úQ¥n2ÖMQD9E!&9#>(K!#J#K#K-S$0S)(G'%A*&>1ä†ûõÆ¥°≤º•≤¬î°≤ò•∂ëù´ñü®glpFLJSZShogW_T/;/VdWHUK5'A$'F$&H#&F"= 4'6-:&5B. /,C&'@ $= 1I14L4*@+ 31%<"#= ,K,9Z;3R3,K+>`;Bf@:`;2U43T59Z;3R35T45T23S.4T-.N'2R-2Q/0O-3P1(B%,C'$; 744 4"9 65#6 $7!2 31*" íáG±îF…úG“òD…à,‡ù5‘í" Ü∆~ªi∑h ÿó!ﬂ¨,Œ§»† ü…ó…éª|
+«à…ã ê"¬Ö¿}…Å Å"√z≈|√x¬w≈y!Øcƒx$ªs!∂r∫y%∏z'∏w%∂q#±e∂jÆgµt"∫},∑z*±o#≤s&¥{,≤y,±r+Æk'´a"∞f%∏x0æÉ7 X)"Z)*b3*b3'_0+c6/d::lF?nJApN@nQ@nRDrVGu[Kw^JwZLzULyPBoD$M%*L+8U769192U+%L J#M/W#(N/S#2	5'$&94[/7e4$T""M %P%*W,H B"OpQTzURvJNh8wãL∏«r¡Õgπ«V¨øIõ∂AkãU{FqBnHu$Kx%\à;%OA
+"F ?	% #=++A8U%*M*L9^++O8^+=e19d/>j5Fn<-M$+2,?!"5+!#?G28@+#,+#1&5+;-B!B]:NpKLrKDnFCmEAlA1Z0,R)/R*$B .G)@Y;<^93Z.)P#(O"$I@@#B=,L%.T%,V$,[%.]'-Y$B"H$I)P$-S*)R&.U)(M$1U/=`@GlMOxVQzZ6_?GrTItVQ~]DrN>kD><$I)N"+L!)H,F!4N+1L)+I#,J&%H/V)-W'8]26=,G(AX;UfFbhFyqMöÇ^¥în¬°x ´}”ºà‘ƒâ— ÜŒÀÑŒ ÅÀ»{Ã«vŒ…wŒ»rŒ«o–∆m’ƒl—ØX∫å6ƒã4—ê6ÃÜ&»~œÅ’Ñ–{’|ÿÄ÷~€›Å€Ä‹~Ÿy›x‡zﬁt€l⁄k €q›x·}›y‘n ’m ⁄rÿr⁄t‹wŸu÷w◊z‘| ‘Ç—Ç ◊ÑÿÉﬁâ⁄Ä‘r⁄xÿy◊|
+’{	—x“yÕt  p Àt…xÃÑ–ê»è¿Üøà	øåøèæóæùø•Ω¨æ¥!º∂"æ∏&Ω∏(æº+øΩ,¡ø.¡ø.¡¡/¿¿,Ω¿)ºø&ºº&ª∫$∫∫$∫∫$ππ%∑∑%¥∂$±≥"ÆØ#©´$•¶'õö&ëê$áâ$áã,áå2Ñå7Öé?~Ü;{Ö@~ÑFÄÖM|ÉPwyQbaC86+(-'-%.']V:SL0 
+
+$ -*1,3-6-TImc2:2("":3fZ4m`6D8%!   !!""'%&"(!)"%$(,#:3)HB6MG9PJ:OL9NM9KJ5ML7NN6PS6PT1RX,]b,dh+fi$jotx!Ñâ%óö'£•(´´'ÆØ%¥≤)µ¥(∑¥'∏µ&π¥%ª∂&π¥$π¥$∑∞!∂Ø ∂∞∑Ø∑¨∑®∂§±ö∞ì®ã¥öπ¢¡™ ≈≠%»∞(Õ∂,”π.’∫-◊∫.⁄ª/€∫/€∫/›º/€º.›æ0‹Ω/€º.€º0›ª3ﬁæ5ﬂ≈<ﬂ»>·…A„ÕF‡ŒDﬂœDﬁŒC‹Õ@⁄ 7◊ 0‡ÿ7„ﬁ:„ﬁ8„ﬁ8‰›7Âﬁ8Âﬁ8Êﬂ9Ë‡=È·@Ë›CÁ‹BÁ⁄@Â÷=‚“>„—?Â–CË“HÌ’MÌ“MËÕJÎ”OﬁXÚÊ`ÒÁaÓÊaÎ‚_ÒËeÓÁcÌÊaÏÂaÏ„`Î‡`Î‹_Á—WÊŒTÁ—WÁ—Y·ÀSﬁ≈NŸºG“≥?ŒÆ=ŒÆ?ŒÆ?Œ∞BÕ≤I÷∏V⁄≤[»îI≠i,JMA1?%=)H'M'O$L$J#F&F!$C#4U8DfNdÉqmâ{hyÇîòí°®ì¢©guxISR:E?7D;N[QmwlpzoxÑxZg]O_U!1'7G=#=O??W?.M+-P&,M"">1$3!0 /0D("94+C+.F.+C+.+,2)H)FhGLpLCgC:^:=a;=a=2V0/Q.6X56X72T31P.1Q,,O'-P(2T12T10O-1P02O05O2'@#78$= *E$,G&+F'(E&2O06T25S17U36P3'@#2(*- çÉ<ØñB…°I√ç3◊õ9—ò%Õìœì‘ñ ã›¢*‚±1—•"»† ¢ƒô ö»êº«â∆ä«ä≈àø~√}≈|ºs¿wøv≈| æt≥køx&ªx)∫x*ªx*∂s%¥r$ªy+∑s(∞l!≠l≥v%ªÇ1µ~,¨q#¨q#Øv'¨t'®p&∞x.≥}3Ωá=¬åB∏É7#\/(a4/g:0h;2j=7l@8kB9kE4d>3b>?nLGuXBpT?mQCoXHt[Mz[QZ<kAK"!F$,M.6U3)I$:;)L""GDB F$J&J=7Q.43527Z91^3+Z.*W04^8-Z3K'/T5MrSW|ZIj?Çó_ª»Ä…÷z»’kπ«XØ¿N•ºHiÖRv=e0Y+WTÉ3VÑ9Gq1E8\,:Y/$@,F5'@>\*)L(J4V$+L=a1=e1Bn9Cr<Gs@U{L7X-2N&;U.F`9E^73D$*79A*@E/08#*4'4.=,=0F 3M&?[5JiGKmLHkJFlG@iA9b8-R)&F!,E'HaAFfA1T*)N#'L $H@:=(H,P$-U#-Y$,[$2a*/_%/Z$#I E$K-T((Q%0W+(M"+P';^>LqRIrP;gD>gGP|[IuTN|XJxS=jA I!+R&1X)/W%*N"1O)g_MdG,E%9T1+G!1R';c1;f18\,/N$.H%'7FO4qpTêÉcÆóuƒ§~Œ´Åœ±À≤zÕª}À¡|Ã∆z»≈t ≈t≈Ωlƒ∫e«ºc«π`«∏]∆≤Y ØV√ñC∫É0Ãê8–ë4Àá$ÕÖ‘ã"—Ñœ}⁄Ö’–x’vÿwŸy⁄z◊uÿvﬁ}·}⁄p÷l ﬁv›w◊q‘n ◊o ﬁx	‹x—p ÷r €zÿ~÷ÅÿÑ‹ä
+›ìŸèÿâ◊ÖŸÉ
+‘x	Œl‘q‘s‘v‘v—t‘t“u“x—}	ÕÅ	ŒàÃèƒç¬ç≈î≈ô√õ¬°æ§º©ΩÆΩµ"æ∏&æπ)æπ*¿Ω.¡æ/¬ø0¬ø0¿ø/øø-ææ(ææ(ΩΩ)ªª'∫∫(∫∫(∏∑'µ∑(±≥"´Æ§¶¢£!õõ!óï$ìî,åé-âå1Çà2Åà8Äã=zÖ9xÇ=|ÇD{ÄHwzKgiD<:#,&*#(!'%g`Ce^A&!!%"&$%#!% 0)cZ1_V-0+	4.SH*dX2ZP-/'!  ""&$" %(!' %'-$<5+HB6JG8MJ;KI:ON<NM;KJ6KM7OR7RV5SU-WY'[\"`b!im!x|'ÄÖ!ïò%£•&´´%ÆØ%≥≤&¥≥'∂≥(∑¥'∫¥(ªµ)π¥%∏≥$µÆ"µÆ µ≠µ≠µ®±¢±ú≤ò≤ê
+µì∫ü∏ùπúΩü»¨%Õ±*Õ±)Õ≤'Œ±'—±(÷≤*ÿ≤+◊±(÷≤&‘¥%÷∂%÷∂%“≤!—±"‘µ&◊æ-Ÿ≈2Ÿ«5⁄ 7ŸÀ6⁄œ7›œ8ﬂ“8ﬂ“4·◊7‚›9„‡9„‡9Â‡:„‹6‰›7Â›:Áﬂ<Á‚>Ë‚BÌ„FÏ·GÍﬂEÍﬂEÏ·IÓ‚NÔ‡QÎ‹OÌ⁄PÎ’NÌ÷RÏÿUÏ€WÌ·[Í›ZÊ‹XË€YËﬁ[Ëﬁ[Á›ZÈﬂ\Ë€[Á’Y‡ P›¿H⁄ºD’ªD÷ºE–∂?—¥?œ∞<”≥B”µC–≤@–≤B—µG–∏NÿºYÿ∞XœõOµs7~JKC.?*F(L&L&N$J#G%E%E %G">b>GoLMrSHjQE`M9NEFVSL]W0?8(5,+8./?4UeXwÉwwÉu|ä{]k^[kaUe[àïé3@7\lasÜsA\=,L#-N#+J #:,' /DV<+?$.(@*(@()A)-)()2:Y9IkHDhDAc@6X52V24X2/R*0R-;]:2T1-M(4T/*M%2T/6X75T42Q11P02O00M/(B%!<"? 5S1:Z54T-/O*,L'.P+0S+3V,8[39Y46T24O.6HBJòíF™î>∆£Eªç+Œõ0€Ø2·∑1⁄Æ+·≤0€¨*÷™'Ã§—´$À•…£∆û∆ô∆è¿Öƒà»å«äƒÜ¬Ñªyøx∫s¿yªtæwØgªw$ø|-ªy/ª{1≥o&≤n%¥t*∂x-±s(©i∂w*∂x+µz,æÖ8≤y,±w-≥{0´v*™t*∂Ç7ªä>ºà?∑|8≠p-1h@3jB3jC8oH=qJ=qJ=oI=oI3g@4i?/a;.`;1c@<mOCqWJx^M{_M|\OWFuK&N+$I'1T3,N->;$B"BBA@<="A">">#>"=66\76e;4h:5h=-`5+[1%S,0W8IlLZzUb|L∫…Ü—⁄â—‹Ä¡œmÆøYû±Hyä ^tMmDiMu.Ny1RÅ3<m>n$;j&'P8_*0U!,N"?%@2P5V!2T!+M/P!Dh8Hp>IuBFu?Ht?Go=SyJIj=Lm@Jk<SsD>T-0?2:"9>*-1  $$4A#2B0E4I"5K'2F* 75K6JdKNoPFlG3Y2&H#%C!3N+PlF7V-&I#H%HB9 @)L",R#,W"*Y",[$1`)4d*9f/?B"I2Y,*Q$-T'(O#*P'=eCIrPAmI<hDHqOQzXLxUN|WHwM=l>3a08d/7d-5`*1W(4R,QhKYkQF]@=W4+J!:^.>g-En2Fm4Oo=Lc9QV6oVùÉjæ•Ü’øñ◊«ñ÷«êÿ ç“«Ö—«œ»zÃ∆r ∆m…ƒi…¬gÃ¬cÕ¿`Œª\Œ∑WÃ≤SÀ®Lºâ6¡á5Ãê8Œè2Œé*”ê'÷é"“Ö”Å÷Å‘}”x“q
+”pÿv⁄x	⁄yŸxﬁ	ﬂÄ
+ﬁx	Ÿs€r’l’h‘g ÷m ﬂy⁄vœn ÷rŸxŸÉ⁄à
+’Ü◊äÿé	÷å	’Ü÷Ç”y	‘x◊|#€Ç.›á2€Ö0⁄Ç+÷z#‘u◊v’z—}ŒÅÀÖƒÑ√ä	ƒì«ú∆§ƒß¬®æ´ ¿±"ø¥$øπ'æπ)æª,æª.¬ø2¡æ1¬ø2¡¿0¡æ/ææ,ææ*ææ*ΩΩ)∫π)π∏*µ∂,¥µ-±≥+≤µ*∞¥+¨∞(©¨+¶®+†°,ôõ.ìï2éí4Üå6Ü6{Ü8zÖ9u8w}=tw@hi?BA#/)*#'#!IG2IG01.(&(&(&*',) 0,!+))'$$   % IB&e]8QH','0*A9"VK-bW7OH,+%"#!$"#!"#&$)#,#,%(!(.%@9/FB6HF9JH;HH<KL>NOAOP@KL:MO9RR6RT/VU'SSTU^anq"{!ãè!†¢'´´'≤∞'∂≤*∂≥(∂µ)∏∑+πµ-∏¥,∂≤*∑≥+∑±)µ≠$¥´ µ¨∑™¥§¥û∞ñ≥ñªõ∑ö∑ñ≤ä≥ãπïƒ§ ™! ≠#»®Ãß"Ã†∆ï√ì≈ö«û»§…¶∆•
+À™œ≤‘Ω!‘¬$‘∆(⁄Œ.€”0ﬁŸ5‡€9ﬂ⁄8„€8‰ﬂ;‰·:‰„;‰·:ﬂ⁄4ﬁ’2·ÿ5„ﬁ<Ê„@ÈÁEÍÊEÏ„FÍ‡CÏ„HÓËLÔÏQÔVÔÌZÎÈXÎÊWÈ„WÌÁ]ÔÈ_ÏÈ^ÌÍ_ÌÈaÏË`ÓÁbÔËcÓÁcÔÊcÔÊgÌﬂdÌ◊_‰ S‰≈PÁ»SÁÃW·»Q›ƒMÿ¬J◊√JŸ…PŸÀQ÷»N”¬L—¿L–¿Q’øY’≤XŒùQ©k0uGFC0G)J(N'M&L&J+K$'E$D%J1[-Cl@EnFCeD4Q50H2+@-%:'"7$"3!(6'.</LZMP^MXgTfubUcRP`S`pefsj@MDhukÅíÇEY@)B"+J!)I '@ /("10B(.B'0%;&%;$,?).)#%5=W:;X:.K,&C$=A-O*/R*-P(5U03S.1O+3S.+M(6X39X84S42Q21P10M1+H,(G'#B "A/Q,2W.5Z18Z56X32T/.Q)1Q(3V,4Y05X08W.:R HTüûN∞üE¿£?Øãﬁ∫@ﬁƒ;€≈4‚…;◊º/ÕÆ"ºõ“±$”≤%Õ©! • »£…†"æåπÄ¬Ü«ã√âøÜæÑ ¿Ñ"Ω|ªzæ}!Ωz!ªx!¨hºw*ø{2¥o,∑t0∞k(≥p*¥x/∑}3Ær*¨m&≥s,±n(¨g"≠j&∂w2µ|5±{3Ø{2¥Ä7πÉ=≥v3∞l/Ø^)•O=pO>qP?rQBvRAuQCuPDvQJ|WAuO:nGCuO7iC6hE7eH9gM?mSO}cM|\OYGvL$N(F#*O.7X9&E%-5#> ?<>857557<.P-;c>;kA9nB1i<0e7-a3)X.2[9AdC_{RÅñ^«“Ü”‹É∆—s∫»i≠æ^ñ®Ectj Wv&V{5[Ñ>Zà@Wá;Dw(Cx(MÅ63a %Q1X,Q-O&F0Q?`+-O-O@b0Ko?Hp>Am:=i4<h3Ep;Jr>SyHMs@Cj5Hj7,C+:)3,137(!0:!5C"5E!5F"0C#, *!;"6W8:`;:`9+P'"D!+I%F`;RnF0P),O'!D@?)I *O#+R#+W$*Y#.]'/^(/`(2a*:
+B!H/V)*Q$)P#(O#/U,;c@@iG7d=9f?MuSOwUKwSGuNArECuDDt@>o86e..[$+U#/R(5L/FZ?RfJ=W48W.8\,>g/Ir8Sy@Sm=_g@vmL£àmÀ©ç€¡ú›Àù⁄œó◊“í’—ä—À— z“Ãv“Õq”œn“Ãl‘œk÷Õh‘»b—¿X”ΩW”ºT–ÆL¿ç4»å6œí9Õë1Œì+“î'”å –ÉŒ{Œw‘}“z—t
+◊xÿv	◊vŸzﬂÇﬂÇ·Ç‰~⁄qÿm„v⁄j”c ◊n‡|÷t–n “n “q ÿÇ	⁄à
+ÿÜ◊Ö“Ä‘ÇŸÖ‘}	’x‡Ü&‚ê:‹è=ﬂîC‚óF‚ïE›å;›Ñ2“v–s–w“ÇÕÖ…â∆è∆ó≈†≈ß!¿® æ´!øØ$¿µ'ø∑(¿π*ø∫+æª0øª3¡Ω5¿Ω2¬ø4¡¿2¡æ1¿Ω.ΩΩ+ºª+πª,∑∏.∏∏2∏∫5∏π7πº7∏ª6∏º4¥∑2∞≥2¨Æ1§®0û¢3ñõ4èì2àé4á2yÇ1uÄ4q{6pv8ln<NK(2-/')"!)&FD5GF4@>/<:-></;9,:6+84)62&-+(&""!!!1-f`@^U4A:&#.(6/J@'\S4i`AF?#.)(%%#%#&$(&,&.(-&*#) /( A:0GC7HF9JH;JJ>JJ>KK?JK=GH8JL7NQ6QR0ST*VU%XX$]_ im!tyÅÑòô"©©'±Ø(µ±)∑≥+∏∂-∑µ,∏¥.∑≥-∏¥.π≤-π≤-∑Ø*∏Ø&∂≠"∂™ ∏®≤û±ôµôπú∑ó≥è≥â∏å∑ëºòæùæù¿û¬ö∫â∂Å ¬é«ò…ü •…¶
+»®–∞“∂’Ωÿ«"⁄Õ'€“+‹’-ﬂ€2‡€5›ÿ2ﬂ⁄4„ﬁ8‚ﬂ:Ê„>ÈÊAËÂ@Ï‰DÊGÒÈIÚÏLÒÎMÚÈN„GÍ›AÊ€AË·HÓÈQÏÎSÌÌYÌÏ\ÌÏ^ÏÎ]ÌÓbÔÚeÓÒdÓÒdÒeÓÔeÌÎbÏÍaÏËbÏËcË„cÈﬁ`Á‘[ﬁ»P›≈K·»QﬂÀR€«N÷√J’«L◊ÕQÿ”U÷“T’–R—«L“∆P÷…Y◊¡[’∞W¡çBùa%oCBD.K(M&N(N(L +K$)I"(H'K'O.X&<f8;b60R-+H)*D'*C&";#;!"5(9&5C4DRCJ[HK]GK]EJ\FJ[IjzmåÇDQGUcVQ_N%4$8&A  ;&=  4+/<(.<%+:##52 3':$2,+)077;'D%-L,9[86X3/R*+N&,L%0P)2P,/O*,N)6X59X82O10M/1N2-I0.L08Z7;_98[34Y01X,.U).S*.S*4W/7Z08\06Z.4Y.0U)3T)5PBQöúI∂ßL∫°:∑ö%ﬂƒC› =⁄Ã7–¬.–æ,Œµ$ÿº,’∑%‘µ&…•ƒü∆£!…°% ô"∏Ä¡á¡á¿Ü¿á ΩÜ!∫Ç!ºÅ#∏{ ∑z!º|$∫z#Øn∑s(∏s.µp/¥n0´e'¥s1∞u/¥{4≥w1¥w4∞p0≠l,¨f(¢^§i'≠v3Øz6∞{7∞v6∏x:Æf,¶S£D¢?Eu[Eu[Hy[DuUIzZEwTQ~]IvUQÄ`M|ZHwUN}[BqQDqTFrYJv]N|`IxXJzTN}SDqFG%H(0N2;%#	6 ="A"=!:4/.*.73V59c?=mE5j@3k>,a3-a3-\00]6;`7WsCí§h¿Ãz¬Ãlµ¿`¨∫Y≤¿_ú¨IÜô0~ò5_Ä/W8]àCaêJ[éCOÜ5FÄ,KÑ3H|4D*S.S.S3Y 4Z!/T$I-R;a.<b/>f4>i4An7An5@m4>i1Ep8Do7Jq<Dd34H#2?#&0"AJ9 (#'1-: "00 9'F$/Q01V48`;;d<4]34Z1(L('F$6O/UoL5P-1Q*+K$A"E)N#+P$+R%-Y(.Z)7c24`-4e.%V$PH#J,S&'N(O (O"#J/U0;a<:d>:d>FkJRwXAkG>lE@qDFwHHxH=m;9h4<k7Eq>@g:5S/E]=EX<:O05O*0Q&9_0@f5Mn?\mC~qQ°Ég¬£Ñ◊ªñŸƒï‘≈éÿÕèŸ–ã⁄“á⁄”Ç÷–z◊“w◊”r’–l÷Œk’Œf◊–f◊œd”…Z◊À[ŸÃZ◊¡R¿î3ΩÖ( è1Œì/–ï-“ñ(—ç ÀÅ—{”|‘}’÷ÄÿÅ”u“t €Å	›Ö
+ﬁÅ
+›y	Ÿl’c ‹lÍz⁄m◊l⁄tÿvÿw‘s—m —p ÿ}ŸÄ÷{—s ”v “u ÿx‘u”x‡å*ﬂò>ÿóCŸõH›†Oﬂ¢QﬁüO‡ôK‘É4–q—q“z’ÜÀäÕó ü∆§¬¶!¡©#ø´&ΩØ(¿∑,¿π-øπ-¡ª1æ∫4¿º6¬æ8√ø9¬ø4¿Ω0øº/ºπ,∫π+π∫0∫º7ªæ=ºæ?ΩøBºæ?∫ø>∫ø>∑Ω9∂π4≤µ2≠≤2©≠2ß¨8û§6ïö3éñ3âí5Ñå7zÇ7ls0ck2Y\1840)-##!!*' ==3LM?EF6BC5?@2==1;;/<:.75)42%,*(&(&&$&#UP0qiEUL-?7 $!# +$2+C;&UK0ja@lfFD=#3.+()'*(+(.(1+,%&"' 0)!D>2FC4HE6MI=RPCNNBIK>HJ<HJ<JM:IM6GJ+OQ*TW(Z_'af&jp&vz#ÄÇíí ¢£#¨¨&≥±*∑µ,∏µ0∑¥/∂≥.∏¥/∑≥.∫≥/∫∞-πØ+πØ)∑Æ%∏¨$∏´!∑ß ≥üµù∂ò≠ã≥å	∫íµçπì
+∫ñ
+∏ò	πôΩöµé¥Ñ ∫àƒì
+ƒó∆°
+»ß
+ ™
+»´	Õ∞”∑‘º÷√⁄Õ'ﬁ”,ﬁ’.·⁄4„‹6„€8‚⁄7‚⁄7Â›<Ê·?ÍËFÎÈGÓÈMÒËM„GÏ›DÓ›GÒ›JÔ€FÔ€FÔﬂKÒ·M‡MÎ‹KÈﬁPÎ‚WÌ‰[ÎÂ]ÏÌcÏÒcÏÙcÏÙcÔÚcÌÓbÍÎ_ÎÏbÏÓfÎÌfËËbÂ‚_„‹Z‚ŸX„⁄Y„⁄Yﬁ‘X‹“V⁄“Uÿ‘V◊ÿX◊ÿX‘‘R‘œQ”…N‘≈P”¡S÷∫V’ßQ√â?†c$oF>G+N(Q%M)M'J )L"&K &M%M(P*Q"1X,/T+(K#(H#*H&,J(%B#'A$$;!:M9>P@ATAI\FPdIAU:FZA[nZnÄpxÑv4@2,9(#0+&*+2,".<E0DN63<'$104$;!310/2;2Q/<^;=_:9[66Z45X02U-/O(,L#/O(1O+,L',P,7[76U5.K-.K/*F-&B)*I*8\6;b6=b7<c7;b58b47`4;b6:_4:_46[/5Z.6Z.5Y-0O&0H>M
+ù°M∑™Nµû6ø¶/‡…E€…9Œæ*—¡.‘ø.ÿø.—∑$…Æ–≤ Àß¿öƒû≈ù#»õ&∏Ñ¿ÜøÑøÑ∫Éøâ%ºÜ&ΩÖ(µ|"≥w≥w!π|)µx(∑x+∏u/±j*´c(¨h+∫z<≤w5Øv3≥v5±t3≠q2¥z:´t3¶q-¶t/¨z5¥}<≠q3±n7¥h6•M†A¶AÆIBmZKxcRÄfEvXNaKzZQ~_S~`Ly\WÑgTÅdN|_SÄcN{^Mx]P|aRÅaRÅ_QZN{T7`8@#D'+I-.L0(G(< %B&#B# ? #A%(F*< -+(*5&K*9eA:lF9nD+`22h7-a06h74b4%LUs?áù]≤¡n¶±U•≤V¨∫[∂ƒc≥√`¨¬]vî4Uw*\Ö?bèJ_ëJZéCOÖ7Oâ5KÑ3H~2PC
+1V"-R*Q&M(O3X"2Y$6](<b/<b1Em;Ep;Ep:Fq9Bm5Ep:Fn9Hn=9X.FY9@N4=K1"05A-(3"#%#
+(1H+6V12X12[39c;8c86a67`69b8-S,*L).I*<U5G`@8S08X1"E#H+P%)P$(Q%.W+0[.9b68c55f/([#1`*G!H&M %L(O &M %J!)H(1P1;]<#F&0Q6<^C@hFLyRFvLEvGEtFDtD@p>>m97f2/Y)7W09S0=R3<Q27Q.-K%-P&4U*F\5fgEíwZ¡ú€øòﬂ õŸÃï”…ã“«Ö÷ÃÑ€œÉ⁄œ}€œyﬁ”y›‘u€”pÿŒl⁄—lÿœhŸ—f⁄–a‹“_‹”^ﬂÀZ√ô5∏É#…ì1œò3“ú2“ò*Õã Äœ|–yœx—}’Ö—Ä
+“|€Ç
+ﬁà’÷x’qÿkÿh◊h ⁄m€pﬂv‹v
+€wﬁ}Ÿy÷t“p◊w⁄z	ÿt“l ÿr‹x’s—qÃq’Éﬁô<ŸûDÿüHŸ£M⁄¶Rﬁ™V‡•UﬁôK◊Å6ÿ}.”}(Œ" áÀí!Àö#¬ö¿¢ ¬™&¬Ø,¿¥,æ∂-øπ/¿∫2¿π4øª5¿º7√ø9¬æ8Ωπ1º∏0∫∂.ªπ0Ωª4øø;æø@æ¿Eæ¬Iæ¬IΩ¡Fª¿Bª¿@πæ=πº9∏ª6∂π8≥∏8Ø≥:™Ø;£™:ö°9êó7Åâ3rx.dj,bh8BC!2+/%)%% -*#>>6KMBMOBGI;DE7B@3:8+:8+;9-75(42#/-*(+')&;7pjHkc?ND)>6#&"   (%+'3-B;)MF,^U6skGjaBA<4153&31"30!2/ 3/#-)'#)"5.$A>/GD5IF7NK<QO@LM=JL>HJ<JL>KN;IM4HM-KP(PV(X\)]c'fk(pu%~!ãç úú"®®$Ø≠&µ≥,∂≥.∏µ0∑¥/∏¥/π≤.∏Ø,∏Æ+∑™(∑™'µ©#µ©#π´&∫©%∑•∏†µóØå∏ëΩó≥è∏î∑î∑óπôπñπî∫èπä ∏â ∂â æô  ®	»® ™	Õ∞“µ’πÿ¿€»#€Ã'€Œ(€Œ*ﬁ—-Â◊6ÈŸ;Í◊;Ì÷;Ìÿ?Ú·IÚ„LÚ·M‹IÏ‘@Ë–<È–@Í—AÂ—>ÍŸEÏ‹IË⁄F‚“AË◊IÏ›PÔ‚XÌﬂXÍﬁXÎÂ]ÌÏ`Î`ÍÚaËÎ\ÊËYÊÁ[ËÎ^ÌÒfÓÚiÏhÎÌfÎÎeËËbÂÁb‚‚^·‹\ﬂ⁄\ﬁ⁄]‹€]⁄€\◊÷W‘œQÕ√GÕΩDÃ∏E…≤HÀ™I‘¢M≈â@ö\lE@K*O(Q'P&J(L 'L 'N$N$O&N&M,S&2Y-7\11T,-P(4W//O*)G%%?"0H04I6;P=BV=RiLAY9E\?RhQK^J5C2*7&-:)+:'%4!,&,$2!()2>F/CH2*2 +"15'?%&>$#<&@#<&E#4V34X2@d>=b9=b98]25Z/3V.2R+,L#-M$.L(*J%.P-3V50O0-L--J."?#!?#%D$/T+7^17^26]05_12\.1[-0Z,2W,1V+4W-8[16Y/0P'-I#.F=L	û¢N∑™N¨ó.—ªA–º5≈µ$ ∫&—¡-œæ*«±√´÷Ω%“∑"—≠!πîæõ¿ú"¡ò$∑â∑~∑y∫~¥z∑Å!≤}∂Ä&∑(µ{'µ{)¥y+±v*Øq(±q*±m.≠h-°a$±u7∞y9™s3≠q3¨r3©q4©v5Æ~<™}9±Ç>µÇA∞t8Æk4¨`/°J§D™D´F´F:cUNwgTÅjO}aM~aQcO|_XÖhYÑiQ}bXÑiTÅdP}`TÅbQ~aO|]O~ZKyT8b>4Y7 B!8"?#)G+/R1.V15]81Y4,T/#I$ A"&E&$A#4.*/=2Z78fA:mD/d6,b04i5*_)-_*/a.1]*El5dÇDôØdó©Uß∂a±¡h∑≈dµ«dñ±RSu_Ö<cçKdìM[èG^êGOÉ8Tâ9NÉ3I~03b@
+$F)K&K#J.W7_#8_&Fk7Im=>b6Di=Fn<Hp<Ek8Ek:Fl=Ae9KiE;T6SjNDX<>S2,?!+9 ,8$$-$,&$%< 9W53X/0Y/3\48a7;f9:e7<g9;d80V-1S.5S1:S3@Y9D_<?[5'G 'J *Q%(Q%+T*.W-3\2:e::h:2d/&Y!*[$G G!F%L'N(M!#A%((;(%-8V>MrSMyUGtK=l>9h:3c18h43c/9h42\..N'+F#8R/AZ:>W73N--M&8Q*OP0sbD¨âm’±ç€…ô‹”öÿ‘î‘–â÷ŒÜ◊…Ä◊≈{ÿ¬v⁄√s›«r‹»o€ n›Œqﬂ–q›œnŸÀh◊ bﬁ–eﬁ–c· `ƒö8ªà,Œû<—°;—°5Ãñ)Àâ…Œ}Õx–{“ÄœÕÅ	’â⁄åÿÑ
+‘{‘tÿw›w	Ÿs’m ÿp⁄p⁄oŸl›t	›|⁄|
+÷x“r‘rﬁx€p–e –e ÷p◊w–rÃoÀxÿí0⁄ù@ŸûDŸ°J◊¶J€¨RﬁÆYﬁßT”êB⁄ëDﬂñG”å:–â1ÀÜ'Àå#…î$«£(≈Æ,√≤.¿¥,æ∂-¡π0¡ª3¡∫5¬ª6√º7√ª4º∂.π≥+ª∑1æª8ææ<øæ?¿¿D¿¬G¿¡I¿¡I¡¬Jø¿Hø¡FΩ¬Dº¡Aºø<ºæ9ªΩ8π∫8∑∏9±≥8©≠5ú†1àç){Å)rz1jr7Y[351.&+!+"+$-+AA5RRFPREOQCJL>JG8GA1E>.=5(:6*:8+96'2/ 1-"/,4/`[>oiI]V9KC.=4%/&&)"%! (%+),(1+;6#HB*UN1i`?{sNc];@>%=<*=;,97(63$74%40$+),(95)@=,GD3JI7LK9QP<QS>NQ>LO<JM:IM6HO0KQ/IM(LQ(OR%PT"V[!ci#wy%áá#öô%¶•&±Æ+µ±+∑¥/∏µ0πµ0ª¥2∏±/¥´*µ™*∏´)∏´)∫¨)ª™(ª®'Ω®(ª§"ª†ªúπñ∏ìøõªó∑î∂ìπô∏òπõªõºñ∑å ∞Å ªå ƒö…¢	≈°»¶Œ™…•…•–ÆŒ∞—∏◊¡◊ƒ €≈$⁄¬$‹Ω%„Ω,Ê∑+Ë∑.Ò¡9Û≈>ı≈?ı«@¯ŒD˜“FÙÿIıﬂNÙÊQÚÎTÍTÌÁQÍ‚OÏ·QÎ‡RÂ⁄M‰‘K„”L·–L„◊QËÂZÈÎ\ÊËY‰ÊW‰ÊWÈÏ_ÏÒcÌÒfÏgÎÔgÈÏgÁÍe‰Ád„‰b‡€]ﬂ◊Zﬁÿ\‹÷Z›’YÿÃR“øGœ∏DœµDÃ≤D ØHŒ´M÷¶Q√â@óZ!lD@H+M*Q*S)P&N$O#N"J%M'O$N'S"2^-6`26`24^05\00U,+M(&E#$>! 7#2G4AX>AX;QkFSmJTmP=S<#6#- 1!"3!&7$'8%!2 4E54@2!,,5 NV?SVA16  ,1!5&?"'@#2M.DaBDcA:^8@e<=a;8\63V.9\24Y-4Y-5X./R*+K")I *J%)I$3R05T4-L-+J+%G&-P/;]:BdABe==b78^58_33]/2\.7^17\0<_5@c9FfA>^9/O()I")E1GAP£•Q∏©L¥ù3√Æ1–ø3’ 4—»/ÿœ6’ 2—¿*‘¿)’¿%ÿø'Ωû»®Ω†¿¢&ªö&ºí"∂}Øoµv∂y±x∞z Øy!¥~(µz,´p$Æp'Øp)≠q+Øt0∞r5¶j.ßo2≤@≥ÅBÆ{<™r7¶n3•o3´y<´~=©}<Ø?Æx<±n:©[-†I•H™H!®E™GÆK!4XNYrZÑpR~eTÇhNbN|_HuVR~cO{`P}`TÅbN{ZO|[KwVBnMIrPBjG>217:!"C&1Y65b;5b;3a:0]6.X21V4/R2%G&%D"$? !:&A"$C#-W39g@1d9.b2.c/0b-$W#V([#(Y!4_'@f)háC|ñMmÇ5ò¨W©∫\ßº]{ô?\Å1_àBfìR_ëL^ëL[çFUá>Uà=Vâ<I~0Ap*A:!A2T!0X2\4\ 4Y#0O#-K%#C2T/Ch<Gm>?c5Cd7Ff=Db>ZtWMeKbz`KdFC]8,E*:%1$$3L//Q.-S,-X-2[36a6;f8:f55`24_10Y/0T.?];MhID]?F_?B\9%C&I'N")R&,W,2[37`8;d<;f92b0)\$(Y!"ND F%M(P+P$:	*GcLKpQBlF8e:3c33c35e34d0;k7@n=2\.1T,+I%2M*;T4>U88P07Q.HS1fU;êlR¿óy◊∂ç“≈ê—–ê””çœÕÇ–»}◊…~ÿ≈yÿæsﬁ¡s‹øo€¡m›≈o‹ƒn‹«nﬁ…n‹«j€«f‡ eﬂ…c‡√_√î8√ê4–¢B—§?Œù4Àï(Àç–äŒÅ…{Ã~œÑ“á÷å÷è÷ã‘Å	”}‘{÷{Ÿ~	›‰É‰~·w
+‹oÿf“e ◊sﬂ›}÷v“m“i ”h Ãa —h ÷q“rÃpŒr u
+”ä#›ù9÷ö:’ûA’£DŸ´M›≤V€≠UœñEÿõKÂ™\›¢R‹ûK◊ï?Œã0 è)…û- ¨2ƒØ/¡≥.√∑1¡∑1¡π2¬∫3¡ª3¿∏1Ωµ,∏∞)∫≥.æ∫5¿Ω<¬æA¡øD√¡H¬¬J¿¡I¿¡I¿¬Gø¡F¿¬GΩ¬DΩ¬BΩæ<ºæ9ΩΩ9∫º7π∫8≥µ6™Æ3û£/íó1Öã3r|3em4BD.,,&1* ;7,JH<PQCSUGTVIOQDPREOPBMI=NF9LC4B;+?<-<:-96'52#63$83 XR8}xZidFWP6JB/?5)8/&1(!2)"+$)"+'-)+),(2.";5%KD1TM3bY:tlGáZa^?IG.FE1CB0@=,>;*<9*:7(:7(?<+?<+A@,ED2GF4ML8KM8NQ<MP;JN7JN3JQ/MS-MT+JO&HM$JP"QV \a!jm z{åé!††(Æ™,≥∞+∂¥-π∑0πµ0ª¥0∫≥/π∞/πÆ.∫≠+º≠,º™*∑§$¥ü πü$ØìØå∂èµãµå∫îºòºòºôΩòΩò∫öπöºòªí∫å¿ëΩê √úƒ†…ßœ´œ´œ´œ≠Ÿπﬁ¬ ‚Ã(‰—,Á—.ÊŒ0Á»0‰ª+ﬁ≠"ÿ§›´&ﬂ≠(Ÿ§ ‹™%‰∂/Ô≈=ÓÕ@Û›LÛÁSÎSÌÏTÒZÙ[ÚÏZÚÎ\ÚÈ\ÚÂ[ÔﬂVÏ⁄TÌ›VÎ„ZÍÈ[ÈÎ\ÎÌ^ÎÌ^ÍÏ]ËÈ]ËÈ_ÈÍbÈÊaÊ„`„„_„„a·‹\⁄œS›ÕSÿ P”√J“øIÃ∑B ±=Ã±@Ã≤CŒ≥H”∑S◊¥V’•QøÜAíV$[427,I+M*O-S (N&N!ID(P&Q%Q&R-\(4`/5`2:f53^0,S'*O$,O'*I'9 '?'-D*2K-JdA\wT[uX<T</D1/1!!2 &7$$5"0B2\m]LXJ5@0)5!T]HhmW?G2+ 26(A$.I*#@!(G%9[8Bf@Ae?5Y5-Q--Q+1V+0V'/U&0S),O'*J!$D%E )I$4R0.K,+H,#B#(J)9]9;_9=b9?d;=b7<a8<c7<e9Ah<Bg<Dg=Ff=HhA?_:/O*)I$*H"*F1GFV¶®T∂¶G≠ï)—æ=€Ã=€—;€’9€“7‘…/’∆-ÿ≈+—º!¡©«´∆©æ¶ ¿©)º§*∏ó$≤±u¥wΩÇ(∑Ä&≤|&¶p±z(≠s)¶j"™k&≠p-∞w4™p0§i-•m2ßq5≤ÄCÆ|?¢p3®t8¶r8©x=®z<¨ÄAµÖGØx@Æo<¶Y-ùH°E¨L$®HßF´L ±R&$A<\{s[ÄoT~hUÅhK|^M\7iD@oOBoNP~ZJxSLzS6c<BjH4W9< 8/114;$'H-/V73_>8dA7eA;iD=iE<eC;c@8`;.R,,L%-K%1O-+M*,T/>mC3d7-_./_-,\(!R$U$U(Z2_$9e*=e)Gk-D^ÄñM†¥]ûµZÅ°Ldç?eêKfîS^èNbïSTáDYåGUá@\èDOÑ6?q(%NB%G;^(Bi(8a5]!,M1&-5R4Bd?@c9A`6Hd<>\8`{\az]PiLa{^OjINjA7R'.B+7 	 1/L0*M,+P.0X35_79d97b4-[*,W))T&*S),R+-L*3N/8O5>R9PiI+I#&J+R%-V*1\15^6:`9=c:>g;5c2/`))Z"(TC!E(P*R-S$'E! 1!D]GDiH;h?5e54f12b.1`,9e2Co>;e77^2Bg>5W2GeALeE:Q47K/CS6YX:zT?¶r\ üŸºê’ í–œé——âœÕÇ–»}÷»}’¬u’ªn€ærÿ∑j◊∂g⁄πh⁄πhŸ∏g‹ºiﬂøhﬂ¿e‡øb·¿cﬁ∑Z«ë9 ë8‘üA–ú9Õñ/Õî)œì#—í!…Ü Ñ–é’ì÷ë‘å‘ä’Ü’Ñ‘É‘Öﬁèﬁé‚é„Ö‡|ﬁs‹l◊e◊g‹q‹v
+’p“mœh ”l‘n’o”nœm Õn n…o –|ÕÑ÷î&◊ô2“õ7÷¢?÷¶D›±R◊™MÃòB‘†L‡≥^‹≤^›∞]€®U’õGœî: í1Œü5…©2∆±2ƒ≤2√µ2¬∂.ø∂-ª¥(∫≥'ª≥*Ωµ.ø∏4Ω∂4Ω∏:æ∏<Ω∑=Ω∏@¬¿I¡¡Iæ¬Gæ√Eø¡Dæ¿Aª¿@º¡@æø?Ωæ<æ¿;Ωø:∫º7µ∏7≠±6¢ß3êó0{Ñ+mw0]f/9=24?A,OR?Y]L_cRZaQTZLRUJMODNPEMMCLH?IB8E?3D>2B?0B?0B<0@:,A<)JF-}xXxtQgbE]WAPI7@8+8.$5,#5,#,%-)1-"/+ 0,!0,!51%?9-KD4PJ4\U9lcBÖ}XâÑ\b`:ML0JH1IG2DB-C@-B?,E@,C>+>;(>=+A?0CB0GF4GI4JN7NR9OS8OT4MS-KR(LS'LT%JR#IQ IPQY^c ns!{ëî#••)±Æ+µ≥,∂¥+∏∂/πµ/πµ/∫≥/∏Ø,πØ,∫≠+∏¶&∏£&≤ò∑ò#≠â≤á≤ÇÆz≠z±É	∂ãæòºï∏âπã∫ëπìªï∏è ∫ç ∏ã ∫ç æñ √†«ßŒ¨Ã¨–≥÷Ω‹≈ﬂ #€Õ$‚’.Âÿ2Ë€7Íÿ:Á–5Ê»4ÈÀ9Îœ?Îœ@ÎÃ>È»;Â¿4‡ª/·Ω3ËÕ>‚NÒÍTÒÌXÒZÔYÌÎXÓÏ[ÚÌ]ÚÎ]ÒË[Ò‰XÎ‡SÂﬁRËÁYÍÌ^ÍÔ]ÎÔ]ÏÓ]Â‚U„›Uﬂ’Q⁄ÀJ◊»G÷«FŸÃL›ÀMŸ¡G”πB–≥>Œ±<ÃÆ<Ã±>Œ≥Bœ∏F”øN”¡S”¿Y÷π[◊®Vµ~=ÄI H#)*&;&@'C*I$E$D> G*T"&R)U *V#.Z'6b13_.2`15`21\..X(.U&.R&'E#'A$-E+.G*.G)JeFHdK6R<;T?6" 3 #6#$7$,J\Nó©õQ_P3A00=,KVE`iVAJ7!.0 7'A$7V6CeB4S1(G%/Q0;\=,O1+P/0V//T),R#*P!*M#*M#)I"'E&D &D"/J+*D)%?$;&E%6Z4<a86]16]11V*,Q&'N"%N"*P',P*1S.5U0/O*.L(*H$'G"(G)E/HK[©¨U∂£DØó)€ HŸŒ>€—;›‘9ÿŒ1ÿ….‘¿)⁄≈,Œ∑Õ¥“∂$√®æ®∫®"ª¨+∏¢*∞à´z´vªà,∂Ñ+¨z#üh≠t%®n%§i%©n,©o/®q1©q4¶k1®m5£k2§n2†j.ôg*ßw9§v8•y:´@©{?≠v>≠i:†S)õH¢J"¶O$©P$ßL©NØW'ØY(-*4MGNl`\~nQwbNy]P[6f@9gC?kH;gCNxRNxRA:80+).3 :!(F,/Q63Z=3^@7cB:gF;iE9eA/[7,Y2,V.*S)1V+8X/7V48Z7/W2=jA6e76d5#N!%Q %T%W$V+]",\ ,Y-Z!/X 6W ^z=ùµkìÆaníHeéHgîSeìUkõ_hö]OÅB[éKYåG\êHSâ=;m$#L&K&F.OQu7>e&Ci04S' 4%*@+D^C;]8;^4@_6B^8JeDTmORkMC\>E`?Db<A`68S*3C&+7! $
+,?+-J.)L,.S22Z75]8;e=<g:<g9;f8?j=7`60V/,N++H)'?%4K1AZ:,J$+P$+U',W*5`5:c;:`9>d=DmC9e45d0/^(,X# E!E)Q,T"3W+4	$4-P06_78f83a0/Y)F:d4Cm?<e9Cl@HqGEkB=]8LgFI`D>N4OW?iZCê_N≥yeœ§ÇŸæë◊Õí‘–ê”–â“ÀÉ“∆|◊≈{ÿ¿vŸΩsŸ∑o€µl€µj€∂h÷±c’∞`ÿµcÿ∂_’≥Y‘≥V’≤VŸ∞V í;…ç5œó:œó6Õí,Àé$Ãí$œì!Œå–èÿó“íÕàÃÜ“á–Ü”á÷ä‹è‡î‹çÿÖ÷{⁄x	ÿm”fŸl€pŸp€r⁄qﬁw›xÿv	“p“r–qÕn «h »i Œt–z	œÇ‘éÿö-—ò/”û8“†=◊´Hÿ¨KŒüC“§L⁄∑]◊∏^ÿ∏aŸ≥^Ÿ¶U⁄¢O”ó?Õï6Õû4Œ©6 Æ3ƒØ/Ω≠&∫Æ$ª≤'Ω∂*¿∏/ø∑2ø∏6æ∂7æ∂:æ∏<ªµ;ª∂>ΩªB¿¿Fæ¿CΩ¬Bø¡Bø¡Bø¬Aæ¡@¿¡Aæø?æø=ªæ9πº9≥∏7≠≥7ú£1äí+vÄ)it/bl7]e>]cG`eNbjS`iT`iVYbQPXKMPGLMGMLGLIBKF@JE?KG<HD8FC4HE6IE9GD3OJ4rnQÉÄ]tqPgcHb]IWP>G=13) 3) 4*!0(51&73(62'62'84)@9/D<1G@0OH5[T:jdD{sNêãaèä`_[8TP3RN5QM4LJ1JI-JF+EA(EC,DB-B?,A>+A@+AC-FH0LQ3OT4RX4T[1QY*PW#QZ#PW#OX!QZ!U]!V]`gpuÜâ ùû'¨¨*¥±,∏∂-π∑.πµ-πµ/∫≥.π∞-πØ,π¨)∫®(π•(π°'Ω†+µë∂ã∂Ü∂Çªàªä∂äæñπé±Ä ∫âºëºìªï∂êπéºíøï∆û ©ÃÆœ≤“∑◊¿◊¬÷¡◊≈‹Œ%‰◊0Â÷1„‘1Ë‘7Î÷;Î÷=ÌŸB·JÔﬂKÒﬂMı‡O˘‡P˜ﬁNı‹NÚ›LÔÂPÔÎTÚÓYÔÓXZÔÔ[\^ÔÍ[ÏÂWÓ„UÓ„VÓÂZÓÎ^ÌÔ^ÈÌ[ÊËVËÂVÏÊZÎ‚YÎﬂYÁŸTÁ÷TÂ‘R·”PﬁÃL€∆I⁄¿GŸøH›√L⁄¡KÿøKœ∏D—ΩJ”ƒQ–√SœºS“µW‘£T¨t7l7<$"*15 :5/5,S$.Z'&U'V *Y%1],3_.8d34b32`15a08d32Z(1W(3S,"@/I,)A'$= !;2N76R<B[F,D."5"#6#$7$)&=+[r`QfS3F3*8'2?.DO>AL;"/25;Z:,N+BdADfC:Y7+J+*H,*M/BeE6Z4+P%'L 'K"E><$?"='B!'@#%=#": &@#4S1?d;>c8:a45\/3Z-4Y-9`4=d8@f=HjEHjG7W2+K&)G#)G!&F'H*I4OZj!©¨U¥¢@ª•5⁄ÃG—…8÷œ8Ÿ–5€—4“√(ﬂÃ2◊¬)œ∂”∫ Ã≤ø¶Ω´≠†∞©$µ™.≥ò'®É©~∞É(¨Ä)ßy$ùjßr&´u-•o)•n-ßq1£p1°k/£k2¢j1ûf-üi-üm0°q3üs6õr4§|>¶z=¢m7¢d3ùR(óE£P&®U)©W(¶T$¶R#´X&Æ\*´[((#)<6D[Q.H;DePS{Y2\6 E$;`?1V4?'H).
+"&,+(*5/M10U65\=7bD8cE9dF7cB/[8+W30]6:i??lA;f9.U)(K#5T4AcB2Z55_73^3A2,Q&+W"%W#U%W'Y(X+X&Q+S!8]*No:Kl5bàOfèWiî\eí[y¶ohó`MD\éO_íPZèIRä?<q)"K B1N "=6T"Ab-Jl9:V-"5%1H,@^<2U+4X,9Y2<Z6SnKD^;=U3AY7Fb<;W/9U/+@!),# ,B--J..Q10U32W5;`><b==c<;d:8a76a62[1.T-+O+'I&(G%+I%+I#.N%-T'.X*0[.:e:9b:BjE>fAHqI:e7:f35a,6`.AB0V'.R&8V0* %4!@! B!.P-!C 6?Af;HoC=h;KvIItI:c96X3>\:AZ=FT=\[GjSCï`R«åz÷Øé’æí◊«ì“»ã—»Ö–√}–πuÃØkÀ™eÕ®b…°[Õ£Y–¶Zœ®Y”∞_Ÿπf€¿g›ƒg·«hﬁƒc›¡^‡æ]ŒúC¡à/Õï8‘ö9–ê.…ä#Õê%—ï%—í!”ê÷èœá—â—ä—å’êŸó⁄î€å⁄Ü’{”w
+÷z◊x
+œh ÷o‹|Ÿ{	÷t‹v‹s
+⁄s
+ÿv⁄{”w“xœu…lÃkÃkÀl Àt—Ä—â’ñ$’õ-‘û4”¢;’™DÿÆJ–§CŒ¶G⁄πZÿæ_◊Ω`÷¥[–¶R›™W›¶S”ó? â+—ñ.Œ°,¡¢#º•!Ω∞&æ≤(Ωµ,¿∏3ø∏4Ωµ6ø∑:æ∏<øª>Ωº>¿øAøøCøøCææBæø@¿¡B¿¡A¿¡B¡¬Cæø@ø¿Aºø<ªæ;πº;≤∑7¨≤8ö£0Üê-vÇ,jw1cp8fnEelKekOemUbkX]fUTZNRUNLNILKGNJGMHDSPKXUNUSGQOBQO@OM>PN?QP<ieJéãl~{\utVjhQjeQbYHJ>27*$3%"5( 9/&?6-@9/>7/<5-?80G@6IB2ME2NF3VO5e_?pkEâÇXûókÜÅYb^9YT6VR5UU3SS/PM*LI(LI*JF)HD)HG+ED(EE)EF'DG(IM,MQ,SY+Y`*`f*^g&^e"U^Xa Yb![baginuyãç¶¶*∞∞,∏∂-π∂+æ∏0ºµ0ª¥/∫±.πØ,ªÆ,∏©(πß)∏§)∏†&∂ô!ªò"øò!ªîΩïÆÖ	µå∂éªêπå∑ãªè∫ëπíπí∏ëºìºñ√ü	»™ÀØ—∏’æ◊¬”æŒ∑ÿ¡›À#‚Ã(Ê )ﬂæ#ﬂΩ&‚√-ÊÃ7Î◊@Ï›DÌ‚JÒÊPÒÁRÒÍSÛÓVıÒZÒXÔWÏÔVÏÍWÎÎWÏÔZÓÚ]Ù_ÓÒ\Î[ÓÊWÎﬁRÍ›QÍﬁTÍ„WÎË[ÍÁX‡ŸJﬁ◊H‰›O‰›QÂﬂSÊ‡TÊ‡T‰ﬁRﬂ‹QﬁÿN‹‘MŸœKÿÕM⁄—Rÿ–S—«K æDÃ¿HŒ√MÕ¬Oœ∫Q‘±U—úP•m4[.6 '.0.)+
+&I4\*-Y$)X!+\%0`.2`13a25c47e42`/5a04`/4[,3Y*3V,(F"+E(*D)#<!;$@)=YCAZE/D1#4""3!/+!?%>_DMkQ9S:,=+/<++6%*7% .09HjG2T15W2Ac>;]:.M-*I)-L,0R/=_<9[6'J %E!?3'	1 7&= &=!&=##;!1L->a9>c7>c7?e6?d8<a5<c7?f:=d8>c8=_:5U0.L()G#)G!(F (I*K1U%Ba(iz4ß´V≠ù;¿´8÷ Dÿ“@÷–:÷œ6‹”6ŸÃ0ﬁÀ1»≥–∑œ∏…¥«≥Ω´Æ££°£¢$≠£2°é(¶Ñ*¶Ä+§~+¢y)ñköo!ûr)§u-°p-úk)ùm/ûl1öc*ó`'ôg*ôk-ùt4õu6ùw9ùw9†x=ûo7¢e6ñR%îJ°W(¢X)†V%°U$§V%¶Z(¶Z(¶Y%¶Y%
+	
+	6 5V7 D 8? !B#;73/-+../#A%3X77_=8dA<hG8eD4_A0\;5a=9g@CrH>mA:i;1\1$J#@/P1AdD/W2/Y11Z0	-%7W2/Y'(Z%V"T$V"R%T"N!L-V*;b5=d7JtDaãYeê[hî_Å≠zfï_TÉL`íWgôZYçKQâ@;n)%N'I4T%1N"(E&C8U'#>)(8Q3;[4-Q#1W(5X09Y46T06Q.6P-7Q,6R,2P*(A!%7:1",,B++H,-N/.Q13V61T46Y80S24X4?e>6_7(Q)*P)-S,0T..S*&I#F,Q%-W)/Z,2]08c86`8EmH=eBGoJ9d7=i89e2=d5596T0/J)$8,(;'#;#)C('F'$C#(G''D%$= A\=YyTCj>ItGGuGJuJ6_72V01P.5N0+7TK:ÑdW°i\—òÑŸ∑î‘ΩëœªàÃπÅœΩ—º{—∂sœÆkœ™f◊∞k›µmŸ≤gÿ±bﬁ∏gﬂ∫i·¡lﬁ√h›≈eÿ¿^’ΩYÿ¡[ﬂøZ“£G¬ã1‘ú?Ÿù=œè-Àä$—í(’ï)”è$ŒÜ»zÀ}’â‘ç’ìÿò€õ ÿí’Ñ—w”t
+‹}ﬁÑ÷|—qŸyﬂÑﬁÉﬁ|€u	’l–k‘u◊}”y	—z	“z r»k»k—u“{
+œ~	ŒÉ—ê”ö'“ú/“ü4”ß>ÿ≠E—ßC–™GŸπV◊Ω\‘º\—¥Xœ™Rÿ´V‹¨X⁄¢MÀà/∆Å"¡à¬ï »¶+ Æ0≈Æ,¬±-¡¥1Ω≤2Ω¥5Ω≥8Ω≥:¡π=¿º?¿ø@æΩ?¿øA¡¿B¿øA¬¡C¡¿Bø¿A¿¡BøøCø¿AΩ¿?ºø>∏Ω=≤∑9™∞6óü/Çå+uÉ.cs,^m2bn@hrOgpScmU_hUW_PTZPTVQOOMLLJPLK\XUfe`kkaij\_`PYZJTUCXWE``Hãàiçäi{z\usZrp[ojVd[JI=19,$3& 6,#D:1E<3F=4B;3D=5D=5IC7NG7IA.H@+OH._Y9fa;zuMèã^ùñjÖÄVc_:[X5]^6]^4XW+UT(QO&MK"NL&OM'JJ$JJ&JL'MO*IM(JO&TX&_d*gn+mu,ou+jq$ag_ebikppuv{ÑÜôô™™$¥≥'π∂)º∂*º∂.ºµ0∑∞+∏Ø,∫≠+∂ß&∂§&π•(ºß*π°%Ω°$æ°#Ωûæúªòºï∂çªêΩêΩêºê∏åºí
+Ωë
+ºå∫äæå«ò ¢»•Ã∞—∫◊¡ÿ¬⁄√ﬁ«#€≈!÷ø÷∏€∏·º&Á√1ÁÃ7Í÷AËŸBÂ◊@Â◊CÁ›HÎ‰NÓÌUÛ\ÔÙ\Ôˆ[ÔÙ\ÒÒ]^ÌÒ\Ù_Ò˜aÒÛaÒÏ\ÔÁXÒ‰X„WÏ„XÎ‰XÏÊZÍÁZÈ‚TÈ‚TÊ·RÂ‚SÊÂUÊÂU‰„Sﬁ‡O‹ﬁOﬁﬂS‹€OŸ◊N◊‘Oÿ’R””OœœM–»L—«N–≈QŒæOÕ¥OŒ©PÀëHùa-P'/	"*,)*'F$8_35a.,[$)Z#/`)5e35c46d56d57e43a02^-3]-3Z+4[,5Z.)L$'D%-G*!:!:9 7P;G`K*?,#4$ 1,.8[=GlKIjM<X?2C0AL<>I86A0+.#= BaA=_<1S07Y6/Q.)H&)H&.N),L%&F!2R-=]4&F%C#> 9/0!5"9!:6$B7[/7].0V'+Q"*O#,S&0W+2Y-8]28[13S,*J%)G#(F (G)J*N 3Y(=e3Ef/l=¢•TÆû< µ@ﬂ’O⁄’CŸ’>€÷<Ÿ”7€—4“¬'Õ∫œªÕπ—¡$…∫!Ω¨±¶££ôù$òó-ôí7í2îy2ñz1ô{2ît)úz0õy/öv,ñn(óo*öq1ôm0òg,ë`%ïi*óp/ñt4òv7õw;õr:ûp<õg5êQ%çIïQ"ùY(û['òU!õT †Y%¢['£Z'¶X'¨\+		%3!>">"A"#B##A%$B&!?%!=$!=$&@%&@%#= 9:5[6:d>7c?4`=0\93_<?kJDpL@oEDuHFwJ;j>0]4+S.(K+:*J28Z?6`<.X03Y0--3N/.X*%V&W$U$V!Q%T#Q 0^/9g8;k9;k9LzIaçZdèZhî_eë\]åVYàR_éWeó\WâJOÄ?:h*/W".T#4X*4X,1R'(D'@"820GeC@c9/U"-S"8[15W21S0:\93R05T26X54S1'A$(	'*!+3& .,B--I0/M3%F+1R7+L/5V9: *K.2U50V19a<6_70Y10V-+Q((M"'L ,S$.Z'.\+3a2:g<:g@:d@?gEBjG:e:9g98d38_3-(1'	
+)/E.4Q33R3.P/+M*,N++M(/N,0I,G`BPpKNtKItGAnC>g?2X1,P*4T/3N-CM2TA0ÇXH´sb…ï}‘≤çÃ¥àƒ®x¬§p¬•k»¨m“µsÃÆhÕ≠d÷∂k⁄∫m⁄πj⁄∑f⁄µdŸ≥b⁄¥_⁄∏_›æa‹¬a⁄¡\⁄¬Xﬂ¿V—£C√å1‘ú?‘ö9”ï2Œè(œå$“ä$“á"Õ~…w’Ñ’á”ä”éÿìŸî⁄è◊Å“v	“s	÷z›â◊Ü›â›ÜŸ}◊u
+—j–fŒg “p“{
+”}–v–v”}‘Ä“~”÷Ç–|
+»w—Üœéœî—ö&”ü1—°5‘®=’™Bœ®A÷¥P◊ªW—∑V–≥U—ÆT’≠UŸ∞X€≠UÿüFÕç5»á+«à'«ê+Àò+ƒö$…ß+≈Æ.¡Ø/øØ5Øü&îÅ∏•-√∑=¿∏;ø∫<√ΩA√øBøª@¿ºAøΩBæø@¿¬Cæ¿Cæ¿CΩø@ªΩ>∑π:≥∏:©Æ6íö+~â+ly)eu.`o4esBdpJbmO`jR]fUZbUW\UTVQQSRZ\[`b_klglmehj]ghXghVbcQ_aLddL|{_òïtäáf}|`ww_xvaqlYibRWN?C7+C9-H@5H@5B<0A:0?8.@9/?;0JD8PI9IA.NC/NG-ZT2b^8mjAzwLëç`ùöm{xMdc7ec:ed8dd2``,^]'ZY#UU#TT"RT#KNMP#NQ&PV*PV(SZ&[a%dk'jp&pu%vz&wy%vy w{xz~ÅÖàéèóò§ßÆ∞∑µ$π∑&∫∑*∏µ*∫¥,π±,∂©&∂§$µ†#π°%ºß*ª¶'π†"ªü!∏õ∫ùΩüΩöæï∏åπåªã∫ä
+πà∏Öµ~ µt ∑p ªo¿wÃê”†—©◊∂÷º◊ø‹∆#‹…%›Ã'ﬂŒ)Ê–/ÁÕ0Á»/‚√-Ê 8Ï”BÏÿEÌÿGÁ—@ÂŒ@Á“CÓﬂNÓËVÌÌYÛ^ÚˆaÒÛaÙaÙaˆbÒıbÔÒ`ÔÍ[Í„UÌÊXÒÍ\ÓÎ^ÔaÏÌaÍÎ_ÍÏ]ÁÈZÊÂU‚·Qﬂ·RÂ‰V„‚TﬂﬁP‹€O›‹Pﬁ‹U⁄ÿQŸ’P’“M““L“œN—ÀO“∆P…∑I√¨F…≠L“™UÕêMìV'G"+!$% 99]7=h:4d0+^&)[&3e0=k:6d36d59g81a/3b.5a06`02Y*0W(4^.3Z-,N)*H&747'@*F_J9P>/!--#?&CfFKpNMnQC]D4C0EP@EN=MVE+-": ,I+6T8/P1.P/&H%+M(-P(&I'K*K &G,M"+L!'G#C >8425 :/M):]3:a46].9`3;b57a3;e7Cj>DjA=b90S+,L'(H#(H!'G)J+O!<d2Ak9;e5Np=fx:û°T§î2ŒπB€“Iÿ◊Aÿ◊>€ÿ=÷—5’Ã/‘«+’«)∆∏–¬#—√%Àº!∏ß≤•¶¶$öü+ëï6Üá;B=VLpc,És5è|7ë~2íz0ér)ér)ës+ës-ëp-ãd#ëj)íq,ër/îv6ïu8ím6ól9ñb3äO#ÜIëU#ìW#ñZ$óX#ïSóV õX#£`,¶^,©X)•S$	 3'?%%B$'F',K,,M./M1,J.+I/(F*&D('F''F'#B" ? +N-;f;7f:4b;9gBBpKFrOKwTAoHArEEvG9j=6e;/Y3'L*?$!A)*L37^A4`<1^5:c96#;!5'L!%Q%T#T#R#R)W&5c4GvHSÇTEyH:o;AqAVÑScéYdèYbéYdëZ[áRZáP`êTXÜHJs78]'WxK;[4;^67Z0-P&*I (@%8#6%9D_<De:0U"*O9]16[2.S*6[24V18\89]96X7)F(&<%*$!)7B4&4#)?**C-&D*:!,J08V<DbH-I2-K13T58[:;a<=c<EkD8^7+P',R)-T(0W*3_,1`,5c4:g<=jC7a=;c@?iC:e:6d6:e72W.#	 
+
+
+#4"7Q44V32V22V20T..R,/Q,2Q/6O2B[=JlGMsJFsH5b90Y1-S,,Q(/O*1J*PT;ÇeS†qa öÉ›≤í‹¿òÿƒí”ºÜ’ºÉ’Ω◊¿|’øv’ær’æn÷Ωk”∫f÷ºg”¥aŒ´W–™U“™U”´T÷±X◊πYÿºX’∫O⁄πPŒù>√ä0–ò;‘ö9”ô5œë*Õå$œä#–á!”à"÷â!ÿã!”Ü’â’å‘ç◊è◊ä—{Œs—vÿ~÷Ä÷Ç◊É“zœpÃiœhÕgÀj ‘z
+⁄Ü—ÄÕwŒx—}	”Ñ”Ñ“Éœ…|…|œâÀçÕïÕñ!—û+‘¢3”§8◊´>Œ®=—ÆF÷∂O’πU“∂S—ÆP“≠R’∞W€¥Yﬁ∞XŸ¶M⁄°H◊úBœî:«è.æâ!≈ï&≈†+∆ß2æ°,ô~óy	∑û*º¨3µ´/∏∞3¿∫>¿∫@º∑?øπA¬ΩE¿¡Bø¡Bø¡Bø¡DΩø@ªΩ>∑π:Ø¥6†•/Éåq~"hw&hw2cs5^l9[h=Wb@[eL[dS_gZTYRSVOce`jlgmpgorgnpbrubrt_jlWjmX_aKllPíërñìpÑÑbzz^xwbsp]khWlfVf_OWMAND8F@2E?3>8,<6*<5+=6,>:/KE9MF4JB-LB)MF)WQ-^[2jg<wtGÑÅTòñföògzxHkh;gf6ii5ji1ff*hh,dd(\]!Z^#UZ TY!SX"TY#UZ"Y_#[bagglpt{!ÅÉ âä"éê#êì óò!ñòöõ°£®´Æ∞≥≥∑µ$∑¥%∏µ*π≥+π±*∂¨(∑©&≥† Øö∂£#≥† ∞ò∫°"º° ∫ù∏ôπìøì∂à∂à∂Ü
+Ø∂Ö∂~≤v ∞j ≥d ≥] Ø\ æs Ãã	÷ú‹¨€≤€∂‹æ"·«(„À+„Õ,‡ )„À-Ê…-Â 1Ë–:Ê“=‚—=Í’DÌ◊FÍ”EÁ–DÔ‹OÂWÌËXÔÔ]ÌÒ^ÓÚ`ÒıcÓÛaÒˆdÚÙcÚÒaÚÏ`ÚÎ_ÚÏ`ÙÓbÒÓaÔaÌÏ`ÎÏ`ÏÔbÈÏ_ÈÎ\ÂÁX„ÂV·„T‚ﬂP‹ŸL⁄◊L›ŸQ◊”MœÀF”ÃH”ÃH—ÃJÃ«GÃ√JÀæK«≤G–∑S‘∑Y‘´[øÇCÑI="%")'D%>g==m=5g2.`+-_,3c1=k<6d58f78h84d23a03]-5\/9^23X,2Y,8_3:Z5)D#12 6 8"6O:G`M#5',-+I-LoNQtSIjMGaH5F3JUDNUECL;),/G-3M2&B)#A%1S2&J&/T+2W,.R&*N )J&G%I$H"F"B#C"= 734,I+?a<Af;?i;>h:;b6:c79b68a7?e<=a;0R-)K&)I$(H!'J &J+Q"?g5Fp><h7Al>QvC\q6óõO°ë1ŒªE‹‘K⁄ŸC›‹D‹Ÿ>ﬁŸ?ÿ“6‘ -Õ√$Ã¬#Œƒ$—≈%¡≥øÆµ®™©*ù£5îöDjo/#$  ($ B;ZStj/}m1Åo1át2át2Üq.àq.Öj'ãn*év0ëx5ìw8êp5ëj3ã[*ÉMÜKãS"èZ&í_(ë^%ëX!ó\$ô^&üb+úZ&òRöNõK-$>#"D#&G(+N.0S34W70U4,O/*K.'H+%F)%F'%H("G%'M(4^6@n?>p?AuGBuLIySKyTAoJ<kAHyJCwGArE2a74^8$I(8$E*9a?EqM?pC9j;5e5=,	#<'N!'Q"N(T-Y&3a2HwKSÉYRÜXDxHFzJArEO}N_äUcéVbçWeíYP}FXÖJ[âI^àHMo3@Z*F^>>U;IcFDcA2T/+K&'?2&6&92J(A]58X)0R =a13Y*2V&;_/<`2:_45[46Y8$A"%>!%8"$5"'8&4B1.<+,=+%<(!=&'A&3P4FdH=[?1N24Q3=\<Ac@4V30R/<[;7V6=_<3W3-Q-3Y04^07c29g8AoAIsKGpH9b:<g:8c53_.:d6&F!	!0C/:W87Y64X44Z55[42V05T48S4@Y;C`AKqJJtL:g@2_81Z22[16_34W-=P2LF0Ç[LµÖq”∞ê‹≈õ’≈í–∆ã“…à÷ŒÜ◊—Öÿ—Å”Àx“»s’«o“¬j”øfŸƒiÿ¿f÷ª`‹∏`ﬁ¥^ﬂ±\ﬁ±\ﬂ∫_„¬a‚≈_„¿Z–õ?ƒâ/“ó;—ô8”ú7–ó.œí(…å!–ì(◊ô,’ì%’é"“à’á”Ö”Ö—Ö }»v—|◊ÄÿÄ“u–p	–oŒmÃl mŒqÀqÃx“É“áÀÄ	»y {–É◊åÕÄ
+–É—â—äÃáœéÀêÀî»îŒú)”°0“¢3◊Æ<“≠;–¨>’µH‘∏M‘∑Q—ØMŒ™L“ØS÷µX⁄π\ÿµYÿ≥XŸ∞Vÿ™R—¢JÕó=»ë4∆ê,Œö4Ωâ#ùn•|∫ú.Ω¨6æ∂:¿ª=¡ª?¿∫@Ω∑?æµ@ºµ@Ωª@ø¿Aø¡Bø¡BΩ¿?∫Ω:≤∏4§™,êó#{ÑsÄ$mz*er-]k.Yf1Zf8Xb=ajMbjU\cS[^S_bWik^uxgru`qu^z~cw{`uy^tx_uy`orWÉÉaòïréélÅÄazz`wvaifW]YM`\P`ZLTNBIC7IC7D@5?8.;4*;5)<6*D>2PJ<KD1MF,LF&NH$YT,^Y/ea2vrBÉÅPãâVúõeóïb{yHlj9ig4kj2ll0kk+ij(il'ci#^d^c bg%_d!]cadeikpuy"yzÄÉäåìñ!ü°$¢•$®©'™¨%´Æ#Æ∞!∞≤ ¥¥"∂¥#∂≥$∂≥&π≥)∏≤*∑±)∏∞)∂¨&µß$µß$∫©'µ§"∂°"∫¢$∑ûµó∂í∏éªä∫âøë¡îªéæéΩáªÅ∂w∑q¥g ¥c πi øp …{ ”àÿî·£Á∞"Áπ&Êæ)›∫"ÿ∑÷∏Ÿº „Ã0Áÿ=Ê€AÂ◊@ÁŸBÏﬁJÔ·MÌ·OÌ‚RÔËYÛÓ_ÚÒaÚaÔÚcÒÙeÔÙdÛdıÙfÚÔbË_ÛÎbÚÏdËaÌ‰[Ï‡XÂ€UÊﬁWÈÁ^ÁË\ÁË\‰ÁX„ÂV·„R‹⁄IŸ÷G⁄◊J›◊OŸ“MÿœL÷ÃIÀ¿@…æBÀ¡HÃ¡KÃ¡N–¬U“øX”πZÃ¶U©l3m94%&(0+$1<`<GrG=o>6h5/a.1_.5c4;i;9h:<k=8g96f68c59`3"E,L#.N'1O+0N,1L-#<.//0$;'G^J2G6,-0N2QtSLoNPnRB\C8J4JUDPWG5>-!../I,3R3,I-:2T3<`:9^3.U(*P!+O!-N(L$J$J&J)J(H$B 9309-Q-Aj@HqGCnCBkCGpHFnI?gB9_:.R.)K&'I$*J#'J %J)P!9c3FrA>j9>i;NwKRvFZs9ìõPûë1…∏D‹‘M‹⁄G‚ﬁIŸ‘<›÷=– .– ,“Ã,…∆#œ &Œ¬ ∫¨≈∂ª∞ Æ≠.•®?ù†SFH*&	@:XO&i^0nd/sh0xl0}n-Ñs.áv1às0äp3ék3â^)ÇPÖQ!ÖQ!ÖSè`(çc'éa&ç_#îb'òd*î\#íSñSùX†[ 	  6!%D$$H$*O.-R1.S2.V4*R0$K,'L-*O00S55Z;;cA9a>4^8(U*3c3@rAK|ODwLHxPBrJApF;j>GyH2f58i<4c9$L)B";^@@eFMyUSÉ[Xâ\Xâ\SÑUIvK7Z9 ?9%L&P &R!*X'0^-9h:PSPÄVMÄUFzLOÄSO~R_ä\rò_oìUjíTaäNKv>_åQYáF[ÉE4N$ 
+#1 I\FNgJ9W5*H$.
+(1#6#8%=2O!0P5Y)1U%=^/Jn>Hl@=b72X16Y8,I*'A$(@&%=%*?,.A./@.)<('A(*G)/L-=\<;Z;3R35R45R3=\:GiF4S1%B#9#="1P13U4/R1-Q-+R&1[-8c5EpCKtJIrH=f:6a32^-1],;`5+ +>(?\=;]88^94Z55[46Z65T4;X9=Z;@_=JrMCmG8d@8d@2]26a4=h:@a6JS6TE0ùtb †à‘æó”…ñÕ∆èÕ…â—ÕÑ“œÄ—Œ}Œ sÕ«oœ»mœ∆iÃøaŒª_ÿ¡dÿøb⁄ª`Ÿ¥[—§OœúK”†M◊´T◊≥U’≥Q‘©J≈å3¬Ç+–ï9“ö;”ú8—ö3—õ1œô-ÿ§6’†0÷ö*’ì%‘ä‘Ü–ÇŒÇŒÖ“Ü’á‘Ç’~–tÃlÕkœm
+ÃlÕr	œyŒ|À~
+ÕÖ–ãÕâÃàÃÑÕÖ‘é‘åÃ	ÕÇœäÕèÀèÃî ñœû'Õû(—§/“£1—§1”™4’Æ9“≠:÷≤B÷∏J÷∑M“ØKŒ™I”∞R‘∂V”πZ‘∫[‘∫[”∂X⁄∏_Ÿ¥\Ÿ¨W’£LÃï;»ã0ªz™k∞{«†9≈Æ>ƒ∏@ƒº@¿∫>Ω∑?∫≥>Ω¥?¿πDøΩB¿¡Bø¡Bæ¡@ºø:πº7¨±0ôü#èó'Ñè){Ö,ly)bo'bn,ao4cp;enCfnI\bHX]GchRpt]y}bvyZz~]ÄÑaÄÜbzÄ\z_}ÇdÑfâåmóósììoââgÄÅb}}avu`lkYa^OWTESPAQK=HB4C?4B>3?8.81'82&93'>8,E>.F>)OH,PJ&RM#\X+]Y*jd0xu>}|DÜÖMïìZ§¢iëêXvu=li4li2ll.mn,op*mo$nq$johlns#ux'vz&vx$vy y}áâ$ëì&óò#óôü¢!•ß"©´#Æ±&±¥'±≥$≥µ#¥¥"µµ#∑¥%∏µ(∏µ*∑¥)∑±'∏≤(π±(∂Æ'∂¨&µ©#¥ß$∂®%µ£#±ú∞ò©ã™Ü¨Ç¨zÆ}µá∏ãªé∑á¥É∏Ç∏ÅΩÅƒÜÕå÷î—ãÃÇÀÅŒáÀàŒé
+’ó‡¶Â∞&Ë∫)Í¬/Ë…1Í’:ÈﬂBÍ‰HÏ„HÎ‚IÎ‰MÓÈQÌÈRÎÍTÏÁWÎÈXÈÈWÁÈXÓÒbıgÓÛeÏÓ_ÓË^Ï‰[Ê`˜Îe˜ÍgÛÂbﬂ[Ì⁄Wﬂ[Ò„`ÊbÏÂ`ÁÂ\„‰ZÊÂY‰„U„‡Q‚ﬂP·€O⁄‘J◊œHŸœK◊ J—√F’«L‘≈N“≈RÕ¬OÃ¿P‘√Y÷π[¡öMì`)iCCB#5I-AZ<GbC<U89$C#9_8DqF?q@4f52d10^-;i:8f8;j>:k>5d6:h9:e7:_3%H'G>\675#:611&9%(;('?)6N8@UB00=[?PsSIlLGeI@Z?6H2JWELTE/7( /68U67V6'D&"A!-O*0W+4[.0W*.T%+Q",P"(L&L(N-Q#3W+,P$%E"=4065Y5IrJJtLJtLHpKIqNEmJ7\:-P/*N*&H#&I!)I 'K(P3_,>j9?j<>i<HsFS|ROsE\x>íüW¶ù@¿∞?‚€Wﬂ‹M·‹J€’Aœ»1— 1œÀ,–Ã+ŒÃ)ŒÀ&∆º»ºƒ∑∏∞±Æ-™´CõõU10
+
+%#
++*1/	97B@NKfa)qj3rg/ve-v`'vX"{Z$~Y%É^)Üc)äh+Ñe%Ñe$Öb äe!çd"ç`ïb ûh"°k#†h/$>#$F%'M(*M-,Q2,Q0)Q/*Q2/X:;dF@kMEnPEnPDmKAkG=gC1[5,Y.*W,<i@=lB?pCCtE5d60`0=o<;p<4e8*X1@<aBV}^S\RÇ\OÅ[RÇ\TÑ^UÖ_WÖ`WÑ]S}U?j<&R!$P(V'-]-<n=L}NIzMI}OLÄRKzNTÅV_ä_dâVè™gó±gä¨bYÅ;Js9Ü±{YáI"I(
+)7I15M-)DNj:)E4134%@*G0P!,M 3S*2U-9[89[:9\;7X9/L.,F+/I0,E/+B.,C/3I4-E+;[6Af;Ch=8]4/Q.9X94Q30O/;]:<`:2T/3.95=#G#@'J",Q(9^5PtNQwN?i;-Y(*V#.X*1O+ 
+!#6 ?Z;?a>9_85^63Y44Z55X76Y83V5<_>NsQ@hF>gE<iB5c5;f8;g6C^5LK/r\Eµï|’ªö”Àú–œó »ã«ƒÅÕ≈|Ã√tÀøk…ªbÕæcÿ…j◊Ài÷∆f‘ª_÷∑]÷±XÿØW÷®S”†MŒóG–ôI‘°N◊©Sÿ≠Q÷§K»á5ø{(—î;“ö=œï4œò4”¢;÷ß;÷¶8–ú.“ñ(—ç “à”Ü—à—ã÷ì €ï#◊ã–{œnÀh
+Àm…p…s«t
+…{…}…ÇÃäŒêŒìœîÀéÀç äŒâÀÉ¬w≈~ å î ôÀûÕ°$Ã¢)…†*œ®3“©5–ß1“™1’≠4‘´5”Æ;’µF‘µI”∞J…¶B“∞N’∑U”∑T”∫V–∑S“∏W’ª^◊ºaÿ∫`Ÿµ]◊©SœïAƒ|(Ωqºy" î4 •;»±A¬≥<¡∏?øπA¿ªE¬ªF¬ΩE¿¡B¿√Bø¬?ø¬=ªø7∑∫5ß¨.ñû'äì(~à'yÉ*my%jy(jz/lx6ny=iq>_f<agCioMv|VÅÜ^}ÉWy|OÅÑUÉâY~ÖYÜ]~ÜaÜåjäémôözññtèèmàáhÄ`yz[vv\onYfePZYDSQ<PI7F?/A;/A=2<8-51&5/#82$<4'<5%?7"JC&RM%WS$YU%\Y$ni/}y:|z=áÖHëèR†ûa®¶iãâLwu<pn5oo/qr.tt*wu(yx&zz${{#yy}~!ÑÜ%ãã'ãç"äåñó °¢#®™%≠Ø(≠Ø'≠Æ&Ø∞(±≤(≥¥*¥µ)µ∑(µ¥$∂µ%∑¥)∑≥+∂µ)¥≥%∂≥&µ≤%∑±%∂Æ%µ≠$≥©#≥¶#≤•#µß$∂•#≤ü≤ô±ë©Ö≠É©{∞Ç∑ä∂ä∏å	ªå
+∏âµÖ ºå∆ù–™◊≤#ÿ≤#‹Æ$›Æ$‚∞)÷†«ÜÃÑ–Ñ’ãﬁùÍ∂.Èƒ7ÁŒ=Â⁄BÊﬂFË·HÍÂKÈÊKÍÍNÏUÍÓSËËRÏÏXÎÓYÏ]ÔÙdÚ˜iÔÙfÒdÌÂ^ÊÿS„“NÁ”PÎ‘TÓ÷XÒÿZÚ⁄\˜‚cÙ·aÚﬂ_·`Ï·aË·]Â·[‚ﬁVﬁ€PﬂŸO›÷J’ÕD’ÕFŸ—LÿÕM÷…I‘∆I“ƒI–ƒLÕ¡Kœ¬P‘øV”∞V¥åD~](uc;\jFOmKQpNNpMJiG>`=7[59b8CqC?q@5g61c23a2=k=9f;?nB9j=;j<<g97a13Z+3Y*;_1=^3 ;*C%(?#!81/35 #8%*B,C\F+E,29W;KlOGhK?]A7Q66H2GTBEP@/<*4F0-F);X9-L**I'7Z2;`47^/2Y,0Z,*Q$)N"(M!%K(N)O*P1W(.T%'L #C74(G%BhAGpHDlGDlIAfDAfE9^=.Q0%I%&H#'G)J)J.R"2](<h3=h:7b5@k@IsKNwMOuFWt>ÖîQß°IΩ±C‚›]·‡TŸ÷I—Ã<À¡.Õ√-Õ∆-—Ã0œÕ+Ã…&À√# Ω≈∏∏Æ¨ß%≠™AíèJ31'& "#$%&**-.2OU%Y^&ab(hf+qk/wm0uj*xk'zk&}l&l Élãt$ìy%óy!úz üzüx 6!$B&%H''L*'L+(M..V43\:=fHBmOEpTFsVEqVErUFrQIrP8a?3]90Z4,V03]93]7;j>.]/(V(*X)5e36f4/^2H!!I'@gHS\RÄ[MÄWJ}THxRIxTGwQEuMCsIDsE4d2&U!*X)+Z,@qDVä\FzLG{MDyKI}OIzMQ~SUÄU^ÄNë™fùµgyöK]É:WÄDw¢lYÑL6	
+
+ ,#3"8-G^}AVu95S!.I5!:7Q"7S"0L=Z*>]35U.5T5:X<7X90N2%=#0H02K5-I2.G2,E/;U:DcAGl@KsACk94[.6X37Y82Q1*L):_6:a57^2*L'&C%:T9DcDIkJFjF?c=;_9>a9?b8:_4=b7>e8/V'&P&R-T%8	"
+
+!!5K4DaBDfC:c;6_75]82X33X66[90U37\:ChG@hF=gC>kB6d6<h7?d8FX2\N4ìw_«Æè€…°÷”†‘’õ““í–ÃÖ–»}œ√q—¡j’¡h◊¬e’æ`’Ω]◊∫\”∞V—®P‘¶PŸ©T€´V›≠X›©U€ßSŸ©T€≠U€∞Tﬁ¨S—ê>¡},”ï@—ò>≈ç0Àñ6”¶Aÿ≠D’¶:œô-—ë'‘ç#ŒÑŒÑœâ”è “êÕá»w∆n
+∆e√b rÀy∆y∆|√{∆Ä âŒí í∆ê√å«è…ë éƒÉ≈Ä»ÉÃéÕóÀõÕ§$Ã•& ¢& ¢( °+“©3—©0Œ¶,–ß)”¨-’≠4”Æ9’¥A’µF’≥HÃ©C–ÆJ’µP—¥N“∑Pœ∂Q—πU‘Ω_◊¿c◊¿cÿΩb⁄∂^’£Nœå;œá3»Ñ/ƒâ/ƒî2∆°9 Æ@ ∂C∆πF∆ªE∆ΩF√ΩC¡¿A¿¡?¿¬=ø¡:ªø7≠≥/°•*éï#ÅäyÉ vÄ zÖ)zà0xá4uÅ7lw3dl1gn:rxH|ÇRÉäVÅÜNÄÖMÑáNÄÖKÅÜNÄáTÉã\áçgäêlíîo°°}úúxééjÜáeÇÉawxXnoPccG__EYY?TR;PK7G@.>:.@<1>:/73'82$82"82";4">8 HB"RM#\Y&^[$^\!qm-}z5Ç:ãàCìíOúõXß¶c•§cÜÖE}|<xy7xx2xy-yx&}{&Ä#áá'àà$âá ççöö(£§,§§(ß®&¨≠%∞±%≤≥'¥µ)¥µ+≤≥)¥µ-µ∂,µ∂,µ∂*∂µ)∑¥)∑≥-∂≤,µ≥*¥≥'≥∞#≥∞#µØ%µ≠$¥¨#¥´"¥™&µ®%∂©&µß$∂•#∂°!∫°"ºù ºò∑èªíªê∏êΩïΩì¥ä ∂ç¿õ∆®Õ¥”º!ÿø'’∑%Ÿ∂(‚ª2‰µ1Ë¨0Ì´3‡ô#–ãœí‹™'·π3Â»>Ï’GÈŸFÈ€GÍﬁJÍ‡JÎÊLÌÓTÔVÒZÚÒ[ÚÚ^ÒÛaÒıcıeÛfÚÓfÛÈc˘Ëd˘Êc¯„cÛ‹\Î”UË”TÎ÷WË’U·ŒN‡ÀN‚ÕPÊ‘XËŸ\Á›ZÂ€Xﬂ’Qﬂ’Q‡÷P‚÷Pﬁ—OŸÃJ÷…I”∆F“√F“ƒI–¬HŒøJŒæM–∑RÕ•P°z5k6noEWpIRvRSwSGkGLpJKoI<a8FoEGuG@p@7i84f55d6BqE?lA@oC@oC>m?=h:7a1&M,R#4Z))M)G!,G()B%$;!55!4 .)-2J4BZDF`GD`GHfNB`FB`F4N55H2?N;<I81>,RdNNeKC]@2P.DfAKpE<c6/Y))S%)S%)S%(O"'N!'N'O)Q*R ,T"-U#+R#%F9<.P+IoHEnF?gDBgEFkJ=`@.Q1*L+&H#&I(L )M.S 5\'8e.<k59e4?j=;e=GqIJsILqEVvDrÖE™®Sµ™A‡⁄^€ŸR–ÕBÃ«8Ãƒ3“À5”Œ6–Õ2ÀÀ+«≈%Õƒ'»æ!≈∏∫Æ¨£ ≠©>ÜÉ@75,.(/&."-  $$ !	;K$AU"Ia'Vl.Vj-Wg)\h(cl)lq.y{0É~-àÅ)ëÜ,óà)ôä#üä!ûÜõ-!;"$E($I*$K,*Q21X99b@>jG@kM@kODoTEpUFrYErUJwVEqN,X5:fC@iG0Z68`>:b@6b>2_83`5)T',W*4_2)S+-Z3LxTNzVM{VJzRDwLEyKCvKAtI?sE?pA;l=0`0%S"+Z&-]-0a4PÄXXädSÜ]H}QBzKHÄO@vEEyIKxMZÄOÄú_ìÆghåBcãD^àHcéVBh5,			.= Ne9-H/M^8Mq)>a!=^%0Q8V"?[!Yr8?W,E4O9V(.L*8U97T8(B')2H34M7/M5.J3.J1@b?Fk@Bi:Iq=Ck7?f75W2.P-(J%4Y.Fm>Eq<IuBLwIQzPS|TXÅYXÅY\Ö[XÅUOxLGqCCm?Ak;Bl:8c.,T #K&Q+S!!H-T'5\/;b59]1-N#"B2/ :7V4@d>>d=:c;6^98`;6^92W50U43X7AfE>hD@mF=j?2`1=d7A[4SX8y_H∫ñ~÷æúŸÃ†”–õ‘‘ò–œåÃ»~Ã≈uœ≈n–√gœº`–≤Z»§L«öE»òC≈ì>»î@ÕõF÷ßO‹±UŸ∞Tÿ∞Q·πZ‡∏Y›∂Wﬁ∏Wﬁ≤S’ôC…à6”ñCÃî?…ì;—£E”©Gÿ≠G“û8Œê)Õà!ÕÑ…ÇÀá–ç"Õä…Ç«y≈m¿c√f«q»{∆~√{¬zøy
+ƒÅ«à≈ä¿â¬é√è≈ë∆è¬ä¡Ñ≈à«è«ï»úÕ¶' §'…£(À°(Õ†)—†*÷§+÷¶&’©&“™&“´(”´/”Ø7”≤>÷∂E‘¥GœÆC–≠G—∞Iœ∞F“∂K–µL–∑R’Ω]’æ`‘Ω_÷Ω`ÿª_“≠R—üFÿ°G’üE—ûC î:∆ì7Àù;—¨Bœ≥EÀ∂AÕºF æD…¡B≈¬?≈√<ø¿8∏∫5®≠,òú#âêàé"Öå$Ñå%Üê-Öê0Ñé5v0mu,qx2yÄ=ÄÜHÖãMÇâFÑãGéëNåéMÉàHÖIÖäTÉäWáédäèf†°w°¢xûüwåçeÑÜ_ÇÜavzUklJ`_@`_AYY=SS9OM6DA.A>/@>1=;.97(74#3074!94 ?; IE"US#`_&db%ba ro*{y/ÇÄ5âá<íêFôôOüüW™¨c°°[ããEÖÖ?ÄÄ8ÉÑ6ÉÇ0ÅÄ&ÜÜ&êé)ìì%ñï!úú"§•&®©'ÆÆ*∞±)≤≥)∂¥+¥µ)µ∂*∏∑+∏∂-µ∂.µ∂.≥µ-≥¥,¥≤+≥Ø)∂≠*¥´(≥¨'¥∞*¥Æ&≥≠#∞®!≤™#±®±®≤© ≤© Ø£≤¶ ∂®#∂•#π§$∂ùªû ∫õπò∑ïπóºõºòπñΩù«©À∞Õ¥÷ª$“∑"’µ&◊≥)ÿ≤)”©#€´+‚≤2„ª8Á¿=‰ø;ﬁπ5‘≠*’≠*ﬂπ4Î∆AÔÕEÓ—GÔ÷HÚ‡PÛÈTÛÎXÛÈVÔ‰TÚÍ[ÙÔ_Ò`ÚcÚÒeÛÌeÚÂbÚ‰a„`˜Íg˜ÌiˆÏhÛÎfÊcÔ‚`ËŸX‰—QÂÕQ‡»N‚ PÁœUÊ—T‡ÃO›…LﬁÀK⁄«G◊√H‘¿E—øC”¡E‘≈H—√HŒæEœªHŒπL“¥T∆òJòr3vo9_oBRpJ[~]UxWHkJRtQImG3X/Ag>GrEBqC:j:2d35f7ArEAoH>mC@oC=k=9d63]-(O")N".T%$H$F!&E%$>!!:%<""5&('%)%6$3F3>UAF_JFbLB^HAZDAWB<O;4B1/<+TaPsÅp9L6:T7@b=7^22[/,U)+U'/Y)-W'%O+U%)S#)U"(W!'V +W"+W$0W(+K"#A3S,=`8NtMMsNJoMHmL?bB/P1)K*(G%(H&J&J-S"7_*5`(9i/7f/<k7EpB=h=FqFJsINuI[|Mau:•§T±•Cﬂ÷_‘ÕI∆¿6”Œ?Ã«8‘œ=ŒÕ7…»/ÀÀ-œÃ/ ¡&»Ω#¡≥Ω±!∞£!Æ•<ur/4506+7#-;$/>)+<*&7%'8((!!.?[+Be-Fn2Fm6Dk4Ah/Ko2Sq1d{3~å7äè1ìë-ôí(õì$ùí°çùà+ 3#="$E(&K,+R3/X88aA;gD>jI?kJAlNBmRFqVErUJwXDqP2`<:fE@lKAmL4]=;bCAhIDpM?kGFpH<e;81U1(P+;e?LzSN|UK{SHxNBvH?sC>rB?sCDxG=o>(X(M%T 'V")Y)2c6M}WWâdUâbE|RIÅR@xGC{JCyHBqCZÑTqí[ã™nyù]ZÉAR|=]ÜL+O2(.DfÅJXu3Sr&_Å+Xz$Ej8[-Q2Q>ZVl+k7f{0ÇöP]v5*D4N+8Q4!7 "5!8N94P92P8/K41O3>b<@g:;b3=e3Fn:Bi:3X/)M'-R);b5@l9@o9Bq=@n=AoAAnCEpEJuJGrGItGLwJLwIIuD>j71^'+X*U)Q&N.V"(T/^(5f.7h0:i2=i4>h68_2'I$'I&=a;Ag@=f>9b:5_96`:7_:5]80U49^=ChGFpJAnC1_17b4<\3DR1`V;úycŒ¶ç”ªó…ºè«¿äŒ»ä–ÀáÃ∆zŒ»t”…p’»j‘¡c”≥\Õ•P–†Lÿ°N€•O⁄§N€ßQ›´Rÿ´N‘©Kÿ≠N€∞Q÷´L”®I÷¨J‘¶H—ï=«Ü4“ïD“ôHÿ¶Q◊¨P‘¨L—•BÃñ2»ä%≈ÑÕä!Õè"Œí$”ñ+Õç#…Ä√s¬i≈l≈s¬w√æ~ø{ø{¬~øæÇΩÜ¿èƒñ∆ïƒì√ê≈ë«ê¬é≈ó«û"…¢#»¢#≈ü"»†$ °#«ö∏á∏áªã¬ó
+»£…®Ã™%œ¨.”±6’¥@‘¥C“≤Eœ™@œ™@œØB—µGœ≥FÕ≤I“∫V–∏Xœ∑W”ª[÷º]”≤U–•I÷ßM⁄≠R‹≠Uÿ†K–ó@ ì9…ó6»ù5≈ü2…ß9œØ>–µ@œπ?Õª=ƒ∑7∏∞1©•(úú"õú%ôú)õü.õ¢2ö¢3îù4Ñå)~Ñ*áç7áè:åîAàèAÇâ;ãíBëòHçëDÖâ?áäEäèOåèVäé[ÖàYõúp©®x™©yòóiáà\~ÅV|~VqsKeg@__;dd@YZ8SW6RP7DB-B?.@>/;9*:7&85"75 ;6";7>:ECUS `^!ih%bblj wu*ÇÄ3àá5éç;óñDúùM¶ßY´¨`ùûRééDáà<èé>êê:ãä.åä&íè&öò'ùù!¶¶$¨¨&∞±)¥µ+∂¥+∑µ,∂¥+µ∂,µ∂*∏∂-∑µ,∏∂/µµ/¥¥.µ≤-≥Ø*¥≠)≤©&∞¶#Ø§$≥©&±§"≥¶$Ø†Ø°≥¢ ≥¢≥• ≥•±£≥•∏®!∂£ ∂¢¥ù¥õ∂õπù∑ö∑ö∂ó	∏ö∑úπû∆≠À≤…∞Õ≤—µ#ÿπ+ﬁΩ2‚º3‹∂/Ÿ≤/‚¿;‰ BÁ—HÈ—KÍŒIÌ JÁ¿AŸ∞0⁄Ø/·∂6‰º9Êø<‰¬<ÁÀCÔ’LÒ◊OÏ‘LË÷LÚÂ[ÙÌaıÔeÛÍaÓ‚\ﬁ^˜ÂeˆÁfıËeıÎgÒÈdÛÎfÙÏg˜Ëg˜‰d˜ﬂa˜€`Ú‘\ÌÕVË»QÊ»P‰«O›√J‹¬I€¡H›¿J’ªD’ΩC‘¿E—øC»∏>«¥>Õ∑G“∑N”∞T∫ãCçk.ff2VmAWwPWzYKnMLpLRtQDfA/S-3Y0EpCCqC<l<4d48i:FwJEsL:i??m?;i:;e74[.%J'L +P$$I&H#&E%<";-D*-A(($)*%!#0 -B1*A/*A-3I4F\E`rZUbPU`PP[M`l^:K86P5=_>6\71Y6+U/2[3/X,+T(/Z-0Z,-Y(-\(-]),]&.])1[+1V*&D<%EAd<OsMRvRKpN?bB.Q1+M,+J()I$)M!'K/U&6^,3^(4a*8g09h1Co<@l;EpBJsGQwNMrGRvHVm5óôNØ¶G÷ÃY»ø>Õ«?‹÷J÷”DÕÀ:«≈2 …3—Œ5»√)À¿*»∫%æÆ¡≤%±¢!™ü6ol)?D6@%0B,5I06L53K53J64K9+=-+ !;W/@h4Cs9@q:Bt?<q9Ew<Fr3Jo)b},Çì7ëó3óñ*ôñ%†ó"†èòÖ.3;"#D'*O0.W70\;6b?;hG;hGAmLBnMGrTGrTLxUFrN0\87c@@kMAlNAlN5`B8cE=iHFrODpLIrH<a8%(B'DgGPzVKyRK{SIyQJzRGzODyKAwE@vD4f3&V$D#O*Y%&V")[*7h9GwM[éeQÜ\JÇUJÇSDzIBxGKOGxIQ|OX|PfáZdàXhèZFo58_(9X,5M)3C&4B(2B'G]7Ki7Ww6Vu'vì9zñ0mã'Rr8Y*K/M6OG\éûEö™Gõ≠GÖö=G\&:	2C#);%7J6;S=6R;+I/*F//M1:`76]04Y-=c4Fn<?f70W*+R&7a3Bn=?m<DrAEsDLwJOzOR|TS}US}US}UPzRPyQHqG=g91]**V!&S%P%MC%M'T(W *[#2c,6f2;j6Ap<?m<;i:=k<:h:8c88a99b:8b:6c:4^64\73[9?dC8^9KtL<g90[-8_36N*JF-pWC∞áuœßé–∏íœæê ∫Ü»∫}≈∏t«æqÕ≈p“…n“≈g“øa‘π`÷¥[ÿ∞XŸ≠T‡≥X·∞T‹©N‡™Pﬁ®N‹¶LŸ£I“úBÕó=“úB“ùAÃì9—è9≈É/œê@◊ûMŸ™X÷≠U“ßKœ°A…ï2≈é)Ãñ,Õô,…ó(Ãö+œô,…å"≈}øq¡søsºwø~¡ÉæÇ¬Ç¬Çº~ªÅΩâ¿ë¿ñ¿ò¬ò ¡óƒòƒò¬ï¬ò √õ"ƒú"≈ü"»£!»°…°—ß“©”™œß…§Õ¨œµÀ≥ Æ»´#œÆ-”≥8—≤=”≥BÀß9À•:Õ´=œ±AŒ¥EÃ¥F“πRŒ∑Q–∏T”∫V‘∏W“ÆPÃüD‘•K€ØVﬁ∞Zÿ°N◊ùI”öC—ò>œî6≈ã*≈à+»å,Àê,Ãó/Õ°6≈°1¿£.∏£,∞¶+∞¨/Æ≠/Æ∞1¨±3¶¨2ô°*êó%óü0ñù3ô°:ö¢?ëñ8êï9ïú?ñúBëóAãê>ëïKìñSíìYããUèåY©£q≠™w§°nìë`àáW|{MwvJklBcd:fd;jkA_b7Z_7RQ2FD+GD1C@1?<-;8'=8%94 ;5=9>:EAURZVmm%hikisq&{|,ÜÖ2ëè8öô?ûûF§§N®ßU¨´[õôLçå<ëé=ñî=ìì3îí-îë&úô&•§&Æ´(¥≤+µ≥*∑µ,π∑.∫∏1π∑.∂∑-∂∑-µ∂.∑µ.∏µ0∂≤-µ±,≤´'∞®#≥´&≤®%∞£#∞°$≤û#∞ñØí∞ñ∞îØìØì≤ô≥ú≠ô±ù∞ú≤û¥û±ô¥ö¥ö∏ù∏ù¥ô
+≥ô∂ú∏°¬´∆≤À∑ÃµÃ¥⁄¿-⁄æ.‹Ω/€∑-ﬂª3‰¬=Ë F‰ŒE„–F‰ŒGÊŒJÎ–OÌ–PÎÃOÈ∆HÁæBÁπ?‰≤9Ï∏@Î¥=·™3Í∂@¯ÃSı÷YÚ€[Úﬂ^Û‡_ˆ·a¯„cÙﬂbÚ›`Ú⁄\ÔÿXÒ⁄ZÚﬁ[ı‰b˜‰cı‹^˘€_˙⁄_˚Ÿ^˙÷^ÚÀVÎ¬NÌ∆QÌÃXË…T„¬N‡ΩG›∏C⁄∑A÷∫?—π? ¥:∆±:«≥@–∏J‘¥Q»†I©|8Üg0`f6Pk@XxQW{UGkENsJIlD@d>1W05^4BpBBrB<j;8h89h:EtHGvJ>mA=k<8f78b4/V)$I'J +P%+P')K($C#<$= .E)0D+%7!(4#;%#6"(%,"3!+ 1CU?ZjObpVhq\en]@L><M;1G2-I0?aFImSCiP=cJ9]A3[95]:6^96_70[..\-.\+0_+6`07\1(H#:;>)I$>`=IkHDgF/R1*M,'K''I$(K!'M,T"3]+1](4`+9e0:f1Dp=KrE:a4@j:LsFInC=`6Bf:B]&ÄÜ@§üDœ»V≈æ<Ÿ’O◊÷JŒÀ<»∆5 »7œ :√Ω)À¡.Õæ-ª´ª©∆≥(±ûßô0jg"CJ>N34L64M84Q;6S?6SA6S?6Q>4K;-?3#0&$"!!8Bf8Gr<Fw?Fy@J}DEw<Cs5An+Cl ]}(Éî6êó0ôô+üï"†èúá(/9 'E+.Q32Z84`<6d?;iEDrNDrNHvRKyUKwTEoK0X3(Q/?hH?jL>iK=jK7dE7dE<iHAoKFtMNwM9  $6Y;MwSLzUPÄXK{SExOF{ODzI>t@0e/'W%>B,X')Z#(Y"*Z*K|MK|OMÄUKÄVSä`C{LDyK=rFSÜ[PSCpGOuPníljëeuùkDl7.S<X/9Q-7J*9L,>T0Ib8Rr@Cb&Uq&ÖùE~ó1jÑ@`3S,M3Q2KoÉ;°∞S™∑K∞¡Oö¨@Éñ=:M- 0-@*?U@D]G>WA8P:6P5<^;:]5.Q)=`6Ci:9`19c3:f5;g6?m<;k;>n><j<?j=@i?@iAEmHGoJJrMFnIEnFAj@-Y(+W"!P%R'R KG'R&S'W)Z"'X ,]&6f2?n8@q:As>Cu@>n>.\.7`87`85_78b:7a94^64\7;c>/U.5[27a34[.8Z57F)S@/Ö`P¡ñÉŸ¥ô◊¡ò“≈ë—¿à–¿Ç“¡{‘ƒw”ƒq—√k”ƒi–ª`»≠T…ßNÀ£KÃ°EÀú@ƒì7√ç3√ä1»å4Œí:”ó?–î<‘ò@€†F›¢F€ûCŸò>Àâ3«Ü4‘óG⁄ßV‘•Sœ°IÕüAÀõ9œü9Õ°6Ã¢4Ã¢2Œ£3»ì)√à Ωxπqªw¡Ç¬á!¿á√ã¿à¬ÖæÅΩÑºà∫åªí ∫ï Ωô!ªóªóøõ ¿ú!¬†$¡ü$æú «•'≈ß#Ã¨%Ã´ “Ø’±’¥ÿ∑ÿ∫€ø ÷æœªœª”π$…¨  ©$–Æ0–∞5”≥<œ™8«°2Àß5ŒØ;œ¥A ≥CŒ≥HÕµKŒµN–∑P”∂RŒßH õ?‘•K€ØVÿ¨U“†K◊†Mÿ†IŸ†G€†Dÿò>Ÿó@’í;–ä2Ãâ.–ò; ò7ƒô1ƒû3ƒ¢6ƒ©6≈∞9¬¥9Ωµ8µ¥6∞∞4Æ≤7≠≥7®∞7§´7°©:û§:ù¢;ôü;ïõ9òùAö†JôúMïòQèëRïêXîÑPve1ÑyA¢úbìëXÉÇJywDxvEon>ce6ml>fh9im;eh;SS1FE)FA-C=-A;->8(A<)=7!;5>8A<GD^Y"a\rp#su"onpq!ts!ÅÅ)ìê3ûõ:¶¶D®™Iß¶L®¶O¨™Uïì>îí;úò=õô5öó.†ú.¢†)™¶(±Æ)∂¥-∏∂-ª∑/º∏0∫∏1π∑0∏π/∑∏.∑¥/∑≥.∑∞,∑Æ+∏Ø,≥™'Æ§ ±ß#≤®$≥¶$Øù£ã¢É™â∞çØå´ã®à´ç∞î±ïØó≠ï∑úµõ≤ò∂ú∏ù∏ù∫†∏úµô∫°	º•
+√± ∏“¿ ”¡#’¬(⁄≈.◊¡-⁄¡0€ø0‹º3ÿ∫6ﬁ¡?ﬁ»AﬂÀDﬁ E€«D‹»E‰œOÏ◊XÏ”UÍ»LÏ¬IÏªEÍ±>È™9Ë©8ÏÆAÎ∂FÔ∆PÙ÷\ı‹^Ï‘VÁŒPÓ’W˘ﬂfˇÂl˚›cÒ”WÒ‘VÛ⁄[Ô‹[ÓŸYË N‹∫?›∂=‚∫A„πCﬂµ?„∏E‚πEﬁπF€∏D”∞<œ™7…§/À´2“∏=”æA‘¿G‘¡I—ΩJŒ∂J—™Kºí@ñn0Én9[g7Ll=StIPsIHmAEl?@e:?d;6\55`5CqC@p@<j;:h9?o?BqCCrD=k=7e65a03]/*Q%#H)L"-R')L$(J''F&<$? )B$)@$+A*+A**D+2L31G2 3.-)*$3 1>*`lTcmUNWBLUDDQ@/@./E0&B+/O8:[FCfRHkWFiSGjRBfL5\=7_=8`=2\60Z24]37\3-L*>:,K++K&= @&E#-O,)M)'K''I$&I&K-S"4\*1](4`+7a/<f6Cm=MtGGjB.Q':_3@e96V/,L%/R*6P bk*õôD∆¿Pÿ–Qÿ’P–ŒE≈¬5≈¬3∆¿4∆ø1Ã¡3Õ¿3√≤&∏•≈∞#¿® ∞ò§ì+b_?H7L-2N76S=6VA3TA7XE:YG:ZE>[I>VF0D8!1&(&+G!.R$PzHJyCJyC?n7Br8Bp2<k%Dm`|(Öî7îô3õî)ùç°ã*++$>%+M,3[64a89i?BrJJzRK{SK{SJ}R?mF3V5=2T9ElO?jL;hI8eF:gF7dC6eA7jA@pFHsH2V0  !:%FkLLxTL|VLVJ}TExMAvH<r@1d,(Y"#M	0.Z).^*._'-^'<j;UÑVKQLÅSAvLPá]F~QHÄS;pFVàbN|WLxTwü}wüz_ä\[áRAl4/T!8T,>V49Q1;P/@V2?X11K$-GBW|êIwé6^x!:YEg+Io6Fh,E`vã@ï£L©µS∑ƒZØøTì•Atä7.C
+**)"3!2@/8F5>O<G^D;U80K,7W29^3/Y+;g69h4<k7=m9>n>>m?CqB@k>=f<@iADjECiDGmHGpH:e8-[*'X!%W$V'W!LB(S(U#S&V)[.`#0c(/b'4e-=n6At<As>Ap<=h:8^78\88a95^62[10Y/>d;4Z11V-,Q(4W/<\75O2AF/dD5õl\…üá›ºõ‘√ï–«é”»ä’»Ñ‘√{“øs”ºn“ºi÷¿j÷æf”≥\Õ•NœüJœôC–òA‘õD”öC”óA–î<Œê9“ï<‘ô?ŸûB‹§GŸ°B÷ú;€°@Ÿú?Àâ2Ãã9“óI”ûNŒûIÃ°CŒ§B–¶@ £:À•:Ã£7ƒï+øà#¿Çª{º}¡å$¡ê'¡ë%øè#¿ç Ωâ∫Å∏∂Åªä!Ωï&πï#ªö&ªõ$∏ò∏öº° øß#¬ß$æ£ ¿• Õ≥+“ª/÷¿/Ÿ¡-ÿø'ÿæ#ÿ¿"⁄∆%◊∆!—ø«µÕªÃ∏–∑ÕÆÃ™"Õ™(œ≠/“∞5“Ø9…¶0 •0Œ≠9Õ≤=Ã≤AÃ∞CÀØDÀ≥I“∑N‘¥O §A≈ñ:”§J⁄ÆU‘´S—£Kÿ©OŸ™N◊©K⁄©L‹´Oﬁ´R‹¶PÿúFŸúIﬂ®U‹®T’ùFÃê8Ãà3Àâ2–ò9–•=ÃÆ>«¥<¡π=Ωº=ªº<≥∏8∞¥9Æ≥;™Æ=§®:°§;ù¢<¢¶E†•Iõ†NîòNêìPßù`Öf0oLàr6ßû]çåIÅÉB{{?{zBtt>ii7ik:\^-km;^`1QQ-DC'D?+D>.C=-=8%@;'=8":4>9C>GC`Zok!us}}#svtw ||$~}!ïí1†û7©®>Ø±F´©D™™H¨¨L¶•Hñì6ùö;¢ü8§†4®•0©ß,Æ´*¥±,∏¥,ºπ.Ω∫/¿Ω2º∫1π∫0∏π/∏∂-ª¥0∏Ø,µ®&∏´)∏Æ+∑≠)µ´%≥™!∞¶ µ®%≥§#Æö™ê°Çùz¢	Æê∞í™ä≥îÆè±ì≤î±ì≤î≥ó≥ò∑õπù∫û∏ô
+∂òæ£√´∆≥«∑Œ¿"–¬$”≈'◊»-÷«,◊∆.›…4ﬂ∆8ﬁ¬;›¿>„»GÈ“RË’U‚—O‡œM‹ŒK‰’TÈ⁄YÌ‹ZÌ‘UÃQÏøHÍ∑DÌ∏H∫NÙ¿SÛ≈UÀVÛ€_ı·dÌÿ[ÁœSÁ RÏŒVı“\¯ÿ_˝·d˛ÁgıÁd‚_Ì’WÂ≈J„∫D„¥@·≤@„∂C·∏B›∂Aÿ≥@”∞<“Æ<’¥@◊∫BŸ¡GŸ«IÿÀK÷»M”≈KÕºJŒ≥J—®L∞Ü:wYsi6Pb.@c-Hm:LrA?g3?i7Ah;Ag>2X18a7>i<>l><k=:j:;i:@n??m?;i:8b2.U&1V*)N#'J 'J ,O%+N$0R-)K("D!)H&+J(/M+9V8=W<3M4$='":$500..$5"+8&4<-9A2DM<NYHFQA,:))?*#=$2N7?]E8XA4U@6WD9ZG<]J5XB3V>CjOJpWBfL?`E/K2"?#<$F#@d>:_4+P%$G*J%(J%)K&&H#&I!'K(N/U$.V"-X#7a/2V(6Y/MpFGg@5S1-K)-M$0P'0K(0K*(F$0GHSíïDƒ¿U◊—U—ŒK…«@√ø7«¡7—…@“ AÃ¿6√∂*¬∞&√∞& ∞'±ñ±ò©ò0\Y<H3I%0M11O51Q:6VA9XF9ZG9ZG8YF:YG9VD5M?$6*""(*,L%/T)5\/4^.Bl:Dq:>l.:g$Fj$\w(Ñë7îî2ôå$°è#($&171S2+P.5_9=gCJvRHvQN|U?nD*T.62,L5DhNAlN:iG:gF@oK9hD7gA7jA?oE@k@A 	HdNRyZO}XK}WFyPBuLBwI?uD.d0*]%-\&< I3a0.`+0c*4e.FtF`ècSáYEzLJUNÇ[OÜ\D{QEySYàdQ[XÑ`lñrgígAp:Cs9:e/(N3O):S3>V69Q16K*:O.)@#%:1CL^*\q.GbFe,]LQv@Ei,Ih$^x.ar$ßµ^ØæY≥≈Yô¨Ayë3`y7=W(/G'2$"$%)'"8!1K.2T/,V(8d3<k7;l58h45g69h:;i;;f9Aj@HnGLrKNtMLrK1Z.,X',[%*\!'[+],\"8%O,Y"'W&V)Y*\*\/c%4g,4g,5h-<o6<o78g1%Q +P'1U18^79b::c99b6<c70W+-R)*O&+K&4O.8L1KF2|PC∏~p–§ã⁄ºñ‘¬êœ≈äÃ¡∆∫r«≥j¬®]»®_»ßZ«¶U“Ø]—ßS óD»ê=Àé;Àç:Àç:»å6Œí<“î=‘î<”ì;—ë7Œì7œî6Õì2«ê,Ãó1–ô4œì3≈Ö-∆á7‘õJ—¢J–ßK—´JÃ¶C…¢=«†;∆ú6¿ê,∂~∏|ΩÇ$¡ã+¬í,Ωí)æï)æï)πè#ªå"ªá!µÑ∂ä!æò+Ωù.∫ù(∂ú%∂ú#π†"ø®&¡Ø'∆∂+»∏/ ∫/–ø3◊»9‹–<ŸŒ8‹Õ4Ÿ….⁄»*Ÿ«'ŸÃ(÷ &‘»$“≈!–¡«≥¬¢≈†…£…¢!Ã•&–™/“Æ4œ´1 ¶.œ¨4Œ±9Ã≥=À∞?…Ø@…±CœµG–±G∆†;√ï7◊¶J◊´R“©O—¶J◊¨N’™K÷´Lÿ≠O€∞T›±X⁄¨V‹•Rﬂ®V‰±bÊ≥dÁ©^‰úTﬂäG’Å;“Ü:—ê<Ãó9œ¶=Õ≤? ∫@∆æ?ææ<ºΩ=∂∏;Æ≤9©¨9¶®:•®?§©Cû£Eõ†LïòKúóS™òXzRÅYì|8°óOçã@ÑÜ=ÄÅ=wy8uv<hh2bd2Z\*eh3Z\+OO)B>!A<(E>,C>+>9%><%>:!=7B=GAIB^Vys%|xÄÄ}|{zÜÅ%Ñ~ îå)ß†6´•5≥≠;∑±C∏±G±¨FÆ™Fß°?õñ2ß†8≠•6Ø©1≥Æ0∏±/π≤.æ∂/¿∏1¡ª3¡ª3¿º4æº3º∫1º∏0æ¥0¿Ø-∫ß&ª¶&∫ß&∏ß#∂¶∏®∞£¥ßµß ∞ù¥õ≥ï±è≠ã∂ö∑õÆè©á	∞é∑îµê±å∂î∫ö∏ñ∑ñ	ªõ∑ó±é ≤è ≥ïΩ§«≤Àª Œø$œ¬$“»)’Õ-◊Œ1◊Œ1◊ 0€…7· @‡≈@›∆Dﬁ…I‡—P„÷TÈ‹Y‰⁄T‚€WÈ‚^È‚^ÊŸWÁŒPÎ»P…T˚–`˜À^Ï¿SÍ¿PÔÃX¯ﬁe˘Âj˜Âi˜„h¯ﬂhˆ‹cÒ”[Ë PËÃQÒŸ[¯Áe˙Èg¸‰f˘€_¯—ZÒ»RÔ∆PÒÕUÓ–VÌ—VÎŒVÁ TÂ»R‰«Q‚≈Oﬁ≈N◊√H“√FŒ¿EŒΩGÀµE“≤Mœ£Lôq+O:VU%E^'8^#;`*<c,=h2=i6=g9<e;8^74Z1.Y,=k=>l>9i9;i::h9=h;8c68_2/T(+N$(K!$G'J $G"E-Q++O+*L+>]=Ba?EdB5T51P1)E,)E,5N8.G1#<&5N8IaK;Q:->+(5$$,!3;.HQ@_jYMXH+8')<(%=%+E,(D+*H0,L50Q<6WD3T?*L4)M34X>:]EEgO?ZG'@+;" ? @fAFoEAh<7\1-P(*M%&I!&I!'J"'J )O (P'OE#I0T&7";3L.%>!%<"'>")B"+D$-F(+D&#>.G BPtz2»ƒ`–ÀS  H…∆A≈¡;“ÃD“»DÀ¡=¬¥/∆∂/¬∞*“º5∂ö≥ñ∞ò¨ù8RS8F/H!+H*.L0/P5.N7.N93T?4U@1T>5XB;ZH:WE1F7 0% "%&7(D-L#1Q(1T*2W+6^*=f.Fn2Gg$_t'àê:ñê0üë."'*)*0/ 8"1J5&D,-P2@eD,O133!6&1N<FiS@mN=oL>mICrN7fB7fB8jD=mCKuM &*BcHLuSJzTEyRF{QAvJ?uD.d2(_(+]('W#D1_12d3/d0/a,8j76e9]çcWä_OÇWMÄWGySQà`E|UH|XM\[ãeVÖ[UÄSP|IDt:Gw;0]&)O *E"2I,8O29P33G+(< #7/&:/G%4M%=Z,OpETxLcâXIp9Ah'Be!]v4ï™_°≤T¶πPîß<uç-gÖ?Kk9=]4;Y72K+%9*".D->`;:d6:f3:i39i5;k9>m?=l@<i>:c;<b;Ag@DmC4_2,W).Z',[%2a*-_"1c&5e+$Q73]-.]&*\(X(X/_#1c(.a&3f+<r6=s79o5<o6?r97f2B,P*4Z32[37]47]45\03Z.2X//T+1Q*3M*:G-WH5ìZO«Ñt”§à’≥ç—∫à–ΩÉÃΩz πsÀ≥k≈ß^√õU»ôQ òOœöN–ïI»â<–è?—ê>“ë?–í?—îA◊õE‘î=Õã4…Ü/√Ä'≈Ö+…å/√á'¬à%«î+Œû2–ù4Ãñ4¡Ü,“ôB“•J—™Kœ®I≈û?∆õ=¡ï6¬î6ªä+≥~ æâ+¬ê1¿è0ºé,¿ñ0¿õ1∏ñ+¥í'∑í*∫ì,∏ì+ºõ0ª°0π¢0π§-Ω©,¿Ø-ƒ¥-»ª/…¡2Œ«8—Ã=◊“CŸ◊F›€H›‹F›ŸB€÷>⁄—8ÿÀ/’«(”≈$◊…(÷Õ*‘À(Œø≈¨¨É ØÄ ºå¡ë≈ôÀ°(Œ®+–™/À§+Õ©/Œ≤7Õµ;Õ∑? ¥=»≥>Õ∂FÕ±D»£;¬î4”¢F”®Lœ¶JŒ¶G‘©J÷¨H’´Iÿ≠NŸ±R›¥XŸ≠T€®Uﬁ´Z‰µgË∑kÈ≠gÂû^·èUÊëXËö\·ñS⁄åD◊ê@÷üB”≠BÕ∏A«æ?¡æ;∫ª9¥∂7≠±6≠∞;™Æ?°¶?õ†BõùJòíF´öTãn*}Wíq$öâ7óí>èé<Üâ:z|1ux1oq0bf+]`)^a,hk2_a/NL&B>!B>%FA+EA(@<#A=$>:=8C?IDPJ^T{r%ÄyÑà~â}çÄ îÜ%òâ"¨õ1±ü/ª™6¿Ø=¿∞?ºÆAµ®?∂™D´ü9¨û5∑¶:∏¨6ΩØ4¿±2ƒ∂3≈∑4»∫7»ª9«Ω:…ø<Ãƒ?Õ«?À√<Õ∫7Õ¥3Õ≤/Œ≤-ÕØ+ÕØ)Õ≤'Œµ'Õ∏)…π(≈¥&æ®∏ú∏ö¥ñ¥ó∏ùπû∂ô±ìµí¥ç±Ü∑å
+πíªñ∂é
+µçΩñ∫ì∂è∂ë∏òæ£«∞ÃπŒæ!œ¬$“ *‘—.÷“1ÿ‘5Ÿ–5ÿÕ7Ÿ…8Ÿ»:ﬁ—E·’M‡÷R‡ÿSÂ›VÊ‡XÂ‚]ÂÂ_ÊÊ`Êﬂ]‚ŒQ‚≈MÈÃV˜ÿd˜◊fÔœ^Í YÈ…X”^ıﬂg˘ÎpˆÏpÚËlÙÊiı„gÛﬁaÒ◊^ÏœWÈÕRÈÕRÓ–VÛ’[ˆÿ^ÛŸ^Ô⁄]Ó‹\Ïﬂ]Ëﬂ\„⁄Y‰ŸY‰–U‹¬Kÿ¥Bÿ≥A–≠9À¨7À≤<ŒµAŒ∞BŒ®G∑à:Å[>31<<Y#2Z3[4]#=h3Bn=JsGGpHKqJ6\3.X*7b4=k<9g8;f8<g:<e93Y03X-,O%,O')I"'G (H!?'J"4X2;_;9X95R4.K-%D%>"A",M.>\@<X?-G.1K2=W<IcHC[A.A+%3"%0"4</NWFgp_VaQ+8'1D0":"-G,+H,0N4-M51S;/Q8(J/&I)'M(1W24X4+J+#<& 9#:/R1EkFIrJ>d=.R,+M((J%(J%%J!&K *O#-W'5_-9d.1Y$+L:+$$)"4(<#)<&4-H)6P+DU)T]∞ØRÃ…V… J≈≈?“ŒHœ«B∆π7…∫;∆∑6 π7—∫:¿•$£Ü¬¶)∞õ&§ö9CJ4E+E (G''H)*K,,J.-N30R92T;0S;2U=8XC:WC7P=-?1$$(, 30F"5K%3I%-B#6$@3T)Dl7Ai+Ki)k}3ëì?ïê4#'"#	#=$,H/'+#5)+?4+E8=^KCnP>pK9kE9iC8gE6eA;mG@pH?iC99Z=NqSLxTI|SAuN@wMDyM4j9)_+(^*,^+%U%$S%5f70d3/e1-b.7i88h>OWSÉ[Uà_JzTM|XMÅ[H|XDvSUÑb\ãgQÄVXÜXKzFCs9TÑJ5d.6].+F#2F*4H-2F+.B& 4+'1)A)2K.>[<SuTgãgkêeV~LJv9@h)]|CÜü^ôÆ_î©NÖö;sç6_<@e17^11V-2V*.M$'A"6+)+'>$4V1;e7<k7;j66f24d48e:>kBEoGMvNPvOGmD3^1.\+2a-.]'3b+5g,2d'9k0=i4= G=g74e-.b$*\(Z1a'1c(:k3;n58n4=t:=s97m39l3<h50U,4S15Y58\8;_9:_67]46\33Y03X/0S+5M)@D)`J5°cVÃáw◊•äœ¨ÑÀØŒµ|–ªz–πsŒ¥jŒ¨dÃ¢Z∆îM«èEÃéEÕãA«Ç5Àà9—é=œå;Œç;«â6«â4«á/ƒÑ* ã.Àé1Õí4Àì2∆ê,»ó.Ã¢2–´8À®4ƒü-øì*¬ï0«¢:Õ≠F ®D¬û=√õ;¡ñ8øí5Ωë2Ωè1≈ó9√ï7πç.∏å-æñ4ºú5∑ö2∂õ2πû5Ω¢7º§6¡≠:√≤<»∏?∆∏;∆π7≈π1∆Ω2»¡2œ :’”B◊ŸJ‹ﬁO‹ﬂP€ﬂM€›K€€Gÿ◊AŸ‘<ÿœ4”∆(Õø!”«'‘Ã,“ )Õø À¥≈†≈õ¬ïºë∂çªìƒû…£&Ã¶+Õ©/À≠1 ±3Ã¥8 ∂;À∑>ÃµAÃ±@«•:¡ì1—†A—¶Hœ®I“™J‘¨J÷¨F‘™F‘¨Lÿ∞Q€¥WÿØU◊ßS‹´\„≥gÊ±kÂ•eﬁñ[ﬂí\Û£n˙≠uÚ£hÏñ[ÈñT€òJ‘°F—ÆFÃ∑D»ΩA¿ª;π∏9¥∂7∞¥;™≠<§ß>£¢EõïA°ëDíx.Ä`êq™í8úì6ëê3ãã3ÇÑ0z}.w{/jp*oq0`_&if/uo5k_+[G"T=S>!S?$M< I:K<I8K7U=]EfKlPÑhî|"ï}ò~ózñ|°Ñ&¶Ö$©â$∞è$≤í%πó+∫ò,Ωú3æû7πú8¥ó3¨å'≥î*ªù-Ω£,¡£)ƒ¶* ≠/‘∏;⁄¿E‹¬G›≈Iﬂ K‚–P‚–P·…Kﬁ¿D‡¡B‚¡@‡æ@·æ<ﬁΩ8⁄Ω3ﬂ∆6‡À:›À9Ÿƒ5–∂+ ≠%ƒß¡§æ¢πü¥ò≤î∑í≥ãÆÅ ≥á∑è∫è∫éºã
+πà∑Ñºá≈ìÕüœ¶–Æœ¥Õ¥Õ∏“∆&’Õ,‘–/◊”4€’9ﬁ’<‡’?›”>ﬁÿF„ﬁNÊ‡V‚ﬂTﬂ‹QﬂﬁR‚ÂZÂÈaÁÍeÍÁfÎ›bÏ◊`Î◊dÏ◊dË—_Ó‘e˘›oˆÿjÍ [ÁÕ\Û‚nÙÍqÚÍnÚÍmÙÈmÚ‚h˜ﬁg˜⁄d¯’aı“\Û–ZÔœX–YÙ◊_ÛŸ^Ú⁄^Ô€^Î‹]ÊŸYÈ◊Y„…PŸ∂B◊´>“£7 †0Õ©7–±=œØ@Õ¶=¿ï9öp(cF/-1	/L0V0Y2^!:g0Eq>JuGLuIPvM9`4-T')S%Al>=h;=h;GpD>d;-R))L$%E *J%*J%&D'E=)H&Ac@4V3+J+&C',I-3Q5>_@EfGEhGFiIRpTLhO(D+(E)-J..H-;N83B/"-2:+OXGhsbltg*7&3F2$<"1K02O3-I0-K1%C+<]BBcD8Z7:^8:^80P+"? 77&H'HnIJpIFlE2X3+O))K&'J"'L#(M$*O$/V)0Z,6b1<h5Fn<Dd;(A!0'!'"8!1N07R1>R-N[%èì>ÃŒ` ÃQÕœJÃ C…¬=œƒDÀΩ@Àº?—ΩB Æ3™å∫û#º¶/±†6éà0>H3H,G$)H(+J*,N-0O00Q23T74V;6Z>8ZA<\E?ZG<SA/@0# 	&(. ,4 .4 :A ?F28 ,0 #* # -GFl3Gn-Om'Vg}~!òí0#4$0C0
+(%5+';0&>19XFEnPApL=mG5e?>jI7eA;kE@nG7_:0BeGMtUCsMAuN@wM<tG3h:,`0-a0*^--\.*X*1b32f50g02i23h47i8DsIXÜaVÜ`P[XÜbO~\M|ZTÉaCpO\âh^ãjSÅ\N{RVÑVSÖPVâQKzD6].(B2D*3B+/A'0C'%9$6/,&9#.G*;X:XvZÇ£ÜhãjjëeHs=@i/SuBMi6ay?ÉôXñPmäGX{C>e6:a57a34^,4\(4X(,K")B$)@$#<6T2@f=>i;8f57g59g6?m?CmEEoIFpJHrJ<e;.Y+4b18h46f21b+9j25h/<o4HyB/V':/V'@o;5h/1g+,b&*]"1c(3e*4e-<o6=r:<s:?u;=p7/`(H=!;-J,5T47V48Z56Z41W.3Y02Y-0U*6O(FE'eI3¶k]”êÿ©çœ¨ÑŒÆ}Œ±wÕ¥rŒ≥lÃÆeœ≠c“¨aÀ†R óH ëBÃä<œå=—é= á6ƒÄ/¬~-¡+¬Ç+¬Ç*¬á)¬ë+¡ï,øî+æï+Ωô)ªú(æ¶,¿¨/¬∞0√±1«≥6√Ø2¡≠2ø´2º•3πü0ªú2ºö6Ωö6øô8¡ô9¿ò8ªê4±à,µè.ªõ6º°:ª§:¿´@øØ@√∂D«ºFÀ¡FÀ¬Cƒπ;¡∂6∆º8 ¿:À√:Œ»<“œDÿŸO‹›S›‡U‹ﬂTŸ⁄NŸÿJ€÷GŸ‘B‘Œ8’Œ7◊Œ3”».“»+“…,—»+Ã¬%Àº#…µ ∆≠ø§πùªù¿¢ªùΩú»¢%…•*»©,»¨.…∞2Ã¥6 µ8 ¥<…Æ;…ß9¡ñ.…ú7œßEŒ´G“¨G”ÆF‘´B’´E”´I÷ØP⁄±U÷≠Uÿ™U‹´\„Ød‚©d·õ]‹ëXﬂòb˜∞z˜±vÎ†fÍö_Ù•jÍ©gÊÆd·Æ]“©Mœ≥H πE¬º@ºΩ>µ∑<≠≠;™ß@°ñ:éx%âläiîy •ì1´¢9ûõ2òô1çè,Ñà*tx$qu(nr(tu1ia#És8äo8É[*ÉK&ÖH)ÉK*vA!h;_6^7b7m9}BéLïRòX£g™r¨tØy!Ø}&±Ç*±Ç*≥}%ØyµÇ&µÄ"≥{¥y∂{∏}±t¨o¨qØx∂É∫äªáøå∆ï—†*›Æ:Â∂DÁ∏FÍøLÏ…UÓœ[Ó–^Ë XÊ«RË RÂ∆Q‰∆LÁ…M‰«E‡∆>‰ÕCÁ‘GÊ’G„ŒA‹¡6÷∂-›ª3€æ4”∏-∆©ºú≤åµç∫í∏ê
+∑ã≤Å ¥ÅπÅ∏wµo ∑l øt –ä…ä	Õô–£À£Õ´“π‘ƒ&÷…+◊Õ.€—4‹”8›◊;ﬁŸ?›‹CﬁﬂF‚‚P‰‰R·„Q‚ÊT‡ËW„Í`ÁÍgËÁi‰€dÍﬂlÊwÔ„uÍ’jÁÃaÔ”h¯Ÿoˆ’lÒ“hÓ”hÚ‹mÚ·mˆÍtıÈsÚ·kŸeÔ—_Û–\˘—_˘—_Û XÒ√TÛ¿SÎ∑JÍ¥HÎπJÍ∫KÍøNÈæMÂµG·ÆA€ß:”£5—¨:÷µB”∂AÃ™<Ãú:ÆÄ+xYSF6=2";2R#2[!1_!9f+?l3Ds=Ds?Dp??i;8]1#HLuIBk?GpDMtH;^63S,+I% >'F$)I$'E(F &D"#@!2Q15T42Q29Z;FgHKnNGlKBgF=bA@eDJkNDbH'E+">%$@'.F.7J6;J7+1<,JUDhsbowj/:,/B,.F,.F,)A)&<'01F`ED^A&C$HgG:Y9'D(98>DjCMvLFjD6Z6+O)+M('J")L"*O$,Q&)N#.T+2]28e<@jBKsNUxW<Z>4*&$1G28T;6S59R4FW*r}/À“k “[œ‘S» EœœI–ÕL“ Mœ¡G ¥=≥í∏ó$ª§0≥¢6≤ßK][3<0D!-H%+J*-L,/N/1P03T54U87Z<7Z<7X=:V@+B0$2#'#! '' >< icéÖûê•ñ∞û ìÇkY :0 "# <LKj&St%^rÄÜòçüè&2&0>/
+"-<7.B9.C:6RCBiNCoLBpL>lH=iF:fC;kC?mF@eD)
+7Z<GpNBrLBwM@uI6k=/e4-c10d3-^/)V+7d9<n=7m96m65l59o;7k;BpIYÖb]ãgYàdWÑcYÜeQÄ^Q~]GsR^äi]äiVÑ`QXSÇVXäYQÉNVáP(O $=(:",:#1@),>$,@$0B(3C),.,C)?Y>Zv]nètképnîm[ÉOIq<Dh8<[/;U(Pg9Yq=Vr?RvHIpDCl@Bl>9e28c.8^-'H$?!<!?2T/=f:>l==m==m=:i;:g<=gAEoIEoG9d96a45c4=k:EuC5e1;k79l4At;@s;Cr>7<:d4Et>:m56m32h..d*.a(9j2=n6;n6<q9EzB=r:Bu=Cr<-T'1,1+E**E&<Z8<[97Y66X35X05U0=N,QG.xUAµ|k–ñÇÕ§Ñ»´Å…Ø|Ã¥x«∞mƒ©b¡£Zƒ£Vƒ†RƒûM∆úH∆ñAøâ3πÅ*µ~$≥|"µ~#∂$∂Å#µÉ"∏à&ªí)Ωù.Ω¢/ø¶2√¨8«¥;»∫=∆ª;≈æ:∆¬<∆¬: «< «<…√;«Ω9…º<«∑=≈∞;ø®8æ¢5ºù3Ωù6πô4¥î1∂ô5æ•>ƒØD√±C¿≥C∆∫J≈ªH«¬L ∆K»ƒF«¬B»ø@∆Ω<»ø<œ«B“ E‘ÕHÿ’P⁄⁄T⁄⁄V€€W››W⁄◊RŸ”Kÿ—EŸ—BŸ—>ÿ—;÷œ8“…0‘À2‘À0Õƒ)≈∫ «º"«∫ ≈∑ ƒ≤ ¡¨º¶æ®Ω¢¡§"¡£!¿°"»©,«™,»¨.…∞1»∞2»∞4∆¨5…™6ƒõ/√ò/Ã•>Œ®Cœ™BŒß@Œ•<‘´B‘¨J”≠L’¨P÷™S÷¶RŸ¶Wﬁ®^ﬂ†]ﬁîW◊ãQ‡ôaÙ≤xÔ©m‰ù_Ì¢h˘≥wıπ}ˆ¿Äªy„≤fÿØW”∂R ∫I¡ªC¥¥<¨¨:öï-sÉlçoöÄ!©ñ/≠•6•§0°°/ùü1îï/ÑÉ&tq rn$}v0zl-|c+ñr@£pAßh=∑mHƒxT≈ÄW∂wLúb:äS*ÉL#ãP$õW&´_+∏g/√s4…~:≈Ä3√Ä/…à4Ãí>ŒòB õCÃöC…ë<√â5 í;…ê7∆É,¬{#¬{!Ωsµh¥h∂o∏vººÇºÉƒã∆è…íœò$“ô(–ñ(‘ú-‹™;‡µEÈ¿TÌ»]Ó \Î…[Œ`ÎÀ\È…X”]ÁÀP‰ÀLÊ‘NÁ◊NÈ◊OË“I‚∆A·√=Â…AËÃD‚«<Ÿº2 ¶ºñºò∏íºç	∑Ö∂ÑºÖ±p Æe ªk æj æj æo  Ö‘ôÃô»û
+ ´—∏‘Ω"“ø#–¿%œ¬&◊Œ3ÿ”7Ÿ÷;⁄Ÿ@ﬁﬁH‡‡L‡„N‚ÊS‰ÈW‚È]ÊÈfÂÁhÊ‰mÈÊsÍËyÈ‚wÎ⁄pÁ“i‰ÀdÊÕfÈÕiÈÕiÌ–jÚ◊nÎ”gÔŸlˆ‡q˜ﬂq˘ﬂpˆÿhÈ V‰√OÓÕYÒÃZÓƒT‚≤F€¶<‘õ0–ó,Àï( ò)»ñ'ƒë$≈í%Ãú-“©7‘≥?œµ>«¨7œ≠A≈ì:ça]KFH7H";/<-U 3`%9f+=j/Aq7Et>Eq@Cj=:Z3 @=_<<`:EjA:]5)G!+F#2M,/J)+I'*J%'G (F <9< =$A%'F'/P34U87Z<>aCDgIHjO9Z?0N64R:?[D3L6&>(0C/@Q>'5$2?-IVDcp^mxj2>0*='-E+&>$":"/&,,C)!8-&@%'D($<$!9#5*I*OuNHnE6Z6-O,*L'(K#*M#*M#/R(3S*+K$&H#1Z2=gA@jFKsQNsTJhN":$.*'"8P::X>5S97Q6AX.Sb!º∆mÀ”cŒ‘VÀŒM“”QŒœP– PÃªGµõ*¥î'√ß:∂•9±©FùöKGK1=)>*C#0K(3O'6R)9T+:V.9W5:Y:;Y=<X?3K5!2 $!(/^b0ol'âÉ#∫Ø3»∂&Õ∂Œ≤«´
+◊∫!’∏0º¶.ÄtVW Xg
+o}ëë#°ó£è†â
+
+ -9+&2$
+	
+	6BB=MJBYQGcT:]E5\?ClLDpMCoL>lG<lB?lC'H+"	:[>DlJ@pH>sG8m?.d3.g4/h3/e11c2%O'<g<=q@;r;8n:5k78n<:n@@nITÄ]Zàd`éjUÑbYàfWÖaSÅ]@lI\àeP~ZYâcPÄXOÄSUâXQÉNPÅJ=g7&A &8 0=+3@.3G.6J/7J.=K2)->+AYAZv]dÇf}û}°{T|JPxCAg8:]36R,4N)5K'@Z5Eh@KrFEnBFpB?i;<a52N(%=":9(G%9_8@k@>m?<k=;j<<k?9h><i@<f>1\1@k>5`2M{L=k<L|L;i8Dt@@s;FyADt@'R$8"BBl>KzD@s;Aw=8o64k2/b*:m5=m9Cs?;n5At;H{CK}HN}IQ{M,N)/011%<"$= ";%>!(A#)@$9>'R;+~RE∑ÇpÃùÉÕ≥éÕøê ΩÜ∆∏yøÆi≤ûW¨íHØíD´ä9©â2©ä/©ã+™á#™á!∞è&∏ô-ø£5¿©7¿´8¡¨9√Ø<¬≥>¬π@¡ªA¡ª?¡Ω?ƒƒB¡¡=¬¬>¡¡;¡√;¡ƒ9√∆9√∆7√≈6≈«8∆≈9»ƒ<»¿;Àæ>Ãπ@»≥>»≥@«≥@¬µB∆ΩH…√K…ƒL∆¿H≈øG«¬J∆ƒK…«NÀ…NÀ…N ƒHÕ√G øC–«H‘ÀJ÷œMÿ–Qÿ”SŸ’Wÿ‘V€◊Y›ÿZŸ—RÿŒK“∆@‘«:◊À9‘ 5–…3”…3”…3“…0À¬)…æ$»Ω#≈∫ ≈∑ ¡±æ≠ª™¡Ø%¡Ø%¡≠&ƒÆ'¿®$ø¢"ƒß)«™*»´+»¨.≈¨-…≠0…´3∆û-Ωì'»ù5Œ£=Ã°;…û8…û6”©C”¨G“™J‘©M‘•M”ûNÿûTﬁ§[‹õYﬁéS‘ÇH‡ï[™nÈü`‰ù]Ó™kÛ∑yÛ¡Ñı…åı…äÚ≈ÑÎºv‹≥c“¥T»∑M≤¨:≠≠;ûö.úï*§ò,Ø¢2¥©5≤¨4∞∞4™¨/¢£+ùù+êé'|uzmÇm*ô|BüzFµÑ[√ÑaœÇdÿáiÊöxÏ©È≤|„±v’üc∆ãOæ|@ƒÄAÃáDŒäC“éE÷óJﬂ§VŸ¢P“úF‘¢K’©P—¨SÕÆSŒ¨RÀ£K√ó@∆ô>»ï:¬Ä)øx¡xΩr∑j∏mπsΩ|æÇ∏ºä¬í¿ì≈ï√ë√å∆ä¬ÑƒàÀì"–ú/‡≠DÎ∫SÔ¬[ıÀeÛÕhÍ«aœfÔ”fÊÃ[Ë’]ÁŸ\Ë›]Í›[Í÷YÊŒP‰ÀLË–LÊŒF‰ Aﬂ√;⁄∫3…ßªïªè¡ì¡ì	ƒïæâøÇºv øp ƒm ∆l œz›í‹û›¨÷≤—¥“≥◊∫!’º$’¿'ŸÃ0€“5€’9€÷<€◊@ﬁ›G·ﬂL‚‚P‰ÊWÁÍ_ÁÍe‰ÈhÍÏmÏÓsÍÎtÊ„rË›qÏ‡tÎﬁvÍ›uÈ⁄u„œlÊÕi‘q”oÌÀi„ªYË¡\˜‘lˇÂw˚‰p€dÎ÷_ÌÿaÓŸbÏ÷_Ï—\Â∆R·æH€∏Bÿµ?⁄∫C‹æFÿªC‘∂<‘∏=”ªA–∫@Œ∏AÀ´Dß|-dBHE:J5O0P!*I?@*U 6c*=j1?n7Dp;GnA=]6%> +5+D'/J+*E$"=";)B"+F#-K'*J%(H!+K&,K)"A";8!9!668 <%&B+,H21M71J5/H33O96R<9P<(>)&<'5H40A.3D1HWDWeTUaS5C2$:%.F,'A&,F+%=#623F0%'"8!#;#!9#5,$A%@bA6Z6-O,+M(+K$*M#+O#6Z.Ca;;U05O,,G$)K&6\7AiDNsQLmP0L3!7"/+&	(1M4;\A5V;7S::R.HZ&äñJÕ’nŒ”[ œQ◊ÿYŒÃSœ∆Q¿®:πü1º¶9Ω¨B∏ØJ¨™Shn.ES"DU1 520E:QAWBTDW?T)>S20G-0C/&7%+"$19mp7vs&à~±•+√≤&—∏ ’πÃ¨	…©÷∂Ÿº —π%¡Æ$òâ•í≠ï®è§à
+£ä"4?/#.	
+/9:FVU?VNEaS1Q<,N50R7=bCHoPCmI@mB0V1,&G,BkI=mE8m?.d3.d2,e02h6/c20_1C?iA>rA:s<9o;9o=8q><qC@pJIwS_çi\âh_élRÅ]\äeO}X?mH_çiJyUM}WQÅWUÜYNÄOUáRPÄLKuG!<#5+8&0=+4F09K3?O4AO6!?Y@XvZsîwÄ°ÇqïoU{LRzFCh<=`87W2'B!$;+B&8S4FeCEdBDd?>];-H)+ /#5!8+J*8^7@k@?n@:i=7f:;j@?nD4a8;h=:e7DoA@k=DrCO~P>m?IwHFvDL|HIyEP~O=</M+HrDPÄLHyBF{C<s<6m62g16h3?o;<n9:m4<r8Dw>J}EPKR|LEh@533 6!"53121!3$%:~REøí}ÿµï”∆öÕÃñ»»ä∆∆Ä»ƒz ¡rÃΩl ∏bƒ∞W∆≥T∆∑P«πN»∏G≈∂C∆∑B«ªC≈ΩA¬æ@æΩ>æΩ>∫π;∫∫>ªΩ@ªΩ>ªæ=æ¡>∫¿:∫¿:∫æ6πª4Ωø7æ¬7Ω¬4∫Ω0ºø0æ¿/ø¡2¿ø1¡ª1¿∂2¡≤3ø∞3≈∑<Ã¬F ∆H« I√»Gƒ…H»…I… J ÀLÀÀOÀÀQÕÀRŒÃQÃ∆JÃ¬G…øCœ«J‘ÃO‘ŒR“ŒQ—ÕP’—TŸ’X⁄÷Y÷–T◊ÕQÿ MŒº<Õª5–¡4—≈5–∆1œ√/Œ√-À¿(ƒπ¬∑»ª¬µø∞¿Æø≠øÆ"¬≥&æ±%Ω∞&√µ. ∑4¡©+æ•'¡§&¡§&≈®(∆©)…¨. ™/À¶1¿ñ&ƒò-Ã†7Õù7«ö3…ú5—¶>œ®CÃ¶C“ßI—¢J—òG÷òM›ûW‹óT⁄ÜJ“|C‡îXÎ°b‚óV·óVÍ©iÌ∂vÓ¿ÑÒ…åÛÀéıÃéˆ√äÈ∑x‹µfÕ≤WπÆE≠©;¥±@∏µBΩπ>º∏:∂∂4¥µ3≤µ0≠∞/§§(üú+êÜ%ã{&ò}6™äM√õgÿ®zÈØäÔ®åÔôÇÒö˚Øç˚æèÚƒàÔ«ÇÎºvÊ∞h·•]„£Y·¶Xﬂ¶Uﬁ™V€´V€≠XŸ¨W‘¶P’¨T”∞V”∂ZŒµXÀ≤U…™OƒüD¬õ>øé1πxªqΩrªq∫n∫pΩz¿ÇæÇπÇæéøîæì¿ìæåøà¿Öº
+ƒâ∆éƒåÀì&“ô2›¶AÍ¥Ræ]øbÔ¬e¯“qÌÕhÈ—eÏ€iÈﬁhÎ‚iÏ‡hÈŸ`Ë“ZÍ“VÂ–P‰–MÊœM‰ÃHﬁ¬=»ß"¨Ñ µã∫ëªí¬ïÀö∆åÕâ
+œÄ	∆q «p Õz∆Å ”ô€Æÿ≥–≠∆•’∂⁄¡'€∆+€Õ/ÿŒ1€’9‹◊?ﬁÿB›◊A‹◊E‡€L‚‹TÁ„^ÈÊeÎËgÓÍlÎÎqÈÈqÊ„nÔÈyÌÈ}ÔËÄÙÎÜÙÊÉÒ›|Ó‘uœrÙÕpÒƒgÌ¡bÊ¿]È…bÓ◊g˜„p˚Ër˜ÈoıÎoÚËlÌ„hÍ‹aÁÿ[Ë‘WÂ—T‚ŒQ‡—R›ŒMŸ«G”¡AÃΩ>Õ∫AŒπF¥ú:qTF5 AK3N-N2W#6[(<b1?i9<f6;g47b-3]+0U)4T/)B$# #-!5%< #744#<,J('I$&I!1U/NrNOqPXwXGdH4Q5&C'!?#=#;#7 48":$!:%";%";%(>)+>*#5(:$,=*6G5FWE@Q?GXH;M=(=*4L43K3<V;@ZA?WA'=(#6#(1!6# 7#"7$":$8"?#,K+,N++M*)K&)L",P$5Z.KlAbxTUfFAR23H'.L(*N(5[6GlJYz[5O42-*"-E/<Z@>_D:[@3Q74M/CX/[k-Ω∆kÃ“d–”^“—[Õ«Wƒ∏Lπ¢:¬´Cø∞Iª≥Pµ±Ztz0O^'@W->V28Q*0=KQ]	{Ç#vzosNT?G#.-*&(+'1:ALLYTtnxl öáßë
+∫†«´ø£ Ã∞…≠∂ö ™ä †~ úw õy ó{ ëx#+.9)&.	
+#+-HVV=RKGaT6S?+H2--E/CaELoNDfA"? ;[C>jG=mC0f51g50f21g59m=1`6H!F"HuNAuD:s>?uC>tB8q><tC>qHAsMFsR\âhVÖc\ãgPÄXSÉ[;kEXàbK{UK{SO~RRÅSQÅQVÜTWáU2Y-#<$6 *9$5B.1>,?L8FV<GW=/@.7!9W=Y|^kép}†Ärñr[ÄTV|Mmêfdá_-P($B $8!0 /%2 +* .+9()$5"/I,CgCAl?;i;9f;<i>;j@/^43`5@n@BpA;i8MxJGuFO~PCtEL|LJzHSÉQSÅR9b8<;=\:QzNPÄNQÅML~IEyH;o>9k84f1=o:<o78m5<s9:p2<p24d*G#>445"8!#9""6"6!3.&"M3&ågUø¢Ñ’√õŒ—ú∆“îƒ–à¬œÄ√œy√ÃqƒÀk√»b¬≈\¡≈V¿≈OæƒJΩ¡Fø¡Dæø@Ωæ>æ¡>πø;µº:µº:πª<∏∫;∑π:π∫:π∏9ππ7∏∫5µ∑0¥µ-π∫2æø7ø¿8¿¡9æº5¿º4¬æ6¡æ3¡ª3æ¥.ª≠*º™,ø∞3≈º; «D»ÀH≈ÀG√ F≈ÃH∆ÃH…œK œNÃ—QÃŒQŒŒT—ÕR“ N“»M–»K‘ŒR‘”U◊◊[‘‘X—“S÷’V‘”T‘”T’œS’ÀP”≈K…∂=Ã∏;—æ;œø4Àº+»∏$∆∑ ≈∂≈∂∆∑ƒµæ≠≤û	∫§¿´¡Æ#¡±&ø≤(¬∂0«Ω:…æ>ÀªA≈±8¿¶-Ωü#¿û"≈£'√£(∆¶+À©.∆¢*√ò'Àú0Õú3≈î-»ó0œ£:Õ¶=Œ®C“ßHœ†FŒîB“íH⁄óQ⁄êO”}B“y?‚îVÁú[ﬂëO·ñSÍ©gÎ±q¿ÇÔ√ÜÒ≈àı…åı¬çÛ¿âÓ¿Ñ€πoæ´Oº¥I¿ΩJ¬¿E¿¿<æø7∂∑/≤¥,Æ≤*ÆØ-®¶-†ï+†ä4∑ñO §e‹µ|Êæä∆ñˆ≈ú˜∏óı§âÓö~¯≥å˚√íÒ»äÓÀáÍ≈~Âøt‰πk‚∑h‡∂d‹∂a‹∏`‹∫aŸµ]’∞X“•P‘®Q–´R–ØRÃ≤S…ØPƒ¶F¡ü=√õ9Ωã*∑rπl∫n∫pªsªvæ{Ω∫ÅΩâæëøíΩãπÖºÑ¿ÖªÄºÖ¿èæé¿éæâ¡Ö«á”ã)ﬂñ8Á†HÍ™S˙¬kÒƒiœnÚ€uÍ‹oÏ‚qÏ‡pË€iÈÿfÎÿbÈ÷^Â“YÎ◊^Ë‘YË’Uﬂ∆G…¶(≥å	πìæô¡ú»ûÃû—ú—ó«á«| ¡s ∆{ «Ç  ë‹Æ‹π!”¥÷µ’∂◊Ω ⁄∆'›œ0‡÷7ﬂ÷9·ÿ;‡Ÿ@ﬂÿB·’E‚“I„–OÊ—TÂ–SÈ⁄]ÓÊiÌÏnÈÈmËËpÎÎyÌÍÌËÄÔÊÅÔﬂÄÚ€~Ú‘zÚ–wÌ pÒÃqÒÃqÍ«iÍ»dÈ `Ó–bÛ‹hıÁmÒÈlÍÊiÂ‰fÊ‚d‰·`‰›[‡ŸWﬁ◊Sÿ—M—»EÕƒAÃ¡AŒøH¬≠BàwHC?F<U1T,R2[!6b'>k4Ds?M{JQ|NBi=+K$6.&'* -,) 7-J+(J'!G ,R)AjBEnFGmHDjEAfD<dA8`>=eC;`A/T55Z;:_@,N3.L2+E,#: (:"/?%1=%*6 .;)1B0DWD;P?lÅri~o?TCG^J?VBBYEHaN8O=)>/.C4#8'"7&!8&6$4#"9%!>",K+-O,)M'+M(+N&,P$2W+MrFSoG\gGVZ?PW89G&9S0-O,*N*?e@OrQ<Y; 6+:',  (B)>_BA_E<ZB7S</I0AY9HZ*âîHÕ”sŒ“d––bÕƒ]ºÆKƒ¥R√µT¡∏Y∏∂_ÜåBR`#D\,>Z2;Y3@Z*GTàå+§ü≥¶≤¢ª©)úåUI %" "(!/'  ,&2.;5?:BAGFIGC[P àx∆∞'≈Æƒ¨»∞¬¶≥ì•Ä ®É §Ñ	ùáÅp ")4&%2!"
+ )328KEF`S3N=.E1%(0H0$;	'Uw^<hD9i?4h86l:4j8,`0;j>&S,EoKEqMRÄYOÑVF~MG}LBxG<tC>vE:rE>rK?nLIvU^çkQÅ[VÜ\J{N?oEDtJExODtLSÇVK{KWáUTÑRMyH&K"$;'6!,;&7D0/8'+4!HT>8E1@S@GeK:]?InO\ÅbÇ•ÖÉßÉ\ÅVX|Pä≠Öeà`3X/8X3"6!. 
+"'  '
+#1"<T<GiFFoE=k=>i<;h=.]10_3@oCDsECqBHvEJuGUÉUIxJPÅRL{MRÇRUÉTS~Q"F"!@ #@!?^<U~ROOQÅONÄMPÅRCwG<n=8j76h3=p8<q9:q75m,/f%5e)'M)	.56 8 7#:%<  4!51D.IQ:nWG†Äk…≤ê“ õ»–óƒ’ë¬‘àæ“{ºœs∫Ãh∏…_¥≈U≥¡O¥¬I¥√F¥¿B≥ø?≤Ω;Ø∏7Ø∂4±ª6±ª6∞∫7Ø∏7±∏7∞µ5¨Ø.™´+Æ≠.∞∞.¥¥0∏∏2∏π1ªπ0º∫3æ∫4¬ª7ø∂3æ∂1¡π2¡ª3≈ø5»æ8∆π6∆∑8…º<∆¡?∆»Cƒ«B∆ÃHƒ F«ÕI»ÀH»ÀF«ÕG –LŒ–QŒÃQœ∆M“»M‘ NŸ—T‹÷Z‹⁄_€€_Ÿ€^ÿ⁄[”÷U”‘T“”S–ÃOœ∆M–ƒNœæJ“øG—Ω@Ã∫4≈≤%«µ#«∂ «∂√≥æØ¬≤ø´π£¬¨≈∞#¿Ø#Ω≠$¿∞)«∫7«æ=≈º=…ªA≈≤:«≠4¿†'ªóøõ!¡ù#ƒ¢'«•*…•+«û*∆ò(«ó)≈í'¬í&Àú2Ã¶;Ãß=—•BŒõ?Àç:Õâ>÷ìLÿèK–z=Ãv9‡íR„öVﬁëMﬂñRËßeÈ≠nÌ∑yÌª~ÔΩÄÚæÑÙ∫àÙ∫ä˘≈ìÓ≈á“∏dÃΩX«¬L¬¬>¡¬8∫º-¥∂'±¥'¥∑,¥¥2¨¢/¶í1≈•Z€≥uÊΩÖÒ»îÒÃò˜œû˜ÀûıπîÙ°Å‰émÎ¢wıºáÌƒÑÏÀÑÈÃÄ‰≈uﬂøl›∫f€ªfÿ∫bŸæcÿæaÿπ^“ØUŒ¢K–§M £HÀ®J∆®H¿¢@øù;øô6¡ó1ªá$∑p∫j∏n∫rºy∫zΩ}æÇºÉ¿å¡ë¿êΩâπÉ	ΩÇ
+ºÅ∫Ç¿éºè∫è∫ä∑Éº¡}ƒy»z»~œà,‡†H„¨RÍΩ`˘◊vÔ÷qÔŸs›vÌ⁄sÏ◊lÔŸlÓŸlÈ’eÈ’eÈ’dÍ◊aË“Z„√LÃ•&Ωì	ƒöƒú¡ôΩì ≈ô û
+”£÷òÕä“ç’ï¬ã –§›º#€æ"◊∏‘µŸº ›≈'ﬂÀ.ﬂœ1⁄ ,‹Ã/„‘9Áÿ?Ê—@ËÃDÍ…H‰¿E„¡F·≈HË÷XÓ„eÎÊfÈÂhÎËsÍÊxÏÂ{ÁﬁwÁ◊wÌÿ{Ì“y“zÒ—z—wÔÕtÓÀqÒŒrÃkÍƒ_‚¡VÍ–_Ô‹fÌ·kË‚hÁ„f„‡_ﬂ‹[€ÿUŸ‘R÷“M‘–K“ÀIÕ√H¿¥Döç/ifGUD_(=`&6`!1[1]4d&:l/Bs<K{IQ|OTzQ@^<4*$!
+		6+J*&J&!G,U+;d:;f;=g??iA:g@6c<@mFBlHAkGLtQKsPCkHEmKMpRGdH3L/>R6XfLlv]FP8?J9@N?4G4=TBWm`OeX?UH]sfÑöéI_SLaXQf_Wlg3F@&:/"7( 7'[rbFZN1"(E)-O,,N)(M$+N&,Q&2Y,GnARwLMiCboQNT8RY:DS26O/5W4'K'7[7JnJ8W7"9)8%"/$8P8B`D@^D=[C;W@-I0=W<EZ3Yd(≥∑jÀÃo–Ãk ºc≈µ^ƒ∫aΩ∑aª∫hçìIP^!I](A]-?\.?[*EYQYèå¿Ø«Øæ¢ ∏û∆©•çA3 ,*1<%5*#%* ,$/$,!) #,* ME |q ≥£≤°≈±∞ú	¨ïöÇõÖñáÄzhg.&9#);%(	
+'%")!#+ "#%"+<4>TH/F6$9("	2F:SvX7d=9h>8l>9m=0d4 N'&R.+U1ZÜbRÄ[\ådVãaLÑWSà\HÄQFÄPA{K<tG=qJBqM;jFTÇ^UÖ]HyJI~J6k76j9@qDFvLJ{NL|LSÉOWÜPDn<3S*#7(5!0<&;D/>B1CG87=/$"5">`E<cDBgH[~`Ö¶áç¨å_ÇZ]ÄXçØäDhB:^85T2 4+$")!#&<'JiJFoG?n@<j<2`24c5>m?<m@IzMEuEM{LLzLVÉXPSTÉWRTRTPyO6Z4!@ #@"(C$6U3XÉVPÄPVÜTPÇQTÖXM}SCrDDtD6f2;m8=r:<s95p.6m,Dt8Bh7'(04685)C&8R5D^AHcDQ^Bn\FûÄh¬™ÜÕ¬î∆ÃêæœàªŒ}∏Ãsµ…fµ»_≤¬U´πGÆπC≤ΩEÆ∫>∞∫=∞ª;≠∏6≠∂5¨µ4≠∑4Æ∑6Ø∏7≥π;≥π;¥π9¥π8µ∏7∑∏6∫∫8∑∑3ºº6ø¿8æø7Ωπ4ª≤/ªÆ,¿≥0√π3¡ª1≈¬5»«9…∆;≈ø7Ω¥1ƒª:«ƒA∆«E∆≈F»«H«ƒC∆√B≈¿@√¿?≈«@ÕœJ—–Q‘ÃP“√L‘√MŸÕS‹“V›’Y÷“U‘”U‘’V‘◊V—÷U—‘Qœ“QÕÀPÕ»P–∆S“≈R—¿LŒ∫A ∂3≈Ø&∆Ø#√Æ≈¥¡≤¡≤¬≥øÆª™æ¨¡∞$¿∞'¡±*ƒ≥/«π6≈∫:≈∑:√±5¿®.Ωù&∂íøõ#¬û&æó ºì¬ô#∆ù' °+≈õ%√î"«ï$»ñ'∆ò)Ã§5Œ•;Ãú6»ê3»Ü2 Ö8“íHŸïNÕ~<«v5◊åI›óQ‹ñP›ôR‰£_‰§dÁ´mÔ≥uÒµwÓ∞uÏ®wÒÆÅ¸¬í¯«ç‚ær‘æ[À¡H«≈<√¬2ºø*ªæ)∫º+∫∏/¥¨0±ù:ƒ®U‚º{ÁæÜÌ≈ëı–úÚ—ûıœûˆ«ôÒ≤Üñq‚ÇZ‰êaˆ¥zÓø{È≈{Ê…y·≈r›Ωh⁄∏a⁄∏aÿπ_ÿª]◊∫\◊¥Xœ®MÃ†GÕ¢F«ü@…£B¬û>ªï4∏ê.æì-√ì/∑Ä∑n∑j∏p∫vº}π|æÇΩÑºÑæà¿é¡ëºâºÜ
+æÜ∫ÇºâΩçªê∏ç∏àµ~∏}∏{πzº}ª}Ω√Ñ…ã(“ö9Ô∫\Ó¿b»iı—sÙ”tÚ—rÚ‘r◊sÌ◊rÌ◊rÍ‘nË”hÏ‘fÌÃ[ÿØ9∏á√èºã ¿í¿ì¬ö«¢–´–¢«ó‘¶⁄Æ”´ ßŒ±Ÿø$⁄¡&ÿø$ÿæ#ﬁƒ)⁄¿%›¿&⁄Ω$‘∑›¬)ËÕ4·¡.ÿ≥&‰∏5Á∫;Ï¿E„ªA€π>·≈HÂ—TÏﬁcÎﬂgÍﬂlÁ›n‰◊n‡—jË÷tÓ’yÔ—yÓŒwÔ—yÔ‘{Ï—xÍÀqÊ≈hÏ≈fÌ√a‰∑RËΩUÌÀ`Ô’dÓ€eÁŸ_ﬂ‘X‹”T◊œP÷ŒO” KœƒH≈∏Füï3ps$P_Ca%=e)9e&7e$2a/]/`2d%:l1Ct=N|KQzNJlG(C$1*'#
+
+#
+&A"+M*)M'$I )N#6_5BmBBmB@mDFpJ?iCGqKMwQJtNFnKLtQRzWJrOInMUxXHgHH_B\lOakPMU>YbQM[L%7'DYHJ_PTj]EZQ_touâàdvzizÅyåìò¨≥ó™∞/?>&7/2I9Çôâ®π≥1E:/K2-O,)K&+N&,Q&2Y,>h:MwIW~RFiAQlI?W7EZ9F^>4Q21S2,P,0T0Ac@,I*"9.& +A*A^BCaE?]C;W>0M18U9D\<O^5os@™•a∆∫n¿∞e¿≤g¬∫qùûX}ÜEJ\ D\(C_,C^)H`&M\RZSR çÇ≈Æ—≤	 ´∏ö ºù¬¶({e3( ;D1B)6'1* 33 GB ld éÉüóèârnYZ ajguYlMc.E+&=##7 2 -!.+7)5A59E9<H<6@5(3%"*#+ ',%'"/%5G9*<,$5# &TiZ7U9"J%2\4,[//`3 P&0^9MyV\àe^ågTÑ^QÑ[NÇ[MÇXMÇXLÑWHÄQHÇRHÄSDyMAtK:jDAqKUÖ]H|K=r:4i17i4>p?J{NArCQÅQQÅMXÑQKpD"= 2+7#3<)<C17;*>@3 #(#:&@eF<eC=eCSvVlãl}ú|oël]Å[aÖ_9_88^7'I&!5&$'2H3KjKDnF:i;2`15c4;j<BqCIzMCtGN~NGuFSÅSSÄUYÜ]WÑ[ZÑ\S|T&H#!@ #= #= *E&>];S|PK{KXàXPQYâ_QÅYIxLQÄR9i7<n9<q9=t:;s4Ax7Jz>)O%	 / 8 #="+H*:W9FcDHgHIhHMlJYhIp^FìtX≥õu«ªâ¡«âªÀÇ¥»s≤«j±∆a≤√YØ¿PØºJ≠∏BÆ∑@≠∑=Øπ>∞∫=∞π:≥º;≥º;≥º;≥º;∏æ@∏æ@ª¡Cª¿@∑º<∏ª:æø=ºº:ª∏7ºπ6ºº6¿æ7√º8º≤/∏©(¬≥2∆º6∆¿6…»:» ;«»<≈¡9≈æ<…¡B∆√B√øA≈Ω@¡∑;æ¥8¬∑9»ΩAÃ√D” I’ÃM◊…N÷√K“ΩJ◊¬M›œUÿŒR’–R”œQ‘”T’ÿW—÷Uœ‘SŒ”Rœ–QŒ…QÕƒO“≈UœøN…µDÀ∂?…¥5≈Ø(¿´∆± «∂"∆µƒ∞¬Æø™Ω®æ®æ®æß#º•#º•%æ©)øÆ,¿Æ.ø™+ø£(√†(∆ü(À§/¡ò&¿ê"øãªáªâ¡î√ô!√ñ√î ∆î!ƒï#Ã¢2–¶8«ñ/≈ç,«Ö.Ãà7“ïE◊òKÃ9≈v1—âA€óN‹öP‹ôRﬂûZ›úZ·übÎ©lÌ´nÈ£hËúkÎ°tı≥ÉÙΩÖÈΩv€º_ŒøH«ƒ9√√1¡¡+¡¡-æΩ-Ω∂4∫™;√®Q„æxÓƒäÎ¬åÓ…îÙ–úÒÃó«ëøáÌ™uÈä\‡zJ·ÜOˆ¨mÈ∑n‡ªk‡¡n›øi€πb’±Y‘±W‘≥V‘∂VŒ∞Nœ®I»ù?«ö= ù@∆ö9ƒö8æñ4πè+∂å&æë*æà$¥u¥i∑j∂rπzª~∫~ªÇºÉºÖΩâ¡ëøèºàæàºÑ	∑Åªâªé∫è∑ä∏Ü∏Å
+∑∑|∏Ä∫Ç	πÉ	ªÑæÖ¿Ü¿Öœï1ﬁ§AÍ≤SÌ∂\Ï∂^ÒªcÌªbÔ√jÛÃoÚœsÔÕlÎ»dÓ…_Ô≈W’¶2∞z ªÖπÖ √í≈õ	¬ö»£ÃßŒ¶∆û	Õ•”∞’∂“µœ∂‘Ω!◊√&’¡$’º!›√(–±◊µÊƒ-ﬂΩ&ÿª"‡√*„≈/ﬂº*ﬁ∑,◊´(„∂7ÌΩAÏªDÓ¬IÁ«NÈ—W„œV‚—[Ë€hÌ·qÏ‡rÏﬂvÍÿvÁ–rÈœrÍœtÓ÷|Û€Å◊}ÌœuÏ…mÂº`‹´OﬂÆO‡∂R€∏PŸ∫N€¡R›∆Tﬁ W’∆Q–ƒN«ªE¡µG•õ:vu"Xg$If,?f-;h-6d&3d"2c!3d"2e#7i*;m0<m5DrAMxJRwN9W5 4--!	0B\9.N'.P+*N('L!*O$;`7=c<:d<FsLR|XNxTLuSFoMKsQRzXSz[NsTOwUW]SxWNoPYrUXkOIS:AI2P[JHVG%7':O>G\MF\PNe_cxyê°©ÖìûhvÉm}äåû¨≠¿«est.=6[p_oÜtÄîâ;QD1N20O-+M(.Q)/R*;`5GpDMwIXSLrIImIEgFFcD=Z;4Q2.M-/Q.-O,FeC*G("9.&/8R7@^B<]@9W;3P43P4F_BL_AQ[8[Z*ke+~v7É~:yz4\cJZ>VE`)F`#N_px%}| {sm^ Ür «™‘¥	—±√¢ ¥î πú´é&A/ KHOT==7545,/
+%)EKjo,cfUZ KR U_ O\H[PjOmGf"Aa",(&*%$,(0!&1!'2" +"'&.%-'.&/%2/>)(5!>J4"+")!"' "2%czf1**N*6_7AnEPUUÖ_QÉ]PÇ\OÅ[M}WPÄZWâcOÇYH}SEzNKÄRJÄOAwFH|LFzL?rG;nEI|QH~J:q86i.3d,?o;Br@PÄPPÄNTÇQBi<%@ 4#0-6%26'9=.46( ,A.=[A;cA:fB;eABgEUwVsír~†{Z~XClD7`62]05Y3&=#
+
+$"3!+C)IkH>i>6f65e5=l>BqEHwKHuLP}RKzLRÇRO}OP{P\Ö][ÅZ?c=6X5 ;";": 'A$*G(/Q,=c:P~PWÜZRÇX^éhWáaM|RRÅU?m>?o;At<=t:=u6Cy;TÑJ3W)
+!&#;#7T8A^@GeCKiGLiJMjLKhI[hLwaIòvZ∏°wƒªÑº√Ä≤√u∞¬l±¬d±¡^∞øV≥¿T∞ºLØπF±ºD≥æD¥æC≤∫@≤ª>≥º=∂ø>µæ?±∫;µº;∂ª;≥∏:≥µ6∑π:∂∑7∑∂7º∏:∂±3¥Ø/π∂1¡Ω8√ª6∫∞-º≠,∆π7«Ω:«¿;«»>∆…>«≈>≈æ:≈º=∆º@ø∑:∑≠1Ω≠3¡Æ5∆≥:À∏?–¡D÷√J€¬L◊πG–Æ@÷¥F‹ºM◊æJŸ…PŸœSŸ’W◊⁄Y”ÿW–◊V—ÿW–’Wœ—TÕÀR–≈QŒºL∆∞C«ØCÀ¥DŒ∏A«≤3≈≥-«∂*…∑%…µ"≈Øº°∏ù∑õºûøúªï¥åµç±â≠ã∏†æß#º§ Ω† ¿û#«†)∆õ*Ωä≈Ö#ºvØg´l≥ÅµãπëΩì¬ì√î «ú+Ã¢2≈ô.∆í-«å.…å3Õî=–ìB∆~2«{0“çB÷íGÿñJ◊óM›öTÿóUﬁú_Ê¢eÁüdÁöbÍòfÍôjÔ•tÌ¨t‰≠l‡∏aœæL∆¬<ƒƒ2¡¡+√√1¿π4¬∞@Ã±V‹∑pÔ≈âÒ√èÏ¡åÌ∆è…êÎæÉÁ∑wÈ≤qÈ§c‰ÖK›v<‡ÑEÔ•^Á¥e›πc‹ºe›æd⁄∑]“≠Rœ™Oœ¨NŒÆK…ßC…û?¬î6¬ë4ƒì4√í3øì0ºí,πê'∏è%Ωé&∏|≤m∂iπo∏wª~ªÅªÅ∫~ªÑæåΩêæëøèΩâ∫ÉπÅΩáºå∫ç∏ãµÖ∂Çµ~µ}∑∏Å
+∑É	∏Ü∏à∑á∏á∫áΩà≈å‘ì+”ä+Õ}&Ÿá5⁄á7⁄ç=Ê¢MÚ∂`Û∫`Ê¨K€†:ÿú,ÕíºÇ∏Ñ øêæî»†¿ò¬ò«ö	…õ
+≈òŒ°–™’∂œ∂”ø ”¡!’¡$÷¬%‘ø$€ƒ)ÿΩ$ÿ∫$ﬂƒ-È–6‰À1‹«,·—6Èÿ@Ë“>€ø0‚∑4Ÿ£'›†+Ï≥?Ó¡LÌ RÓ—YÍ‘ZËÿ_ËﬁeÈ‰lÍÁrÎ„tÎﬂsÎŸsÈ’rÊ“qË‘uÓ◊yŸ{Ó◊yÈœr‰≈jÊ√gÂ¬dﬂª]Ÿ≤S“´L”ØN”≥P’∫S–∫Tƒ∞M•ó>uv*Ve$He-Bi4>i3<i07d)5e'5g(8k)9k,As6Gv?GvBJvEFpBHl@=X5**&(6P)@b0eáU/S#.S*+Q*'N"+N$"@"A1V4QzXRy\FmRCiPFlSQt\Sy`Pv_Sy`YÄeT{^QxYVy[[t^?Q;CM5<D-7B1<J9,>.,A0>UCKcVcywráåú¨π•±økuÅjtÄ}äìçö†\hf2@36I5AW@<U?3O60O/1Q,0P+1Q,)G%5S/JoFFmAVSKtJFkIAfE@cC9[:4S30O/0O-5T2FeC/J+#;!0,-%('!	 7=Z<>_@:]=5V94R6-J,B\?G^BCV:CR1?L!JY"SbVdN_CX@WMd Whåã!•ô†ãßåû{öw ¡†’µ÷¥
+…© Ωù ≤í∂îuW Åkàtáo_I M= KA//
+"3>N\`tLd4M E_PlC`?`Bb<Y;U+&""!'#)!$"("(,2$4;+8?-7?*8A,1='-7<F. ,&2%&(##*"7L;WpZ'6@d@:c;?lAEuKMÄWPÖ[I~T;pFH{ROYM}WNÅXQÑYKÄRCwGG{JMÅPH|K@tDEyIDxJDxH?v?5m02d'0b%=n7Cs?L|HP~MHrD @4"1%0-6%.2#;=/(**-"0H2HiJGoJ<iB;hA:b=DgFfàe}°{héeWÄT2]04_13W1+
+
+	%-,B+4Q3BfB=f<5`2CnAHqGAjBNvQIoJVWDoDQ|QQzR,R+MqM@b?"A!!>77&@#)F(-L*+O)7]4S~STÉYVÜ^_çh[âdQÄVP}RJxIJzHCv>?u;@x;Gz?@l75X.%&41K2:X<<^=Ba?Cb@DcCMjLRoQ_iN~fN•Çdø™}¬ºÇª¬~≥¡r≤¬jØæa´∂V∞ªU∞ºP≤ºL≤ºI¥øG¥øE≥ΩB±π?∞∏>≤ª<∂ø>∑¿A∂ø>π¿?∫ø?πæ@ºæ?ºø>ºΩ=ªº:ææ<¡æ=¿Ω:√¿;≈¡;∆æ9≈ª7√π6ƒ∫7√∫7»¡=…«@∆√>¬ª9µ¨-Ω±7ƒ∏>…æB…π?À∞;Œ≠<‘∞@ÿ≤E◊±D”®?Õô6¬ä)Œò4›ÆFÿ∂H’ºH⁄ Q‹“Vÿ◊X◊⁄Y”⁄Y—◊Yœ’Wœ—VŒÃU…¬N¬µEæ©<≈≠AÀ±C ≥CÀ∂?À∑:Ãπ6Àπ/∆≥&ø®πû∫ö¡ú√õΩë±Ä	¨{∞~≥É±Ñ≥ä∫óªùæùºôºîæëºà≠rßcßaØjæÅ¬ï æöπñ¥éµãªé¿ñ ∆õ*»ù-≈î+ƒé*ƒå-»ë6 é6√.ƒ{.–ã>–ç?œç?’ìG÷ìLÿïQﬁù[‚°a‰ù]Êó\‚è[„ê^ÔülËüh‡õ`‚Æc◊ªWÃ¿H«¿<≈ø7≈æ:∆∑@Õ≥T›∏jÁª|Ú¡âÌ∫ÉÈ∂ÈªÍΩ|‰≥pﬂ´b‰™`Í¢XﬁÅ>“l*Ÿz6ÊòM‰∞\Ÿ¥YŸ∂Z⁄πZ⁄∂V“ÆN–©JŒ®G ©B≈ü:ƒñ4¡è0¡å.¬ç-øç,πã)πé(∫è'Ωé&∑Å∑r∂kµhªrº}ºÉªÉ∫Çµ~
+ªá¿êΩë∫çæçΩÜπÄπÅ
+∫ÜπâπâµÉ±}¥}Øx≥z¥|∑ÄµÅ	∂Ü
+∂â
+¥áµà∂â
+∫à¿àƒÅΩm
+∑^æ_∆gæe∆tÃÖ+œä-»Ä≈|¿v	¬}æÉΩâøëªí√üæò∫ê ¿ì¬ï√ô≈õ	√õÀ©“µ“π–πŒ∫‘¿#ÿ≈)‹…-Ÿ¡)◊æ&ﬁ≈-„ 2‚…/Ê—6È‹@Î‚GÍ·FÍŸEÓœC›≤/÷†$ﬂ´3‹≤:⁄∂>‡¿G‚ƒLÂÀTÁ‘[Ê‹aÊ‚g‰ﬂi‰›iË‹nÈÿpÈ◊sÎ◊vÁ”t„œpÎ÷yÈ‘yÁ“wÈ–vÁ…s‹πeŸ∞^◊≠[œ•SƒûK¡°Læ•Q£íDsp+Xf+Mh5Fj:?i9<h34c,8e.8h.8j+:l-:l/?q6Et@M{JN|MOyKJoD0K* 
+$<gâVS{=rô`,R.S**P)%L SwK)E5=_>KpQIkRNoZZ{jmç~mçÄYyn^}uoêÖ]~mUw_Y}cSs[B[H,=+QZEEM6.:&%4!!2 %7'4K9Xpce{x~ëó§≤Ω†™∂LU^R[`VacS_]guhAR?4H/3L.2O01P.2R-2Q/2O0)F(&@%.H-5T41U1MsLHqICkHCkI=bA9\;2T30O-0O-4S1:W80J-$<"6&@%7P3;O4>P6FV<7K0,E(.M.=^?;^>5V90N20M/?\>D^C?W7BW.9LPaeuwÉ!Åå&vÅ!^kWcjp∞§,µüæ¢¡û∑ê™Å ≤ç ’≤÷¥
+Õ≠¬†∫ò∂í
+®Ö°û{ùwïqâkzgVL85-+ 31
+ ,7JLiUv:\EeDcEc4S8W;V;T/+   ##%*+#79.?A3;?.,3!&-05!8@) .?O5'&%0(UlX8U9(5JsIEuEBsD<p@BvHF{OJSKÄTExMCvMI|SQÑ[LTH|NINE{IAwE>t@BvE?sB@tCCxD=t:0f(+_,^3f-?r:IzCIsC*J!!:,+%0-6%.5%-1#!03*"(*%<"FeEAjB@mD9f=9f=9a<MsNdäcdã_XÇT8d33^0)K&&	#,9(8N7:Y:>_@;a<0V-&K Dd?%C!7T5A^@1N/YxV ?PoO6U5 =)C&#="873 :*I).P-/S-1W.3\49d9UÇWZâ]]äa\â`XÖ\XÖZO}OQÅQHzE>s;Cy?QÇK#J)
+(%;&5O67U97Z:9^=9^<CfEFiIHgHMhIgpS}cJ¶Éeæ¨~¡ºÇº√¥¬u∞æi≠∫`´µUÆ¥P∞∑M≥πK∂ΩM∂øJµøE¥æC≥ΩB≥Ω@µ¿>µ¿=µ¿>∑¬@∏¡@º√Aª¬Aæ√Cª¿?º¬>¿∆@¡«A≈…A∆»Aƒ¬;¿º6√Ω5…√;À≈=Ã∆>»ø<»ø<≈æ<«æ?¬∂<æØ8≈¥>ÃªE–ΩE”∫D’¨@÷¢=‘ó:–à3Ã{,–x.’x2“|/ÿì8›©C·¡PﬁÀR›œT›’XŸ’W”‘T”’X–‘YÕ—XÃÀUÃ¬QΩØBæ≠A«µIÃ∑JÕºJÀ∫FÀªAÃΩ@Ãª9ƒ∞-∫¢Ω†∆•$»°"√ïøà≤v©n µ}µÉµà	µà	≥á
+≤Ü	∏åΩè∏áæÜ∂y£d £d ¥z∫Ñæç√õ!¬§"¬ß"ƒ©$Ωüµí∞à∑äøíƒñ&ƒî(ƒè'ƒç)ƒå+∆ã/¬~)¬{+…Ñ7Õä<Ãâ;Œã=Õâ@”êIŸöS€úWﬂöU›íQﬁâR€ÉQÍîaﬂåX”ÇM·ù`ﬁ¥h‘ªaÕ∫T πMÃπR ≤R’±c·¥qÂ≤sÎ∞tÊ®k‚•f‰´fÂØe„Øc‹ßW‹¢P·öJ‹Ä7–k%Õh"‹â=ﬁßM’ØN‘∞O÷≤Q’≤N–™GÕ•E»¢?ƒü7√ô3æå+ªÖ%øâ)¡å,ªâ(µá%∂ã%∏à"∏~≤o∂hπg≥f∑rªÄºà∫à∑Ö∑Üªçæê∫å∏ÜªÑ∏∂z∑Ä∫Ü∏ÑµÅ	≤{¥{≤y±x≥z¥{≥z≥|≥Å∞Éµà∂ä∂äπäπÜπ}¥jÆZ ∑`ƒm¥a∑iµlπr
+∏næq	∑e ∫n º|∫Ñ ºçªí¡ù∆§√ü	∆¢ ® ´»§∑í ºîŒ©–¨Ã≠Œµ”æ#◊«)€Õ/‹Õ2ÿ≈+÷ª"⁄ª#Ÿ∫"„»1Î⁄BÍ·FÊ·EÊﬂFË›GÎŸI‰ A‚∆AÊÀJ‡ƒG◊¥<’≠;€∞@‡∫KÁÃWË◊aÂ‹c‰€fﬁ—_‚—eÊ’mÎ◊tÍ÷uÈ“uÁŒt‚ r‚Œw„œy‚…y⁄ºsœ≠e»£]√úWºóS±íQôÖHur;_m<Lg:@e9@g:?i;>j7=i4:i29i/:j,7g)<l2Bq:CsAFuGN}QS}UW{W3M0!	-JbâPcçNcàT0Q$.R,-S,$KoïfA]44'B#9S:Wp[XpbZtiqäÜò∞≤xèïxëòó∞¥hÅ{To`Vsa9TA*A1%3$AI4[`J4<%,8$(+&;,F\OWlgoÅÅâóòlvx-76%0*(5+M^L[mSQfG9R22P.1Q,1T,2R-2O0+E,'@-(@2/G9.I60N6>_@8];FkIBjG<a?2X3.R,*N(-Q+3U2.K-(B'!> *G)5T5B_@EY=?R6J]AOcGIfJ8V<4U:@^B9W=3P4-J,>[=B]>E\0HYclää§ü™¢ßü£öèÜ{t	umñÖöÖø©≈´ƒ°	ªì ÆÖ  £◊≤œØ¿û ∫ò∫ï±ã©Ç¶|¢wüuöuíuÜp~náx}p!D8# ! +>DbdÜ0NmGa@TAU9S4N>WD[62+)%&% %$12,991==3?A459++- 02%13%/6$'5 /*$2#!.%*:/`yc#B#6U6[[RÅSPÖQLÇPINKQDwL@uIG|POÇWTá\SÜ]K~SGzOI~PE{I>t@;q=>s=?t@>s=>s=<r8:r33j'/c!)],b&?r9>o8,V&*I *B"*<"&5'4 ,8$)2%,!&.!(0!.=(-F(7Y4:c99g99h:8e:8b::c;DmCQzNCo>6b12\.6V1'
+
+
+(6I5DaCDgF2U58[:0S+!A#< 3#9"*B(/H+(#: 6 8#: $;!537&@#*I),N+/Q,0T.2V04Z3X~W[Ñ\QzR[Ñ\]Ü\\á\TRUÖUPÇOAv@DyAP~M:\7	#0+C+6S75V76[:7_<9a><a?=b@KmLXsR_hIy_D¶Écø≠æºÅ∂¿{≤¿sØΩh≠∫`±ª[µªW∂ΩS∏æP∏øMµºH∂¿F∏¬Gπ√Fª∆F∫√Bº∆CΩ»FΩ»Fæ«FªƒCæ≈D¬…G√ H√ F√ÀDƒÃCƒÀA¡≈<æø7¬æ8≈¡9»ƒ<√ø7Ωπ3ø∂3Ω≤2≈µ; ∑?Õ≥BŒ∞BŒ¨@’∞E”™@—†: ã.¡z"Àz)œt+“j+–f(—j(Ãp%“ã1„ÆHÊ¬R⁄ƒM‘∆Kÿ–S◊”U“”T——W””[œŒZÃ∆V«ºP∆πPŒ¿UÃæQ…ºJÃøLœ¿IÕΩD»µ<∆∞6ƒ´-«©-Àß,∆û$æíπá∏}	µx∂{ºÜ≥Ü≤ä≠Ç´~¨y¨uØv®l ¶g •f ≥u¥zªà∫ç≥ç∂ò∑üµù¥ò´ç	ºõ∏ï±â≥áπåæè≈í%≈ê&¡ä%¬à'√Ç(øx&ƒÄ/…Ü7«Ç4ƒ1ÀÉ9œãB–êH”ìKŸïN€êMŸÑK’{F‹ÇM⁄ÄLÃr@ÿãU‡™l”≠f∆•T»™Tœ∞] ¶X÷©eﬁ´jﬂ£d‡°^ﬁôVŸïNﬁûT‚©Xﬁ™VŸ£MŸõF€ê=÷x0«`∆]◊Ä3ÿ†C–©DÕßBÕßBÕßB»°<«ù;ƒö6øò1Ωí,∏Ç"±y∑Å!ªÜ&µÉ$πà)∏à&∂Ä ≤o≤d∏c∂dµiπwªÇ∑Ö∑ä∂â∏ã∫éªçµÇµ~
+µ|	¥x∂z
+∑Ä∏Å∑~±xµy∂zµ|	¥{≤y∞w±x¥}	≤~¥Ç∑á∑ã∏åµâ∂Ñ∂|πq¥e ∑c æj∑h∂l∑o∫r∏n∏i ±[ ∂c ∫q º ¿èºî¬û¬£
+¬°«® ∞Ã≤ÃØ ®»£∆°»£√°
+Œ≥”º —Ω ’√%⁄Ã.›œ1€ƒ)÷ª$⁄º&ﬁƒ/ﬂÀ6·”<Â‡FÊÊJËÁNÂ·JÊ‹IÍ›PÏ‡XÎ⁄XÍ—SÊ∆OﬂµE‹∞C‘Ø=Â≈TÔ’dÍ”cË…_Í eËÀg‰»g‚≈gË…oË»qÂ…u‚Ãwﬁ…z÷æv“µs…©l√†føúdπöc®é[rh7R]2Mh?EjA@i?BkABk?=i8:i5;j4:i2;k/9i-=j3@o9EuEGvHLyNR|TU{V:T7#	'AAf2WÅBoò\VxF2S(/Q,+Q*&P hé]Kk<726(B'%>)#>/%?6-BEbväù¨Üö•J^];PGH`R+B2(:."0#)4#CL9)4$@K=6B6"/%#3&$8,<PG[ld]leKXO$1'(6)"3!0C-\tT<V33Q-2R-/R*1T,2Q/&C'+C5E\VTjhZopG]Z8RG$?,(F,DeF-P/4W63W3/S-0T.5W44S3&C%'D&'F&+M,;]<EdEHaDE\@D[>IbEKiOGgO=[C5S99U<3P4-J,9T3;U.G\!|Ö(õõ!•òº©Ω©
+∞ú ™îõÖ çy Äl }g {f îÇ ∫®≈´«•∂êµç –¨Ã™
+ºõªò∏ë≥â≠Ç©{•v £vûuñs ö}óóÅê{lY2' !# ,<@[Po!Pl!AXBT8K:S3MPi%D[(L&G#=3
+	&%!,+'/+(B>;DC>GG??B736+*+#./',.#$(!-)6")!/ 0"@WE]z^6X7'I(U~VPÑSD}HD}JF~ONÉWSà^VãaVãaSÜ]RÇZN~TPÉXRÜVKÅOCyGAwC@u=At<Bu<9o58n03k*2k'-f")`)`3i->q9$T #M'J .J$+D$*A$+;!*8)5%1$/%2!(5#CZ>JjEBk?5c43c35e52b28f83^10Y-0Z,2]/3^04[.&D 
+	
+7H6>X=AbCGjI1T3-O,)G#8,!%//,(&*!4&=#(A$"968!:(A!0K*2P,0N*3Q/,I*D^AB_AQpPXzWQuO^Ñ[UÄUUÉUQÅOGyDI{FEq@+K&6,F+4Q57V78Z98];:`;8^7?e>IoHMqKOmGZdAÄgI¨âiº™|ΩªÄª≈Äπ«xπ…q∑∆i∫∆bª∆]∫∆Xπ∆TªƒOªƒMæ∆MΩ≈KæƒJªøDªΩ@¿≈E¿…H√ÃK¡ Iª¬Aª¬A¡»FƒŒK¬ÃG∆ÃF∆ÃDƒ»?√«>√ƒ<ƒ¬;≈¡;…≈?ƒ¿;¬π6√∂6»∂:Œ∑C“≤C◊¨Cÿ¢>‘ï8ÃÇ-»u'≈j!»j"—p)Ÿ{3⁄y4“h*”m+‘~1⁄ì;„ßGÂ±Kÿ¨A”≤A’¿K◊ÕT’‘V‘‘X“–Y– X»¿S…¡VŒ≈\œ»^Õ…]Ã…XÃ≈QÕ¬LÀ∫D¬´7ø¶2À≠;ÕÆ:À¶1…ú'æã∏Ü∏Ñºàªâ¥á∏ê∑í¥è
+≤ä¥É
+¥xÆk©d ¢] ¢d Øz∑âπç≥áß~ ±è
+Æë	≤ñ∞í¶Ä†{ ∑ñ∞ì±è
+≥é≤â±Ö∫ã¬ê!√é$¬ã&≈Ü'πxæz'«É2ƒ}-æw)ƒz/ Ç8…Ö<Ãà?“äB“ÖA÷ÄC”x?’v>’v@ j7—~HŸùa…òV∑àB¡íL ùY…öVœöT“óQ’íL÷êJÿêF⁄íF⁄õK€°MŸ£K‘ùC—è8‘É1Œi%¿R¿T“w.–ó= †<«†9≈û7≈õ5¬ó1øë/ªç+∑å&πâ%∂Ä ≥{¥} µÄ"≤Ä!∑Ñ(∑Ç&∞sÆ`≤]∑b∑fµp∫|∏É¥ÑµàµãµãµàµÇµ}¥x
+µw
+µyµ|µ~
+¥{≥w≥u≤t≥wµ|¥|≥|Øx≤y≥z≤{≤|∂Éπàπä±Ç ≥} µy ∫t∑j µ^ ∫cªl∂l¥l ªt∫r≥f µ^ µ[ Ωg ¿w√ç¬ö¬ü¿ü¡ûƒ£»´≈´«Ø ∞…Ø…¨ÃØ»´ÃØ‘∑Œ±«≠ÿ∆(€Õ.›Œ3›–6‹Õ6ﬁÕ9›»7⁄»6‰€BËÂJÁËNÂÊMÂ·L‰ﬂOËÂVÍÈ]ÈÂ]Èﬂ\„ŒQÿ∑C”®8‡ØFÌºV‚≠M‹°G·•MË≤ZËπ_Ê∏`ﬁ≤[€≥^Ê¡pÁ |ﬂ√z€º|’µ|»ßrΩùlπök≠óhäRNT(<S)>a7IoFGpFDmC@i??j<?n:?n:9j3:k49j3:i3@o;FtEGuGItGHqEMtH:Z51
+ !(
+?a.XÇCgëRgéUDi6/S'-R)+Q(.X*jí`gâW)I!B"B9]1MpH0Q4,L72NB<URäûßhzÑ.BC0E>MaV:L@-=3/$-"/%CSRÜîïwÅ.74$1'/"/"BTFVgWTeS(9'!2 $9&!9#4N33P1/Q./Q,-O*0O-+H,-sããáû¶ò´πúØæÉï£vâè9LF0!/D1-'D&4S3,K+8W7=\=1N0$? )F'2V22W58[;DeHB`F?]CB`DDbHDdLDdMB_I7S<3M23M0,I+.I&;S#Vd≤≤:∏¨¥¢ª£¡™∫†™é §á ô} çr Ñj {e h[ uk õêæ™'¡°´Ü ∑ì≈§ªö∑ì	¥äØÉ ≠Ä™|®y¢wõsót óy ô} öÅñ}án
+bO 5/ 6>=MAWKbJc!=R0G0M1ONg&F[5`(.W+P)E.$ #'(#!!51.52-<<4EG<<?47:1()#('")*$""+0;*))7(1TpYDeF&L'8`;ApFG}LD}JGNNÉUOÑZMÇXLÅWPÖ[Xã`Xã`SáYMÅSG{KAwF=vC@vDAv@>q9At<;q7;s4?w6:s/6o+3j'+a#2h.Bt?FvD6a3,S&-P&/M)0I)1C)0>'4@,.7&''(5#6M3<`:9g88f73c11a/2b03a21_0,W)*U'-X*4]13X-*		
+	
+&F\EJiJEhH:]<4V59X6/J' 8''&**)("'#4!'>$/H+$=9"=956!<3&=!%8"&';Q:5N1E`?]}XKmHYVWÇTRÄOM{JJqD8*A$/I,/N.4V38\88^79_8=b9Af=Ch?KnDJi@Zd?åqTµír¡ØÅ¿æÉª≈Ä∑»x∫ r∏«h∫∆bª»^ª…Zº…Wø»S¿»Q¡…P¡«M¬∆M¬ƒI¬¬Fƒ∆G∆»K√»J¬«I¿≈G¬«G√»G¬…G¬«F¬√Aøø;øø;ƒƒ>∆¬=≈º;…º<Œ∫?–∑@“µ@‘Æ?’©@”û>—î9∆~)¿m√iÀi"”g'œ^"’d(‚t5Â~<ﬂz6”n*·Ö:Ï¢KÈ≠M‹•A‘£<“¶;ÿ∂H€»R’ÃS“–U——WÀ∆Q∆æOÀ√VŒ∆[œ»^Õ…^—œbŒ \Õ√R«∏E¬¨<«¨;À©=À•8≈ù.ªí ∂áπàøçæéΩêºëºìΩñªï∏ê∞É©w ¶j §d ¨i ≥sµ~	≥Ü	≤ã≠àØÑØÑ∞ã∞é≤ê
+¨á¢y ¨Ö∞ê	£à •à ≠ã¥ç
+∞á±àµàªå¿å¬ã$ΩÅ∑v¿|'√|*ºs$Ωt'¡w,¡y/√{1 Ä5…{3Õu5–s6Ãn1 j0¡b*∆q8ÕåLøàE≤y4ΩÑA¡äI≈äH…âB Ü= Ç:œÖ:‘ã<ÿë?÷òCŸ†G◊†F–ï;ÃÜ.Œy( c ªJ∏K…n' è5√ô3¡ò/Ωî+ªí)ºë+∏ä(∑á%≥Ü!±Å∞{±z≥{ÆwØzµ~$¥x"Æg≠Z≥[µbµi¥qµy≥~Ø±É≥à∂â±Ç±y±w∞s	≤u
+≥y≤z≥|±x≥u∞r∞t∞v±yØz∞{±|≥|≥z≥w®m ∑∑Å¥É∞ ≥}µz∑t≤e ±Z ØX ∂gØe ¨a ∑nªtπoºe¥W ≤S πc √É»ó√ôøö¿ù√•	»´≈≠≈≠»∞…±…±Õµœ∑À±ÃØ”¥…Ø—Ω÷»)‹“5ﬂ÷;„⁄AÂ◊B‰œ>Â‘@Î‡JÏÁOÏÎSÁÊPÊ·OÂ„RÂÁVÁÍ[ÊÍ_Ê‰]Á›ZÈ—W‰ºJÿ•<‚¶FŸñ?‹è?·ñE‹ïE’îB‹üL‚™W„Æ^ﬁØa◊∞cŸ¥m’ØpÃßp∆¢nøùoªût•ìknlEDS*5T*2Y-=d8DjAEnFFoEBm@<j;>l;Ap<=m9:j6;j6@o;GrDHsFHrDBl>@g87[/,D$$ )0Ip7lôXnó[Pw@7],,Q%,Q(+Q(<e9ÑÆ~nì_Bg3VzLRuK^ÉX`Ñ^]Ä`fàprëÇgÅ~|êôïß≥íò^rsi|xXic+:7$22&88Qdhî•Øô•±pu{6<<#/%)7(&.=N;TgSIZH9L9AVC/H20M11P0/Q.0R-0O-(E&6(@2å¶•ï≠∑åüÆí£µãõ´\mu:JI&$2": 5&@%<Y=A^B0M.2Q1<_>BgFAfG<^C;]D@bI?aH>`G>`H<^F;[D8V>6P5/I,-G*.H#:PXeª∑2¿∞¬¨ø¶¿ß¿§¥ñ ¨ç £Ç öz ìt Ñl l^ VP TR xt	îÖöÅ
+ô}±í∞ç´ÑÆÅ≠}¶x ür óm ëh éj ñt ú £à•ãüÑñ|äsdXTPMSEP?SAXAV4K0L3M:MBQ4d(2_$.Y!+Q*F%:!)($?>98:/?C5BF8-3',/&!"&'"$#)0 9B1/7*4B3!:%]d+U1<kAJzPH|NH}OJQKÄRSÜ[\èdYåaTàZNÉUING}LBxGAuEBvHJQJÇUMÇTMÅQQÖTH|KKÄLD{B=w:>y77p,,c"-`%9k6DvERÑSPÄP/Z,-T(-M(,E'+:%$/+1#"
+$CVBAcB:g<8f84d42`/2a-/],1_.*X')U$+W&2Y,'E! 	$$	*5%I`FVuVKlM>_@9[:2Q/-H%&>*: +9"'5%2&%&)+ 1&=!)D% ?!D#F)M!+O!"C-$ ,<K6UgM1E)^xUOoHY|RKoC6R*.(;0I,4S3?b:=b7=c:=c:@e:Ej?LqFHkAFb:goJânS≤çp¬≠Ä√æÑº«Çπ zª…tπ∆j∫ƒc∏√[∏ƒXª≈Uª¬P∏ΩIΩ¬Lº¡IæƒJø√H¿¬Gªª?¿ªCæπA¡ºD¡øDƒ¬Gƒ≈Fƒ≈Føæ@æ∂:¿∂:∆æA ¡B…ª@ ¥=Œ™:Ãõ2Àë0ÀÖ- w)√f √[«Z!Ã[#Œ[$–_%‹k/›l0’e&›m.‰v7‚v6‹w3Ÿ1ÂóB·†B‘ö9—ó6 ô3”±E€»R÷–T—“S–“U……Q∆¿NÃ∆VŒÀZœÕ\—Õ_—À]”»\œ¡V∆≥J≈ÆDÕ≤GÀ©>¬ñ-Ωå#∏Öºèøó¿ö∫ì¥ç∑é∫èπåªâ¥Ä≥}Æx ™t ©u Æ|∂Ñ∑á¥â∞à∞ä¨Ñ Ø≠}¨Ñ ≤å™Ç ® ©Ñ Æå´é•ä ®ã©â™Ö¨áØç±å
+ØÜ
+¥áºç¡å"ª∑vºu∏pπqΩt%ºu'Ωt'ƒx,√q(¡j%…m,≈k,ƒj+øe'ªj)√Å7πÄ1Øt&∑y.º|4Ωw1¿s-¬r)ƒt+œÇ4ÕÖ1Àà1Œê9“ô@—ï=∆Ü.≈~&…t$≈^±B
+≥I≈m&¬á-ªê*∑é%µå"¥ã"≥à ≤Ö ±Ñ≠Æ~Øz≠v™q©p¨v≤x$∞k©[©UØ[∞bØgØmØr¨r©s≠|∞Å±Ä™uØq≠o
+≠r
+±xØw
+Øw∞x	ÆtØrÆqØu	±y
+Æy∞}
+∞	∞≥≤y∂s•` ±o≤u±{∞} ≤| ≥x≥q ∞f ØW ¨R µb≥c ¨Y ±a ∂m∏p∫f∂X ØI ±O æn »á	ƒè√ó¡û≈®»Æ«Æƒ™√¶
+ƒ™»∞ ≥Õ∂ÕµÀ≤◊æ$’æ#–¿"”≈&ÿŒ/ÿŒ/·‘8Áÿ=‡œ7Á÷@ÏﬁGÏ‚LÂUÊﬁO„⁄MÊ‡T‰„WÂÊ\‰‚[Â·\Ê›ZÈ⁄[Ì’[„ΩN÷ü;ÿí:„ïCÎöK„ëEÿä?ŸçAŸëE€ñK‚§Y„∞a‚¥g⁄≠iÃ£cƒúa∫ñbªúpôäcW\4=T*6Z,1[-1[-4]1@i?BkCAj@?j=Al>?k:>m9<l8;k7<l:@n?DoABl>=g7;c16Z*2N(&9
+*B VGx¶fvùdPwB.T%-R'+P'*N(V|Sä±Ñhé[jê]yûuvóxùÖmçxmåzfÖvwíçÇöûuàñzãõÜô®´ø ô™≤et{kyÇxÜìiyâdqÑô§∫{Äì14=043$.#+9*+(9'8I6XiWXj\gykUjY5O62O11P.1Q,2R-/H*56)F28THSmjuàéÖñûWim<NN2F;,	
+*('+A*=W>@^B=[?=^?BcFAdF>bF?cI=aG<`F@bIBdL=`J;^H6WB2R;0L3.H+(B%+E"5O N_∞Ø0ªÆ¿≠¬´æß Ω¶∫ù≥ï ¨ç ¶Ü †~ óxáp]R )- 9E JS `_átãm åg òm ûo úm ïj ìj ín ú{ •à ©é ´í´ï©ì¶è¢äúÖí~Åte_JL<H 8IK]?S4H7J
+BLNU5g,1c&.[",W.S )C841;;3=@5;A3:C2*7#*5$$()$ %& 7@/9D35@2,=-5S9PyW:j@DzIJÇQOáVSãZIÅPBwIG|NH|NDxJCwIG{MKÅPVå[TäYTâ[RÖZWäaPÖ[QÜZVâ^I}ORÜVLÄOJKE|B5m.,c"-a#0a*DtDJyMVáZOÄQP~P/X,.P+'A$)&)/#	
+AO@JiJBkC<i>7f84b10_+/],,[',['$S*V#0U):$(!/"0(6%'3%'3%9D3UdONgJJiJDcD?^>9W59W53M*%=/ .*6*6 (#$',,!8'E#*M%'N!'N(S2]'7_*-S$2#$+1#,5"".9I/6K,6N,,D 2.-="<U7<\7RvJQxI@j<<f8Dk?GlACh=Gj@Gc;qxVälRØäm√ÆÉ√æÜΩ«ÇΩÀ~ª«s∫ƒk∏¬b∫≈_∫≈\ªƒW∑æN∏ΩIª¿Jª¿H∑øE∫¿DºæCπ∑>∫¥<Ω¥=¡∂Bæ≥?º±;Ω≤<≈∫D¡≤=∆¨=–∞C–∞CÕ®>≈ö4¡ã+Ωz!ºnƒi »b  Y!ÀNÕJ÷N&€S+’R&Ÿ[)ﬂf1›f,‹h+›m.€m.Ÿm-÷s/⁄à6€ò=ﬂ©E’•?œü;⁄≥J‹∆V◊ŒU—“SÕ“RÃ–UÃÕUÕ WŒÀZ–Œ]—œ^“Ã^“«[ÀΩT«¥MÃ≥O—¥PÕ¨E¬õ4ƒò/≈ï)ƒî%«ù'¬†%æü"∫ó¿ô¬ñæëµÉ
+•q ®q ±{≥Ä∏á∏å	¥å≥ãÆà Æà ±ã≥ãÆÉßu ≠{ ±ÑÆÉ¶y ß ≠ã¨è≠í≠í®ç ¶â ¢Ä ´âÆë	¶â•É ¥ë≥ê∑ê∫ä∂|µtªv∏r∫v#ªt"∑p Ωq#ºm"ªg¡j%¬m*æi&Ωj(πl&º{)≥z!´m¥s∫u'∂l!∏f∫fæj!«u)ƒy&Ωz#√É,∆à1¬Ç*ªx!Ωq¬kªUß<≥O√o)ΩÇ(≥Ü!¥á ≤á∞Ö¨Å´}´{©x™y¨yßqßp™qÆt"´l£YßX©Z´^©aßd®j£j¢k°n¶u™y™x®p´n¨m≠s≠w¨x≠w
+¨t™r´s©s´w≠{´|≠ÆÄÆÄ¥ÇÆu¨g ¢X £Y ≤n∂{≥}±{Øt ±o∞g ´V ØW ∞] µe≠Z ´[ ¥k∂o∂g ∂_ ºX∑S ≥Z ¬u¿Å ¬í«¢∆©«≠«Æ≈®¿£	∆©…±…≤«≥…µ»¥œ∫’¬&ÿ +⁄–0‹‘3Ÿœ/◊À+ﬂ—2·—6Á”<Í÷AÂ–?ÎÿMËÿOÂŸQË‡YÊ‚Z‰‡Z‰›YÂ‹[ﬂ‘T⁄ÀN‚ÃRÔŒ[ÍæUŸ°B—ã3‚ïCÈñJ‰êGÁïK‰ïJ◊â?“ä>“ïEÿ†S÷†X’£^”¶e¬ö_∑ïgåzRLT-2N%5[,2\,4^.0Z,6_3EnDClD?h>>h:@l;?n:;k79i58g3;j6Am::e09a-8_*(I,F!(8$	&@YÄGmöYsöaOvA0W*/V*,R+'M&qónéµâxûomígÖ¶ãÄüèyíåtçäsêãjáÉjÇÑrÜèvâóh{åVk~í£±¡—¶≥ƒÄçû|âútÄòt~ó|ÇòDGX''/"&%"*'3%)7(IWF:K8CVBEZKG^N:Q=4N32O00N*/M)1J*3//H2=ZD:WC2N?8MH=PL7LE3I=/D5/!#!! 38R9<Z@>_D?aFAaI<\D<`F=aG=aG=aG<_G=`H?bL9\F3V@-O7,J0&C%$? #=.I BVàåµÆπ´Ω´¿´Ω®º§∑ù ≤ó ±ì≠é•áò}
+qb6@ DZEZBMf[Éjìqût†qûoút£Å©ã∞ì¥ö∑ûµû±úÆòÆò´ï©í§ç	îÅfY RK beckMW;G:H
+R\poyt2c+0b'/\%.Y#4Z',H" 
+)&!61-<;69<3=E6BQ:Ga>2J*(+.''*#7B17D00<.*?,InLJyMOÉSIKGÄKFH>yA7r:?xC;tADyKOÇWTá\Vâ^ZçdTá^Uà_UáaSÖ`PÇ\\åfXà^RÇXZã^NPTÜUL|L-])+^#2d'3b+3a0IvMRÄYGwOVÜ\QÄR:g<-S.,I+ 3!)/#)<T<JlKEoG<j<1a1/_-*Z&(Y")X"$S'S /V)'G"73!4 "8#&<',B-F\E_x[NiJOlMFeEDcCQoMPkHB\73I%.A!'7&4#1!/(!#,-57U13Y*,W"&Q,Y /_#5e':j.7d-0V'7"  &+,*!+-;!6O/<\3YLOwBT~L\àWGqCAj>@j<>c8PlDnuSånT¥èr≈∞Ö√ºÜæ¿∏¿w∂øn∏¬iª∆f∫≈_∫≈\ªƒW∫√P∫¬K∫øGª¡GΩ√IΩ¡HΩΩEΩ∏Bø∂Aø≤?º™:º®8¿´>…≥D—∑IÀ®@Õñ9 Ü1∆y+√o&√g$√a"ƒZ ≈VÕZ$—W&–P#’P%◊M&ŸN'ÿO%÷N$‚`/‰f3⁄^(⁄a(Ÿe*—`$œc%œp,’ä7‹§E’¨C“≤E◊ΩN€«V” S—œVÃ—SÃ“Tœ’Y–‘[“”\”“^’“a‘Œ`—√ZÀπUÃ∫X“ª[“∂U»¶D¡ö5ƒõ2∆†3¬û,ƒ£/æ†&ºû"ø†#¬ö!¬ìæä∑É±¨| ∑á∂ã∏ë∫î∑ë≤å∞ä™Ñ ≠â ≥é¥â≠} ¶t ±≤Ç†s •x ¨Ñ ≠é´ê¨ñ´ï¶ã ßä £Ü ≠ê¨èüÑ ´í±öÆõÆóØë∞á±|∂zπ|!πy"µs±m¥mªo$∏j ∂fΩm(∫k&µk$≤o!¥x ≠ußj≤r∏v ≤n±c≤_∑`∫f∑h∂nªw"∫x"∂s∂n∑hπa≤K§<≥Wºp%∂z"Æ|¨z¨z©y®xßv•r§q¶sßu§u•s©r©iûYúR†VüX†]üaùdõgöjôkúpüs†r¢p°k£j£k®p™u©v®u
+®t®t¶t®yß}©Å¨Ö©Ç™Å∞Ö≤Ç¨s Æi™^ üP µk∑z¥~≤w∞s Æj ∑n™W ¥_¨Y ∑g∞a•Y Øh ∂r∂n∑j ΩgΩc¥V æi »Ñ	¬å∆û»©»´¡ß«™≈®∆©∆Æ ≥ ∂À∑∆≤»¥œø!‘À(ÿ”/€ÿ3◊“.’Ã)›œ0Â“6‰Ã4Á«8„¬7Ë»AÓ÷PÈŸRÎ·[Í„_Âﬁ\Â◊ZÈŸ_Ê”[‘ªE‘≥@Á√SÔ—aÈ…\›ØM”ñ=·îDÁîH·ã@ÂíF‚îIﬂñIÿëCŸñH—éG éH—úX¿íT≠ÖRÑoBLW-/P%/V'0\)3]+6`00Z,7`4BmBDoD@k><j;:j85e1/^*/[&4a(>l.;g(9c$:]%)D 0#
+7Tz?TÅ<hêR@g0/V*/U.*S+&O'uûvã±àÖ®Ä{úà£úÉú£yèúoÖìnÜíáü©ë®∞ç°™zéôoÖìsàôîßéü≥°∞≈åòÆzáövÅï_hy5;G$'."'.&"-+7)N_M<O9NfNC\F3O80L31N00N,3N+1H+!5.26O9@\EA_E9W?1J72J:.I6.G2,A.*$ 62L3:[@>`G>`HAaL<\G7XC6YA<_G:`G6\C7ZB3V>1S;-O7)K2)G+#@" ;!:,F!AU ]iêì¥™∏ßΩ´ª© ª•∫§π£∑†¥õÆì§âáz
+YeQk"Md ?LIC eR ïuúvôlìh öy´é¥ò	πûΩ£º§π°µûÆñÆï™î©íúÖí}hZ dZ îâùñ+ffGK?FcfÜxí}/a&+]"*Y".Y#2X%+J! 52-52-./)-3)?N;QjMNnE4R,#(! &9F4,;("0!F]INvQFxG?t@<s<7q7:u;>y?<w?;v@FLQÜXTá\Vâ`Vâ`YåcVàbVàbVàcRÑ_]èiXà`Xá]^çaRÅSZâ[DrCK(W#2a*8g09e2<g:WÉ_FtPP~YGwOSÑWHwK*S++M,+A*!#.?-MgLImIBmB;i;2b2.`+*[$(W!&R)S!(O#>!; :!!;" <#(F,?\@MjLMkILjHHgEGfFHgG\zX?Y6+C!9$< 5!6&6'6(6#0)%'-)@#Ff?:d40_()Y+[.`!2f&4k(7k+@r7Dk<"	#((-)2&1 47S+Fj<Ox@S~Fdé^™}©ÅYÇZFoEFkBUqKpuUälR∑ês¬¨É¬ªÖ¿¬Éæ∆}æ«vº∆m∏¬b∑øZ∏øX∫¿T∑ªJ∑∫G∑∏CΩºF√¿M≈æL≈∏H«≤E ≤HÃ¨EÀ£CÕ†C õ?Ãô@ ì9º{'πe∑XªQøP≈Q…P!ÀP$ÀN"—R%—Q"–M’P#ŸR%◊N"◊N"‘P ÷X%‘]#—a"◊k*ﬁw4ﬁ{7‡Ç<Ÿä;ÿùA€≤IŸΩOŸ»T◊ÃV”ŒV“–W“‘Y—’Z”Ÿ]“ÿ^–‘\—–Z‘—^‘Ã_Ã¡WÃ∫V”ø^Ÿ≈f–πY«´J∆§C¡õ6√û4√•3Ω£,√¶0ø°)øõ#øï∏Ü§o ¶m ¥}Ωãºè∏ç
+∑ë∏ó
+∂ñ±ë∞ç ≥è≥è¥ëµé≥Ñ®v Æ| µÖ≠Ä¶{ ÆÜØã¨ç Æî≠î´ï¨ì´ê´é¨ë™è®ë´ô™ú´ü¨üÆú¨ì™Ö©}±Å≥~µ|"¥x ≥r ¥q"∂n"Øe±dµh"≤j"∞oÆu™rßk∞s≤u≠lØe∞`ÆY∞\±b∏m¥p±m∞j∂i≥a≥W≠E¢?∞]¥o!Æu™w§r£r£r£r¢p†nüm†p°t†s üpúhïXêNïSöZô[ó]ì\í`ìeíiíkëlëkïlñlölúmúk°q£s§u§x§y	£z¶ßÉ	©á	´ä	≠å©áßÇ ´Ç¨™s Øo™` üN ∂j
+∑x≤z∞u ±rÆj ∂k´X µ]ØZ µeπk	®\ £W ∂m∑sºv∑j πc ª^ ¥[ ƒy«å
+¬ï ¶ ¨ƒß√§…´ÀÆ«≠À±œ∂Œ∑ ∂«≥»∂—»%÷—+⁄Ÿ1›‹6·‹8‡◊4Êÿ9È—9„æ1Á¿7ÀGı◊U›ZÓ‰`ÓÂb„⁄Y·—WÈ‘]ŸeÍÃ\⁄¥G⁄¥EÁÕ\Ôÿfœd‰∏U◊öA⁄è<‡í@ÂîEﬂíBÂöIﬁïFŸíDÿêF≈Å:ÕéG∆êP•zExc4R_38Y,1X)1[)2\*5_-5_/3^02]0=h=>k@>l>?m>=l8;g22_&/]@n-Iv3Is1Ei,-I'
+	
+
+,Z}E`äHMu73Z#/V*-V.*T,5`5à±áú¡òÉ¶~|öÄà¢°}î¢vàûÖó≠äü∞Ñößç°®ï™Øh|ÖsâñÇó®ú±∆°≥…ù≠ƒäô∞íü≤ajyPYb4<>" !(!(/'(-9+/@-&<%;U:3P4-K/.M..K,.L*6O/1E*-0!7"":"#?&,I-6T80J1-I2-I0,H1*?.&
+*)?(2N56W<5W?5VA2Q?1P>1R=0Q<*M5-P8.T;0V=4WA4V>3T?1S:1R5,K+(C (A8LL\T]
+]_ ßõ∂¶ª©º©∫® ª©∫©∫©π•≥û´îèÑaiViR`UYaYkW c çlÖ_ }[ Çf †Ü ≥öæ§¿ßΩ•∑ü∞óßê§ç£åûÜ ï~ óÉf\ aZ åÅúì*vtHK=CUUzjíw8j-0b%-]#.[$,T/P%&#)01)('"*,'7A6OgORtSKpG-M( &+$% <I7*(D]HRzUGyFG|D>u;=w<:v:5p8?yFKÉTMÖXSà\QÜ\Wâc[éeSÜ[RÖZTÑ^[ãe[çgPÉZPÑV\ç^TÉUVÑV4]1 J+W&3b,:i3?n:5`2UWLxWFsT]ãgCsMK~SPÅT>l>*P)/I."
+	
+'/"6G4JdGFlG@mB9j;/_-,]&*Y#)S!*Q$ B: :< #D'4Y8@eDKnPPoPkÜg<W6HfDC`A3P19V72K++F%-L*,N)3V.6V/5-"2-;"6B*>K1@J15E(D^;LoE?k:4e.2c++]",`"1e'4j,9o1>r25b+3	
+$))/+6(82LKm:Hq9Ju=^âTjìkÑ¨äÉ™çÇ©å|§ÇbÜbWqNqtUêpWΩîx√≠Ñ¬ªÖ¿¬Éª¬|π¬qπ¡kπ¿c∂∫Y∑¥S∫µOΩπNø∏M¿¥H√≤H≈ØI¬¶B√õ<≈ì:«ç9¬0¿r*ªf%º_"æ^"ø\!ªSøM√M»O"ÃS$ŒX( T" Q"—W&÷](◊^'ÕU‘Y⁄]#ÿY"ÿW Ÿ\$÷c$—k#◊Å.‚ñ>·ò<‡û@‚£D€ßB◊≤Gÿ√N◊ÕR‘”U‘‘X“‘W””W“‘Y—’\”◊^”◊_“—[÷œ]–ƒXÕ¿ZŒ¿]◊«eŸ«e”ø\¬™Hƒ®E…¨H≈™A∆Æ@√Æ9ƒ´4≈§0≈ö)∫Å´l¨lØqπÄΩãæëπé∞àµè∏î≤í∞ê ¥ñ∂ò∑ó∂ì¥ä±Ä Ø| ≤É≥âÆÜ ∞ä∞å¨ã ØêÆí™è ¨ë™ë´í´ê©éßê™ò®ú¶úßù
+©û´ü´ù™ô®ì®ã®Ü¨Ö≤Ñ"≤$≤z%≥t$™e©\´^¨b™g¨p´s§i¨q±xØsÆi≠`¨Y¨Z´_≠f´g´g©`Æ`≠V®K¢>
+•H≠c≠qßq£r†t†uùrûrùoôlòkónóp#ëjåaàXâRãTêY!è["âVàWÖWá[åe$âd ÜcÖbÜdáeâhêoïsôvùwùvõu
+ü{°Ç§äßé®ê©ë	ßç©å®àßÇ ¨É´~©v ∞t™e ûO πj∂t≤u Æs Æq ∞n ∞e ≤ZØS ≥Y∑bΩo¥f¢M Ø\ ∏ræ{∫q ∂e øhπ` ∫h »Ç	»î ¢À¨«™≈£∆•À¨…¨»ß»ßÀ±Ã¥À¥ƒ∞Àº÷œ)◊Ÿ0Ÿﬂ5ﬁ·8·‡:ﬂ⁄8ÈŸ>Á«8·ª2Ò Gı‘S‹YÌ·[ÔËcÍ·^›ÀO€¬KÂ W–aÌ«Zÿ≤Eﬂ∫OÏÃ_Ó‘eÏ–cÁ¿Y‹ßGŸò>‡òC·ñC·ñC›ôFﬁöG€ñHÕÖ9 Å<¿ÄBïh1hV$M].?`17],4\*6^*4_*9e24b11_02`2>k@<i@<i>@k=Co:?l3>o.Ft3SÄ?Q{;Qz8@a(3A^.héSCk/0W".U)*S+%P#JuGå≥Üì∑ãtïh_~^yóçê©∞áö©sÜï[ozâû°ñ™®Éóïbu{àúßçü≥¶∏–§¥Õçù∂©∏œô¶∑mwÄ[gg=JC<I?)7*"."07/$,!*5'-;*"5!(@&*I*(J)*L+,K+0K,7N2&:!211G0(@&"?#)F(,J..H/,H1-I0+G0!7*/.D-8T;;[C4V=2T<5U>8XC8YD9ZE?`KDeP=`J:`I>dO@cM>aM;]E9\>3R01N"9NT`ÄÇ!}yuj Ét ®ó∂¢Ω´º©ª™∫¨∫Æ∏©≤§¶óéÖpq ru
+vsvjxdx^ u[ mS aG |d òÅ ¨ì∞ï ∫ù¿¶º£	±õ°åïÄ ñ úÉùÑñ~îÑ[YPRdcom PU<E8EAFcWxd8e,6c,4`+0[&/U$.M$*<"%-&)  (-)JWMYsZNqPMqK6!"--8(*5$4C0,QjUSwS%P"@p<Bu=Ax>;u;D}HJÇQUä^MÇXSà^[êfTâ_Vâ^PÑVNÅVXãbXãbNÅVOÉUTàWUÖUQ|O%N"$K/Y)6b/7f0Ap::h76c8S[FsRQ~_TÅ`N~XLTNÇRQÄR+T*/L.
+
+ #*0$/:*;N8KhJNqPCmE>l=3b.*V#)S!&K =7"@$1T4BjHHrNGqMGjJgÜgHeFFcDCb@5W6/N.*I))F'-L*3Y47a9:c7-T(1//-!-$.0:"<L/OkEGnA@n=5h06i.-a#0d&4h*8l.<r4=t3?q6?d9+	+53@";M'Oi:XyDZÇFEq4Hu:UÅNjîl¶áá´ëÉ¶éé≤ñkåmToNnsSénWπèv¡´Ñø∏Ñ¿¡áº¡~ªæqªΩj∫∂_µÆT∂©M∑ßH∂¶D≥ü<≤ñ5∞ç/∫ë7∑Ö0¥r$≥i πf"∑]ªXΩSøO≈Q"≈Q"»R$…N" P!«MŒV$“](◊d-€h1Ÿf-‘`#‘a €h%Ëv0Ên/Ÿ^"’] ﬁm)‡z/›á2Í•FÂ¨E⁄•=Ãù1ƒû/‘∂D÷∆M‘ŒR”’V—ÿW–÷XŒ‘V—”XŒ–U—“Z‘’^’“_“Ã\»ºNŒ¿W’»bŸÀh÷«b”¡[–∫UÀ≤NÃ≤QÕ¥P µL…µE«≤?√®3∑î ©|	Øu
+≥t
+º~æÖøçΩí∑è∞ä≤å∂íµë¨å µó∂õ∂ò≤í≤ç ¥àØ| ´x ≤Ü±âÆÜ ∞äÆä¨ç≠é ¨ê´è ßå ©é≠í™ç¶ã ßí©ôßõ§ö¢ò¶õßû§õ§úßü™ù™ó¶è™é ¨â#≠Ç$¨z#©n¶b§[†Z°_©q¨w¢i¶m±y"¨t™h´f´]¶X®a¶a¢_£^•[®Y£MûEúC•U¶h†nùqôtñtów ów$ís!çm äl#ák"Ñi$|c!w[vXxU{V!}X#}Z$zV"yU#xW$yX#yZ#y^'w^&u_&wa(xd)ye&}j%Ñq"å{#ïÅ ôÄúÅô{°Ü¢é£ë•î•ì£ê§ç•â®à©Ñ ´Ç´}™wØxÆn°R ∑h	≤n±t¥y≥x≤r±h∏`©I ¥S≥W ªi∏f≠S ØX µm º{Ωz∫s æpΩk ∏f ¡v…è
+ õ∆¢…™«£…¶Ã≠«®√û√õ∆£Õ¨œ≤À≥Àπ”«%ÿ◊/Ÿﬂ5›Â:‡Ê>‚„?ÁﬁAÏ÷D„∆<Ê≈@ÈÀIÍ”QÏﬁYÌÊaÌÈcÌ‡^Á”X‡«QﬁæMÌƒZ‚≥K›ßC„≤LÈ¬YÍ»]Í≈[Ï¬\‡ÆK“ö;÷ï;◊î=›õE€ôE–â7¬y,øp+Æm-Ñ]&[Q EW';\-:`/7_-1Y%4_)6b-9h27f22`/6c8@k@>i>:e7>j7@m4Fv8ZàHbãQ_àL[ÑBJn1:T'$	
+	(>^~MEj7+Q .S*+Q(*T&gë_É©v|°ngåXSvL]~kê≠´Çñ°h|áe}}ê™°|îÑWobh~|í§Æñßª†∞ }çß^ná≥¬◊sÅå`llÄçÑRbUSdTO]P5?4@E>180.9+/=,%8"#;!)F(*I),K)3Q/$=.1/(#: #= 'D&(G((F*-I0,H1,I33O@8OI2AD ).+,B+:V??`EBdK?aHBdKGgP<^F=_GHhQAbM:]G<bM?eP@fQBeQ;^F<_A<\38QWgstôêôãíÄâv âw îÇ ©ñ µ£π™∫Æ
+∑Æ±ß
+®û	öëÑ} ÜÇçÜã~ävÜnÇfx^rY s] ê|ßë
+∑ü	ø•
+ªü ∑ù ¨í Øô£éãv éy ï| òí|ymWXMTCIBG:D3?/;/5	HB\OB)N"/R(/O()G!$='
+ANG[t^NmN2Q2!%-&8+;!'6# 2"^uaLiK>-P(MvJK}JOÜOWãZ^íbNÇT]êe_íg\ëcSàZKÅPUâ[Uâ[Tâ]NÉUXå\SáVUáTP~M%J!"G5\/9e23f.>q99k6FvF3`9P|YO~ZTÉaIxT]çgAtIQÖUNPBmB-O.
+$(. 06(.6'5@0'6#>T?IfJGkE?i;/[((R &I"B)M);c>?kGBpKDpLCkHYxYXuW>`?@cB?dB7_<1V4+Q,1W28a9=g?>k@?j?3\09`33S*8)!"(:"TtM@j:?p95h-:n04h(4f'8l,<p.;r/8p/?r9MtG(C" 	)< :R.Hb;\|MgéUQ{<Fr3Ft4K{?\çUcë`sùurïwéÆñó∑ücÅeWrSjpTänY¥éw≈Æå«ºé∆¿å¬æÅ¬πv√µl¬Øb¡®V¡ßR¿•NæûGæôAæê;¿â9¿Ä6¿u1ºd%Ω^$ø\#¡^%ƒ_'ƒ\'øQ∆V$»Y$Ã]&Œ_'–c(‘g,‹p2⁄l/’g(⁄n-„x4„t-‹l$‰t*‰r+‹a%⁄b%Ÿh$ﬁz,Âë9‚ú<›¢<÷£:‘•;’±Cÿ¬K÷ P’—T”’V–ŸXœ⁄Z–Ÿ\Œ‘X–‘[—“Z”‘]÷”`“«[≈∏OŒ¡XŸŒd÷ŒcÿÃ`”¿W—∫RŒ∑QÃ¥PÃ¥TÀµR ¥N»±G∆ß;≤ë ≠ä∑ìøñ ∫ê∑ç¿ôøöºö∫õ∏úπò∑ñ	¥ìµñ¥òµô¥îØä ≥âµÜ≠w ™v ≥áÆÉ ≤Ç™} ´É ≠å¨ç´è ™é ©å ®ã¶Ö ¶â£à ®ì©ô¶ö§ò°ï•ò•óòå£ô¶ü§†§ü§ú•ô!•ñ#§ç#¶Ö$•y £lú^ö[†fßw#©{#§nßo≠w!™r§f™h¶`†[¢`£a†\ùWüTûPúLóKôU†eôkïpèsâs Ép!}m"rejahc!ie&ec(\Y"\V$`X'e[(eY%gZ&gY(eY'dX(eX+gY*fX'fZ(h]0g`4ca1cb2bd3gg1ts2ÖÑ4çâ.ëå&óå õãòÇõÜúåüí¢î£ì£ç¢ã §ä•á©Ñ® ™|ßt ØxØo°R ¥d≤n¥w≤zØw ≥uØh µ`´K ØI ≥P ∑^ªd≤T ¨U ∂n ∫|ºÄπ~ º|ºw ∫r πq ¬Å…ë
+«ù«£»• ©Õ∞À¨…°≈ô∆ñ»öÀ¶Õ∞œ∏Õø”À(‹€3›„9‡Ë=‚ÈDÂÁHÈ‚LÌﬁOÌ◊Nﬁ∆@‚ FÚ‡ZÌÁ_ÎÏbÏÌeÎÁbË€[€æH€®?Ê¶EÂö?‚ñ>ÂûFË®N‰ÆL„∏PÊƒY‚ΩS—°;«è0÷ñ?”è<ÕÜ4»0Ωp(£g(t[%[].Mg:HmAEl=;e32]'2_&3`':g.;h19e03_.8b4Aj>?j<?k::i3Gt;`çTYÅLeåU^ÜGIp1Li1!6
+
+#>V6A_9-R'+O),Q(Bj8túgoò^bãOPy=V~LcÖlá¢õxêîlÑÜ_~o_ÅhYz]Ww`òíü≥∫£µÀùÆ ï¶¿çû≤ù´∏JXYJZMnlrÅnjvhdlaFIBSUPEJC4@23D1*@)!9'A$$A",J(1O-(A#.0()#;!&C%,K+0O/,K,.J3/J7:XLhÖÅòÆπ∞¡—µ¡—<DQ!$(%;&/K22U78\@?cG?aH:\C>`G@bIAcJ<^E>aI=`J@fOAgPBeO7YA.O2B_1I]}Ñ'Ü|	öàüçûäõá õà ôÑ ñÅ öÖ ùç §ú¶ü°ôëâ
+Ç~ÄzåÑèÉ	ç|åxätÖlÄdz^ ~e êy£ã±ôª°Ω§ø£≤ó üà úÜ üâöÉ ñ} ñ~ìu[]
+IR<F8D3@,8&/#(
+,+ IF!A+,0-,**(5.JbL<Y;)F(:W9>[=<Y:<X24L,+%/D1d|d7O589Y4LsGJ|ILÇNLÅMSáVXå\Yç_Vä\RÜVFzIKÅOWã[Vä\SàZUâY\ç^TÇSCo>$N >!D1[+6g0:o93h2HzG3b4<jCIwSRÅ]L~YHwSYâcNÅVPÑVSÑUCpE*L+	!	#&3"+8&+8$$1)2*1!06(,7)25O2Ae?9c5*T$$I*O&8a7:g<@pF?mFBlHLoNhÖg8W7AfD=gA4^:2^:6c<7d=8e<:g>>mCApDCpEItGHsEAh<* ;R5[ÅROEJ|?Bv4Cx4Cx2@s.Gz5J}8Dy5=t1Au7'S )	#7I3Hc@\}R[Opòc[âINÄ;Dq0Lz9TáEQÉFDu=SNKoKrìvñ∑öeÉgSrRboQÑkU™Üp¡¶à«¥å¿¥Ñµ™r±°c¨ïR¨éF∞éD∏îF∂ê?∫å>æä>ΩÅ8Ωy2¿o0¡f-¬])¬V%Õa0÷j9‘j6”h4‘d4’c1”a-”a+⁄l1ÿj-€m0‹k/”a%’c%€n+ﬂs+Ÿi!”c‘f–b—`ÿl$÷u&›å1›õ:⁄°:“ü4”§:€∞G€ªL“√L‘–S–’UÕ÷W–€[–⁄]œ◊]œ’[’Ÿ`Ÿ⁄cÿ◊c—À[—√Zÿ∆`ŸÃd◊Ãb÷À_“∆X≈≥GÃµM»±K ≤PÕ∂V–πY≈≠I≥ö3¥ñ(ºù)¬§*√¶(¿£#æ°ø£¿£∫ö∏ô∂ö
+ªúπòØã≤é∂ñ¥ò±íÆà ´Ä ∑Ñ≠w ¶o ≥¥á≤Ö™v •s ¨Ñ ≠ã´å ßä ™è ™è•Ö û} ßäßç§è¶ï•ñ°î§î	ßó°êñà•õ§ùüüùüûü†ü!†õ#¢ò%¢ë'†á#ûy ómñhôn ûz&¶Ä+ürûn•u#¶s$°k!°h!úbõaûfúbñZìVïUìUìWí\êh#ãm%Ém$yk"ldc`[ZSUKQDMGUN]&Yg4%017:>FH!PS(Z]0^d6_f:^e;`g=Y^5KQ%OT+ioMmtSgsOEU.JZ3Zj=hs9ÉãBãê6èê*íé ïãïÑí	õãûë†í£ë¢å°ä †Ü ßâ©Ñß~ ≠|™v ±z≥s†Q ≤c≤nØt ≤|≠y Æw ¨l ∞b ±W ®D ≥N µW ª]∂V ±V πlΩ|∫É∫àΩàæà¡Ñ∫z º} ƒåÕü»£√ûƒ£…¨ÕØÀ¶≈ô≈êƒè∆òÕ©Œµœ¿À¡!’“-‹ﬂ6ﬁÂ=·ÈD‰ÏKÍÓSÌÏVËYËÿO‡…EÏÿSÌÂ^ÏÍaÈÏaÍÌbÌÊaÍ’X€´?◊í3Íë?ÁÖ:„~8ËåAÏ†LË≠OÁ¿WÎÕ]‚æP”¶?Õñ;“í;—ã6–á8¿w2ôe)fY%R_3Lh?JoFMtHEo?9d.2]%2_&8e,8e,7d-8d12^-:d6@k=>l;:i5Fr=\áRT|JSzE[ÉEIr.Kn.2M
+	03N//Q,-Q+.S'QwDcåR`äJP}:Ly8VG]Å]vìvêáb|sQqYQtTVyYMmUGaVZorß∫À†≤»ãù±ùØª}ãéVc\O^KYhQwÜsvÅsaf_;@::?88B74E2/E.*A'8&@##>0K,.G)(?#3/'!7"'A(*G)4Q3LiKZw[AZEGaTdzuéíëßµ§µ…¥¡“xÇév}ÉIRO#, 9#4R8=_D=aE<^E9[B=_D<^C=_D>`G<_G>aIDgQEhRAbM:ZB!B#+EKWââ%ç~ûä£ç°å £é•ê©î©ó®ò†îâÉ { êç|kh ztÑx ày Üs Ñq Üq Åi a xZ y^ çu §ç ≤õ ∫¢ ¡®¿£±ñ ≠î¨ï≠ñ¶èõÇñ~ é| çÅxx IP9G2B*8"/&	" DI !<*+...2):',*""8#1N/=\<>b<>d;Ah;Fl=Fd>&#3&A[BdÅc6%@Ch<Ds=D{BHÉIIÇKIÇMLÇN@vD9m<=q@AuDEyHXâZWàYTàXZâ[HqE6[0%HA@+R#3_*7h1.c-EzF:l97f8JxQKyUSÇ^EtPWÖaN~XZçbTàZVáX*U*&E%2':$,?)-D(/H**C%"6&47@+ $),!+1' 50T03\0/Y+6`06d53c3;j<AnEEkFdÜeA`ACeD=f>6c:7e>8f?6d=:hA?mFApFEtJHwMJwNIvKDrD*S)B+!*=b/\äJRÜ>YçEPÑ:F|.H~0H}/Cv+eîLHz3Fz2PÉ@Fs:/ $ObNuísvõrcãYZÖO[âK[äFHz3Er/Fu1?q*@s.:m+;j3_ÜZÄ§ÄÄ§ÄfäfQuO`qO}mS¢ÄgøùÇ¡£Åµûr¥£o∂£h∫£`æü\≈†YÕ£YÀùRœõRÕëI«Ç=»x9Àm7»b1 ^/Ã]/À\.Õ]/ÕZ+ŒW, O&ÀM%ŒP'—T(÷Y+”V&’U$“S ‘R ŸW#◊[‹b!◊^’a—cÃhÿ|%ﬂã1‹î2‚¢>⁄•;–°5–§7⁄∞D‡¥K •:…∏Dÿ”[’⁄\–€[—⁄]–ÿ^‘‹b÷€c÷⁄b÷◊b÷‘e÷œd⁄Õd€Õd◊…^”≈Z“¡WŒΩSÀπSÕπVŒ∫Y–πYÕ¥W¡ßJ∑õ:πû5¿©5√Æ1¬≠-¿¨'ø´$¬¨#¿©º°∑ñ∞ä∏îªïØÉ ß{ ∂è∑î¥ëØä ™Ä ¥Ç±r†a ≠w ∏á∂Ü≠{ ô` Øx≠Ö´å ©å ßå ©ê ®è§â ßå©èßêßí•í•ì	§î	ßï•íì~ úä°óüõüúõúúüùü ûû$üù&ûò&üó(ûë)ôá%í}"êz$ì}(úÉ/ôz*ïq#ôr'ùs+òp*îl'ìh$ìh$ìf#ç`âYÖYÖ_ Å_ ~b#xd%nf%cc#W`!N\DU@S;O8O7N6N:U D_,Pj=  ##(%*,5GU1DV0YoHe~Wf~ZvåhMa>0C%lÄg^t]by]8Q4E^AMeAQe4{äIäè=êç,ïé$ïâïÅèzõâüç†ê	†é°ã¢à üÉ ®á´Ü®™y ´w∞y∞r§X Æb±n´s ≤Ç∞É¨ ¨x ´m ≤f¨Q ∞O ¥S∂S πT∂V ∂d ∏uæâªçºé¿í¡íøé¿åæç …ùÃß«¢	¡†∆®ÕØŒ¨ƒú	ƒëƒè¡çÕ§Ã≥Œ¿!Œƒ%’œ/⁄€7›‚>‚ËFÂÔNÈÛVËÒVÏÔZÌËYÂ’L‡ŒHÏ‡ZÌÁ_ÈÁ^ÂÊ\Ê‰]Ó·_ÎÀT’ö4◊z-Âq4‚e/·e/„w6ËìCÁ≠L‚πO„√RﬂøP—ßA«í4»Ç-ÀÅ6∂u1âa&a`2PiATtOSwSOsMKpEBh79a-5`*7d-6e.3b+5d.2a-2^+4c/>l;<j9Gs@aãYhé]QxCGq1Do(Gp*Ab) 
+	00J//Q./T+8_0Hq7\âHdëL^åDZáBWÅBSyFQtLUtUKiMMlMFeF6R9(A.&<0&97ct{Äëô?PWP``O^YDREWeTjweuÄpXcU/90".$'5(*=*.D-+C))B%!:#<'@#*A%#: 443K37!9#2$>#HbGjÑihÄjXl`exrrÜÖrÖã{ãòëü¨ÄçñdosèóôzÄÄ (5N;A^H<\E9[C;_E:^B<`D?aH>`G>aI;^FY{cLlUEeN=^C,K,#;KSáÉÖtï} •è•ê§ç•ê©ï´ú≤•	≠¶óî	hg txkouvxså}ç{ àt àt çt åpÖetW t^ óÑ∏•ø©ø®Ω•µö´ê ≤ö∂û¥ú™ìûÜ î çz òåzIL6D.@(7"	$DO''>"/0!4!':'(>)-@*1C-4A0	- @X>.K,2O0DfCGmDJtFPxFA_9''7*NhM\yZ$
+3N/Cm;?r7?y>EÄFIÇKKÑMGÄIAxA)[*5g6GyHAuDHyJ>o@EvG?lA0U,=;"B/U&6b-5f.3f.GyD7i6IyG1`2M{TRÅ]P[EtPXÜbK{UYâ_VäZYä[2]2<&>$)A'*C&'E#)G#-K'/J'-@$*8"9?3'.@0JdKPtP?h>/Z,4`/0`0.]/1^33]5PrOSuT5W6BhCDoD=l>0_58g=>lEGuNJxQGuNHvOGuNJwPLyPMzOMxMMvLEjA6:Y-UzDTÅ@RÑ=OÉ9YãFlûYZéDQÖ;ZåCEt.YàDaèNJ|7SÜCUÖG;c.,H 0	4G1xïvièfXÑQUÖKWáI=o*As*8k >m%=l$7jJ|3NÅ<N~@põffê`oôkÜ∞ÄT{N`wM{pPú}a¿ò~Œßà–∞âÕ±ÅÕØy…¶l≈ó\æäN∏ÅA≤v7ºx9øu6¡q4∆k4√Z+√R(ÕY0”^3œZ/ÕV,ÕS*œQ)—L)–J'’O*÷R+’P'ŒI“K’N◊P ŸV’Y‘^—[◊h‚~(Îí6Êö8€ö4ÿû3⁄•;›™A„¥JÊ∫O“®<πê&¡°4÷…VŸŸ_‘›^—‹\”€a÷‹bÿ‹d’ÿc“–_“–aÿ‘h÷œdœ¬YŒ¿U‘√Y–øUŒªR”¿Z‘¿]–º[Œ∑W ≥S∆ØO«ØM ≥MÀµF∆≥:√µ2¬≤+¡±(¡∞$¡Æ!æ©º£¥ìµèªë	≤Ü¨{ ªå∫ê∂è≤ã ±á ∂áµ£c ´l ∂É≥Ü≤Çõi °j ≥ÅØä´é™ç™è®è •é ¶ç ´ë®ëßê¶ê•è•è£è
+•ì°éàr £èüîúóùôõöôõúûùü$úù%ôö#öõ&úú.úô0ñí.íå.îä3ïâ7íÇ5Ñr*Öm-Öm/Ñp3âv;Öq6Ém3~h.yc)p["m]"f\!\WXYRZFV?W>Y":X$6V%3S$1Q"/O /O /O5W$?a/LkA  	#',:!-@$@Y;RmNE`A\wX^yZ)C(gÇoXs`IeO9U>D`IE_BC\4uÜOàèBâà,ìå$ïáïîz	úÜùä
+üå	ûä†ä°á °Ä ¶É™Ö™~™w™s ´t ¨p ©_ ©_ ∞p´t ∞É±âØâÆÉ∞~≤t±e®P µV∂S∏Q∂R ∏` ∏o ªÑøëµå ºñºñƒõ√ñ	¬ï≈ù ßÕ¨ƒ¶
+≈´»ÆÕ∞…•ƒï»î
+¡ç¬ïÃ¨–ª"“≈)◊Œ1◊”4⁄ÿ8ﬂ·BÁÌOËÙVÁıXÍÛZÏÔZÌ‰WÍ⁄QÍ⁄SÓ‡YÌÁ]ËÁ[·‚XÎ‰_ÏŸYÂ∑H”)”`›U%€N!€Y%ﬂr1ÂìAﬁ§A÷∞C›øM›ªOÀõ9ºv!ªs+ûh(y^)\e:PnHXzY]Ä_TxTLqHGj@Ag8<d25`+7c.7c.:f38g33b,1`*5d0;j4Am8NyDaâTQx?:g"=k"Bm%@c)&	
+
+(9&2L1/Q.4Y.Ck7WÉDcíJkõQhòNfìNZÑEGl68\,3S*)I$(H#$A"#@$%>)%<,(>2*?:3HC4H?4H=JZM.<-'5$/<+*5'%1#%3&)9,%:')A)+E*+E()@& 72(?%*>%11 6,F+%?&.F0$<&.H/=W>pâsczhHYOsÇtÇÇiwxapubqvVddo{yô°£W]]!!0"$;++F36VA:\C<^CA`@F`9Ib:Ea;Db@RlQ_y`XuY@]AB_A5K>F âÉ!é}	är ñÄ °ã§ç£é §í ™õØ•≤¨§ûwvRX cj``qlçÄîÅë|ì}óyäi áeÄc Ñm ≥†¿≠¿Æº¶π° ±ó Æï ∂ü∂üÆñ ¶ê ùá îÄ òÖóäeaBI4H4J#/?$"-7I!+?&0"3#(8+-?//B/0A/2@/($CYDFeECb@+9O8SpQVxSNnG-H))$2%^x[HeF"*D'Co>=s7@z?FÄFLÇNMÇNKÇKE|E?q@HyJL}NEvG?pC5f97k=7d;1S2,5/R(4a*1e'1g+Dz@5g2CsA5e53b6IyQRÇ\JyUOÅ\QÄ\XàbWà[[å]ZäXLwJ65(@&*B()F')H&+K&0N*6O13%4A/!4 HbIPqTJrOHrJ;i;&Q$0[.5d88g=@jDGmHbÑa3U29_:8b:7e75d6?nBHuJIvMDqHDrKEsNJvSNzWQzXLyRKxOO}OZÖW_ãVR~ASÄ=SÇ<NÄ9OÉ;UàFQ~G~™uy•px•n¨ueí[iï`oõffï^\éQOÄ?Hv5Gs6Go::^~WxüslòeNÄCK~;Rá?;q&7k 5j?t&H}-F{-QÜ8NÇ8OÇ=YâKVÜJUÖGTÑFSDrçXÜÅWö}[øñzÕ†ÉÃ°~ üu»ìg¿ÉVøvK∫m?∫l<∫h6Ωe3∆j7Àk9 d4»T-«L*ÀO+ŒR,ÃN(ÃN(ÀK& H&ÃB%ÕB#◊N*◊R)÷N$œK÷O◊T ◊YŸb÷g‘l‡|$Âá-Áê1Ÿç+ÿó1‡•=ﬁ®>‹ß?‚´GÊ∞N–ú7ºê' ™=ÿ«Sÿÿ^’ﬁa”ﬁ^“›]◊ﬂe÷⁄b‘—^—À]◊–e⁄”h‘ÃaŒ√YÃ¿T“ƒY”≈Z ºQÃΩV’¡^’ª\»´M∆¨M–∏V—æWÃæQÀæLÃ¿F«º<√∑1¡±(Ω¨ º©ª®π§∫§∫ûªó∂ä©x ∂á∫é∂å≤ã ∞â ∏éπä©v ©r µÅ∂âµä´~ûq ¨Å≤å≠ê¨ë™è ©ê ¶è•é ßí¶ëßê¶èüÑ °Ü£à£ã§êôÜë{§èùíüóúóõöúùõùõù"ôö"óõ#òõ(òõ*ôù/ñô0íó3çë3ãè;É9jo/fi4Z].X`1gpAu|Pu}Niq@cm9M^(H\'CZ&=U!9T8U2S2U2W#5Z'0V%0T&0Q$.M!0P!0Q"3U#>`.PoE#
+	!!$13E-/A'7N1C\>7Q6`yf]ue@[H5Q:A_G@]?@Z5pÑQáëJÜÜ.íç)ïáó|îtô~	ûâûâ	üã¢ä¢Üùz ¶~©Ä®z ™s ©p ´r ∞t±l°\ ≤r¨u ≠Ä ØâØãÆäÆÜ∞Ä≥u£W ≥Z ∫WµI ∂K ∑U ∫gΩ}¬ê	ªíπì∏í¬ô¡îøî∆¢ ´…Ø∆Æ≈±»¥À¥ÃØ≈üÀûÕû∑à æê—¨”ø*–≈+‘…/÷Õ2⁄”:Ê„JÈUÈÙXÍı[ÍÛZÌÌYÎ‚UÂœHÂœHÌ·WÍÁZ‰ÊWÂ‰XË‡YÏ–U‚•; kŸT‹G›JﬂY&‚s.·ç7÷ü:’¨@‹∂K—ü>Ωt%©d!Ñ\!bV$Pa7JlGOtRSxWQvTLrMLpJDi@:_4:_3<c49`18b4>j9;g28e.5d-7g-;k1>l.Er1An)7g<l >l$;^&)&-A(0M//S-2Y,Bm5M|4OÇ3Zç>iôOwü`RwA0U"%I*M#,O'-P(/Q,/Q,.P/7X=GgPSp^[xf\x_XpXizh6D5#1 $&!2"->,&9&&<%*B(+E(+C)':$+%$5".A+':$$6 "5-E-F^F=U?G_INjQNjSué{|íÖUf^nzvmzshun@OHBSKG[Pj{sgqr(02""$#8'0I62N7>[=I`6aj+|:[e(Vd1[mGXmLK^>:O0JdGJa59E åâ(úåòÇ êx õÉ úÜ õÖ öâ ¢ì©ü≤©®û|wLP Öã3qqmf sgÇq	Üqétòv
+åe Ö^ ] b üâ¡≠¿¨π£ π° ¥ú ∂ù≥ü≤ù¶ê £å ùá ôÖüã{pNS7J
+2N0L$!3!(5-F"0" ,"- !)(.;'3G.PjMMoJGfD&'3%1D.;R84K/++!%1%lÖh)D#$5@l;?w:Cz@G~GMÇNMÅPPÖOH}GJ|KM~OL}NBsD<m>5g64e61^3="(H#<a55g,2i(;s66l2=o:6f43c3;l=CsKN~XHzUSÖ`O~Z`êhUÜY[ã[M{LMvJ"A!7$<"*B(*G)*I).M+0O--J+5"9C[CQoSLqPIrPBpIEtHBoD(S(F?iCBjGHkJgâhAc@EiEIqLAnG8g;5d6.]10]25b78e:>mCAoHFrOJvSLxTIvOO}OUÉR^çYz™pdïT^êKXâGmû]u•imôdx¢t{§zvüsx°uw°sw°sqõmqúnÄ¨{oûgZãJVàCWãCNÅ<Hs;nôc_ãV[çPQÜBAw,9r%7p!2hF{+I~.H}-PÑ9`íINÄ;hôXmùap†daìT_êOs°c~õc~|Lô}X∏âo∆éw¡åm∫Ç_∫xUºpL√oK pM qI√f=¬a6 e9∆_4≈X/ƒM+»K+ÀL+«G$∆F#ŒN)“T.—Q*œJ' F ŒK!‘Q#’V#◊Z"Ÿa%”]‘d‹q!‹x"·Ç&‡à'“Ä’á#ﬁñ2‚û;Ì´J‚ù@◊ï7…ä-¡ã+¬ï.”≥F⁄…U’”Z’ﬁa“ﬁ`“ﬁ`’ﬂb÷‹bÕÃVÕ«WŸŒb‹—e“«]“«[‘…]‘»Z÷»[’«\‘∆]‘≈`Œ∫Y ≠O»©LÕ≥R—ªUœæRÃ¡NŒ≈LÀ√F«æ;√∑1¿Æ$∫ßª®∫®∏¶Ωß∫ü∏î
+±Ö ∑Üªçµä ≤â ∏ëπî∫ì≤ÉÆ| ∞ ±Ñ∞à´É ´Ä ¨Ñ¨ä≠ë¨í´í™ëßé ßê©íßí•ê¶è§çõ £Ü°Ñ•ä	§èôÖñÄ	ûãõèúîúñúòöôõúöö òô!óò!óö%ñö+îö.ìö2èó4ãî7Ñê>ds.>OAT&@U.;T-^xSiÅ]gÄYXqGHe59^*6^*4\*2Y*3[)/W%.V"/W#0X&0X&/V'.T%/P%.O".O 0Q"3X%<`0Lm@2	!(.@(/F*-E+[rbdzmWp]*F/<X?@]?PkJh~PÖèPâç9íé-ïáñvåj ö|
+†Üüä
+ûä°â¢Öü| •}ß~©x ™q ®l ¨u¥x≥p°\ ∞p´t ´~ Æà≠å¨ç Øé¥åµÉ∞n ¶S ø_µI πK æUº_ ∫n ¬á	¡ë	ΩîºñøñΩíºë¡ù«®ÀÆ«Ø≈±≈≥∆±«Æƒ¢«°“©Ωí´y ¬ó—∑&Œø(–¬+ÿÕ5◊…4‹“=ÁÊPÎXÍı[Îˆ\ÏÚZÓÈW‚ÃC’ª3ÈŸNÎ‰VÊ„T‡ﬂQ„‡UÍŸUÎƒK⁄ê-”\⁄I‹DﬁK ’TŸq(ﬁó;ÿ§>Ãü8 ï7¿{.üc%rY#OR%C\4@d>GlJHpMHmKFlGHlHAeA=_::]57\18]2,Q(=d8Ah9>i4>k2>n0>n0>o-6e:j 6f5e8e ,R, 0&4+"4.G)1P03U0/U&Nw=K{1Dx&MÅ/aëEdåN/T?d0<b/>d3RwKZTOtKMrIQuOnìqzúÅâ¶êõÖmálCZ@&4#3?1BP?>O=,?,+@-%;&"8!(?%,D*,E((?%$3 , ,-1B0<M:.@*':$L_IlÇkWmXRhSWpZUnYqâ{zéÖXgbjvryÜ}[h^=OA6K:7N<j~rñ¢¢IQT$'!'',1-$0,#4.()A3BYE[g?Åz4úê<vm qm-V\,8C9BSb9NfFLe=GU~Å&üë©ì	ûÜ òÄ öÑ óÉ ìÅ òà ¢ì®õûí_X VW äã.Ç}sg`Q eU u_ änímãa Ñ\ X zZ ~b °ä∞ú	ª¶Ω¶ª¢µûÆò©î£ç†äûàõÜë~bZ CM4M4T"3R))@$%)0"<*G	
+
+	#,BO3<M)kÅZTnGMmFRuMB_@$1*0$(0#(0#%0"#-"$+$,8,qäm4"
+#<Co<@x;E|BE|CG{JMÅPQÖTLÅMF{GK}LI{JAq?:j66g0+['%Q @>&K LvD@r7?u73k.8o54i12d/-_,FxGAqGGzQJ|VVàcN~X^édTÖVcëc#I")K("?!9": &@%(E)&E&+I-.M.1S2<^=MpPOtUMvTJvSEsOHvQKzPBoF3[609X9NkM`y[]z[>aAMuSEnNGsP<jC=l@9j=3d52a36e70_1)Z-0_50_53b88g9Cr>ZáPZÖOjï_w£nqùlÜØÉå≤âé¥ãÜ¨ÖìªñuûvtöqqönpölpöltùqsönwûqlñdaçRZàH^ëLI|7SÑBeìSaëSXãIRá?G}14m4m@w&F{+Ez*ZçBióVdëVv°lÑÆ~Å´}Ü∞ÇÅ≠|v¢oqúgré[|yLóyUæàp»Ör∆Ük»Üf«~]∆xT«sQ qO»lG«iC…i?»g<ƒ_5√W0ƒM-…L.…M+»L(ÀO+–V-–\-“^+ŒZ'ƒO«M–W Œ[€n)„1Áã6Ûó@Ëç2‘vŒs∆r—É‚ô2Èü<Èï=‹1œj&ƒf√{&“¢>Ÿ¬RŸ”[÷⁄_”ﬁ^”‚c‘„d÷‡cÿﬁd—“[ «Tÿ—_‹“a‘ Y—«V÷Ã[”…X–∆U÷ \“ƒ[‘¬^œ∏X»∞P∆©KÃ≤Q“ºV–æRŒºN»πFÃ¬I ¿D≈∫:∆∏5¿Æ&ª®Ω™ø≠æ¨Ω©≥ó¥êªî	∫ê∫è≤â ∏íºô	ºôµê∞Å Ø~ ≠Å ≥ã≠Ö ßÅ ¨Ü ´â¨êÆî´í®í ßë ¶ê ®ë®ë§ç ¶èßê§çßã•â°Ö £ä	£éûäì|ûäúêúîúñúòõóòñôóñññóïò#óõ,îö0ìö3ëò8ãî;Äã=EW2J=X+6T.2O0fÉehÉdWrOBa73W'5])2](1[)1[+1[+/Y'+V!0[&0Z(.V$-U#.T#-Q#-N!.O 0Q"2W$;a.Fl;?_67P3*='. 
+)7&,?+1F3`thxåÅezi2J45O4>Y:OjIZqEtÇGâêCêç0ñá"ñvèj õ{
+°á°âûá°â¢Ö£Ä§| ¶}©x™s £j ®q ±x≤o¢] ´k ´r ¨| Æà∞è≠é Æè ¥êµã∂~ßY ∏\∏Q∂K ΩR¬\µ[ ær√ä	ºé∫è¬ô∫è∫åªê√ö
+«£«®∆Øƒ∞≈∞≈¨ƒ¢«§ ¨«ß∏çπê»¨ŒΩ)—√.÷ 6◊…5’∆5ﬂ”AÎÊTÏÚ\È˜\ÎÙ[ÓÓZÎ⁄N“º3Â”IÎﬂUÊﬂSﬂŸM„›QÁﬁUÈ“P‰≤A‘u!”V⁄G⁄B‘H’_!€â5‰•F‘ú;¡ä0≤s,å_&ic3Rd:NlFKqLAiD?gB>d?@d@?c?>a@CeBCeB@d>?c=8W5'G"8X1,P"=f.5c%;k-<m+4f6f6f7g8f0Z$F:Z+D_4/J!&B-K'5R33Q//P%báQ_àBJy+K|+VÜ:ZáFeéRgëQ]áGUÅBhì[tõlxûurónníltóv}ûÉè®ìå°êUfV .!%#4",B-@XB=U?%=%%<"(?%)@$+?$%7)&.+6(&0%.:,tÇq8G4/@-WiS\nXYjWZmYJ`KJ_NaujrÇiwxjvvwÉEUJ2G64M8AZGbxkáìëù§™óû¶Åàékps1;=õ™±?Q[?SZtáãâóóéêxÑt6üÖ0äo{f3* 3/ YT[`*Mb;Lf?Nb-qz)úí™ïßê°ä †ä ûà ïÅ í ñÉ öâof	D? \[É~ ~qyejV VA s[ Üiåfãa ÅX ~W {V }] |` Ün ∑§≈±¿®¨ìüáåt êx éy °å§êîÇZS <G5N3S$1Q(-G$%:!97"A+L	
+
+	"@H1WeBdwI_zG[vKRqHRpL2I-$/%(!"+,&/2+,1+&-&;I:e|`0!>W7>h8Dz@By?C}CI~JEyHKÄLKÄLDyCH}EFxC@s;1d)'Y"T M!I H;e3Gv@:m2,b&7n46m35j20e/-_,L~MCwIExMMYUáaPÇ\UÖ[Wà[_åa(L(.K-"<!; $>#%B&&D($B& >$$B&0S2HpMMwSGuPDrM?oIFuQGwQQX8e><d?5"9PbLwãrJdGLqRGpPFqS@lKGuPBqGArE?pCArE>oB=n?BsD;l?:k<?q@JzFPHWÑM_äUkícÄ©ÅfékÜ´åà´çåØëá¨ãè¥ì~£ÅÉ©Çx°wtürkñhoôkoôisõipòd]àPdíR`ëOVäBTÜ?[çHaíPYåIVä@XåA=s%5lE|)D{(ZèATÜ=RÄBsûiÄ™|{°xá≠àÜ¨áÇ´ÉrõqÜØÉã¶yáà^ñyW∏~høvc¬zb«}b¬uW¬rQ≈qO¡kH¡gD≈iB…pDŒsDÕn@∆a7»Z5ŒZ5œ[4ÀW.ÀZ.»^, f+œq1ÿ}7”x1œn)’s,€z-·Ö0÷Å&÷à&»}¡s“Ä‚é,Íñ4Áï2Âï6‹à.–p#«b»b –x.‹°E‚¡V€‘_’ﬁa—‡_—‚`“„c’·e’›c“÷]œÃWŸ‘_Ÿ‘_”ÃXœ»S“ÀV–…U‘ÕY’ÀZ—≈Wœ¿YÃ∫V–ºY”ΩZ“∫V÷øY◊¬YŒºN∆¥DÕºHÕ¡I«º@∆∏;√¥3¬∞*¬Ø%æ´ ª©ª´π•≥ó∏ó
+∂ì∑î≤ç ∏ìªò∏òµï∞ã ∞Ñ ÆÇ ∞à≤é≠â ≠å∞è¨ê¨í´í™î®íßë ®í©í®ë§ç ¶èßê£å ®éßç°â•é°åöÜî
+ùäúêõíõíóëöñôïòñóóñó îó$ïô+ìò1ëó3çî5àê;nz26I5O"Ga:@^<.K-NkM\vYGeA,L#.T#2](1](.Z'.Z)1[-4^.*T"+V!,V$+U#-U#0V%-Q#+O!/P!.R"3X%<b/Gm<;_3=X7>V<;S96L5-@*$3 $1B2/B/Zo^]ocoÅuXm\6L72L19T5@[<F_7_p:áëLëê6ìÉ!ózèmôyüÖ°à
+üà°â£Ü¢Å §~ß~©{™u©r ™v ∞y∞r°a ™l ∞y´~ ∞åØê´è Æí ±ì¥ëπä≤n´W ª[∑N πK ƒY	ºX ∫c ¿~¬ê	∫èøô¿ó∂ã æê¬ó
+¬ú	∆ß√¨ƒ∞»±ƒ©Ωö¬¢ÀØÀØÀ¶≈†∆™Œπ(Œ¬.“»5◊Õ:÷ :’∆7Â›NÎÔ\ÍÙ]ÍÙ]ÎÔZÏ‰U€…?›ÀCÓﬁUÂ‹Q‹÷J‹÷J„‹P‚‘O„¡F‡ò4Œd’N÷A÷C“P“m'‹ã9€ï@¬Ö5ög&{])^f7MlCMqKQwRIoJ@fA=a=DhDHkJJmLDgFBeDBhCBfB>[<71 <?e28d)2b$:k*Ao/=k*:i#9h 5d5d3`;d(8^%0R -N#2R-4O00K*0L$?_.däMVÅ:N~2NÅ6aêLmõZgîOXÜ>TÅ<VÇCeê[y†sÉ®}Ñ©Ä~†}wñwwåyYi\(4("!+)<)!7"6 2J4E]E3K1*A'*>#)8!*6 .7$,3#19,1;0V`UXdV/@.1D.CU?@R<O`ML_KObNdvfk|tsÉÇ£Æ≤]hjCRM6H<*A-2K6=YCVl_{áÖèòùÇãî¶Æπáèö¢´∫£¥»Sh}è§πùÆæêò•®§òÑk3îoùvÄ^B. ^Pl]EADU+KfCNh;cr-ñí&†è¶í™î
+ßë£åõÜîãyqdDA 44 UTxrm	~fx`iQ án
+ãkãcécÜ]W W Å^}_ |a Ém ùÜ°âñ~ år Üm èxxd |m ìáá~NO 9K4P4S'2R)-G -F*B1J?[Eb"
+
+$HQ6kzQh|Gd{EH^7UjKJ^C*$ 23-984*,') TeSSgK7!9=[53Z+Fw@D{AD~CLÅKQÜPI|DF|BCy=Dz<@v:;q36m,6m*3g%0c!/]-Z8h,6h+/b)<r8By@1h/4i3-b.0b1J{LG{MCxLNÇ[OÉ\Vàb\èf\åb[à_*M,.K- :(B'&C'&D*'E+)G-)G+)L,BjEOySJwPDrKBpIDrKHvQHvRK{U7e>>hB'I(#5\iWPaOWpZUy]HtSFoQO{Z@nJDrMFtMEuMCvMGzQH{PEvIDuHRÇRXâRZãSaê\kófhëgz†{ã∞ëê¥öè≥ôÜ™êÖ™ãÄ•Ñè≤íä≠åàÆâÄ©ÅÜ±Üs°rVÖNK{?WÖG_çO`éPgòVUàCVä@WãARÑ=_êNXÜEN}5RÖ:Dx.Aw+Ax%By&[êBDv/YÜKx§osünmñlgèjröxã∞èã∞éã±åñ≤åö†|ì|]¨r\≈xd«ycƒt]ƒsX»uW»uU«sO¬mH¿kB√sB zE»uA√k9—qA—m<Ãf5 i2œu9÷ÉA◊çD’îB‹•Jﬂ™J·¶Hﬁù?’å.–Ñ$»z≈{»Ñ„ü0Âü0Âõ2Áì1›Ç)‘p"œi!Õd"≈g’ç8›≠K›√U›‘_◊›a”‚a—‚`”‰d‘„f÷‡f”◊_‘‘\◊’\◊’\”—XœÕT–ŒU“–W”—Z”–]‘ [—≈Y∆∏OŒ¿W”»\‘…]ÿ«]◊¬Yœ∑Mƒ¨@Ã∏H“√NÀøG≈∫>…∫=≈≥3¿Ø+¡Ø'æ´ Ω´æÆ∑•∫°µõ
+πù≤ó∂ö∏ú
+∫û¥ïÆé ±ç≠á ≤å±èØê¨ê´è ¨ê¨ë©ê ´í™ë®èßê®ëßí¶ë ¶ë ßêßê¶è®ë•è°ç£éûàóÉ
+öÖûéúêõëôèñéôìòîòññïîó$îò)îó,íó1êñ4åì6Åä9S`9M>R-euXTfL0I+?Z9KfE7U/,M",R!2](/\%/[&.Z'8a5;b6,T"*U )S!)S#-T%0V'-Q#,P"*N /S#3X%<a.Hl<2S(-F(.E+/G-.F,/F,0C-,=*%6$*%8%CVCata[m]_qaBUB9O:5N8:W;DaE<V3L_1ÄäKëê=ìÖ$ò|ït	ñx°á°á†á§â£Ü¢Å £} ßÅ®™y®u ©x ±Ä∞{¢m ®q ≥ÉÆàÆè≠ì¨í Øï ∞ñ≥ïπíªÉ
+£\ ∏a ¬^∏J √U√[æb ¬{…ì¬úæú¬üøõ	ºñ¬ú¿†∆´¬≠ø¨∆Øƒ©æõ	¿ù…™«´»©»¨»Ø!Àπ)À¡.– 6”Œ<ÿ”CÿœBﬁ◊IÊÍXÈÒ]ÊÛ]ÈÒ]ÍËWﬁ’H›ÕDÁŸRÊﬁUﬁ€P›◊M‡◊N›œJﬁ¬E‚∞A‘É'ÕW“F“?”FÕT–i'–w3πv2Ö\$^R K^0Bg<HnGMsNVzVQtS>a@>cBChGFkJGjJIlKIoJHjG7R3/%,7X+RzEVÉHYÜM]àS^ÜRR{A>k(8j!8l!:n$4f!5]'L*N"6V12M.0I+&?85W%WC_åITÉ=ZåGlõWkòS[âA[âA[àEZÜKbçXrôjxùqqígiÑaI\F%3$(",,?,3F2':&1 6!)?*D\D;S;)=$'3-5 -1 ,3!3;,6A3HSETbQ$:%2J2@W;<P5?S:EY@TjUkÄorÖ{ããü™Æamm6F<)>-+D/=YC1J5JaQzâÜ}àåyÑä|àîò•∏ª…„Üñ∑ì¶«∞√‰†ÆÀßØƒ´£†ìtEût(¶y$tP t[ jx_@2 5AFaBDb<Mb*ÅÖ.çÖúå®ï´ì°âùÜävh]B> 06)1 GHwpÄn
+Çk|ezbåqêoåe çbÖ\ÅYÄY É_Å`~a }a Åe ál án äq ãqízn^ XT [`OY<L0K2R!2S(2Q(/H/F:O
+Obgvjx"!+ 
+!/7(DL4ozXoRXi=-%4-$&#%'"8:5653"$'ih>V4*C=W0-I!-Q%NxHNÅIIÄGKÄJJILÅKG}C<t79q29p/4k*8p/4k(<o-;l+6g&/_!0b#7i,Ex=Bx>-d*0g.+`*+`,<m>DuHKÄRDyMPÖ[PÑ]ZåfWäaXâ\JuJ*L++H*5.H-(D+(F,*H0%F+(I,9\<LvPLyPKzP@pF9g@BpICqLN|XAqK9g@BlF>];0?(S^M%3&QhXSu\Qz\JsUDpOHvRAqKAoJHxRFxRI{UH{RK{QJyKOM^çWhócÖ∞Éò¿õüƒ£ñ∏ù§∆Æü¡©è≤öí∂öà≠é}¢Å{ü{{°zjìi}®{á≤Ñt•nSÜDAv.Cw/Dx0M8YãD@t)@t)K5Uá@hñUVÖAIv1O~6M:MÅ9Ax'?v#J1Fx1aëUhó`_ãZhìfÖ≠àëπóé≥îé≥íå±èò∂î†≠èòäoßp\ÀÄmÀ~j¿u^¬{_¿{ZºxS¿{Rƒ{R¿xH∆ÉNÀâOœàPÀÄG»yAÕ{AÕy=Õ|;—ÜB’ëF—îC◊§I◊∞I‘ØD⁄∞D÷£8€û4ÿï,ÿë'‡ò,Âù/‰ú.ﬂó+œÄ”zœnﬁs+’n)œq)›ï@‚∑Oﬁ…Vÿ“Z’Ÿ^’·a“„a”‰d‘‰g◊·g÷€c’÷_““ZœœU““V“‘Y““X”—X’”\’“]—Œ[Õ√TÀøS”¬XŸÀ`◊Õ\”…X’»X–ªN…ÆC…±C–øM–ƒLÃ¿F øCÀº?¬∞2ƒ≥/¬≤)¿Ø#¿Ø!Ω≠ª©¥û∏¢ª£∑ü	∑¢∑¢π°≥ô≤ìµî±ê≥îÆë´êØñ¨ì´í¨ì´í™ë ßé ®è®ë©í¶ë •ê ßí•ê¶è§ç¢å§é£è¢çùàòÑ	ùä†êõêõëóãôèôìòîïìóñ ìñ#îò*ëó-êï/èï5àë8vÅ5AO@Q%CT4R`GM]C-D'+F#1L)/M'-M$9_0/Z%.[$/[&0\+BhA<b;-T%.V")S!(R +R#.U&.T%-Q#,P$.R$1U%;`-Fj:/N%3':$&>&#;!53#6"$7$ 3 /BUBNaN`s`\o\ATABWDE^IXt]sèvZsUH^7hu?ëíDìà,òÄö{ïz	°á†Ü¢â
+°à§á§É§Å™ÑßÄ•w ßv •y ≠ÅØÅßv ©w ≤Ö±ãØê≠ì´ì Æñ Øó Øñ ∂ñºêØt ±b «j∏O ªM ¡T¡`¬r√Ü…†√§ºüø†
+ºùªúø§≈≠ƒ±¡±«Ø«¨√£øüƒ•ƒ®ø¶∆Ø!«∞$…∂) æ.Õ«5–Œ=”–A⁄”G‹÷J‡‚SÁÏ\ÁÒ]Ê\ÈÌ[ﬂ‹O‹”H·ÿO‚ﬂTﬂﬁR‡›R·ŸRﬁ‘PŸ∆F‹ºEﬂ¶? m»PÃDÀ@…G X$æa(ôZ$jS!LR$>Y.:`7@i?KqLfâinësVx]ImQDhNGkOUw\KnNIoJHlH?Z9/"!
+5Kl?QzB]àPoñgmìdeãXQ}@Bq+=q&H~37k#6` )P2V*3S.1L+0I+$=685Z'Ox>VÇCXÜEdìMhñNXÜ=eêIqõYoò\eçXfåY`ÑT_~T>X5 2)+%7'/B/1D1':&"5!"3!!4!4#9$<T>FYC4@,18&2:%5>+4?/2>02>01B0"8#6N48O35L08O3?V:G_E\s_bvmpÄ}àîî\hd2D8'>,/F23L7&=)VkZ~èâú™´¢±∏≠ΩÃ≤¬€ë¢¿àöæ•∑›¨ª‚©∑⁄´¥—®•¨†ãpú|Iìr-lP åtêyÉjE5 '2?X8@^<@Z+T`nq wryoxksd	l]XN96 ,2$/#/59 qk{l|h	wc
+lW w^ îtíkÜ^ ~Y zV Ä[ ÑbÑb Ñb Ñb Éc än ëvçs êwêyUH W[JZ7L2M,L6X&8X)1L1DJWozëò$™¨1¶•&"5-0=,&/5'CG8NV?YeM+	!495=?<///#)<)råo,H:W)8Q)5N'9U/Be;RÄONÄKMÇNKÅMNÑRNÑPBy?5m05k-6m,3k*8l.<i2Fq;Cn8Dq8;k1Gz?Cy=-e(-c'*`&.c-&Z)EyKBuJKÄTF{ORá]QÑ[Uà]Yä]N}O&O#-L*+D'21I3/K2*H.*J2(J1'I.0U69c?DsIJzP?rG<lFAqKJxTIwRFtM>kDFnIMlJPdH1>*%'7,Ql[Tw_P{]BqOFuQCuO?oGCvMJ|VI{UL|VM|RRÇRXÜWXÅUuõvùø§û¿®óπ°£≈≠°√´í¥úÉßãáÆèê∏ñw†xoôkeë^N}Gköceï[_íPdòPF|.D{(6mMÇ2I~.<s 5lAu-QÉ>köVdëNUÑ>M|8TÄCTÇB>s#;p;o$]èJfñX^êUXáSfîeã≥éè¥íî∑ñè≥èä≠åã™äí©çß•éß|kª|k…àt ëv…õwÕ§x–®w÷≠y‘¢o‘°j◊§k“ûd÷ûc’ö^œëT äLÀäF…âB—ëG”îEœí?’†D‘©Aœ•9‘ü5…è$–í%‡†2Êß6‡ö+—~‘z€Ä#…n’t#‰Ä4‰Ä5»q!’ô9Á¡T‹…Qœ L÷◊X÷›\”ﬁ^“·b÷‰i◊‚jÿ›g’÷a‘’^‘’]“÷[—◊[”Ÿ_‘’]”ŒY–…U’Œ\‘Ã]“»Y‘∆YŸ«[⁄»Z‘«W—ƒR”¡QÕπHÕ∑GÃªGÕ¡IÕ√HŒƒHŒ≈F…ª>≈∂5≈∑2√∂,¬≤'¿Ø!¿∞∏¶µ†Ω®º¶∏§∑¶∏ß¥£±õ	±ï≥î∞îµô
+Æî±ôÆô¨ó ≠ï¨ì≠î®í ¶ê ®í©ì®í¶ê ®ì©î¶ë¶é†à°ä£å§ç†ãûâ
+òÑûåùèõêöêôèôëóëóìñëóîïï#ìó(êñ,êï1åë3Öç8cn)=JGU1JY<9G-;N2*C#&A/M):Z5Bd?Ah<1]*)X"(W#/Z-DiH;`>.U(+V!-U +S)S#.U(.U(-R&+N$,P$/U$9_.Dh88W.', 6"8! 6."#) 1!):(DWDTgTi~kN`PPeTUlZgÄkrãviÉjayYVg:àéHìå4í{ö}óy£à¢ä†ã¢ã•ä•Ñ§Å™Ö©Ç¶z §x ®| ¨Å∞Ñ©| ¨| ≥É∞àØã Æí≠ì ØóØó Øó ¥õªõ
+∫ãØi ∏` ¿\øU¿Q ºT ¡e ≈}ƒîƒ¢∫ùΩ§
+¡®∏°∑ü¡¨√¥√¥¿´ø•¿§ƒ®√®ƒ´¿©ƒ≠!¬™"«±(…∑- Ω1–«:”ÕAÿ“H€◊Oﬂ›T‰ÂY‰Ï[Ê\ÊÓ]‚ÁW·‡Rﬂ‹Oﬁ›QﬂﬁRﬂ‡V‡ﬁW›ŸT€“Q◊«M‡¿Qÿû=≈p ≈TÃP MΩN °S#ÅU&WS&@U*<\5>d=6_7BhCY{`tñ~sîÅkäzeÑtXweVx`GiNEjIGkGJhF!8-G$Bg1Ox<aâTlí_nîceçXR~?Bt/UÜDK|;Am.4[$7[/0P+2M,0I)#=!;;"A%I6]&Ku6VÉ>`éCVÑ9eêKwüarô`iéXeáT]zL8P.0(,+@-6K8/@-(9&.++,./!7"/E0I[E<K6(4.:&4C0/@.2@/+<)%;$>V<BY?'?%*C&9T5ToPay_Yk[Ue[K[Q9K?+=-$9&(=,)>++>*EXEN^Tiww™ª√Ø¿“æ–Ë©º⁄øœΩÕÔƒ‘ˆ√—Ù¨π€Ø∑Œ∂µªõïác]9f]"å}*è'}kND>G>T.;S/8Q*>S(GX+R_1PY*<B4613.2&0 -."0+3]]tgtc\O	F8 WC ìwïqvR kM kO wZ Éc åiëoèmçm ís ô}úÄùÑöÜ^U [d!<S1L3Q-M;[)9T=Nqvôñ≥®π¨ø±ø±63%(:$;L9 08-LVK3?5%,1-7<89;8"$##*#AYAaÅ\*K7T(3G$9L,4I*4R.8_3L|JNÄMOÑPLÇNNÖNOÜL>v74j,4h*3d,5a.>)I"/R(KrEO{HDu=0f*,d%&\ 0f,+`*+_.I|QBwMHÄSBzMSà^RÖZTâ[SÑU<g9$I*E$&=#"+>+5O6.O2,O.-R0(K+,Q0GqKKzPEvIBuJAsMDvQJyUFtOFtMBlDHnGkãf:R0%5-D4Uu^S|^KzVBtNBuLBuJ@sHDvPK{UR~[eèk_ä]bç`Ä¶Åû¡£¢ƒ¨†¬™óπ†qñwóºõÉ´àqõuiîi™}oûj[ãQXäKRÖCK~;XãF[èEXè>D~)<v8p;q>t :t6m:l%P~=nö[iìT]äIVÄAEl7Bk1>n$8m>r'ZéFPÉ>LÄ>UáJgñ_w£rrúnz§vbâ]]É\É¶Öõπù¨¥ú±íÄ≥Äm√èyŒ°Ç”≤â÷∫ä“¥Ä ¶r√òe√î`¡éYªáNºàL¡ãM≈ãL’ôZŸûZ÷öRÿñL÷îF‘ñ?“ö;◊¢<Ÿ£9€ú3‘è'◊é%€ì'€î(ŒÑ«o«j–u·á/ﬂÑ3Õw$ƒt–ë0ﬂøN‹—U’‘Uœ‘S’‹[—‹\‘‡d◊‚h◊‚jÿ›g”“^»≈P”“\ÿŸa‘ÿ]’Ÿ`’Ÿa’‘`ŒƒSƒ∑G“ƒW€ ^Ÿ«[‘øTœ∑KÃ∂I”¡Q’ƒR–ºK–øK‘≈N—≈KŒ∆IÕ»H–»IÃ√D»π<≈≥5ƒ≥1ƒ¥-ƒ≤*¿Ø#º©Ω´æ¨Ω´∂¢∂¢¥£∑¶¥•≥ü
+±ï≠é ∞î≥ô±ô∞õ∞õ¨ô ≠ó´ï¨ñßì ©ï™ñ®í°ã ßë ©î®ì®í¶é†áüà§ç•é°äûâ	ñÇûåûêõêöèòçöêôìòîóíòï ìì!ëì%êì,éí1ãê6|Ñ7N\DU(WfE_oU);!5I-*C#*E"LjHUuPPrMEkB3_,,[')W&.Y.JoP;^>.U(+V *R(P(R"-T'-T(*O$*O$,Q%0V'9_.Cg7@a6&	).4"5"3 + ")<(1D08N9:P;PeRG\KF]K:Q?:S@:S@9R=:T;CX1s}AìêCî&ô|ñz§â£ç¢è°ç•ç	¶à†} ¶Å ´Ñ¨Ö® ß~ ´ÇÆÖ®{ ™x ∞~∞Ö±å ≤î±ó≠ï ∞õ ∞õ ≥û∑†Ωò	πÆa øb¡YƒWøU ¿\ ¬m¡Ñ≈ö¬§¡™¡Æº¨π¶
+∏•ø∞ƒ≥Ωß∂ú¿§«¨√™√™≈Æ$¡©!√®#¬ß"»≠*»±-Ãº5–∆@“ÃD’—K⁄”N€◊Q·‚VÊÎ[ÂÓ_‚Î\·ÊX‡„V€‹P’÷L‹›UﬁﬁX€ÿU€÷XÿŒU‹»WﬂºT”ö@Ãu.…e*ƒY+ßN"ÇM!bO$O\1>]47Y6?e@=f>=e@CgKdÖpuñÖtíÜrêÑqêÅVvaGiNGlKIlKEbC"6!
+(+HKp:U|EdãTeåUdçSQ~=P~=aèO_çOWÄF?f19Z/0N*0K(0L&%A%B$D%E#DA$KGo0ZÖ@Ny4aáJeàRjåYeÖTUpC9R*0(-,?+5K6+A,$7!(:$#5/.-./25 (>'=Q8CR;1@)5F30C/.?-):(*=)(>'*?,0H23M24Q2Db@[vW^t_9K;,>.'<+'<)$9&4!#9$:Q7?R<DVHBUS°µæ£∏À©∫‘∫ÀÈ∆◊ı¿œæÃÔ∂ƒÁ®∏Ÿù≠«ú©º~âçMXGLT+VV\X^X889EDU+BS'=N$8L'>V6F]CI_J?QA3A0&5"!.--!1#2$0
+14JEKB?5 D8 gR ÖjòwtT y`oX z^ Üf îp òuòuòxö| ¢Ö•ä§çöãkhKY2L4R 3U#.O :X$3K`l∞≠*µß	Õ∏À¥Ãµ µ *M%2.H_C(9&
+ %!$*&>IAKYL$2%!1:57<802/! .8-MhGMqE7V,,D 8F,6B,/A' 9;(R$1a-9l4<q9=t:5p00h'1e%'W%I3 %8$I.])*]"']-`%-`'+]*2f6F{O>uKHÄS@xKPÖYTâ[Uç\+_.-V*&F(A#(<#(+C)2T/9c3Fp>&M!3\2LwLFuICtGDwLCvMI{UApLP~YCpIDmETwO[zQ:V.%:
+.FbKMtULzVHxRCvMFyNBuJFvPKwTzûÇ∞“∑vûyà±âíµîöΩùfâk~£ÅpôoWÉR]çYUÜO[åTL~AUâITâEPÖ=aóLRà=OÖ9Cy+JÑ0Má0<w9t6q5l5o5o0f4f!Fr5fçXdãV_ÜMZÄGAa07Z$:g"5h=t#IÇ1B{*F0Sâ=WãCWåHPÑBL|@\àSy§wå≤ãí¥ì™∑õ≤ûÜ±çuÀ¶ã‘≤è–≥âÃ≠¡õl¡íd¡ã_√ÜZ«á[‘ïbŸõb÷ò[“îW◊ïX’êOœàFÃ;ŒÖ8‘ë:÷ñ5’î0€ñ1Ÿã'€Ñ#Õp¡b√f	ød…u›ç,‹í1‚ú<Œâ*«å(Œ¢5€¡J‹”TŸ‹Y÷‡]’‡^’·c÷·g÷„oÿ‚oŸﬁh÷’_–∆SŒ√P”ŒY‘“[ÿ”^’œ]÷Œ_“∆XÃªOÕªO‘ΩSŸ¡W—±J¡†9«¶?÷∫O’¡P—¿LŒøJ–ƒLÕ√Hœ«J–ÃNŒÀJÃƒEÀ¿B ∏<∆∞6øß)≈Æ,…±-æ®º©¡±¿ÆΩ®±õ
+∂ù∂†∏§∂•¥û
+Æè≠å ≤ñ≥ö	∞ò≠òÆô≠ö ™ñ™ñ¨ò®ó®ô©ò©ì§é ßë ®ì®ì®íßè¢â¢ã	¢é	¢ã†âûâ	õá
+üêüëûêõçîÜôçöíñêïêîëìë"íë%èë,çë3áä9ir/Sg4UnGSjMG_E&>$GaF)D%2M,`}^XwUSsLInB5a./^(*Z*3^3FkJ3V5-T%-U ,T*R*R -T'.S(+P%+P%.S'.T%8`.Bh7Gh;+.E)(?"20#4!'6#0,C):S63P27T6BZBG_IC\G6Q>4O<6SA9VD9VB9VBB[=Zj=åéOé{,ózò{¢à£è°èûç	¢é	¶ã°É §É ¨ä≠ã©Ñ ®Å ™É≠Ü™ ¨x ´w ∞Ñ≤çµó¥õ±ô±ú≥ü¥¢∂¢∏ùøï≥w ±] ¡_¿[ƒ\¿V º[ ªj ≈ä…¶¡Æ¡≥¿≥ºØ∂ßπ•¿™ø¶∏ùµï«™ ¡ßª°√ß"æ°≈®&¿û øô∆§)»∞2Àº;“…F’ŒJ◊ŒK◊ŒK‹ÿP‰ÂY„Í\„Ï]‡ÈZﬂÊZﬁ‚W◊ŸQ⁄◊T‡€[€”VŸœV‘…V◊∆ZŸ¬Z⁄∂X÷õM¬|>Æf6ê[1iX,JV(Hc8@e<6Z6<a?FnICkF<dAMqUoí~vñâtíÜjâzQq\@aF?dCFhGE_B/#
+	/Je<UwDV|?Q{9SÄ;Ix0N}7díReëV\ÉL@a26R,-H%0L&/N$&G&K*O-R-R&K#E)K8]'2W!?_.<Y-Kf=Ld@1F'!501"4*<&':$&<%$8#: !8!8&=#'>"0I,0I,2H1-C,$:#3J0ey`ZnUViUmÄmARB/=.1B0@RBXj^LaR5O66S59W5;Y76N4*@+$:%5!2I5)B-7!/I0ZuVSmPC\I=TN°π√πœÊ´∫Ÿ±æ‡∞ø‡ï£∆Yeç^jêfwìMbsI`hKa_CZJ=T8;M'9H;G4@:GHT$W\$UXHPCT*D[?E`M,D67N>4G40-!/$2 .($"(-, C; ziò~õ}õ{ãn íx	d Üj îtü{°{ üy ù{ û †Ö¢ä°èÖ~Z_;M1M>`-1V#0T$3Q-D t~ø∑( ∏œ∏”ª“º“Ω-R)6-L*JdG
+
+&4'GQH!(!.21&,(:F<R_U?LC7@;:?;13.&+'3?1Fd@<`4-K'.E)7F1/>).B'8V2Di=Dp=Fw@I|CG}C>u;=u6;s2:n.F#C8"	&+82W,+Z$-`%&\ 0c()\$7l85k:GRB{PGRH}QKÄTRáYVåZH%K"#A 9!8#
+)#ABh7Hv8Ar14a*-Y&>l=?n@DuHH|NGzOExOEuOEsN=gAJpIcÜ\;\1Cd7'C
+"*=*5O67Z<HrNFsLEsLGvLEtJHvOR{YÅ°âèØó^ÉbYZVyXVyXW|ZLtOHsEGwCJ{CI|AHz?NÄAEz4C{0B{,D~*B|(>x#9s=x8u5r5r3p1l0l0l+d/a9e&Io<_ÉU]ÇOZ|JcÄR;^(<g"3f=t!A{&A}%GÉ+LÉ/Qà5MÜ7HÅ4VãC^ëOfï^sün|£wî©Ç¶ù~±ñy…¶ä—≠çÕ´Öƒ°w»õqŒónÀäd√{U¬wO≈|OƒÅJ√ÉF…âKÕåLÃÖC…~:—Ç=⁄é@’í7œè-Œä'√{Ωm
+ s oƒg
+Õrﬁä*›î.‹õ3–ï-⁄•;‹∞EﬂæM‹ N⁄’S◊›Y÷·^÷·aÿ‚g◊ﬂhÿ‹k◊›o÷⁄k––^Ã…T—«T‘ W÷œ[’–[—«V“∆V‘√W“¿TŸ¬X€√W—πMŸΩR–ØFŒ≠D÷∫O”ªM‘√OŒ¬J”…PŒƒIÕ≈H–ÀKŒÀJÃ«EÃ√B∆∑:≈Ø7≈≠3≈´0À≤3ø¶%æ®!¬±#¡±æ©π£∏üª¢ª¢∂†∑°≥ôØé∞è∂ö
+≤ô≥õ∞öÆô´ó ´ó≠ôßñ ©ò ßò®ò©î™î™ïßí®ì¶ê•ç	§ç§ê£è
+£åûäûâ	†éüíüíûëõåôâöåõèñçïéíèëè ëê&êê.ãé7ÇÜ<U`&jÅWKfE8U7:W9'D(YvX'B#-K)Cb@6Y16Y/0V'3^)1`*-[,6`8@cB/Q,-S"-U *R+S*R .T%2U+/R(-Q%-R&0V'7].Ag6MqC/3&= +B% 4+"3 ':$)B%3P14S3?^?HbIJbLHaLZubxïÉÇûèÖ†ëâ§ïÜ°íÇõÖáözíögêÅ<íx!úÄ¢à¶ë°è¢ë£ê¶ç§áßÜ¨ã´äßÜßÇ ®É ¨Ö≠ÑØ}§p ±Ä ∏é∂ò∂ù≥õ≤ù≥°∏¶∑®∏§ª†ºê©c ªc¿a¬]≈[ªV π] ¿y«ùƒ¨¡≥æ¥º±∫¨¥ü∏ü∫ûΩüÆçºõ¬¶º†ºùæü …™-»§)≥Üƒó$«ß0Àµ;Œ¿C“…H’ LŸŒP€“O‹⁄S‚‰\·È_ﬁÊ\€Ê[ﬂÂ]›‡[⁄ŸZ›Ÿ\⁄‘\÷ÃY÷»[‘¡Z÷æ\⁄∏_’§X∂ÇF†tGÄhBXa6=X-Ad:FlE?bA<_>FnKIqLCkFEmKNq[cÉtnåÇiá{Qq\@aF:]<<^=:Q7,#	
+//H!;Y'=c&Ju0Lz1Jz0TÅ<_âJTyE<]0/J'0K*1O)4U*/T!-T4\ 1[1X0W"7\)2S$)K4T#1N"!;0/00#6 &9##5 3#6 $;!$;!#:#: #: ';"5L2B[>A[>CZ@AW@9Q9>V>h~gPfQYn[k}m`qa:H;BPCN[QScYWk_.F01N2/L-,G()B%'?'"8#5-D0'@*5OlP^{\SpRLgT:SMå§Æ±∆€û©≈õ°¡√ÕË…‘áëµ3@b.>U3IT:TS=XO;WH7T>2N50J-.G)-B!0B4ADIUVY\%MV)F[<F_J 8*1G:/D10$3"2.($',(+ kaöÑ™å
+±è´éßã•ä	ûÇìs õx ®Ç¨Ö®Ç§ÅüÅ õÇôÜãÅotFV2K:Z(Mr>/U",P -K2IR] ≤´”¡÷¿÷æ”æ’¿*P)@?^<-G."Tc\iyl(4(+-,(.,+43AJIS\YCME,6-.8-0A.>\8.Q)-G,3I4/D3*B,8Z5T~NOEMÅCJÄDEzBAvBF|HLÉJF~A?u7II%J%J>8B1[)1a'-`%*]")\$5j48n<;sDHÅVE|RNÉWH}QOÑVQÖWJzJ@#F ;8+J!8^+9e*Iv5Hz3I}3E{0Cx4(\:k4@rAG{KG{MJQ@uI=pE2a7<b;`Ñ^8]4Dk?Al>(M""#4!-C,,F+'D&-O.9]95[4EnDAlA?iAHmKtíz´…±íµïñºóê¥êì∑ìè¥ìÇ™à{•Åpùtoùomõm|ßzÇ±}hö[NÉ;LÉ0B|%?{#A}#<w:u6s4q:x9y7u7t5r6p6m:l'9_,KoC`ÄWPoEUuFNt;Dr*;p ?v"E(HÖ(EÇ%DÄ&IÉ,Lá3JÖ3MÜ9MÖ:RáAWäGXàJläTÑÖ[ßéo≈õÉ–ûá»õ|∆öw∆ík«âb√yV¡qL≈sKƒwI√~G«âLÕîOœïL…â?¬}0∆}0 Ñ/√Ü)Õì/Ÿ†9Ãè%»ÉÀÑ‘í$‹ú.÷ñ(’ó(‹§5ÿ§6“¢3”Æ<⁄≈N‹“VÿÿV’€W÷ﬂ^ÿ‚eŸ·h››k€”h÷…a”∆^’ `–Õ\‘”_ŸÿdŸÿd÷”`—ÀY÷Ã[ÿ»Yÿ¬U‹¡V’πNœ≥FŒ∂Hÿ¬S’øO”¬P”∆S’ÃU‘ŒT”ÕQ“ÕO–ÀM—…JŒ∆G–…Gœ∆EÕæ?¡≠2¬¨4»Ø8Õµ;ƒØ0Ω©&«µ-∆∑(¡± Ω§∏ùæ•æßº£∏ù¥ò	¥ì∞å¥ì∏ô
+∞ñ±õ∞ú≠ó¨ñ≠ô≠ô´ö´ö©ò®ó®ñ™ò´ô	®ñ®ì§é§ê	¢é¢ê°è¢é†å	ùå
+üëúíùìùêõåõãúãöâñáñåîéëè"êé'åã.Öà7tz:<JSiCNkLUtTZ|[$C!8X3%C!(H#0U*/V'.V$'O,W!/[(.Y,8a9<`<-P(.T!.U+T-U +S.T#2V*1Q(/P%.R&1U'7].Ag6KoA7204$;!0,,D,/L.8W8<Z>:V==U?JaM8Q>láxè©úí¨°êßüë¶üî©†âûèÜúÖëùuëãMé{,õ~ †Å©í§í¢ê£í¶èßä¶Ö≠ä™å©ãßÖ ®Ü≠à≥å	≤Ç°m ™t ºç∂ñµúµù∞õ ≤†∏®
+∏™	∏™∑§ø†∑ÅÆf øgæ] ƒ_¡^∏W Ωlƒç»•¬≠∫≠∫Øæ∞∑¢≤ò∑ñøú∂ìÆåæùæü ∂îΩû!«©-»•-∏ÑºÜ«õ.À™7Ã∑@–¬H”«O‘ O÷ŒQ’–P€€Y·‰aﬁÂaŸ„^‹ÊcﬁÂcﬁ„e⁄€cŸÿdŸ”e’∆_–∏X‘ØW–üRƒàJ®vEêzUnoMQf?:Z3GjIZ^FiI9\<@cCKpNNsQFkJHjQWxepéÑoçÅTt_DfK?dBDcC,@'&
+"2Lm4Q{3L{+Jy)Lz2Dk47[/,L'2P.3Q--L#1R%6[':d%:g&2` 2^!Aj2PwB>c/?a/:W+"<.,*)!3+='"4"5$;!$<"%=#%<"&=!';")%%8"+B(2H14L64M8Yr_wãk}qM_Sdvhçùêâñå\f^PZRJWM;M?/D1/G/,D*"9%<"&<%!4  6!5 6 +C+?Y>RmNRlQazgG^Xràì†Ø¬êí©Åîêî†≥ª»¥æ◊¨ª“xàò2EI4NC5R>5R<6T<3Q70M//J+*E")A*@*;1=KOPV(HV3DV>"4$'<-':$!5!3$6%90- .$/89 îÜ™è
+µï∏ñ∑ó∏ö∏öµî©áüy †x ©ÇÆá™á°ÇöÑ
+ÅwbfL\2L0Q>c/7]*,Q*L-K,H6G wx»Ω'’¡◊¬‘ø’¿+M*%D"B\?+*94nzxdti&$&(#++)&&&&'+48;>BEEKKMWOEQC3D14K/8V28U6EZGCXI@WGJhPU~TQÇKNÑFIÅB@w>>t@NÇQVäYOÜOLÇHJÄFL/],LxGM|HAm:9c3'S )Y,^!,`".a&/b*CxD9o>E}PIÇWF}SPÖYGzORÜX4c7Cl@C#C<3Ae5Dp1Gy0H{./d@w$E|+E{0Cx4Ct<CuBI}LI}MAwF?sC-^/6c8GlCOrJ3Y0@k>@p>FoC,!8&>$$>! ;#A%E %H ,Q&0W+3Y20S2:V?zñá®ãkèkqñm}¢yé¥ç¢ ßõƒ¢ë∫òä¥êÅ©Ñîºôâ¥ânühLÄ>F|0?v%IÇ1Rç9D~)<v3o8tDÅ$<|>{<y7t;x9sEy.Dp59_.Fi?Cg9<a+Gq/>q">u!>x!DÄ&AÅ#CÉ%Mâ1Uë9Nä4Yî@Sç@SãBSàBVãGPÇCYFzÉVêÄ^≥Ön«éz«îw…ót în√Ö^¡|Sƒ{P…ÅQÀàQ–îVœôS”¢V’§UÿüNÃé;–é8◊ó=›£B„ÆF‡™@–ò+‹û/€ü-ﬁß2Àò"–ù'÷•/Ÿ™8”™6”∞<ÿ¬JŸ‘V÷€Z‘€Y‘€Z⁄‡d›·i‹Ÿh”»^Œ∫WŒ∏UÃπR”≈Z€”d‹Ÿfﬁÿh€”d€œc⁄…]€∆Y⁄øT”≤I’≤JÀ¨@”πK⁄ƒTŸ»T◊»S‘ÀR“ŒS–—R“—SœŒOœÃK–»IÃ√DÕ¬B—∆F»ª;…∑9…µ:À∑>Œ∫AÃ∏=∆¥4 π7 ∫3≈¥(¬≠ ¥óªú¬ßΩ£πûπô≥èµë∏î
+πò∞ë±ó≥ù	∞ü	Æö≠ô≠ôÆö≠ú¨õ®óßó™ö´õ
+™ò©îßë¶ê¶í£ë	§í¢ê§êüå	üé
+ùëõëöêùêúèúåõàôÖîÇïâîåíé#êé*áá-}Å5aj34CBW8RlQLiK9X8+I'1O+$B$D-R'-W),S$&M(R",W*0X39a>5Y5/T)/U"*S)R*R*R-U#1U).R&/P%-Q%1U'7[+?e4LpB%C)D# 9/074D\D;X<6S7FbI6O9C[EF]ID]JnÜx|îáÉöêÉöêvçÉîãmÑtd}gbsOvyBèÉ;ó}&ú|™ê!ßí¶î•î•ë©éù| ©Ü™å¨é¨ã®à≠ã≥é
+¥â	©w £l ∑Öπï	¥ô∂ú≥õ∞ùµ•∏™∏¨∫¨ºß¿ô∞v ≥e ºb¬e¬eøaæhº{∆ó≈¶º®ΩØ¿≤ª™≥õ¥íΩñ¿ú$≤è¥í¬†%∫ö∂ò¡•*∆£-¿ç ∂}¬ç% û3À∞?À∫FÃ¿Jœ∆O’œU‘–U‘”Uﬁ‡a‹‚dŸ‰dŸÂgŸÂi‹Ân⁄·oŸ›o›⁄s⁄ÀlŸæg‘§ZΩÖH¶n?õuP}xZ`pSNiH=_>IkPjåsMnQ>_@<_?KnMPuS[~^OrTQqZ_~ofÖvNpXDgIBeDGfF(:$'		:P)Ik/Eo'Fr'It/=d/3V,0P+3R01O+ ?!@%F6]$Gs6@l/?h.@g2QvCIn;Bc4:V.*D!&=!%9 2++%7#6 $;!$<"#;!$<"'>$)=$#2)/,+!7"+D/]ueÅíäwÜYi_m}réûìì†órxvAGC9E;0>/)<)(>)/B,)=$':$#6 1!7"441I/4N3=V9QiQzêÉj~|rÑéü¨Ωîï©jhvlps~Üàçó°Q_jkxÄ7GD0G50L31O53Q74P7/L0,I*+F#)D!+E"*B);09=DDP,?O4$5#0"6"6 2 4/F)0G*%7!0*3GE °é≥óªôºõ ΩúΩüøûΩõ¥è∞ä®Å ¢z ü{ ûÄîÉ{ioSg6S*K>a+:_,0V#(M&F&C#@(> 8? ™•#Õø’¡÷¡÷¬%@!:S6"5!(21nxw7A9!).1**+%'&"00.446=<A@?D<=?AHAESBAZ:8V07U15M35E82B82F:EcIZàZLÅI>x>7p9CyHSáYQÖWVäZUäTQÜNM~GFDtDQÉRSÖRSÜNTÖNFy>@v8/f%.b"1e'<q9J~M?tFJÅWLÉYE|RSà\J~PJyOE5X0.N'%H .Q)<"FAn-PÄ4Du&2c=qH|)H|18k)+Z$IyIJ|KDxG<q=:l9,Z+>e9X{Q4W-:c7<j;>l;7a3 ;555="@%E(H-Q%5Z/1U/*L+&B)/I0C`DTsQY}Q\ÑRaãYjîfÇ™áû≈¶è∑ïà≠åû√§Ñ¨âgógNÅIWâNaìViù_kü]YéHJÄ58q"B}+HÉ1Nâ5LÜ/>z ?|={=zIÉ.NÉ;>n05`*7`&Fq*Fw&Ay =x>{?!?~#DÖ+Rê;Pé9Lä5VëAYëJdòXgöalúh^é\nîeÉïkäÇ^´}eƒàp¡ènΩåd¿ãa»ídÃîc»î[–ü]◊´b÷≠^ §QÕßR“©Q‘•MŒõ@“ô?◊ü>‡©DÂØEÿü4“ò*Œì≈ç–ú$‹©3‹©3ÿß1”®5–≠9◊¡JÿŒSÿŸZ”Ÿ[÷‹^⁄‹a‹ŸfÿÕa‘æY–∂U’∏Z”ªY”¬Z›—cﬂ’d‹–b›»_‚≈_‹∏W’≠Kﬂ∏S⁄∞LŒû<œ£@◊∏Nﬂ…Z‡œ]ÿ…TÃ¿F◊œS“”S–”P–—OŒŒJÕ∆DÕ¬BÃø?”ƒE ∏:«µ9 ª>ÃΩ@Œ¿EŒ¿EÀΩ@Àæ>ÃΩ<«¥3ƒ¨(Ω°¥óƒ§¡°Æé∫ò∫ñ∏í	∑ëπòµñ
+™ã ≥ô≥ù	∞üÆù¨ò™ñ¨ò≠ú´õ¨ú´õ≠ù
+´õ
+™ïßê§å®ê
+¶í•ë
+§í§í
+†åüå	°ë
+úéúèöçôåúéöåúãôÉôÑñàïç"ëå&çä+ÇÅ/mr0BO#7H(BT<;N83I20H.8Q49T5(C""@-L*;_;<_>9^<4\:0X61Z:9`A/U0.U)*T"'R&Q'R)T-U#0V'.S',P$-Q%0T&6Z*=c2Jp?0P'7#< 737/E.QgP;R8.F,7Q69S:D\DYoZ_vb]tbZq_ZrboäyTq_Ro[^|deÉgKe@_m<ÖÖEïÄ1ú#•ä!©í®ñßñßï©ë¢Ñ®Ö®á©ã≠ë	¨èØè≥ë≥é	∞Ö•q ≥Å∑êµï¥ôµú≥û≥†∫¨∏´π¨∫ßΩ°∑àÆk æp√tºkºd øiæu¿Ñ
+∆ö¿°ø™¡≤#∫≠ ∫¶!≥ê∂éªï&ºò(≥êµïæ†(µò ªú'¡û*≈ñ*ªÑ¥v»ë-Ãß<ÀµE…ºI √N“ÕW“–Y––X÷⁄aÿ‚h÷„m’‰o’„qŸÂw⁄„zÿﬁz€⁄~ﬁ“~⁄æuœõa™qDàdBé~dxÇj[u\RqR?`CTu`qí}aeKjK=`?FkINqPY|[\}^JkPFhPDfMBeGCfFEdDC]@$5"&!	 33P"=c*?d.<]26V/3S.6V/4T+%D"A#B,M;\-?`1?^2@\3A`7>^54T--K))D%";%<""92.!5&=#$= &?"%>!&=!(<!'6!&##03,'*#8%=RCsÑzwá}Zj_Zj]iynÄêÜYb_;A?4>50<0*8)&7%+>()<&'8%"5! 6!!9#6"<!6S7;X<VpWXo]oÖyxåãäù§¶≥√}Çïnr~GQP<IBçòîgqp0;5+8..A-,D*0J/.K/3M2.H-)D%'@ $>'A(@(<)7&4/@ 4G+':$1"4 22-2"9$8"28Bli®îπú∫ú ¿üøû¿üøûøû∏ì¥é±â™Ñù~	áuhiXgJfAf<d1W1S -N'K)M"A!>97'7 jmƒ∫”¡	÷√ÿƒ/C'TfN&'&AJI%/'&-%#"-.)./*;;9===<<>8:9@JA@R<8V09Y0A\;!7 #0'(!-Vy[L|L>u<9r=IÇOQÑYXã`^ídRÑSUáTVÜR.\-MRÉTNÇQNÇQTâUVãUUãQNÜG>v54h*1d)J|IEyIG|PLÉYKÇXG|PQÇUQÄT7d;E0R-:Z34Z11Z.4Y-.V!Et.PÑ2RÜ3&ZI~&MÅ,1dP4`+P{MDtD>p=?q<.^*5\-Cg;@d85Z.<j9:j87g3F026!;$? 'B,K"1R'4X,6[01V-)K(.M..K-0J-EcAOpEOsCT|GbçXdçcà∞ãoòpròs~°ÄÅ¶Ñ}ß≠äµäá≤Öu£tlõg[çRVàIgúXUçDSà@ZêEJÄ2B|(HÑ*?|AÅ!HÑ,KÑ7;n+0]"<h)O3K*GÄ"=z?{!CÇ)EÉ.B/KÖ9UèE\ñJLÑ=WãMp†léªêã∏ëä∂íë∑í†∏ñ™©äßeƒåq”£–£yÕûp—°p“•lÕ°bŒ¶`“≠_—¨[Ã¶Q“®T”•OœõEœò>“ó;–î4…é(ƒäÕë#“ñ$⁄ù*‹°+Ÿ¢+÷£-Õú&…ü)“Ø;€¬K”…N÷’W⁄‹aŸ€`‹⁄c’ŒZ“∆Z»∑Oœ∑S’ªZ◊Ω\ÿ¿\ﬁÀb‡Œb‡…_ŸºV“ßH…ñ;…ê7◊ûD⁄•G’£BŒú;⁄∞J€øR’ƒR◊»SŒ¬H—«K“ÕM——M“‘O––JŒÀFŒ«Cœ≈B—¬CÀπ;…µ:–ºAœºCÃæCœƒHœƒHÕ¬DÃæA∆¥8«≤5≈©+ºù¡• ≈ß!≤ê
+≤çΩòøõ∑ë
+Æä ∫õ≤ï	≥óµú≥ü
+±†
+±ù™ñ¨ñ≠ô≠ù	¨ú	¨ú	Æû≠ü©ô™ï§ç§å®ê
+¶ê	•ë
+§í£ë	üç†é¢íüë
+ûêùéúçùèõäôàòÑòÜòå ñç&ëã)âà.||4KSAS-E\@I\FGZFI\HDWA8O5?V:2K-'@"*D'.K/0N45U=9[B<`F>eJ;bE6[:.T-*S'(R$)S#*T$*T$,V&/T(/T(-R&-R&/S%4Z)?e2Fl;=^346";!9&>&J`INdMCZ@>W:9T5;Y7C^?C]@>V>:R<:Q=JcN|ôÖsì|yôÇbÑkTwYKjHE[4]e2éÉAñÄ-ùÉ$©é#ßí¶î®ò©ï©ç•Ñ™â©à∞îØî	≠ê±ë±è∞ä©| ∞Ä¥å∂ñ∞î∂úµ†≤üπ©∏´∑™ºÆø™æû∂Ä≥u ≈Ç¡y
+∫l ¡p¿r∫r¡Ö√ñæ†ø¨"ø≤(Ω¨*∫õ&∞ä≥ç"ºñ+∏í%¶Öªú(æ°,∑ò$Ωô)√õ,«ñ-¥u∫~∆ô2Ã≠AÀπK«ΩL ƒT“œ^””a–‘cŒÿh”ﬂq”‡vœﬁu÷‚~ÿ‚ÇŸ‹Ö›÷ÜﬁÀÜ‘±w∂ÉVëeBkZ>qu^rátjásnåtEeNYxhyòàlärQpQGiFBfBJmLNqQaccÑiMmUEgLEhH@bA=Z<-D*'"#!$$
+%89U-<]2>\66T06V/8X/Gh=6W*/N"2Q%0O#4Q%.G %;#8$=-L*.P--J,(B%$<"7611!8$= $= &?")@$)="(7  +%##0 41-0/,1A65E;?OBO_R]oaiyn^ieOXUAHAEMBCMBVbT+9((9&'8%!4 #8% 8")A+.H/NjQTpW]vaaykcxqqÖÑ£µø©π»ßØ¬MWc8HG1B:?KG]hd0;5(6)):(%8"';",@'1C)-@$(;*>.?1>/<+6*4&4!1)< &8 "6"4325#:&?!)@#+<;E ëé%≠öπú ªùøûΩúøû¿ü∫ò∑í∞ä™Éû{ãql` XaQiIn Dn&@k&:b$'I&F&G(I(G!@:;'<<F £†Õø“¿÷¬5H,M\E	"+&*4+)5)'1((.1*()#CD>IJD;=:9@94B31H.5S-Ba89R4.% 0L5RzUI{HByBOÖSUâYWã]\ç`\ç^[ã[XÜUTQA3]7VáXPÑTLÄPTàZXâZVãWVåRH~B5f/KQÄRK{QI~TIÄVPÖYTÖX0]2JuJClB@i?Ag>9b84a63a25d.Hy8PÜ8Té7Qå2=xNâ-NÜ-E|+N	9d.KuEDrA?o;8i20\'=a1MnA.S'4`/9i58k38i2,X'4#=  9 86*C%4P*6V-/T(.U(,S',R)/S-.M+/M+9T16P-7S*PuBVGiî^v£lVÉJlóaâÆÉå∞äå≤çÇ™áï∫ôêµìmïplój`é]oûhnûdkõ_`ìQL<WäETä?Xë@EÅ+Qé1Uë9Qá<<o-1^#?k,QÅ7PÑ1KÉ,A{$C|+Má:LÜ<F;SáIjõclüdbì[oûjpõpë∏ôí∏üóø•¢∆¨±À≤∫æ•ü}d«ñx“®Ç‘ÆÅ—´zœßs“™o—®h”®dÿ¨e‹¨dŸ•\÷öQ◊ïK€ìG‹ìDŸè:œÜ*–ä(÷ï-€õ/÷ó&‘í!÷ó%‘ô%–õ'Àû'Õ™2⁄∆M’ÀP”“T◊◊[Ÿ◊`›”bÿ«[‘øTÕ∫QÀ∫PÿÃ`ŸÕa‹ŒcﬂÃcﬁ≈^ﬂΩY›ØQ÷ùD—è;“ä8ﬂêCŸé=÷ô>’£@‹≥J‡øT–πI–ºI“ƒJ—»IŒ«E—ÕH–ŒG“–I–ÃGŒ«C“ÀI“«GÀº;¬∞2–ΩDœºCÃ∑@»µ<œ¡F“ƒI–ΩDƒ∞7«±9…∞9Ω†(¬§(ƒ©(ø£Øçªïªñ¿úπó¥óª¢µüµüµ°¥†≥ü≥ù´ï™ì¨ö
+¨ù¨ùÆûÆû™ú©õ™ó
+®í®í¶ê	¢é•ë
+§í
+°ë†ê†ê	üë
+†íùêûèûéúãõáôàôáôåóå"ìé(èå+ÑÜ2ms3BP<T0<Y=<T:?U>DWA@R<0D+PdICW<+?$)?($<&'?)*C.,I3+K42T<6Z@9]A8]>6[:5Z82X3/U./X.:c96[20U,-R'.S'/U&2X';a.Dj9Fj>87'?%(@(0F/NaMLbKD[A<W6:^2Ag6Ek<Gj@@_=4Q55Q:9U?C_ITq[oåv`ÄiFjN]ÄbpåsrÅ`||JçÄ<ò{+¶Ö&´ì%®ñ®ö™ö´ìßã≠å	ßÜ∞î±ó≠ê≠é±ë±è	≤ä®Ä ¥ì∏ú∞ñµù	∑¢¥°∑§π´∑´ª±æ±Ω©ΩúØÉ ∫Ñ√áºyæu¬tªl∫m√Åƒñƒß)√≤0ø∞1Ωß/µï&ØÖ∂ä'Ωí,≠Ñ¨áøù1ºú-∏ò'Ωú+À°3¬ç'¨rΩá'Õ°@Œ≤N«∂N¿≥KÀƒ\—”hÕ‘jÃ‘mœŸv—‹|—‹Ä”›Ü◊‹ä€’ã› à⁄∑Å¿ïhînGqZ8SX:[nXÄòäzñàqç~WsdiÖywìÖrè{Wu[SrPFhCGjJKmR`~fwî~lâuSpZFgJA`A<T:'
+ '&!/$2+
+	 #:;Y7:X63R06T08X/VzLHl<7\(9[(:\);X*)=)*5,I+3T50M/,F+&>$!82.6";%>!%>!%?"(?#%4"  #"/"946"; 4,,)7I9UhUViV`qamzp{Ö}HOHCHBLQKEMB.:,&4#):'/B./D3+@/9N=4#VnXSjVJaQ`xkjÅ{zèêø—›π»›àí´=H\0CIwåçJ[b#29'56)83'4+)"$GK25:",	<CKIMEKB	IB?>6=)7%5'7#5!5/15$;'@")B$4HHQ òï$∞õªùºõºòºòΩõ∫òµí±ãßÄ ûw èm |c gZ WYK\A_;b!9a#5\%)J$C*J+M+P-R'L#D$A	/D dl º∂ Œæ’¿6H.<K4	) *4+2<35A7<F=?E;YZRqqeZ\OMPENVGBQ<5L0A[89T11H+)&(<0KlQR|TK}LVãWWãZUâY[å_aêdZàZ\áZ@i=.T+@AiF^çaTàXOÉULTRÖZRÜVTÜQFy@Ds?EIvKHwMI|Q>sEFzJGvH"M 4]1;d8=h;=h;0^02b23c/6h+I~8Tç<Ré6Pä3Pã1Qé1Mâ/KÑ3P+X!7a/Dp=:i32^)8`,QrC6Z,0Z*3c17j29l38i2%O>'B#"<'*3/J)4T-.U)*S'*S'*S'*P''L#*H$6Q.EZ;D\:Fe9Ns?\ÖM_ãN[âHZàHbçUwûoÑ™ÉÜ´âäØê}¢Éé≥ëÇ´ÉÅ¨t†omôdiñ]M}?WàGjù[kû[_óLWê?Té7OÜ3Bu06c(8e,@n0J|5Yå?[ê@QÜ8G|4kü]l†b_íZdîbt¢s~¨~Ü≥àÄ´ÄhêmÑ®éë¥ûó∫¶¢ƒ¨≤–¥ÆπõôÄa¿ïsŒß~“¨“¨{œ¶rŒ°jÀö`–ô`—î[ŒçS…ÉGÃ~@ y8Ãx2Õz.–~,”Ü,Ÿè.ÿì+›õ-‘í!–ç—í ’ú)◊•2ÿ±:⁄¬H‹“W’”XŸŸ]⁄ÿaŸÃ\œ∫Oœ∏P÷øW€…]ﬂ—d‚÷hﬂ—d›∆\‹ºWŸ±QŒõ@–è;‹êBËñJ÷É7÷Ñ8‘å:’ù>‚∑O„√V“ªI”æK⁄«OŸÀP‘ÀJ”ŒL‘–K–ÃF— EÃ√B—»G“…HÕ¬B≈∂7Õª?‘¡HÕ∫B≈∞9œ∫C”¿H“ΩF≈¨6√™4À≤>¡®2¬ß2ÃØ7ƒ´,Ω†Ωõºóæôªô¿†æ£∫§∏ß∂•≥¢
+≥ü
+¥†≤ú¶ê ´ñØûÆü≠°Æü≠ù®ößô©ò
+™ó¶ì	£è§ê	¶î£ì
+¢í	°ë
+°ë
+†íüëûëüè†çõáõáõâôåñåìå"íé*åå2|É6T^)@P)?X:<X?:T;4L40F14J5@S=MaHBT<%7&9%-1 5" 9$#?(,L4#E,!C()K01S86W:6W83V51T32X38\80T..S*,Q%/T(.T%8^-Dj9MpF,L'HbE`w]SiR6L5DWC7M6.G*9W3RvFLt?Hp<KrCNrLOpQ4R8/M5>ZCB^GGdNFfOCeMhärã®ñè•é|à`~Fî}7ô{%¶ç&≠ò#™õ©õ¨ò¨î´ä™â¨ê	≤òØî©å ≥ì
+≥ë	≥é	´ÜØçºù∏ù≥ù∂°
+∑§
+∑§
+π©∫Æ∫∞º¥Ω≥ø´ªü±á¡é¿Ñ¡{¬s
+¡k∫dæp¡Çƒô&«≠4√∞7æ©2∫ü.≥â%¨~∂Ö&∏ä(™Ä±ä#Ωõ0∑ó*∑ô'¬°0…û5≥Ç´tƒì7Ã©K«ØO¬ÆO»ª[»»fÕ”qœ‘vÕ”y–÷Ä“◊Ö‘÷ã◊“éŸ√ä–ÆÄºéjïlLr[;ZW6EX:IgMnâxuëÉiÖvkáyÅùënä~têÅcÄjaÄ`LkI@aDKlQXu_pçyÉûçbkCdGCbC@V?$		
++#3':+> +;!"-4;X:5T43R05U0>^5VzLPtD4V#Ac0Aa/<W,+<(')@&3Q54U80L3*D+%=##9"3 6#<$=%>!&?"'@#';", "!8:<)D!#<3-&;*\q^G]HYlVUfSp|nt|q9<5@A<FHCEJC2:/%1#:H7VgUFXJasg5G;$6(MbOH_K>UEBXLNga|îò≈÷ÊΩÃ„KWo6EX.DOå£´Æøœê†∞>LW*7='33 )$46 *-%+TS#pco\_H]MJD@F0;#3$4$6210 7!:$=&A /G?Kèê(Øû∏ú
+∏ï∞ç ¥êÆç™ã ®â ¶Ñ †z ñq ág za p`e_QZ,E/S.U%K'H#B&F(J*Q)P+R)O'J8SJZ åé≈∏—º1@).	)6$8E4#&-&+2*-3)[]RoocfcTYXFSVAMW><L1$8+=#G[@.B&;R8J_NLeRQrWZÇ__åc^èbYä[UÜWWÜZYÜ[HsH6\5 B ?#B#PuS_åaUâYPÑVI~PKÄTOÉUHzG<m6WÉNE0\+@n?=o<*_+3c3+Y*0^/4b36d58f7<j90`.0_+1`)8i([èGZêBJÅ0<q#Vã;Qç5Nä4.gN
+N0\):i38e.8`+OvAAe51X)1_.4f17j2:k4?n:>:%@!!<";+
+2K.=\:7]40[.*U($O"$M##I )I$6Q0FZ>RfJSmJCb9TsIbáT^äKRÑ?NÅ<SÉEcè^É¨Ñcãhpòuô¡ûâ±åÑ≠Éx¢rpùfSÅCQÇANÅ?gó[t¶giûX`ñJQá9Au+'S0[&8c.;h/Ev5RÑ?iòTjòWRD2^)gídu†uw§yzß~à¥êâ≤êá∞éÖ¨ç{üÖã≠ïåÆñá™åÑ©Ä}êcïÑYπîjÕ£yŒ°w“°vÀïi«ä^ Ö[ÀÄX xP»tHÀpAÀm:∆g-¿b"…n%÷Ü/⁄ê1‹î.›ô.‹ö*÷î#Œè‘ô%’§.”¨5ŸøF◊ÃPÿÿ\⁄€cﬁŸd◊«XÃØIÃ¨G”æS⁄Ã_‹–b›œb€ƒ\‘≤PŸ´MÿüF—è;—â7ﬂíD‰íH’}5‘Ä7⁄ñC◊¢F‡ªS‚»Y“ªI÷¡L‹…Q’≈K”≈H÷ÕL‘—N‘—L–…E“…H“«KœƒHŒ√G øCÕøD—¡G—æF√∞:»µ?”æI“ªI Ø>≈™9 Ø>…Ø>¡™8 ≥? ±:ƒ´-¡§"∫úæû¿†ªõæ°πû∑¢∏ßµ¶±¢	∞ü	∑£≠ôßíØü±¢∞§∞§¨ù™ö	ßô©õ™ô´òßë§é•íßï§î¢í°ê¢ë¢î°í†ë†êüåóÉùåöäòåîåëå$åå,Öä8aj))6(8/E.7P:<XB;WA3P<.I6<S?F\GDWC.A+#6"$),0&@'-K/!B#!B#(I*$E&&E&*G).L02P4.O00Q21S0-R),Q%-T',S$4[,Ek<NqI^|X`wZRdJ@R<@S?OeN:R82K-E`=XyLHl<Fl=IpCHqIJrOHmN*L16T:A_EEaJHeOLkYVuejÜwsåwrähZh7Çz<ìÄ3ó∞ô)¨û!™û´õ©ï¨èÆê´è
+∞ñ≤ò≠íØí≤ê≥é	∂ê¨Üªóºü≥ùµüπ•π©∏™∫Æ∂¨∏∞Ωµæ¥øÆπö∏å	¿àΩz	¿q¬l	¡h
+¬m¡r¡É∆û-«¨7√™6º°0∫ï-≤Ü#±Ä#∫á,∂Ö(©{µã'ºô1∂ö,πü.¡¶5øù1ÆÄ¥É'Ã§L ™Sø•N∆µ]«¬gÀŒsÃ–yÕ—}ÕŒÇ”œà◊Œç⁄√ç”¶µe~O=fG5\V>@O2<Z6DfEVtZWt^Tt_eÑt|òå^xmmâ}xïÉkápMkQ>_DBcHPmW]zfuê[xdCfHDcD@V?	
+%5)>(@(@,A")8!!(B)9X92Q13R06Y1Be;cáYLm@(G;X,<W,-F+> ,..K/8Y>4T<)E.$='!9!6":"$<"#= $= '@"*A%)=$"4$0#*&-&-(,%$<"@"B2R+:Y9-I0!:%C\G`xbPgM\nTN\CKR@CC730'52+?@:GJC>C<291BNB[h^anerv+;1);-;R>SkUC[EKbR<UQâ†¶∑»‹pÄó5FV'=HjÇéè¶¥™º“£±Àêú≤4@P(1:$-, "(?A|o!ÇjqVZG><	9D,;!301,.25!:$? 'B!,E2E\cûî!ÆóÆç
+ßÑù~ú£â£à £Ö ü~ ìp ëp èqåuÖuYX0E2S0T$"F#B"A#B'K*R-U (Q-V2Y 6V@W	IS õí∆∂#0B*$6+=%:I2#0 #*"7<6AF?LOF\\RWUI^[La`LTZ@CP20@%!)ET=;O35L0#8'.E5>[EXz_VÄ\UÑZIzMDuH<i>@iA+Q*B ?%D$@!EjHbèd[å]TàXLÅSEzLBvF6h5HwAP}F&S1]*Br>Ex@At<:j62`/1_.4b16f49i59i53d-4e.9k0Ct2\éG;m&*\1`XäAWé;Uè;Bz/T'W+Z#0_(6a)Fm6In:2X'4^.4d27i47j2<m69c3A7"="@)D%6!*@)C`BFjFAkC@jB8c82\41Z20T.6T2:N3L^D_sXXqQ^zTdàZjï]eñUTáBOÇ@nùglóisûpäµáé∏äÅ´}Å´yoödlô^cîSp£aPÉAp¢cq§b]êMOÉ;@r--[&N.U&5_/5a.@p6P}B\àKkóZ_äR6`.dã_|•}x¢zy¶Å™àà±èã≥ëå≥îé≥îï∫õòΩûôøö{£qwè[äÄO≠ã^∆ïmŒímÀçf√Ç\»É\ŒÇ^ÀxVƒkIÃpK—tH—q?◊x>·ÉCËëD‡ê7‹ê0÷ç&Ÿí&Ÿó'–ï!Œö"Ÿ´3—≠3’ªB’«L◊—W⁄⁄bÿ◊c—≈WÀ¥L ®F€ªXﬂÕa›–`ŸÀ^’¿W”±M‘¶H÷õA”è:ﬁñD„ñHÊóJ”Ñ9“É8€îD‹¶L‡∫U·…[‘√O–øI€ÀR’¬I»µ<ŒªB’«J÷œM‘ÕK‘∆I—¡G πC…∏BœæHÕæG“¡K–øKÀ∑D∆∞@—ªKŒ∂H»©=«¶=–±EÃ∞C ∞BÀ±B…Ø>≈™5∆®0√§'ªùƒ¶ ¿¢ø¢æ†≥ô∑¢∏®∑©≥•≥§±†≠úÆû±¢±•∞§Æ¢¨ú®ò©ö	™õ
+™ô¶ì•èßëßî
+•ï
+§î£ì§ë•ê£ê¢ê¢è¢èüåñÇõåöçòéìå!èç)àã2x9CM'	,!4 (?+0K85U@7XC9YD=YC@YCNfPJ`K'=((.1!7 /G-0M.%D$)H(6X7*I)#B"#@"+E(7S:;W>-K/2T3-R)-R&-R&0V'7^/Ch<KpGSsNC[;8J02F-2H15M57Q69S6-K).L&0P'7Z0DjALuMMwQJrPElM9\>0Q4;Y?<ZBEbNQm^UqbRmZLkLKb8\c/Ö~:ì)ßë+≠°)´°™û©ô´îÆì´ê≤ó∞òµû∞ì	µì≤å¥å	≠Ç ´Ö ºü¥û¥†µ§∑®∂ßπ¨∏Æ∫≤ªµΩ∑Ω≤¿™πòºå∏}ªs¬s¡l√n∆n¡t√å'Õ§8«©9¿¶5ø°3πî,µâ*∞Å%∂Ö(±Ä#•y∫ì.º†3∏¢2Ω©6¬´;√ù8ÆÉ'ªì>Œ©Xø¢R∑¢Q≈Ωj …w… |ÕÀÅŒ«Éœ¿Ö÷∫à”©ÉΩÉmÜL@H :&:<.(<#@]>DfCNoPCdGDfMSt_víÉdÄrXtf{òÜdÅmXv^TrZBbJDaMPmYa|kPmYJkPFdH=P:
+&50E&+E &@'A,D",>$%3$:T97Y81P05W47Z2Ej>eâ[Fg:&A&?(@&;$6-(@&9V:>^F5U>(D.&?)#=$"<!"<!#= &@#&?!*A%)="!3 /#/*3 3:(07%&,*!6'C&F.N'A`@JhNOkUOkU[t^`x`j~e]kT@D323%86*/,#23+HKDMOJBGA<C;CNFS^XGTK$4)+@/3K5sãsZpY_vd#<8òØµ~è°?Pb/FN4MT§æÀù≥»§µ—üÆÕú™≈Çé§+2B"+0 +% , (''%*`WÅp ycZK
+8:0>&60!3-(./38%@!)D%1K(2IAPehâÄè|Üoyd Çn õá
+¢é	§â¶â	ö{êtêyíÄtCD ;Q9Y'/S%&I%E/O&0Q&%I6](,S3W6W6T;QN]SW e[ †ç
+*>#/C(4F,+%!)%,$492-2+7:1DC>GD=JG>13%:H.5H*,('AP;:L2-+.;1!5)+G1JoPAnG:i?0_3%N&)O( D#F$G,Q(.W/HrJ_ébXâZVáXRÜUDxG1f2;m8IzBGv?)Z"H{CIEH{B?r97j13d-2c,9i5<l8?o;>m9;j4<o4<p2:m+3d#)WJ'P=j)OÇ7ZèAFz0$W,^/_#4d(;g,RwA.S :d28f5;k9;m87m3<m6$K97#@!#B (G%$? 50KcMMnQLqOHrNIsOKuQKuOEmH?a>8Q4:L4RdLUlO]{W_ÑYfçahíb^ãT\ãT~™uu¢k_çObìQjôUWâDWàFs§bdïSo¢_p£a`ïQjüWRÜ>WâDFt3-Y(P%K)P#0Y-8c5=i8SJVÅIP|?WÅBdçSsùkÅ´}Ö∞ÖÄ™Çzß~qûuä¥êê∫ñîºóÜØáñøïä¥Ü}®rtèXÅyKãe@≤qQ√vX√wW≈{X«Y ÄY«ySÃzT‘ÉV„ë_„ëU›çHﬁèDÏûK‡ê7ﬁè0÷Ü#ÿè&◊ô(◊¶/÷≥5ÿø@◊ƒD”»J—ÀOÿ”[◊–^—≈YœºUÕ∂P÷ΩX‹≈_‹ ^ÿ∆Z‘ΩU⁄∫U◊´J—ú<⁄¢C‡£H·§K‚†J‡ôIœã:›°IŸ®K‡ΩW‹ƒV’ƒP“∆N◊ÀQ’ NÕ∫AœπAœπA◊¡IŸ∆M◊√JŒ±<…´9«∞>Ã∏GŒ∫I“æNÕ∑H ¥GÕ∑J–πO“∂R…©F¡õ:—´JÕ∞JŒµNœ¥K ÆC√°5≈ü2…§2ºó"øù!¡£!ø£¡ß∫†∂ü∑•π©∂®µ©≤§±£Ø£±•∞¶∞¶Æ¢´ù	©ñ	®ï¨õ™ô¶ì	§é®í™î
+™óßó•ï§ìßèüÖ
+£ã°ãüâ†ãüåúãûèöéñè$êé'åã.Ñá8Zb)+5$&!4 "9%*E2/O:.P81S;5U=9W??[DE_F@XB1I32H13K17P38S44O.)G%)H(0O//Q0'F$'E#.I*5M3>V>.H-3R21S.,Q&/S'1U'5[,Bh9LqFLoG6Q05N0-D(.G*-J.A_C5S9(E)(E'&C$*H&3U2?e>GoJLuSNwWKtT3Z=!B%*H.8V<?\FGdRNkWMmUEcAEW/[b,ãÅ:óÜ,¨†2´°%´°®ú≠öÆó´î∞ö±û∑°±ï≤ê
+≥ã∞Öµà	¶ ∑öª•∑£±†∏©º≠π¨∏Æπ∞ªµº∏æ∏¡∂¿¨Ωù∫è∫Å≈Ç∆~√t√h¡h¬v Àë0Ã™>ƒ≠9¡¨9º§6ºù3∂ê+±Ö$∂à(™|¨ÇΩû2æ®8º´9¿¨<ƒ¨BΩü?Øá2∆üRÀÆbª®\¬∂l √{ ≈ÉÕ≈ÜÕæÖ∆™z»ñs¥x`ÑH>T$ 0"0G-DaCJkLAfEDiHKpQfÜo^{gHeQXxaRrZUu]fÉm[xdIdUb}neÄqSn]NjQMeK0?,	.7O-3O'.J"$@%?*B .@& (9'A[@7V62Q/6X39\4ImAWxK<[//G#&;#8"4-(.D-<V=A^H6VA2O9+I1'A(&@%$>!"?!%@!(A#*># 2/,.(5!6?*9B-' 
+,"<$C >"<+D.8Q<D_LLhRSoYVm[J\L9D4'--/"/1$/1$:=4GHBHJE;@:/91WbZ4D90"4K7PhP}ï}kÅjnÉtRgb§∑ªN_g2FM$@Cqéî∞≈ÿ™ª’ö© ô®…ó¶√£±ÀZbw#-7!0+%5* 0%*'&-.VSd[$JD:A+:%5#6&90+-.1"9%>!$>!+F'-H'3L$CU#O] S]VZ]\`[ Äxùíßì©íùàÇsjd_`IP
+2B6Q9[(/U$,R#)N"/T(0U))M0U!5S?T`mbhdb md òà†àìx (<!%9*=!%5 +!)$/!,7)19,.1('("! ,3#AQ7'9'*&GT@1@)"/5?4%$4)3J8IlN@jD:i=,[/%O'(N''M$,S'/V)0[-6d60_1YâYUáVPÇOEwD4i33e0=p7Bu<Ar:<o6F}DCz@Bu::m23g)3f+;n5At<Ex@GxACr;;m24k*/f%0b#+[L L*V1_7i"OÉ9I}5&Y/d 4g%9j)Lx;<c,5[(<h5:j8=o:@r=>q84c->:;$A"$F!%G"+K&%@!&&8(AZDPqTQvWPyWNwUFoMFpJBhC;X:7N2PdKOhKWvTcáctóveãf\ÖYjñehîaWÑKP~>QÉ>PÇ;QÉ:NÇ:Sá?SÜCOÇ?XãIWäHSÜAM:Dp1.W'M)O)N"%L 'P&0[0?iAUÄS^àXaåVSBUÅD]àRpúgbé[pükoùlWÖV{¶{oöoaå^\àUiìceè]iî^jÜSXV-wV3πvYÕy]…yXÃÄ\Õà_‘èf÷ãd’à^Ã~N—ÅLœ@—É;◊ã=„ïB‘Ä(ÃwÿÜ#ÿë'’†.÷Ø6◊¿@ÿÀI”ÀL“ŒQ÷‘[◊“]…ªNÕºR⁄ƒ^€≈_€ƒ^◊¿Z‹«^◊øU‹∫Vﬁ¥R◊•F◊°A·´Kﬂ©I€§Iﬂ¶M€öF÷öB‹ÆP‡ΩW‹ƒV”ƒO’…QÿŒS◊ÕQ—∆J÷√J—ªDœ∂@’∫G◊∫E…®7∂ê#Ã®:Œ¥EÕπH”øO—ªN…±EÕµK—ºS—∫TÕ±N∆£E—™MÃ®Hœ≥O”∫UŒ≥L≈•>Ωñ-Ã£9≈ú0ºó%«§,ƒß)¡©%¡´"∫§ºßπ©≥ß≥ßµ©±•±•≥©±ßÆß∞¶™û
+©ö	£ê´òÆù´ö•è•è©ì	™ó©óßó¶ñ•í§ã°á£â°àõÖ†çûçûèúèóè"íè&åé-áã6nu11=!.',%;&,E/0L64Q;1S;0R9,N5+K30L3:T;:R<9Q;=U=9Q77Q4C^?1L-&A"&C%)H),K+(E&*E$4O03K18P8<T:9V72T//R(/S'2V(5[,@f7HoBJoF-L*3M01K.1N0<Z>GhM0N4(D+*D+(B'&@#'D%1U1BjEDnJKtRNzYMvX@dH-P2,M0.L2*G13S<CeLGhKB]<?P$]\#âÄ5£ô8´°0¨¢&´°≠ü∞ù¨ò≤û≥°µ¢≥ó±è
+∂ç≤Ö∫ç∂èØí
+ª§ª¶∞û∞†ª≠πÆ¥´µØ∏≥∫µπ¥ªµ¡∂ ¡¨¿ü¿îæâ¬Ö√z¿jøc¬j ¿u"Àõ7 ¨>≈Ø?¡≠<æ®9Ω¢7≥ê*µã'∑â)©}µî+¿®:ø´;ª´<¿ØC√≠JπôBπïG ¨cÃµo«∏u√∫y«ªÅÕºà‘πäÃ•~∏|bÜH;P 3"%=S<HeI?`A=_>FgHMkOGeKBcHDgIHkMRtY_jréF`SlÜ{ÑûìgÇsPlUMeM%4!,@%<Z45V+0O&(D#?*B,?# #4!?Y<3R05U0:Z5:Z5Ca;@\42J&-@$/++%/+A,4P:5R<5S;-K1'D(&@#&@#&A")B$(?"!3.-+.$36B,<E0)2#/"2'<%?:5!9!1J5,E22M<GbQTl^Vl_ScVCOA2=-6>/8@15=0:=6=B;@G@(4*S`VK]O+B.7P:WqX[s[ihj|lIZRxàá:MK.DBGcd≤Õ‘´Ω”ß∂”|ã™èûΩò¶¡®¥Œowå$.:0*#7+$6*.#*'''-46+02@'8$7':&9%8!5!53326!9&>$(B',F)3L.5M+8O#@R JXPWZ_xxíã çÑ|wfgMV9K5M,G,L4Y&6\)1W$8^+7Y&:Y 8T5LM[qväáôçòÑíz õßä
+Æê,>&0B(6H.,>$>L5>L5=L53B-&3") &),!4;+O[G-<'+"*#)!,NZD-9#;G37?2&4'0E2CaEEmH=k=.`/*Y+,Z,-[-2`17g5GyDWâV\éYYãVOÑNF{C*`&2e-<o69l1:p4Bu<Bw?=t=?v=;n36h+7i*;o1@v:Bx>@v<>q6Au7:n,7p)6m)3e(L)Z3f#4h 3h 1i 3k"4i#3h"7o(;s,Hy7Nz=@m49h2:j6?q<Av><q97h1)S!9?$C!%G$&J$%K"'L#%D"	!9K;JcMUxZQyWPyYMvTJrOGlJ?bA=\<A_=@]>\}^lèqwó~üÑnîoZÉWLvDJvAO{Hgì``åW]äQSÑCQÑAPÇCDv7PÄBGt99d,-U )N$H(I0T(.S*.S*,R+-U0>hDS|ZjíocåbVÇOMzAJw@OCOÇ@NÅ?VÜH_åUá±Å{•u]äQVÉHR}EQyE9_.1L!8@_L+§kM»}]œÖ^ÿëg⁄ön◊îi÷çdÿâ^–|N”|G“y=Àt1«s* s$Àl÷z#”É"’ï+Œ°.⁄æC◊…Lœ LÕÀPÿÿ`◊—a—∆Z–¬Y÷≈[‹Àaÿ≈\Ÿ¿[ŸΩYﬁ√\·ø[„µWﬁ©M·™O‚´P·¨L‚∞O‰±Uﬁ®N◊õC·¨Pﬂ∑U·«YŸ≈RÿÃR◊œR’ÕP—»I”≈J’≈KÕ∫Bœ∫GÃ±@“©?æí)∆õ3—ØD–πI“¡O—ΩLÀ∑G“ºO—ºO”æS“ΩT»ØJÕ∞L◊µT»ßF–∑R—∏Q…¨D¬°8À¶<»¢7æö,∆•2…¨4≈¨.√Ø,¿Æ&æ¨"æØ ∏Æ¥≠µÆ∂¨±ß±ß≥®≥©≤®Ø•´ü©ö	§ìÆù™õ©ö§ëßî
+™ô©ô®ò®ò•î§ëùÉ•ã§é†ãüå°êûèöèôé"ñè'ëè+âå5|É=P]'2C.E+1J44P94P97S<7S<6S=0P90P9/O8,J2'C*)A+'<).C28O;8Q;.H/D^C=W<0J-0M1'D(&@%)A'>T=McL3K38P6=V99T56V11T,0S)4X,5[,<c4EoAKtJ/Q01O32P6:[@HiN?`E-I0,F-+E,'A($A%#@$&E&6Y8?iEGsPMyXOz\Qx[EiM3V80Q4-N3-N30N49W=C`BC[77DW[ çÜ6®û<≠£0´£$¨¢Æ†¨úØü¥§¥¢µõ±é∏èºèµâºï¥ì¥öπ§≤ü≤¢π´∫Ø∏ØµÆ∏≥π¥∫∑º∑æ∑ √¥#¿™!æú¿ñ¿é√ÖøqΩf¡d¡j#ƒÄ-Ãö;…®?∆∞@¡∞>æ¨<ª£7πò1ªë/≥á&≠Ü!¬¢;¬´Aª≠@Ω≤F¬µOø™O∑ûL∏úSŒµsÀπ{¬≥z»≤ÅÀÆÇ“®Ç∆ïwôePg;.5!%0"@N=9L8/G-C]@E`ACbBCeDChFEjHInOYybwìÑYsjUnhÉûô|óéSp^QjT7J4*:S5<\57Z04T/+I#(G+E':#%,?)=X94T/1S.8W5;V7+B&,<"'5*! "4)C*,I-(E)(B%&A"&A")B$*<"!0!0#2-+* /.;'*6" + ,,':%: 834(@*4M:4L>9QD6NABZMKcUKaTJ_PHZJASC:K;4@41=1/;1+9,2C3G\IE^IB^G>ZCA[BZqW`s]ESF5E:2F:'>6~ìñ¿‘ﬂõ´¬WgÅYkÉÖï¨ô£ºáç£W^n*5;!2*!6'%;.$8,/$(&(("1-@ &;%:#7"4(:""42$8'; -+0 3$:#'>$+B(/F*3K+6N*=S-@U*CW&I\$Qa#O_!K\%K_,@Z*3Q/P0S*K.R":`->c-;]!E`Ob\fdfÅ{üíßì´ë	™é†Ç ßâßä¥ó*2A*0B*"4(7 ;K1;N2/*9&5@2DLAW_TCN=+6%#0%(-&+1'8A.Q]E-6!@L8%2%-@*!9$C$=c<AqA5j4:l92d12d1:l7PÇMVãUUäRQÜNJGCy?=s77m15h-7j/5h-5h-@s:<q98m55k13g)9m-6j*>r4@x;?v<>t8@v8Dx8Bw3>u18o,J5g,Ey7?w09s)8r&9u+7p);r.;r.@x1J}8WÉDIr8Gr=JvE4^0@k=Cs?8h4JD< @$D(K!&M!%N"(Q%*L'!(;S3GfDJnJUxXVy[QvUAfD9^<AeA;_;6X5UxXjãpá§éuì{WzYQwNDn@LvHdçetúypòslïkgí]YÑL?l59h20]&+V!-U#&L'H&G-N#Ad:?a<-Q+4X4OtRAhKV~caàmjípZÖWFu??n8=m3Br4K|;Hx<O|EmîeröhZÖMIu:8c-2X''J 61B KG$ÉX6∏xT≈ÄVƒÄS≈ÖWƒÑVƒÄQ¿vE≈xBŒ~C”ÇA÷Ñ;‰ëEÔïG‹}-Œtœá!‹®8ÿ∏AŸ…O”ÀNœÕR÷÷^÷”`¬∫M…ºS◊∆\€…]⁄≈Z’ΩSÿ∏U‹∂UﬂµS›¨O—ï?Àä6÷öDÿ°G◊§H›™N·™P–î>÷ïA‡ßN‡πT÷ºN÷≈OÿŒS”ÀNÕ≈HÃæCÃæDÃæDœ¿I’¡N‘πH∆õ2 û5“´B”¥H—ΩJ—≈O“¡M“æK“ºM—ªL—ºO”æQ–ªNŒ∑M“∑PÀØKœ∂O–µL ´AÃ´@“≠C¿õ0∆•4 ´7∆©3√©.ºß'¿Æ(øØ$ª∞"∏∞∑Øµ≠¥¨≥®±¶≥®¥©≥®Æ§≠°´ü¨ù¨ù™û®ú©ó©ó©ö¶ôßôßô¶ï§ëûÜ
+ßè§èüèüé†ëöçóçóê&ìè+éè2Çâ9cn2EV*<P44M70L50L53O62L3.G1+D..K5/O83P:2P8-I0$<&)$+B.>UA:R<;S=AYA;S9=W>?W?>T=0C/0C/BXCBZB7O51H.2K-4S12U-/R*/T)4Y-<c4Bl>MvL7Z95V98ZADfMBbJ3Q7,H/+E,*D+)C*'A($A%&C''H)6[:EnLKtTPy[T|aT{`ImS>`E;\A6W<6T:4P71N2<W8@V29F\\ïé=®£;¨¶.™¢#¨¢Æ†Ø°≥¶µ•¥ûÆê≤ãºê≥áºìΩú≥ô¥û≥†∑§ª´∏™πÆ∏ØµÆ∑≤πµª∑ æ∏"¬∑'¡±&æ¶"æü"√ú%¡é!¬Å#¡t$√l%¡j%ƒr(ƒÄ-…ò9À¨B«≥B¿±>Ω´=Ω¢9∏í-∏é*∞Ü$∏ï1√™C√≤JΩ≤I¿∑R√¥Y¡Ø[ª£[¡©iÃ∏}ÃµÉÃ©Å»ù{æço•u^zUBR;+($"*!,'1C-CW<>Y8BdADjE@fA=bAKmRqë|zîâZsorãàÇùñ`|mMiRAX>,1@Y9<\7:]56X5-M((G-H(;&
+"5I09W51S.2T/8W5;R8+!!"- +
+0"<!(B%'A$&A"'B#'B!,C&&6,(5#,9(!/ /*-$1%&!./?%&9$7.)-D05M=BXLRg^6L@8PC8OE8PC@VI@WGBYGQfUEWG6G7*:-,</);-'<-4L<?ZG=XEPiTbxcm~kDRA0A1.C29OC`rt¶∂√[l~:L`î¶∫m|èfmÄQTc7;D+43%7+1H8*B2(?/"7(+&9&M`L'9#';"%<,D$)A!%91!3/2(?# 7-(0"8!,B-!7"(;')<()A+-F01K24N55O4:W8>\:?];@_??^<8]43X,1X#5\'8\.-Q%2W$Bd(Kejy$}Å |xs £ê±ò∂õ≤îØé¶Ö ±ê•Ü ¨è&48F//=&'56E0KZCHX=?M4(3#"*#(" '(1<.&.#+0)36/59+IU=<J02>**7#2I,(C *H"9Y2!CNwMVàUNÖKOÖIJÄD@v:@s:XãSVàSNÉKF|B;r86l01g+/c%.b$-`%,^#._'2c+4e-3i+3j)5l)8o,9o1?u9Cz@D~CGBH~@I};L=@p4%T/^(RÖLH>E~9<x0=y1@|4<x0:s/Cw5J{9VÇCKp:Gh9Dc:(F" ;-K)/R*&KCD!E%F(J-R'O(R",V(.R&,);H`,Rm85S!2Q':S5+E*+H*6W8FiIGlJ<b=4Z5^Ç^oénFbI">%KnM]Ü^KvK_âa{üÉzùÖxõÉpìugÖ_Ed:Ch=DmCBm@Ak=,S$'M$H%I-P&Be;[}X,P,2U5RvZSz_^ÑkaÑljíp[ÜXBq=>j9/Z,6`2Aj>@i=Aj>KpEQtJFk?<c4/V))P$(G%/1L)?I&cI&òg?ΩzO«ÄR√ÉS åY–ì]–îX÷õYÂ©a‰¶Y⁄óF€ê=€â5÷})»|Àï(‹ºC÷«J—ÃN—œT”—X÷œ[Ã¬S»ºN÷»[Ÿ…Z◊¡R–±E◊∞G‚∂S‰ØQ€õC—â7¿t)‘å@⁄úI’ùF›™Q·©R€òG”ä=ÿã=⁄ñC÷®H’∂Jÿ«S÷ÃQ”«M«π?…∏B…∏DÃ¿J”«Qÿ«Q»±=≈§3÷≤B‘∂D“ΩH”«M”ÀN‘»N“øG–πGœ∏FŒπF”¬NœæJ–øM—ªNÀ≥I—∂K–¥IÀ¨@÷∂I ¶8«£3À´:≈®3¡†,∫ú$ª§$¬∞*¡±(∏´º±#∫Ø∏∞!µÆ≥´±©≤™±©≤ß≠¢¨°Ø£≠û¨ù™û™û®õ®õ™ù¶õ©ù®ö®ï¢ç§è¶í¢íúéüê†ëúèñãôë,ëé/àå7oy2BT 3G"%9 /1%;$(?%(?%!45 2N83P:4T<1O5*F-&>&3 ,!6#5J7:P;4J51G27M6=P<AT@EXDFYE8K7?U@E]E5M3+B(%>!4Q21S./Q,.S*4Y-;b3GnAMvJ?e@6[<DfMDdL3Q7/K2,F-*B**D+)C**D)(B'(B'%B&(I,<_?KpQSz[T{^V|cX{eMpZ>`H7W?6T<4P73P42L/9R26K$:C`b#ôó@™¶:´•+≠¶$≠£ ∞£ ≥ß≥ß¥§µü≤ë¥å∑ã∑éΩúº¢¥ûµ¢µ¢∑§∏¶∑¶ª≠∑¨∑∞π≥∫¥æ∏$æ∂'ø¥'√±+ø®(¿¢(√û+√î,∆ã/¬~-√u+≈q)¬p$¡}*…ó8 ÆC≈≥CæÆ=ª¶9πö0ªñ.∫ê,≤å'ø¢>∆∞MΩ≠M∫≠Oƒ∂]√∑c√≥h¿≠k∆≠uÀ©|»ìsπÅhûlU|YC_P9KM7:F0.=*$2!!.&!,);#7T6EgF@fA:`;?dBXy^wíÉrâÅUnhyìäb}lKgNA\=(A!/=V8=\:;]:6X50P++J!'C1#
+	4M08V2/Q,4V1<Y:9L6,&!/$2'5#0+)0G-A[@0J-)C&'A$&C$'E#.L*1J,#2&"/0>-(9)-*+!,!"*,:#!0!3..1J7(C4CYMJ^S2F:FZOYlfUf`=NF/A52G6;R>F_J9P<*<,3C6IYOGVO2EA2G@>THcyl^pdL\O5F6/B/2G4ZnbvÜÜ]nu<SY]t|µ«’ìüØñö¶ÅÅâ\\Z5;1*<,F_J1J7*C0";&)B-4L64J5!4*>%6%=*B"#;3-. 4$;1,12J2=W>]v` 7#):*1A42G85L<3K=/G7)D1*H0,M24U:7W?<_A;_;6]08`+6^)<c79^30T$9Sao~ÄÜ}ã| åx Øòπ†∫†≥ï≠ç ∞å Æç©á ¶Ü JUDWbQ]hWMXG>K7[jSBP9*6"$!#. )4&(-&),%.1(:@2KX>5D'/=&/C(MmFNuFPwHS}M>g;UÄSYãVNÜIPàGQäFLÖA=u6NÑJSÜNOÑLNÉKF|B=s7;q56j,1e',_$)[ 'X -\%3e*5i'4k':n,3g'As8H{BKÅGOÜLPÜLNÅFPÇE>n4$N)U"SÉONÑJKÉDEÄ<?z6EÅ;GÉ=EÅ;/f%>n2Jp7UuC:U*97-17(H!-Q%.O",N0O7WFd$bÖE+S+T8^-Ee3ax@í®hñÆdå®]gÑB.K!9$= CbCIjKHkK@eC:b=8a9Y~U?_:)C&1UwV\Ç[R|Vhên¢årìÇ|ùåÑ§çZsS;U0HgEOuPR{Q<f8.U&&M)O 0U)3X-JnHgãgFiI6Y;<^CVycQw`jçueçk[âZCr>5`2)T'1Y49a<9a<:`;;]8Cc>Dd=5X0,Q(/Q,(E&44S1<P+YQ,|Y1ªÅS÷ì_ŒèZ◊úd‹¶j◊§c‘§Z‹´\Ÿ¢P…ç7–ç6÷è5«~"«å(Ÿ∂Bÿ∆J“ M“ŒS‘œWÃ≈PÃ¿PŒ¡Q◊«X€…Y’øP‘∏J◊ÆE€©FŸ£C›†Eÿê<ÕÄ2›èGÌ£Z‡ùN„•RÂ®WﬂùO◊ã@⁄äAŸä?”ë;ÿ¨I›√T÷«R—…MŒƒI–ƒJ”ƒM’∆O‘…S÷ÃS÷»NÀ∂?Œ±<”∂A–ªD◊…N“ÕM—ÃL‘∆K–ªDÃ±>“∑DŒªE‘≈N—≈M”«Q‘√Q“ºM“∏Jœ≥Eœ≥EŒ∞@øü.–±= Ø:ƒ©4«®3Ω†(ƒØ0ƒ≥/¡±(ªÆ"π¨º±#∏Ø"∂≠ ≥™±©≥´¥¨±¶Æ£Æ£Ø§©ú™ù®õ©ûßú™û©ùßû™û®ö©ñ£é®î£î°ìõèùëûì õè#òè(ïè-çç3zÉ4Rb#3I6%"'-1&: 2(-D07S<5S9,J0&C'$>%#;%5!3 5K6?U@,B+#9""8!*@)-@*2E19L89O84L45O4/I.%=% :2O02T10R-0U,2W+8_0Dk>MtHGmH@eDDfK5U=0N2-J.-G.+E,+E,*D++E*+E*,F-(D+&C',J.DgIOtURy^Sy`]ÄlZ|kLo[>_J:ZC6T<.J33M45N17O/;J)4=gj%†üE´ß9Æ®,±®)∞¶#±ß!≥™!≤©∏®π°∂ï∂é∂éªöº°∏†π£∂¢∏¢π§ª¶∑ß∫ÆπØ∑∞∏∞º∂$æ∑)Ω∂*¬∂0æ´*¿®,≈®2¡ü1¡ó1¬ç1º{)≈v+≈q(ør$ƒÑ-ƒú:…±E√±Cæ¨>º§8æù4ºó/πì.∑ñ5¿¶G∆±Vπ®Pª¨Wƒµd…∏pÀ∂w ´u∆õq¥{^ï_GzV>cS:OU9GZ<?V9<U8;R89L62C0$2!)*$%2 <V;CeBDhB=c:;a8JmL`|fmÖwSmbc}pc~kLhO@^<-I#+,C&?Z;:X65T41Q,.M$*F)A,D"*B *B ";6T06V11S.5W2:W8,?)!$"!*+7#+7#+*&)@$C^?=W:+H*&C%&C$'F$-L*8Z76S4-?'#/&1!,8*,=-1!)*( ' -!/ /,,?,3J:,D65I>7K?0B4.@4/?<*:9&52%2)#4$':'<T>WnZDVF=J@`mf∞ºº•≤∏kz7JH=PLBSM7F?/A30B2I^MnÄto~{?NQ>ST•∫ø∆‘·∏¿Õ••±óñõpoj8@1,B-1M6-F1+D/,H10L30I332%9  7%<%<$8 40.063,3-G,:W;;W@"9%#5')9..@42F;4I@9QD7RC2O=1P><\G5VC5W?5Z87`4;f01\&-W)5Y+@]'M_x{éÜ	õâ¶è•å Æîæ°≈ß∑ó™á ≤é≥èßÖ ®Ü'/$.6)8>2KSD]jV\iUdo_hnbioe_eYIRA0;**7%"(+$(+$*-$8?/P\D4D'"6KiES}MOÄINHL|HM}MQÉRZèYRàLIÅ@JÜ@IÖ=>{5?y<LÉJPÖOPÖOI~FE{?Bx<Cy=Aw;;q57m15h/2c+?q69p,;s,:j,&Q?g5PzJQÇKNÅISÑM;j49c3$K!HSNXäUQàNKÜFIÑBF~=IÑ@HÑ>JÉ??o3>Kb8,;,)9%D")L$'L!'N!'M6V$Pn2ÜûTóÆ\¢ªg®≈sGm 2YJk4fÇH†∂n©Ωh¶ª`òØTë≠YWv03S!=`8>fA>hD<dB:b?6_70V-4Y0.N)*G(4IkHSwQOtSuô}Ñ•í~üéÄ°éÜ§åYtQ?[3QqLW|SNuH6`.7_+*R+U#6`2:c;X}[jènQtVAdFNpUSt_bÖobâlUY\äYIxB5a0'R$1[34^84\77\:8[:9[8@^:D_<7U/5S/'@"76S4=U3NU3cT+¨~L–ìZÀçRÕìT”ù_◊¶cŸ©_⁄ßX‘õJ»ã:Õå8Àé5«ì0◊±F’¬L—«N” S–«RŒƒQŒ√Pœ¬R—¡Rÿ«U÷øO’∂J⁄≥J⁄¶C÷ô>‘í;ﬂùGŸóC‚üN‰°R‡ùO€ñHÏ£VÂóO◊áBŸÜB‡íH–â9—ú@ﬁ¬WŸÕW‘ÀR–ÃO—ŒM“œN”ŒN’ÕN”ŒP‘ÃM’«LÃπ@À∞;“πC’«L’ÕN”–M’ŒL÷∆LŒµ?¬¢1÷∏F”√J—«L”ÀO“»O–øK–πGŒ≤D»™<◊ΩN…≤@«±:–∫C∆∞9»≤;…≥;ƒ∞5≈∂5¬¥1æ∞)π©π¨Ω∞#ª∞#∏≠ ¥©µ¨µ≠≤™≤ß±¶ØßÆ¶Æ¢Æ°´û¨°©†™¢ßüßü©ú¶î®ì®ìßò¢î†ïúíõî úî%úì*óë/íè2Çá3Zk$;S)B0!%*/1-+(=*5M73O6,J.&C'"<!)C*)B,!:$7P:6P7)A'&?""<&@#!; $<"/G-8R51K.1N20L30I3)E,-L,1S00R-2U-3V,9^2Di>LqHOsOBeE5V9,J.1O3.K/+H,,H/,H/,H/,I-,I-+G.+G.*F-(F*0N2EhJW~cQy_V|g]ÇpTyhPrbIkZ5VC-H58O;>T=CW<FV<1?HN ÅÇ@ßßGÆ´8∞™.Ø¶%Æ§ ¥´"µ¨!¥®∑ß ∫£∏ó¥ëºôªùª£ª•≥ú∏¢ª•º©ª¨º∞ º≤π± ∂Æπ≤$º∑(Ω∑+øµ/∂§$ª•-ƒ´7ƒ≠;¬¶9ƒ°9¡ê3ºx'√s*≈w,«Ä0¡â2«°@»±G¬≤C¡´>Ω°6∫ô0øú6Ωõ9∫õ>≈≠U¬≠Zµ†Q√≠d»ØmÃ¨sœ£t¡çfúiJxS6_X;M[:D\:@^:=[9=[9<W8<V9=W<7Q65O4/F,(:$*+:T7=a;=c:7`46_3>d;HiJMkSTq]Sp\Zv`NkO:Z5/N%505L/6M05N.3O)1P&0O%0O&0O%1U'6Z*9]/;_35Z14V17Y4<Y:-C,) #)!
+&3G+5P/-H)'D%(E&(G%)K(2V0>d?BdC:S62A,+3$&.!,8*%6&-*&'2!&4#1 /-,=+&8*%7)"4&&8("7&(<08NKI]\ess]hb>H=6A1KYHò¶ïï°ìmwn;DCY`f^gvtÄê]iuUdkn|Zif8I?0E6Zl^_qeETM;JGK[[Åêïú¶≤≠∞øéåôÇÅÜRUN8E4)A)/K2)C*-G.0J10J/)A)$<$%8""6#:%< %9 1,-.03"9"9%@!/L.2P41M6#<'$9('9+&:.*>3-B93J@8RE:TG9UG>ZLFeVMn[:_@<e;>i43^(2Z&3T9MlsåÜ•ï
+±õ∫°	≥òØë µì æöªóØä ™Ü ¨à •Ä •Ä 19.@H=06*.6'KXF/<*"*(-&/4-39-;G3;I2 -' +'4 7G-CT4)?+I#QxKK{GH}ELÅIG|FI}LLÄOZè[XéTLÑC=y1?}2<|06s0=w<KÄLNÄOIyEM~GMÄGGzACv=Cv=Du>Et@A=d5Fs:@m22Z&7	&F,O%Am:,[%.]'I%LA8a5_ç^XçWPäONàKKÜFG@NÜEKÜBKÇA@m4<\-BQ2%&"9:Y9;a:5`33^14_16^,9Z%å¶e∏Œ|ƒ◊{∏Œl£æ]_É,;aWv;cD¨¡t∞√i∂«g¢∏Vê©MyñDHk+9_.6_76_=5\=8`>3Y4'M$%J!(J%,K+;+O)FjFRvZç∞öè∞üéÆüÜßîlåtmãikâcqîl\ÉVDn<6a+.V!2Z&0Z(9d7HpMeäkgãqSw[BeGTv[lçxoê{rô|lñpQÄLJyC3_.(S&1\10Z23[82Z76[:6W87U3Fa>Ga<;U2)=!%<=X9=V6BS1XV/êl<ºÖM∆äNÿú^’üa’§b◊ß_‘£W◊üT⁄£S“ûJ—§GŸ∑S’øRÕ¿NÕƒO∆ªGƒ∑D“≈S‘ƒS÷¬R◊¡R⁄¿Q”≥Fÿ±HﬂØKÿùA◊ï>ﬁúF⁄òD€ûK‰ßTﬁüO⁄ïH◊á@ﬁÖC◊{<“x9€ãFﬂöLÕó=€∏R›ÃX◊—U‘ŒR—ÕO““Nœ—LŒŒJ“œLÕ»F”ÀL◊»K«≥:À≤<“ΩF÷ÀO”ÀL‘ÕK÷…I⁄ΩH¬û.¿ü.ÿΩJÿ P‘ÃP“ NÕ¡G»µ?—∑F«¨; ∞?‘øLŒªEÕΩDÕ∫A¿´4ƒØ8«µ9∆π9∆π7ø≤/ΩØ*∏´!Ω≤%º±$∫Æ$∂≠"∂≠"π∞%∂≠"¥´¥´≥´∞©Øß±•Ø¢´†©†≠§™¢ß°™¢®õ¶î£ç®îßô¢ò†ñûï ùó%öñ*òì/îë4Üä3cp!=V/M%A2&',033/.02E25O64Q5+E*;&C',J.-K18T;*G+&C$3Q/2P.-L,&E%%B$;U87T64Q30L3+G.,H1,H/-L-4V31S.0S+2U+7[/Af;JpGQuO;^=(G($C$*G)+J+2P40N20N4.L2,J0,J0-K1-K1-I0,H/+G.0Q6ImSRx_W}h[ÄnZnX|nQveCeU,H9(@0+C-7M6AU<:J/@K)PY$âå;™´CÆ¨5±©*≠£ ≤®"µÆ"≥¨ ≥ß∏®!∫¢∑öªö∏ö∏ü¿©'¥ùÆóµû∫§Ω´!ø≤&Ω≤$∏∞!π∞#∏±#π∂)ª∏-ø∑0¬µ3¿≠4¿´6ƒ∞=∆≤A≈≠?…£>ΩÉ/∫s%ƒx,ÕÑ7∆Ö5√ë8…©F∆±F¬´A∫¢8πô2Ωõ7¡ü>∏ñ<Ω°M…Æ_√®a¬§d≈†i¬ñg¬ãd¨wUÑ]<cS1KV4C^;>^9=_:Aa<>^9=]8>];<^=:\;=\<B_@B\?6M3$6 #!"&A"7Z26]12\.2\,8_2<a8Ac@DeHKiO^zcUsW9\40T((D7)>0E&/G'/I$.M$-N#/S'1W(2Z&3^);c/8_05Z16X38X37T54L28K8%/&	%22J*,G$)G%'E#'F$*L)-S.5]8HpNRuWPjO9J7'-!"'%1##1" .'2$(3"'6%4$3,+<*!2""3#*=*/B//B/1E9[qnauvvÑÖÇåãàèà|É{zÑ|nxpYb]ìúôéñôU^g08K:BWrzçéó¶§Æ∑ãôöUf^:NB0E6EWIXh]fsllxxâîöÉãñäêúSV]FJK<F=1B0(@(1N2+E*.F,.F,(@&!9#: 5$8"9#7#5,*+1343 9+H)1P00O0.J1+D.*A-*?.$9*%9-'=1-B94KA9SH=WL:TG4RFLmZDhLAjB=g74]%7Y>UV_Ñ~úã®í ≤ô æ°∫õ¡ü
+ªï¥é µé≥å¨Ü ´ÜßÇ • 2=-9D44?.5B03@/#/!!&$#(!#+ 3@.1@-,'6#AX;QmGUqHGf:6U):^09c3KzFEwBEzDG}IF|JG{KKQUâYUäTJÇA=y16t'6t'4p(6n-=m;OzMQ|NSÅPOKDt@JzFM{JV}P @'!58R/:X2!?.5#A#J$O K9d/C GSÅR_ë^YéVTãQSäPOÜLKÇHRäMQâJPÑFP{CSrF#&*@)?\>DjC@mBAnCApDCrHCm?Rp<®¿Çæ–Ñ»ÿ±∆]ïÆFVwCgMn5^{AßΩu´Ωk¥∆p}ê6Çñ=ë™VOn(7Z"2U-1T66X=;]B.S1#I"'K%*N(,N-A 2[3PxUoízéØûí≤•â©ú}ûç{úáÅ£àÜ™Ücä]>h65b+3^&3[&Ck7Bl<AjB_ÑemèwhâtZ|dMnSVw\_h_Åixö{£~TÄM=j3%O!%K"0Y1/X00X5/W44Y82U55V7=[9LdB=R1:J-6I-@Y;=X7>V4MS/pW.óg7∑zCÀäPŒñ[”üc’§bŒùXœùV“§W—ØX”π\‘¿]ÀΩT…ªP∆πI¡¥A«ªEÕ¿M’ƒRŸøP⁄∏L—´@“¶=ÿ¶CŸ£C”ñ;ﬁûF‡§L‰´T‘úGÊ©X›òK÷É?ﬁ{Dÿn<œg2‹B€ëH–öB›ΩV›ŒYŸœT–ÀKŒ≈F–»I””M”’N‘‘N‘—NÀ√D’ N–ºCÀµ>Àµ>’¿I‘∆K”»J”ƒE÷πA—°5πÜ‘¥C€»PÿŒS÷ŒRÕ¡G»∏? ≥?Œ¥C∆Ø=–ΩGÕæGŒ¬J–¬H…π?≈≤:ƒ±8«∫:…ø<∆º9√∂4π´(ø≥-¿∑.Ωµ,∏∞'π±(∫¥*π≥)∏≤(¥≠!∑∞$≥¨ ∞©∞ß∞•Ø¢¨†¨£≠§™¢™¢¨¢™õßï§ê©ñ§ö£ö!†ó"†ô'ûò*òï,îë0ãé5r/AW0S&K#D%D$> :!;#=#;3..("01G26N6,F)<'I(3U44U85V9%F')K(=a;MpHFfA*I''D%:W9-G.2L3.J1#?&'@*+D.*H,2T32T11T,3V,6Y/=d7FoCSyP5Y3= =#>!> 1R5/Q6-O4/P5.O4-N3/M30N4/K2-I0-I0+I/3S;KnVZÄkZÅo[q]ÅsW}nTxjNpb<\M/L83L65M34L,3I%<NVaíò@´≠?±≠0≠§#∞¶"¥Æ&∂∞(∂¨&∑´%ª´$∏§∑üº° ∏ü ¡©+æ©*≥õ∞î∂õ∏°¡Ø'¬∑*ª≤%ª≤%π≤&ªµ+Ω∫/ª∑/¿º7≈º=¡≥9¡∞<ƒ∞@«±D«ßB∆ó=¥w&ºu' Ä5…Ñ7¬Ö2√ò:»®C≈ÆFæß?ªû:Ωú;¡û@πï=πîF«¢[À¨k»§j≈êdπ}Y´lMíaAkY5QW1DZ4>^7=`8>a9Cc>Cc>Cc>@b=>`=;_;<^;BdAFhGDcCA^?=X9,C),94T/7\05\-2\*0Z(4[,7\16X5>]>Xt[XwX7\1/W%-S",M *D'?7'A*H"*N".S'.U&/Y'4^,;b38]17Y47V47V48U67Q6@XB0>1
+
+
++=%,C&+F%*H&'F$'I$+O)8`=DkLNt[Qr]Vm[:H;$#)"/0;+"!.1!200#6 '6##2/@-4E20>-!.$Rba^mrÑíï±ªΩßØ≤°®Æù¶≠°¨≤~âè_lr≥Ω∆Ω«”ozåU]r{Çïô†≤ltvÅÖSb]M_S9P>CZH]ocqÄyåñòvÜ:EK;IL3B?.?50B4,B-+E*1N0/I.,D*&<% 64 7#: $;!$8!4,'$) 6!-E//F4%>)"?#4S33R21P1,F),D**B*)A+&;(!6%%;.+A50H;8PC<TG<TF/I<EdR;_CAiD=b73T6M	juõï•î©ê ´è ≤ï πó µè ∑é¥ã ¥ä ≥âØà ¨Ü ™Ö ßÇ •Ä ;J5<K49H1,;$'(6%!)$)"'.&)3(*8'6D3&1#AP=ZsUUvKMs@Gn7;b-@h3Fu?IzCFxCDyCCyEE{II}OI}ONÇRUäTOáHDÄ89u+0m -j0g$0\)9^57Z2NqIJoDHoCOtK[}X4O.% '"9%>! 9'@#3Q--Q#'O(S%P1Y'6`0QN_ë\YèUXèURâORâONÖLTãRTäNSÖJbãS&E%09S:BeEHrJEtHIxNHvOGwOLwL]M™√â∑Ãá∞√qú≤Nà¢=aÇ)CgJm3Mk5î™iûØh°≤dN`
+âú@í©Njá7>^,K"0L34R:4U:#F&$H$*N(-Q+/S/.T/^à`U[pñ}Ä¢íÅ¢óÜßúã≠üç∞úÜ™êoótHtC6c,;h-=h05](Dk<sútiémmèviäujãx\}hLlTfÜnbÉnsï}á©éz†y[áR4a*!F"F .T-/U.0U3/T20U43V85X88W7?Y6AT4;K.=M0G_?E`??Z7EU1ZM*yX-ÆzH«åTÕô`‘£i‘¶j∆ù]»ü_◊µn÷ΩmÀπcƒ≥YøØO∏¶@º™>ÃªIœæJ—ΩJ⁄¿Q—´@∆ô2—†:‚ÆK‚™K‘ô=‹úDﬁûG„ßQ·®Q·ßSÊ•U·ìK›B—b4Õ\0÷q;‚èKŒë@€µT€ÃY◊—U“ÕMÃ≈C— H— H÷”N‘’M““L“ÕKœ∆G–¿F ¥=Œ∏A’¿I’≈K‘∆K÷ƒHÿπD”ß:ªÄ…î.‹øJÿ O’ÀO–∆K–¬HŒªCŒ¥CÕ≥B–ªF—¿JÕæGŒ¬HÕøEƒ∂<ÀªB∆∂<À¬A«¿<«æ;¿∂3ªÆ,¡∑3¿∫2ª∑/º∂.∫¥,∫∂.πµ-∑±)≥≠#∂Æ%≥´"Øß±™±•™û¨£Æ•Æ¶¨§≠• ≠£ ™õßï®îßó•õ"§û&†ñ%†ò+úò-ñî0ãé3zÉ0Qg5T*R*S'M$E%D&E&E(D'A$<"6,
+-2H1)F'-O*<^9AeA8Y<7X;1T4/S/BhAcáagâd$C!!>&C';"5Q:0I3 9#34 =!1P01S00R-3V.6Y/;b5Dn@NwK6[2: ; ;=.O21S8/Q61S8/Q8.N6-M50N4/K2.J1.J1.J1+I/3S;Ps_[ÄnW|k\ÅpYpZÄsU{nQuiKk\CcN5S;8U74R0<U+=P^l!û¶A≠Æ7∞´-Æß#¥≠(∂Ø*∂Æ)∑≠)∏¨&π®$∫£!ª¢#Ω§&¿®,≈≠1¿®,¥ñ≤î¥õ∑§!¿¥,ø∏,º≥*π±(π≥+¡Ω7ΩΩ7ºº8¡Ω?ƒªBø≤?¡Ø?ƒØB∆´D≈û?∫à1∏{*ø|.≈Ä3¡Ä0ªÖ-≈ù> ÆJƒ≠Gæ¢?æù>¿ùA¿öE∑êEΩîR…üc ògø[©hJçX9vU4WW1F[2>]4;^6=b7=b7?b:Bd?IlDCh?@d>@d>>b<DhBFlGCiDFhCMlJRoQEbD5R37V46Y/4Z+4\*1Y%-U!2X)2R)#B 3R3:\;5\//Z%-X#.T!+L'C7/*E"0P)1V*1X)4\*3]+8_07\17Y43R05S1:W8<Y=C[E2B5						+,@%)B$'E#'E#)I$.P+5Y5ChGSw]WzfXteTh\1>4"!)&$!"*"4 314K1EY@8I6%4!/B,7J45D1,)85Q_`Zegü©´†®´ü¶¨ô†™©±º∑¡ ¨∂ø°´µ´¥√©¥∆Ñè°àè°biy>FQq{}htpCUIAXFB[FG\M@QIíùüçñõ0;?8FFARH4F82E2-C,*D)-J,.F,$<"+!7 6!8$;!%9 !4,# ,+>*-B12F;0H:/M53Q52P4)F*&>&-C,-E-+C+(@*$;'%<*(?/1G:3I<:PC:QA2K8*F-5U0Ih<Ea.:O9E §§6∏©¡®∏ö±í ∂î ºò¥ã ØÖ Øà´Ü´Ñ´Ñ™Ö®É •Ä £Ä >Q55H,3E+1$80B*-8'(0##. *5'1>-+7)%/$,8,5H29T3Dh8Dm5:c+,U=h2Gs>J{CH{BCzCAwCDxHIzKG{JQÜNRäKIÖ?>z23p#,f.a1Y%3
+)=!3C)3E+:L20D+7I3!.		-*A$+D$$? )D#-H'0O&6X&3Z##L%P)T+W$O{Haí[]ìY[ìVUåROÜLOÑLVãSVâP_éWWÇL3W+$
+2>^FGnOGtMIyQKyRN|UL|TN{P\ÇSvóbú\ç©_yï@jà0Qt"Ek"Ag,Ab-náNï©jÉîMXjïßCàù6wê5Kf!'@.F,5O6-I0!@!'I(-Q-2X14X2<b;_ç_N{RS{`|°èî∏¨Ñ•úÜßúçØûÉßçV~YAm:An3Am29b*8`.Bg>É•äê±úÉ•çdáoeàrHiTSs\wòÉyúàÑßëÜ´åqöpXÖN9d.B!A*L'.P+-P/,O.1T43V66Y97Y8;Y7>V66F)4D'>V6C]:B]:I_;HR-ZS)áh9≤áT¬ì_ ùfÕ®q»©pÀ±v‘º~ µrΩ¶`∫†SµõF≥õ9¬≠BœªK‘ΩMŸªM“©@∆ê.‘ö9ﬂ©Iﬂ®K€†F›üH·üKŸóC€öFÂ§R‡õMﬁêHÁãL⁄r=«X*’m:ËêP’îD€≥Q€«WÿœV’—SÀ∆DœÀF”œJ’“M’“M“œJŒÀF‘ÕI–≈EÀº?Œ∏@À∑>“«K—»I÷ÀMÿøI⁄¶@√á%æÑ!·≤H€¬K“ƒG“ƒG ºA–¿G“øGŒ∑Eœ∏F“¡Kœ¡GŒæE–¿G»∑AÀ∫DÃΩF»æC»√C…ƒB≈æ<¿∑4√∫7¬ª6¿º4º∫1ª∑/Ωπ3ª∑1πµ-∏≤*µ≠&∂¨&∂¨&±© ∞®±•¶ú∞®!Ø©!Ø©¨¶≠¶!¨¢©ó©ï¨ô!ßò!¶ù&£ú(üó(üò-öó0éè1á1]p!;Z.U(T*V*S%L#G$E%D'C'C(B)B"2		"8!1Q,@e:NsJOsO7Z<CeJJmOLoQLqPTwW|ö~7T8%B$(E'<$8T=-F00+-0,I+6U51S.2U-5Z/6`2Ak=MvJBg>88;=*K,3V81S80T8/S9.P7-M51O70N6.J1-I0.J1,H/*H04T=Nq[Y|hSxfZÄq\ÇwY~vUxqQuiQugKp_GjTAcH>];6S'=Uyâ1ßØB≠Ø4Æ´*≤´)∂≠*∂¨)πØ,∂©'∫®(∑ü!∏ü!Ω§&Ω£(√´/æ¶,∫†)µõ$∏û%µ†#π™)¬∏4æ∂/ª≥.ºµ1øº9æø=ºΩ=æºA¡ºD√ºH¬∂F√≤F¿´B≈©F¬û@ºé8ªÑ1øÄ1√Ä1∏y)æä4«§F…≠L¡•Dªú?∏î<∆†OæñN∫åN¬àV¿|U¨eEçT6iQ-TU-G\1Ba7>^7<a8Ah<?f:@c;Ac>GlCEkBDjAAj@>g;@i?JsKTzUPrQHgGTuX\}`_ÄaXzYQqLBe;;_16[(,R-S"/P%850T.4^.1](/Z$0X#+Q *K .J$33/J'6W,2X'2Z%2Z&4^,6]08X36T25T2=\:?^?>V>2>2
+	
+	$6 *C%*E$'E#(H#,N)1S08Z9AbGQqZVsaVn`HXM((3"/8',5$(1 !.0#7"4';"6M3;R85H4(;'/B,/E./B,%8% 0%!0)(5.;F@krk~ÉÖâäñôûåëó±µæ´≤º•≠∫îùÆÜí¢ÅçõU_iENSMWVCPGIYL9N;>UANeUJ^SäòòéôõNXZJSRV^SOXGGT@.@(0I,.K-'?%51!:";&=!';"!3"1 /%"#(7$LZI|ä}sÇATN5P=3Q9D`JqàvCUG3E51I1.H/,E/#<&#:&)@,,C1-B15J98M:*@)$<8PUj)am#_cXV Æ•&ª™∆Æ√¶
+∑ñ ∏ñ Ωôºñ°| °É	™çõ{££Ä£Ä ¢ °Ä 1F'9N/:N2H\@,C&5I.*7#(3#'2"5B00=+'4"#/!$2#+<)*C%QrEKp<Ce39[)Ef9Cg7NyDIzBEzBD{DG|HJIIÄFKÉDFÅ=EÅ9?|/7q$.h-a.Z6
+%8)$0-6#$ #.*>#)C %C'E!,J$-L#0O%Ee6Ii:4U('K&K.S'V}Pbé[aî[[íXYêVQÜNRÑOXäU\ãU_ãVR}H<3@\FImQMvTKyTKyRKyTKyTFvPIwPVUW}N]ÄJ_ÅDWz6Rv.Hm'Cl(Bk/@e/Om9pàN\o-pÇ0áô5|ë*`y6O#9%< .H+"?!=(J'0T.4X26X50T.LuKXÇ\oó}îπßí∂™äÆ§òπÆê≤¢pì{lîoNzGIv;Am29a,=b7KnNò∑•êØ†è≤ûlèw_ÉiAeKWw`wòÉá™îÇ©éÅ©ÑP{MIxA4a*B<(H#,L'*L).P/0S22U42W53V58V4:S3/,: ?T5@Z79T1>Z4Ib;S^6aX-~f8ßÖU¡üo—µÖ÷¿èÕªãƒ≤Äº®u≥öa™ãH≥îD¡•DŒ≥J ÆAŒÆA”™AŒö7‘ì7‹ô@‡•K⁄°G÷òC÷ìB€îD‰ùM⁄ìCÿëCﬂìHﬁáD‹w?Ãb.–k5ÎëS–à<Ÿ¶J‚ \⁄—X’—T”–O”œJ”œI——K’’O—ŒI ∆A–ÃG◊ŒM◊ JŒº@∆≤9–ΩD’ÕN’ÕN€∆O–ß=ø|#ºu◊°=„øO◊√J‘«GÀΩ@—√H’≈L—æH≈Æ<œ∏D“¬IÃæD–ΩEŒªEƒ∞=ÕæI øIÃ√J…≈G«ƒAƒø=«¿>≈æ<¡Ω8º∫3ªº4Ωª4æº5Ωª4πµ/∑≥-∏≤*∂Æ)¥¨%≥≠%≥≠#∞¶ ∞¶ ≥≠%≤¨$Ø©!Æ¶¨•!¨°!§ï´òßñ ¶ö$¶ú)°ô*ûò*úó/ïí1Ñâ/iw(D^6[,X'U&S)U&N%K#D"A < < < ;/'&*5Bd?RyMFkB=a=2U7JlQ]~cgälhãmiån{ô\y]!> *G)%C+:V@-D04.- 6+E*6U53U0/T+3Z.6`2Ak=MtHSxO#A ="? !@ (G(6W:2T9/S7/S9-Q7,N6/O70P8.L2+I/-I0-I2+G0+I11Q:NpXLr]V|m]Éx\ÅyY~vSynR{mQzjPweOu^KoS=`?:W'Pg!ï§I´≤B∞∞4∞´-µ¨-µ¨+∫Ø/∏≠-∂ß*π£)πü$πü$Ω•)øß-∫§,º¶/∫§-∏¢+∫¶-∑©,º≥2√∫9ºµ3º¥5ø∫<øΩBΩΩCªªA¿ΩH¬øN¬∫M√∑K√≤H¿≠F≈´J√§Gøñ>ΩÜ4øÇ2æ/∑,æï;…®K≈©Hªû@∂í<ƒùN…°[≈ìXƒÄS±gDîS5yN,VS*E[-=].=b6@c;=b9Ah<?f:Bf@@d>DjAEnBGpDBm@Bm??m?KuOdãldÜkBbJrízTv[aÑf[~^\~][}X[~TQuI=a31U'+K":!D6]17c23_*.[$1\&,T +Q"4U*0L&-+(B.J"3T'3W)4[,7\1;[66T24T/6V18W58P6%1#	+(?#)D#'E#(H#*L'-O*1S24S45S9@\FH_MK]O7C7$%&'0:E4AJ9-6#&1 #0(7"&8 1$6-A(0C-0A.->,,?++>*,?+(;'%6& 0#!.$+!LWINXMFMFRXVY^asx|õ¢®Æ∑¿ü©µamyiwÄ`nqNZZUa]>NCCTDDWDDYF?TCH\P~éãçõõò†£|ÇÄdg\`gWFR>/A).I**G(#>:!:%> &?!(?#&:!-),)+-2@1[g[ù®†tÄÄAQN7P=5Q:6M;[pa\i_<L?7O91M40L5)E.&=)+@-,A.*='2E)2C0?<IUaktuu}y|s ûí
+¥§æß¿§µî ¥ì ªò ªó´ãán Øô*èsìt ü}°†~ü0H(>V6LcF8O2/F)1E*$1*5%1>*?N71A'*: &8  45=W4RqEQn@<R,1D$:K+1I'Bf:IuDJ|GMÑKNÜIIÑBGÖ<@~1;z)8v#2p2m-h'_-_%N$C3,&2+4!#'(@ (D&E%E+L!,M",M0O#9S,*B  2 2)=$0I,6U5këhbí^^îZYéVVàSTÑP[âXcç[VÄNQyG E(F*FfNJqRMyUN{TM{TM{TN|WP~YRÄ[UÅ]T~VS~SUQZÅRWKOx>@l/@m24_'8])Jg1E[zå@vã.nÜ(Sn-G
+"8"9.I&(F %E/O(6Y/9Y28U6(E'NoPfänè±†óπ´ï∂≠ì¥´ò∏≠É•ï|üâ}•ÉUÅPBo6:e-=e3CgCLlTè´üï≥©ñ∏ßz†áOvY9^?Yz_{õÉÇ§ãfélpõnSÇLAp93_*G?$D(F")G#-L*/Q.2V21W22T11L+5I-&%1?O4E]=6T.5U,8W.DZ3T_5][2rFº´Ä–æö ∫ôƒµñΩ≠åµüz©é_ßàH±êA…¶H∆£;¿ô0–•<›≠G‘ú;“å4›ï@È´TË™U“è@Œá9€èCÿä@Œ~5ÊñM‰ëK÷z9œf/œg0ÏôU⁄óH«ê6ﬂ∏QﬁÕY÷“U”œQ‘—P”–KŒŒH—”L”’NœÃI»√A“ÀIÿÕM’¬I…µ<»µ<’«L”ŒNŸÕS‡πPΩÄ%∑d¬t"‚∑N⁄ƒM÷«JœƒFÃ√D‘ N◊»Q ∂C≈Æ<‘ΩI“¬I“¬I“ΩFƒØ:À∫HŒ¡NÕƒMÃ∆L…ƒF∆¡A∆¡A∆¡?¬Ω;¬æ9¡Ω8¿æ7æø7ºΩ5ºπ4∏µ0π∑0∑≥-∂Ø*∂∞(¥∞(≥≠#∞®¥¨%≥≠%≤¨$∞¶"∞¶#Ø¶#´¢!´ù"™ú"®ô$ßö(•õ,†ö,õñ.òñ2çç5p|*Md:]3].\&S#P)T+S$J!B;7< @-M$)G!#<5"9'A$IkF[ÄWEiE7Z9/R2?`ASrSbÅbkäkZ{\hÜjwîv8U7+H,)E/;WA,C/4!,2#6#64S42V22W,6[/7^1Ah;JqDSzN6U3*G()F',I+,F+:V=3U:.U8/S9/R:.P7-O6/Q8-O4.L2,J0)G/+G0+G0+I1/O7AdNPuc[År^Ñy\ÇwOxhOxfPzfRyfRyfPvaOu\LoOKh<nÉB•∞R≠∞?∞Æ5¥Æ2≤™-π∞1º≥4¥©-∫¶-∂†(π£)ø´0¿¨1ª®/π§-ø¨4æÆ5∫¨2∑≠2º¥7ø∫<¡π<∑´3Ω≤<ø∏CºπDºπDæªH¬æP¬æRƒºQƒπO¿≥K¬≥L∆≤O¬®IΩì=Ωä7∆è<πÖ1∂à0»£H ÆMΩ£DΩöFΩìIÀõ[ ë\¬wP•_={O*^L$LX(=[)9^+<b3@e:?d;@f=Ci@FlEGpHIrJEnDGqCAm<<l:;j<MyXoï~rìÇOn_yòÜPpYPuTPuSTyXQvUSvUY{XZ|WTvQGgB0S+5[2?h<>h84`+/\%3^(,T +S!2X'4U('?$-!:4T-8[3:Y75T42R-0P)2U-4O.*
+%*='*C%&D )G#-M(,N).P+<[;@_@8R7<T<AT@=K:+7)#%!,&1!/:)>I82;*!** -*7%-<'%4);%-@*9J7?M>2>2+7)*8'&7%&7%$5#"3#.! 0#RcSVgW;H>.;4.:8?KI_ijr|}ìû¢sÅÑN\_brqext\qh\peQcUBSASdRdue@RFO`XsÇïùüzÄ~FME;F62E1*B(.K,*J%)I$?]9azZ3J-,C&*A%(<#0,(0#8%:L>fvláêèt~}?OL:NE6M92J4-?/;I<FRF6G73O8:[@:X@5Q;/F4%7'2*==KWbchlm{xÖâÄâÖ{ ëÖ ≤¢ª¶ ø¶Ω† ∏ò ∏ò πößå •êÜs
+{d çsû~¢ÄûÄõ|9S0@X80D(7J.6I-/B&.;'7D0>P6:M15H,8K/FX>VjQJ^E7K/>V4-@ !	#,)53F*>^7*U'As>QãPRçKIá>@Å1;|(8x"1q-k)g'b%^/e>p+;d*)H':(3",5$09($1%7*D(G(I)J+L+L-M1L!*=$
+/Y{Zbç__ë\ZåWWáS\àW_âWXÇP[ÇSCf<:7U;AaIGoMMyUQ~WTÅZWÖ`UÉ^UÉ_UÉ_SÅ]P[RÄ[WÖ^Zá^TQSJ=m34d(0]$0X$@`.Pi/lÉ?g1MhC`-J1G!0H&8T,1R%,M"4U*=^3B`:(A$-TpWuï~üø∞ó∂Æá¶†èÆ®ó∑¨ã≠ùä≠ówü}NyK>j56`.FmA^Åc`m°º≥£¡π§∆∂å≤ôOwU9a<FhGkåm{û}PyQ`åYWÜOBq;:i58c51X,A#A&D -M(2R-0R-0R/+J( 9.B&+9"&5C*?T55S-5X.4W/4R,=V/O_8[b9|yV£úÄ∫ÆòªÆõ∂•ëÆô|™íf´åL≤è=¿ò9≤Ö≈ñ.ﬂ´EŸ¢>Ÿò:◊â6ÿä8ﬁóE’ë>‘èA‚õM‡îH÷Ü=ÿÜ=ÎîOÁéL»j*∆d'‡áEÛ∞a√í5⁄≥N›∆V⁄“V“—RŒÕN——O––L–“KÕ—I–“K“œLÕ»F—∆F“√F…≥; ¥<—¡G’ N◊ÕQ‹¬Q–ï;¥e∂`€ï@ﬁºN÷»MœƒFœ∆G—ÃL”ÀLÿ»O∆±<ÃµA’¿K–¿G–¿G—ºGƒØ< ªHÕ¬NŒ»PÀ«J»ƒG«√E«ƒC∆√B√¿?¡æ;¬ø<¬ø:¿¿:¿¿:Ω∫7ª∏5∫∑2∏∂/∑≥-∂≤,µ±)≥≠%≥´$µ≠&≤¨$≥´&¨¢∞•%Ø¶%Ø¶'Ø•*≠¢,£ñ$•ô+§ô-üò0ôï2íë7{3AM;Y3[.Z,Z'T"O(S,TC;9#C'J /R(2V*-P&%C55;6X3QwPFiI4W70S24W6?^>4R0@_=IhH_~^pèpjái%B&3O8=YC)B, 8"6 /'*0O/5Y32W,4Y-7\0<c6GnAQxLDcA)F'*G)+E(+E*4R84V;0W<0S;1T<0R9-O6/Q8-O6,M2,J0)G/)G/+G.+G.,J0.N6<_IUzhY}o\ÇsWÄnLvbKu_PzdU|iT{iSzhTzcTuZYsDçùR™±Q∞∞@≥Æ6≥≠3∂Æ2º¥7πØ3∂¶-≥û'∑°)¿™2¡´4¿´6ºß2º®5ΩÆ9∫Æ8¥©3π∞9Ω∑?Ω∑?π¨9¥ß5Ω∂DºπH¿ΩLøΩNæºO¬øT¿ΩRø∫RæµN√∑Q√∑Q≈≥Q¡¢Hºî?¬ï@øè:πâ4≈úB ÆM¡ßJøöIªèHƒåQ¬ÇT∞hBçU2eO&KQ%@X(7\(:`-<d2@g;Ag>Ag@EkDJpKKtLLuMHsFGrD;f8;j<CqJhêvxùånêÇIi^|öébÇmJoNDlGPxVQxYQuYNpUMnQPqRXzYY}YQwRJpKEh@9]1/S%5[*.T%*P.T!5T(3H)05S19[65W61S2-O*/R*7Z09W3)$7!)B%)D#)D!/J)/J'+I%-K'4O0;U87O5-A():'&3""-(&&0%%1#$1 %2 ,7&%0 '*+*5$3@.1B//B/*?,/A17C7!+"##(+-"3!..@0RgTNcP4H<:KAUf\/?5-7/>H@ãá|ãàQ`]@PMVkd[rhh~r[ocPbRPaQk{nâñåMZQP]VÖÉ|ÇÄ<F=4B3*B,*G+1N04S1JjEgÖc\uWJ^C-A(0C-,=*#4!-2,A.LaRl{tâïï¨≥πvÄÇ@SM7M@6N8*@+,+7+>L=5H5;W@Ww_MjT<UB-B30 '!2Yg,ls%rqyrÖzä~çåÅà äÄ ¥¶ΩÆ√Æ»≠»´ÃØ…Ø∂ùöÜ	çyqY ívùûÄän y^ =V/:O.0>%7@+9F,?M3KY@<O3E_<NhEWkOTfN2@/,8*&2$&2$)*0"0>'3K+GlCEsDWåVUèROäFCÅ6;{-6w%2q .n+m*j)c$\0j:r'@s.*Q0&!)'/ +8$.A%)C(D,H/L /L.I1J +?'1#('+$*%<T:bÑa^â\_ç^[âX`äXXÉNWÉNAh9=V8&8O;QmWV{\YÉ_UÇ[VÇ^VÑ`R^UÇaSÄ_QÄ^OÅ\N~VL}PP~ORÅKPÄF;k/=m12_&-U#Ei9Gh3Fc-Pl2E`)9W#+H.H!5Q)3T'3W'-Q!Cg9LmB9T1!)såvï≤ûùº≠ñ¥¨ï≤≠§√Ωå´•î∂®úø©kìqS~P7c2?h>róv|ûÜ}úå•¿π•√ª¶∆∑å∞ñWÄX3Z-:Z1Cc:OsGIq?Hx>NÄE?n:<j9?k:7a3-T(%J!&F!+K&2Q/-K)'B#82&:AT8 0.>#/G'2P,2U-2T/3U08X18T.GZ:]gLnmYüòà∞§ò∞£í®ó{¢ç`üÄ=≠Ö0∏Ü'¬ã&–õ3‘õ4÷ñ4‘â.⁄Å1”w,÷É5ÕÄ0„üL·üKÿëA⁄ç?ﬁåB·àD”q4…i,“Ç9Ï©X”†EÃ©Cﬁ Z€“Y◊÷XÕ–Oœ–P“”Q–“M–‘L—‘O–“KœœI—ÕH◊»I»¥9«±9“æEœ¡D⁄ÃO›»Q÷©D¿l#øb¿x&Â≥RŸ¿LœƒH…¿Aœ J‘œM‘ÀJ–ΩD¬¨5”æG‘¡I–ΩE”¿Hœ∫EÕπFÃøL–«Rœ R»…J«»I»…I∆≈F«∆Gƒ√D¬¬@øø;ƒ¡>√¿=¡º:æ∂7¿ª9ºπ4∏∏2ªπ2ª∑1∑∞,¥´(π∞-∏Ø,∑∞+¥≠(≤©&≤©(Æ•&∞¶*±®/´¢-£ó)£ñ-£ó1ûñ4ïè7ÖÜ:LQ/ 4R0Y)W'X'W'U&R,UE>=5Z12Y-5\/0W++P%'J =57:`9EmH;`A6Y;BgF8^9?b:1Q(,L#?_8[}ZcÖdrîs8W8>\B:X@3P4.K-*G)*G)&D""B.Q)5Z13V,4X,7\0;b3El?PwKRtQ#@!%?"#= )F(.O21U90W<0S;2T<2R:.N6.N7.P8,L4+L1,J2)G/*F-+H,+H,,J0,L45VAGjVT{hXÇnUiLv`Kw`Q{gR{iSzhTygX{gXwWnÇMö¶Z≠≤N±Ø>∂±;¥Æ4∂∞4º¥8∏¨2∂¶-∑û*æ†0Ωù0πù/√´=¿¨<ª©9º¨;∏´9≥®5ª¥@ºµAΩ≥@µ´:∫≤Cæ∫LøøQø¡S∫ºOªΩR¿¬W¡øXΩµPπ∞K¿∑Rø±P¡™Mø°I√üI¿ñ@ºé9¬ï@…™Oƒ©P¡úL¡éLæ{G±lBî]6rU-TY0D_2=^15]+6a,9c1Aj>DmEBjEIoJNtOOuNKtHKvHCo>:e8]ÜddäqtñÖvñâY{mCcVwóåoêQyWIsMPxUT{\Y}cZ|dXzaQsXTyZ[Äa`ÇiCaI;Q:1E,#71I)0O&)J.M!5P'/?$	';"=\:9]76Z61T3/U.6\3=d8=]801?.(6%$6 (A$(C$*E$.G'2F*2F*/D%3H)2F*3G,2D. 1*)))",!$0$$0"".  - -!.** +'0,9(4F8@VI7OA.B6&3* $) 1!+>S@E]E7O90G74H<CUEGVC;D3.6'UaWpxYjd@SM9MBKaThÄsZreWobfzozá}ÇåÉW]SMRKQXQó°ô=I?4D7,C/)E.^x_OiPJgKcÄdayasÜrP^Q;G;(4($2#'8&4G4>PBzäÄäîï£™∞°®≤NY]:NE5L<3J6-@,++4G47P:KiQ@]G=VC0E6 0#+&,GU"dn)onvpÇv
+âzå~åÅäÅÖ~ âÅ ©ü
+æ≠…≥Œ¥	Œ≤√´∑†≤õ®ç
+ûú|ö{ †ÉoW bN 9O)*>0:"EM8AJ57C+BP7MaEB]:#A$=&:!!. *")!"'!!#./)9?3=M3A\9QzPWâVZëXUêPKàC>|3<|.8y)6w%2s!/p)j%b&`/l4q#<t)!M/	$-@$.D ,E;Q+CY3Ka:L`;L]=JW;NS=PQ?IL;CE79=.29)6A04F0>W:bÅ_gåcdé^\áRZÖO_åU!F+ "3#E\H_}c[Äa]ÖbUÅ^TÄ_TÅbTÅ`SÄ_SÄaSÇ`PÉZKQK{IRÉLNÄE;m07g+0]"6^*8^+=b.Ik83S!,L+J%D(D)H/S#/U$-Q#8Y.9U/.E)#"2%jÉnoåx~öåï≥´úπ¥ò∑≤êØ©ì¥©°ƒÆRzXEnB:c7báhìµùê±ûûèò≥™ûº≤ôπ™öæ§bãaLt@<a-6['9^+<d/An5Ap98f58f7;f85`25_1%L > @%C!7106$;<Q21F'4I*4M-.N)0T.5Y32V05Y31S07T5@T9RZEqp^õîÑ•öÑõënîÇPóy1ÆÑ.π~"√É!Œï.‹£<‘í1ÃÅ&÷{,÷z-‘Å3‘å8·°J”ó?◊ï?÷é<ÂìG“z3»j*ŸÖ?È´X‡≤T≈¢<Ÿ¡SÿÕW÷’W÷ÿY”÷U‘’U“”Q–“M–“K““NÃÃH‘–K“…F“æA√Æ1÷¬G‘≈H‘…K€»O‹≥IƒÇ+æ\ƒe#ŸûD‡æS–øIÀ√FÕ»H—ŒK”ŒLœ∆Eø´2Àµ=÷√J–¿FÃπA’¿KŒπFÃ∏G—∆R“ÕWŒÃS  N ÃM»ÀJ«»H»…I∆«G≈∆F¬√A¬¬>¬ø>º∑7æ∂7ƒº=æª8ª∏3ºπ4∫∂1ª¥2∫±0Ω¥3º≥2π≤.∑∞,µÆ,≥´,≤®,≥©0≤©4©ü.¶ò/¢ï/†ì3ôí8éã>cc'$+$40P.Z.\._-^,Z)U*S'OBB7`46`22]/0W+*Q%(M!!D69DjE@hE8\@:^BLqRLqOPrMIi@9Z-6Z.LqFU{T]Å[QtSFiK9Z=:\92T/4V3QuOIlBAf:9^33X-0U,2W,5Z.9`1@j<JsGUyU+J*%?"/G-4Q5<Z@5W>2V<1S:2T;3S;/O7-M6.N7,L4,M2+K3+I1,H/+H,-J.,H/.L2,L4/P;7ZDGmVPv_WgV~fQ{eRyfPweNsaOu`StY[tMyãO•≠WØ≤I≥±@µ∞:¥Æ4∫¥8ª≥7º≠6∂ü/µî)æô1πñ.Ωù8∆´Dºß<∫©=∏™?≤¶:∑¨@æ∂Gæ∑E∫¥Dπ≥EΩªNΩøRæ¿SªΩRºæSø¬Yø¿Zæ∫V∫≤P√ªX¬∏Wø∞S¿´P¬®Q¡ûJ∏é<πå;¡ùG…§S«õR∆ãO∫pC§`;É]6c^6Ne;FmABi=:c7:f5>i;FoCT}UGoJHpKMsNLrKEnBItFGuF;h=hësqîÄmç~dÑwKm\PrbÉ£òkã|U|]PxSPxSOwTNuXSz_[~fWzbW{a`Ñj`Äk=VC/!.$!.';+C!0F"/?" ,	 2F-@_=9]73Y4/U04]5;d<Bg>7V4.9K53G.*A%)D%*E$,E((<!%(!/,: +9*8)6"#0 ,*%$#()++ .#/!". $/"-)!/ 1E9_wjCZP:OF*7.#!"'' .!,9K;AWB2J4*A13J:<Q>L^HIUA>F71=3;KAIZRG[PMaU@WG:RDPh[Oi^^sjm}snxoPSJQTKHMFnxpEOF7G:,C/0I3QhTF]IBYEE\HXo]TiXJXKq{pÄà{7?29G6>P@K[NÖíããìï|ÉâT_cCQQ;OD6K::K94B10@30B20H2?[DGcM:UB;RB!3%*,'-0C>MLS[Z
+og|pá{â}áÄz }w ~v ≠†«µƒ±Æú
+ç îÉ±ö¥ò	Øç•Ä úz ùÇkW [K 6J'(9.:"-6#.9(&3"%3"?R<<W6;[4<X08P.!0(""#&25.<=5AJ9@W:HkCTÇTVãWSäQOäJQéKJâBEà;<Å0<}+2s!+l*k(f&d2p#9v)=u, I%	+1#
+0>'?O2DU5IX;Q^DBL49B-6=+07%,. /0"	15$+3,5 -9%DV>]wT]ÅSXÉM_åSUÄK8&!%/B/6M9OkT\aRyZWÇdR`VÅcYÇdV~cWÇdTÉ_MÄW?pCFxGPÇM;n5=m1+W4]#<c*:a(:`%4Z(M#E @<!B-S""F86-,'(6'G^J`}iwñáüæ∂üæπí±¨°¿∫úæ∞àÆïNvT<d?<dA}ûâï¥•ò∑®å®öò≥™ö∏Æò∫™Ñ´êw†voödU}>>f'2Y"2Z&7_-9e48c63a34_12]/4^0.U)=04549 ;#>3L,>X55P-4T//Q,/S-4X43Y47]81U10R/6Q0AQ6YbEáàiûúvòëcôäOßâ@¨~)∫w øy–ï1Ÿ¢;ÿù9“ç0”~+÷Ñ2’ë<ﬁ£IŸ¢G◊†C‘ó<ÿí<ÊîHƒp(À}2‰£QÌøa»®AœπJŸÕW’ÃS–ÃO‘”T”‘R––N““N“œJœ H—…J—»I◊…L”¡E«Ø3Œπ<÷ÀK”ÃJ◊ŒO€ΩK–è5ºdø]’Å9ﬂ≥R”øN–∆M∆≈FÕŒL––L”ÃJ∆∏;æ´3”¿H’≈KÕΩCÕ∏A“ΩHÕ∑GÀ∫H’ÃWŒÃUŒŒTÀÕP…ÀL ÕL ÀK ÀK»«I∆«G∆«E√≈@¬ø>Ω∫9ƒøA√æ@¡º<æª8ºπ6æπ7æ∑5Ω¥5ª∞2Ω¥5∑≤0∑≤2µ≠0∞®,¥™1≤ß3±ß8§ô/•ñ1£ì4óâ0ïå=|{;+.  $5*J.W,X-[/]+Y&R'R.Y!/Z%"M6a42]/1\.3Z.)P$(M!&I85-P/:_@1X;FmRdànuòzbÑc9Y28\0<b1;e5?k:GqCBkA?dC5Z89`4Cj=SzNXRHn?PvG9^30U,1W0.T+3Z.4^0;f8EpCOxP8Z96P5LbKTjUWoY?[E4T<1S:2T91R7/O70M7.N7.N6+K3*J2+I1-I0,H/-I0.J1.J1-K3-K3.K50M79V@CcLHjRKnVQt\Z}g]ÄjSv^RsXWrS\oA~ãE®ÆT±≤J¥±>≥Æ8∂∞6∏≤8∫∞7ªß6∂ö/πì.ºí0∂ã-ºò8¬©D¿ØGº≠F≥¶@µ®Bø¥K¡∫Oº∫Kπ∑J∫πMøæRΩøRΩøTºøVΩ¿YºæYææ\øº[ø∫\¡ª]ø¥Xƒ∑[¡∞X¿ßSºóF∂ã<πé@ÃúRÕìS¡~IÆc;ìX6pb=Wg@Hh?DmEEnFAkCBlDDqFIsKMwOHrJKuOU}XR|V;h=>m?CtE@oEiëvgäveÖvQraAdN[~jÇ¢ïyôädànQyVKtJBmB?iCEnLV}bSy`Ux`\g\~fQmW*;)&!$'0.7$& /E.@_?:^84X41W2;d<Ag@?a>)D%(?%8L3-F))D%&D"+F',?+"	% (",%.%1 + &)($'(*+ , !-! ,*(.!5I>Ti`=RK7KB)6-#&) .!!-!''9+-B3-D4<SCCXIGXHFTE9E9gtmP_ZEVNEYMG^NYp`PfY:PDKbXQh^Sh_Sb[=D<;>77:3`e^]b[MYM.C0<U@UjYYk[i{kgykAUIG\M?R>KXDéë~GJ7HUCUfVqråôêxÇÅO[[?PJ;OD<M=an]~Ñx>F;:H;0G70L6B`H?XC2I7*<.)).(,*B 1G 5G5@[Zojyo }t ~u {t urkd ®úªØ)åÖkh ca vn Øúπõ	≥èßÄ ü{ ó{cQ MA <K,?N/9E-:F2-8(". &7'F\G*B(0I)6P-?T3;J3%0:=4560+.%7:/26'Q]GB[;JoDUÉUUäVWéUXíWXíURèLEÑ>>}65s*&b@01p!+i/m":x+?|/Av27	 *1!,2$)0 *6">L5:M/FY91@#2<$26%%)! ((EE98:-CE7LO>Y\IHM705!(AM7OdE^zRaáX;c1(L<';.=(+:'+9((9)DVF?XBJhNSw]Tx^Tv^Xxa0P;AdNSÄaNÄ[L|TQÇUDxG7j2@p48d'Jr4Hn1@g(8_ 1X/U.Q/O-M-L 4U(6U+&>-++)/8P:nãw§√¥£¬∫ï¥Øô∏≥§√Ω¶»∫xüÑU~\9`AY}cò∏©ûº≤ûº∞ìØ£Æ…¿¢¿¥ìµ§{¢Ökîhmò`\âF8b"8_(7],5\/3\02]23a35`31\.2\.3Z.0S+?8#@"%D%$C#"A!!>)B"=X50P+7Y40T..T/3Y42W54Z51W2/S/1Q,5M+N^:}É]¢°uîê`öãP¨ãD´x)∂n¬u”ì2’ö6◊ò7 Ö(À}(—á0ﬂ¢G€¶H“õ>ÿ†Cﬁ°DﬂôCŒ|0√t)ÿóCÁ∂YŸ∑SƒÆA’ T’—V–ÃOÃÀM—–Q––NÃ…H”ŒL—ÃJÀƒB“«Kÿ≈L“πC—∑@—¥<◊¡G” I÷ÕN€∆O’®C√k#√[æaÁ£RÿπO” SœŒPÕ–OŒ‘P—”N”ÀL…æB–¬G◊…N’«MÃºC“øG÷¡L—ΩL”ƒQ“ÀVÃÃTŒ–UÕœTÕœP ÕLÀÃL ÀL∆≈G…»J«»H≈∆D√¬C¬¡B∆¬Eƒ¿Cøª=ºπ8æª8æª8¿∏9º≥4∂´/∫∞4ª∂8πµ7¥Æ2∞ß.Æ£/∞§4Æ£9¶ö6•ó6†ë6ñã9âÖ>X[&(0	,+J -U +W)W'U'U'R$O(S2_(2`/2`11\./Z,+T('N"'L %H<6%F'4Y:+R3IpSlêt~°É}ü~EgB>d5Fn:5b+1`*7c08b4:`;3Y46b19e0Gr=Bm8?j4Cn9<a50U,4Z3.W/0Y-5_1:e7DoBLuKOsOPjORhQNaMCYD<U?7U=2S82T9/Q6.O4/M51O7/M5,M2,L4+K3,H/,H/-I0.J1.J1-I0.J1-I0,H12N71M62P84T<7Y@:\D8\B9[B8Y>6S7;T-K^'äñLÆ≥W≥≤Hµ≤Aπ¥?∑≤<∏±<º¨;π£6ºö6πë2∑ä/≤â-º†?¬ÆK¡±Oπ≠Iµ©GªØKæ∑OæªRΩ∫Qπ∏NæΩSæΩSæøWø¬[ΩøZºæ]ø¿b¿¡c¡Ωb¿ª`æ∑]√∏_¬≥^ø™Y¬°RªèDπÑ>«äK≈~H≤k=öZ4É]9agCNlHFlECmGFpJCmIBlFErKKuMMxMLwLNxPXÇ\`äf;hA:hA=mEGuQjízsïÑoèÄOp_>aIZ}gÑ§óÜ§òméyNsTEoG>l>7d9CpGU~^U}bTzcX{e[}eWu]6L5,  "%'!29V7:\95W44X4>d?;a<0O-"=/H+.G*+F%(F$(F$0I,)
+"36!15-1-2,3!&$ -"/%1#''()**+*)*#1$5F<@TK3G>1B8,9/$,!!(!-!(%%7+*?0LaR\laGWL<LBP_Xù´¨jxyL[VJ[QLbUVnaoÑ}xçà@WQ=VRJc`I]\]iiLRRBGCJOIT[SEQE-B/NeQmÇqtÑwtÇuÖíà_od=OAFYCL\BV[DdiSXcRVdUScVRbWCRK;LD8NA6K<3?1wr†°õbg`FVK-E5=ZDD`J5J9'9).'/0,/$= ,E',C&-<[_olzs	~wÄyztokZX èã}|^cUY\^ ìå≥ùªù	≥ç§} ¶Çâm YG QE 8E)AN2>K1;G1)1"+8'+>+H^I*;(4A/5B.3?+4@,.7&.1&;<469./6&>G2M]BIc@Fi?MxKOÅPRÜUUäVQÜNPÖMAt<5h0,]&*]"C|59v)1m%6t+A2FÄ6?r0	. !17)5<,KR@XdNH[=9U-0L##;+7A)?C2DF8JK=JK=GH:01!8;(EH558#49#&.WaHDR88K/BV:9P3,'-';.+8$!,)1&+5*.:,4E3#8%4K9"4("3)) A[N[ÅjVÉfRÅ_QÅ[@qB;k7Bo8Ir6_ÖHQu5Kn,Dg%:]:\ 5V.N2R#2O#YtKazR>S,(<':,@$2J*.G)IbLà£í´…Ωë∞®î≥Æ†ø∫¶«æ™ÃºgéqKrSEhPÖ¶ï®∆æ©∆¡´…¡ëØß¢¿∏õªÆöΩ•wü|_âWfíW[áJ/X9]-@d8>c76_3-Z/,[-.\./].1\.3]/0W+@9(G'.O0*K,(I*)F'/H(A[8/M'7Y44Z3/U05[67]83[81W2-Q--O*3M*HZ4qxO†ùrõîhóÖS£{=¶l#ºp"¿p«|!–â-–Ü-ÃÇ)…Ç(‘ë6‡•G»ê1Õç3‹õA·ûE÷é9√p$“Ö7‚≠QÿµQÃØG—øO‘ŒV‘‘X“‘WŒ–Q—“S“ŒP ¿DÕ¬F‘ÃO÷ÃP⁄ Q’ºFŒ™:—¨:–Ø<◊æH◊…N€∆O„∫Q√|*≈W"∆T Ãx0„ÆRÿƒT““Vœ‘SÕ◊Rœ÷RŒ‘PŒ LŒ∆G“ÀI‘ÕK“∆LÕæG–øI”ƒO“∆P‘ÀV—ÃVœœWŒœWÕ—VÕ“TÕœPÃÕN… K«≈J »M…«L∆∆Jƒ√EƒƒH∆ƒI√¡F¡Ω?æª:ææ:ºº8æπ9∫∞4∫Æ4øµ:º∂:∏¥7¥∞5≤´6´°0≥®<≠°;§ö8§ö;ùì<êä>eg(@N.?#	3+J!)O,W*X&V(V(S%P&S0]&4b1/_/0^/0[.,U)(O#'L $H;8.P/3V6/T29a<NtObÜbhåhgåcKuC=j17d)-Z!.Y$4^.2X1.T+/[(1a'9f+5c%8h,An5;c1,Q&5Y31W00Y/4]1:d6Cm?JsGRvP>X;/G-(@(%?&.J13T92T91V71V7-P2.L0/M10N2/M1,M2+L1-I2,H1,H1.J1/M3-J..K//L0.J10L3/K2/M31O7/O71S:1S:0R9/Q60Q62O09R*Sf/ñûSÆ±V≤∞Kµ≥Fµ≤A∂∞>∫∞?π®<∫£;æù<ªñ;≤ç4≤ì8¿©K¡≥Rº≤Pº≤Q∑≠Lº≤Q¿∏Uæ∫VºπRæ∫Vº∫VΩΩ[æ¿_º¿aº¿bø¬g¿√jæºeæ∏bæ∂a√∑e¡±c¿™^¡£Z≈òTæÄCΩr;πf:ûY0Å[4kf@VlHKpNGoLBlFHpKEoIEoKGqKJwNM{MQ|NOzMLvPNwUAjJ>iKDoQ_ámvòàüínéFgV@cKZ}gà®ùá•ùùëQt^ClJ8e<;h=IvKU[U~`X~eSyb[~hYya8R5(: % %'(*""(( "4K1<Y:6U53U40S2'I(.N)1O+,G&*E$(F"*H$.L(,E''
+ "=?'HH,FE)FF.47"'0(7"%6#$3 '5$&2&#!+  + +!,#.  * *) , -:05E:1C7,>0.<-8C5*0&* * (4*5C6XfYjtkHSK4GCdxwÇêôú©±?JLP_\I^YF\YTiji~ÉVio0GMFajó£°±¿ß±ΩPY^FOL?JB4E51I3E]GsàypÄucoegqh_f^HRG<M:EW?LZ@vÇjVcRAO@9K;3H72I73J86M;Yi\pwowyvoqnSYU7H>3K;A^J@YFHZL2@30/5!:33:T9G_EI[C@K#^_okxu}yÅy
+ytef	SXQ[NYMYTXñè∞†πü
+ªú´á ßÅ•ÇÄd ZF ]N DS4.=.= ?M4:E43@/9O8H^G2?-19*5;/5;-/8%5>+7:/58-EH=LSCblTeuX(@?_8Bl>BrBBtCEyHDvACs?>+T(2]0;j6D{8=w-4p(>z2GÑ7F~71]".3A*PVHFL>6?,2B(H`>ImAKqB?`5/I$+> *6#*&*)+:=,7:'9<)@C047$FK5]eN@J1(8+6)/7Q.;W1B^814K.+!!!)(3%)(#"=RKWyhUÄeSÄcOY9j;;j6Go;Z}EdÑEXw1On"On Pn$A`6T-L/NIf0e}Mã°sÖñl_oHIY5N`:Of:D_4iÑc†æ§á®ìdÜvî≥≠ß∆¿ß»øî∂•ElQFmPbÉr¢¿∂ßƒø©∆¡¢¿∏í±©õ∫≤ñ∂ßáÆè\áZ]äSaéSHu<.Y$3W)Cf<?d9;a88a74_20^0-[,.Y+/Z,1X,-R)A(G%+M,+N-*M,-L,7R/@Z54R,6V/6\51Y44Z58^91Y4+S.-S,,N)/M)=S-_f=ñìjùîkòÇS¢u<°d!∫l!∂d¿tŒÑ+Ã~)»|&√}%‡üC—ó6ƒä)œé2’é6◊ã7√u#…x)€îB‰∂VÀØDœπJ‘«Tœ R—”Vœ‘Vœ‘T–“S–ÃO…ΩCÕøD÷ÃQ€ÕS÷ªJÀ•8”ß<œ•7À™9‘ªG÷√K·¡TŸôBΩa…U$Õb,⁄ñE›∏P◊ÃVŒ”SÃ÷SÕ◊Tœ÷T–”RŒ LŒ…IŒÀH—ÃJ–∆KÀøG—≈O’ T’ÃU– RœÕVœ–XŒ“Y—’ZŒ“Wœ—TŒŒR  N  P…«N…«N∆∆LƒƒJ∆∆L∆∆L∆∆J¬¡C¡¿Aøø=ΩΩ;ø∫<¿∏<æ¥;¬∏?ªµ;∑≥8µ∞8¥Ø:±©<Æ•<©†;®ü@¢õ@òìBxy7AJ8J 0H&'*)D!'H)O*U(U(X&S'T&S+[!3b./_/.\..\.+T((O#(M!'K%E:/N.0R1:`9KqHNtKPuLKoIGnB>j75e+5e)6c(7d-2\*+Q(+R&+W"0`$3c%1b!6h);k/0[&,S$4Z11W./X,2[/7a3?i;KrFRwN9W5#= *D'%B&%C)1R72T91V7/T5-P2/M30N22P4/P3-N30N4.J1-I0,H1.J1/L0/L01K./L0.L0/M3/M30N41O7/O70P8/Q6/Q6.P50R7/P32O09R(^m2õ£Z´ÆW≥∞O∂≥J∂≤F∏±F∫ØE¥¢<¿®D√§GøùC∫õA¿ßM¿±Tæ¥Uæ¥UπÆRµ®Læ≥WøπYº∏Wª∑Vª∂X∫π\æøbΩ¡c∫øcªøhø¡m¿ækΩ∂eº±b∆¥h¬¨c¡£]√úYÕóY√zE≤a4•W1éX2k_7Vf?MmHJrOGoLBjGEmHGoJDnHHrJIvKQQP|KNyKKuOpôyuõÇ`ÜqcàvróÜsîâfÜ{}õègÜv>aI]Äjä©°å©§à¶ûcÉtDkPAkGDqFLzLUWR{YRz_Pv]V|c]d5T4*A$!*"$!"()!$%#$1H.:W83R2.P/+M,5W4>^93S.'F$'G"(H!.L&5Q+0J'*=!"0$ $79!CA(KG.JI4-2.:$/>)*<&(9&(6%*8)!-!&'!)%-  '! )5+*:-#3&+7)4>3381+!* 
+&7?2LTIX_W:FB-ABZqwhxáÄåúOYc9FLdw{yéìÑò£{åúhyâuàôì™ºõ±∆¨ª“ÉèüQ\`R^ZN^S8J:8O;>UAxä|O\RnxoY`XSXQFNCCP?<K4H[?M]CHUCCQ@/D10I30J13L6L_LuÉvy~xZ\[?EE9D@1E:7OA=XGlÑtN^Q<J;):'22K-IbD9O8:P;TmWgiuÑorzUed!rmÉÅ*}&zu!ts#Y_IWEW%FW!OYäá&Æ†∏†
+æ°∏òßÖ ®Ñ	õz}` q\ sb
+J\6>P*@S38H-5B.BQ<F_BAZ<9G007'25*-1#;B0:B-EK=8;0=?4ptft|e1>"&9>Z4<c6=k:=o<?t>Cv>Cr></S->g;Bq=IÄ?HÅ<8t,B~6IÖ;=p./O @S5>G4&, "%)=!RpLMtHXÇT[ÉQJn@3R)";*<$#0)218&%)69(;=/EG9EI:18&&2*(C"RtO!G FmAPwHNvB?j5Fq<Q{I#I+L!0"#+'%0  -!/B<_pXÄhQ~_OW4h79h4Ji=d|JvåLÑõKô8zî/rç,Hf7R2OA_JhA_Og+\i=ëôt•¨É®±Ç•¥{°∂{õjsókYÇZ^áiÉ£ñ•ƒºë≤ßã≠ù\gJmWç´ü§ø∏£æπûª∂ô∑Øí≤ßó∑™åØôfëfSÇLL|BJz>9i/3_*-T(9^5<_7;^6@c;7^24]13^01\//Z-2X/3X/%E )I$,N++O+*N*+M*4R,D`8C_65T+8]44Z33Y2<b;3[6-U0.T-+O).R,8R-LT/ÖÄZòàd†ÉW´|Dûa ±eπk…É-Ãâ0»|&¿tÃÖ-‘ë8«ä-—ï5–é0œÉ+Õs%≈kÀ~.„¶M€±Mø•7÷«T” S–ÃQ–—R–’Uœ‘Sœ“QŒÕNÕ»J“»L⁄ÃR÷ºK…ô3 ì/–ü8–ß;“∑D“ªGŸ¬N·∂P∆r*¬Y √X"ŸÄ>€™MŸ√T”œTÕ‘SŒ◊Vœ÷U—“SÕ…L ≈G–ÀMŒŒLŒ LÕ√H ¿G” S”ÕU”ÃWÃ«QŒŒV–—Yœ’Y—◊[œ”XÕŒVŒŒVÃÃTÕÕUÀÀSÀÀS∆∆N«»P«»P∆»M√≈Hƒ≈F¬√D¡¿A¿º>¿∫>¿∏<¡∏?Ω¥;∫¥:∏≥;¥±<¥±@≤´@ß†8¶°=§üAõôBâã@FN0@.G/J''>!%	&= %>:)J(S'W&V(V%S'W2a-/_/+Y+-[-+T(&M!'L (K!&F!</M+4T/Ej?_ÑYqîlqìnrîoTyPLxGJ{CBt7<n/=j3/Y')P#(O %R-]!.`#-_ 6f(5e))T/Y'4`/0[-.W+3\08_2>e8DmAOuLJlG"A+F''D&)G+/P50R71U;0T:-O6-M5/M5/P3/P3.O41O50L3.K/,H/.K/0M11K01K01N21O3-N3/P5.N6-M5/O71R71T6/T3/T3.S4.Q3.Q04R,=T(bp;ù†[≠¨Z±ÆQ∑≥O∂≤N∏≥M∂™F∏¶BΩ•Eø¢FΩüGª°Læ≠Uº±WπÆTª≠UØùI∑ßR¬∂`æ∑]∫≥Yº∑[ª∑\æædΩ¿eº¡g∫æiæΩk¬ºnø∂kª©a∆´f»•c√ìU¡ÑM ÄO¿l@¢R-ÑP)t^7Ud9KlAJlGMpOKpNDlGBkC<g<9d9;f;?m?M{LTÇSOzOKtRyüÜÑ¶ñsíärìäuñçxòçbÄvpåÄxîÖ@aL^nÑ£õé´ßá§üiá{`ÅlV{\KtJMxJUÄUMwQKuQLuSNwW\Å`7Y6/H('3+.##$%& &'!"#%& !"%/G-7V41S2/Q01P.;[63U0)K&&H%)I$+K$/N%5Q).H#*B-@"*8$,(+&',*24&)23A*.@*+=''8%$5#(9)(6)			
+%  $.#$"$,. =?1AG;:G>0CASlqï≠π°≤ƒáñ©Éê°wÑîjzááôßçù¥ñ¶¿áñ≥}å©ò©√§≤Ãó¢∏PYh`ljM]ROdUG\KNcTWl]`pebme^h`KRKTYR[aWV\N:F2@P6GZ>?N73F0-E-1K05O2G^DtÇqâëÜéìçqws}àÑjyr:NC=SF>UE9P@FXJ4E37N23M*iÉ`c|^WlYDYJCZH]r_q~lvzYmi*nj!¢£g¡≈ìßßÅdhEFV/;R(>T-HWäà1∞°.¥ùπõ∫ö	¨ã ™à™äåmt[ v^ ÇkJd4B\/<R,*? *9$>P:KdF?W7DR9<C17;-8<.KR@@G56=-&,FH=oqdFK7=J0EU8C]8;`4<h7=m9Bu=Fw?<f66%B#8Z7FoCPIPÑF@w4H<@s16](3I%) &)"/:*?V:XxSLuMR}R]áW\ÑRCh<>6'9#0=)2;()229)+/ )-!#$6 HaCNrLTRDrCK{IQÄJM~FL~COÇGNÅFHz?P{F<[2 !&.)4$$0"'1B:FbSX~gO|[DtL6h7>h8Ng?nRüØn¶∏f†¥Qî´?â§;Ql>VPj ví=à•Kà•KlÑ8;Icj@àã\°¶pü´k}íQZu>dÜT`äZaâfÉ§ìôπÆôª≠zúåRtc_pö∏∞®√æ®√ºò∂¨£¬≥ë≤°ê≤°Ö¨ëZÖWZâR>k46c,3b+6b/$J!+M*<[9>\8=[79W15Z/4[/2X/3Y0/S-,N)'E#+I'-L**N(+O+,P*4R,:V.QlC8T+:]58^73Y2>d=9a<.V1,R+-S,0V/5S-BN(tnJ£çh∑íh±J¢e$•[ør$∆Ç-Õä3≈y%¬v"“à3Õä1»ã.‘ò8⁄ò:’à0æa n#—ã6Ê±S»£;ÃµE‘…S—ÕR…≈H»…Jœ‘S–◊U“’Tœ–PœÀM“∆L€∆S •:¡â(“ñ6‘•=ÿ¥D€¬N÷ºKﬁ∑Nœè7¡ZƒU »j*·ûMÿ∑P‘…SÃ Oœ‘Tœ÷UŒ”SŒ Oƒº@–»L”ŒPœÀMŒ M– N—ÀQ”—X”—X—œXœœW–—Y–÷\“ÿ\–÷\Õ—XÀÃUœŒXœŒXœ–Yœ–YÃÀW»…T»…R»…Q≈«L≈«Jƒ∆I¬ƒEƒ√E¡Ω@¡π=¡∏?¬πBø∂?Ω¥?∑∞<µ≤A≤ÆB±™B§ü;§†?ûùCêìD^g&)9
+%;$@'E!,E%,(+(8*P)V&V&V$R)V0_+.^.,Y.,W,+T(%N"'L (K!#C >+I'4R,Ae7MsBY}QbÜZlêdbâZ\ãWL~C8l,6h)6c,+U#)P!.V$'T*Z$T+[3`%0\!)T4_)9e20^/.W+1Z.6]09c5Aj>JsIKoI-O,&C$'D&/M31Q92T;1U;1U;/Q8.N7,L4-O4.Q3.O4/M30N21N2.K/-J./L00M13M22O30N2.O4/P5-M5-M5/P52S62U70U4/T3/T3/R2/R2/Q05P/BW.hq<ûü]´®Y±≠T¥±T∂≤Q∏∞N∫ÆL∏®Hπ§GΩ£N∫°Mπ©T¡≤]Ω±[ΩÆYª©W±ûOª¨[¡µc∫∞[∫≥[Ωµ`æ∫cªªeæΩjºπhΩ¥i¬Øj≈©h¿ú^√ñ]≈ê\∏{L≠j?´c=†U5z?W=Z\7NjAClBEiCImIKpNHpK@iA6a61\10[.;i;@n?P~OMzOKtRoï~É£òsíçsíçtìçxóènåÄ^zkgÜt=^I^nÖ§úá§†wîèuìâvïÖfàoPvONwKS|RHrJErKFrNQyWX}\<^;1J*+7#69.&)"$&!%(! !"#)*%&(#+2L/4V32T3,N+%D"+K&*J%&H#'I&)K&,L%#B*F)E&B,D 0@#)6%'4"5D/0B,);%&7$"5"':'+<,#
+
+
+ (0%37(>A0?C4;C8?PJ`uvú¥¿°∏ ¨æ÷î§Ωó¶Ω±¿’èû±¨ªŒëü∫YfÜ~ã≠}ä™ó•¿èô≤jrÖV_htÄ|Xh]cuiqÖywàÄm|ujwn<I@2=5;G=DOADO?NYHJXA5G-?S7CW<.E)/I.5O4<V;jÄi}â{vÄw]c_s|yãóì±¿ª_sjSh_Xoe7ND<PGBVJD\DD_@TmOg~d]rcPdYL`UbthiugkoVlj:sq>äêj∏¿©ëôéMYO=S<9R2=Q,ëõf†ôI¢è)Øï≠èÆç
+ù{ ów ép u\ rZ s\ zcU{>:]%.I!6);%0A.JaD7L-KYBcjXbfWX\MGN>BK:>F7=E6^dVjn_8?-6B,CS84N+>^5:a2;j3Cu:Hs=-Q%2(25O2@`;IpAIv?S~H8Y**@(!#&0%C\?\~[PxVJtP[Ñ\^á[[ÇS6Y/-(7$.=*8E1BO;7C/!* 2>[<TyPR}OP~ML|JL~IM}IL}FJIMÇJIEL}EWÇM ?&)  &"-*4+$4)BYGY{bKwV>nF<k?GlAThCxÉXÆΩ|≤¿qÆæf°µVû∂T\vI`í©Q©ø]Ø∆^õµHpâ+9LLZ%ck2ÜéShx:Mb'Hc.tîcqïgpìr©»∏®»Ωá¨ö]ÇpVvkî≤™•¬æ§¡º™»ºë∞ûè±ôuôÄ£ãú√¶^ÖYEm;8`.8`.<f45_1@9/L-4O09Q/=U3,G$.L($D$C! =3";,F)+H),K)*L'*L'3S,7S+Ib:Ga:8X3<`<5[6:`;?gD.V10V/1W00Y16V-<L%a]7¢Üaºèf±yF•e'¶`≤iπq≈z'æp≈w%–É1Àà1Ãë3”ô8€ñ9¬rπ]Ãw'ﬂüEŒ£=≈ß9—¿L” Q–ÃQ¡ΩBÃÀMÕ“QÃ”Q–”PŒœO—ÀO—¿L‹πQ≈ï3«å.ÿ¢>–¨>⁄øL⁄¡M“≠C›ùE¿h!«S"≈U#“Ü:„∑T‹∆VÃ∆L≈√H——U—”VŒŒRÀ¬IÃ¬G”ÕQ“ÕOŒ»L—ÕP–œQ‘’V“◊Y–‘Y—“Z–‘[œ◊]Œ÷\œ◊]œ’[ÀŒYŒœZ—“]“”^–”^Õ–[»»V……W… U«»Q«»P» Mƒ∆I√≈H≈√H√øD¬π@¬∑A√∏D¬∑Dº∞@πØ@∑ØB≥¨D≠•B¶†B¢ùBóñFx<9G#:9<?$B2(%'+)I -U!)V"R%S)V.])0^00Z2+U-*S)%N"&K%H%C ;(C"*H"9^+Js;Hq9Hs;Hs;Cp7Eu99k,.a,\ -X#(R )Q-X#*W%R K0Y!2Y")P-T/W"/[(1_01Z01Z22[/6_3=f:HqGNtM7Y6(E')C(0L55U=2T;2T91U9/S7.P7+M2.P5/Q6.O2-N1.O41O5/M3.L2-K//M13O60N40L30N42P60N41O52P61R52U71T40S32S4/P10Q20O03P18P.EU.iq@úòY≠•\≥≠Y¥ØT¥ØQπµTπ≥Sµ´L≥°Kº™Vª¨Yº∞\¿¥`Ω±]º∞^∫´Z±†R¿ØaæØ^µ©WºØ`ª≥bª¥dæµh¬±i¬¶eøî]¿àWƒÄSΩsL≥iFûY:ÄG*m>$^8!G133;N.LlGDjCAg@DjCGmHEmH>g?8c88c8+Y+5d6<l<DrAHvHDpL_ám°ìwòëuïêuîéríá[zkKlWFhP?bJeÜs{õêÄùòÑ°úå™¢à§òbÇmOrQOxNR{SIsM?kHEnNfän^bC^?3G+$/28, %&)"$&!*,').' +5P15U00R/*L)%D"%E (H!'J"(J%-O**J#7;,H",H"+E .C"/?"&/ !.2C03B-,>(&7$$7#'=(.A.",!!'#" %!$/!5>-9B12@3ARJi{}_s|§ªÀ≠√⁄Æø€ú©…[fÇzÜûû≠¬°∞≈û©≈Öì∞~ã´âó≤s~îjvÜblutÅhtrUa]~çäï°üt~Ä\fghwpèÖ?QE-?/7H5OcJE\?E\?6N.1I)>W98S48R53M2;Q<CVCBRE9I>P]Vmyuêúö≥¡¡h{yi}uèé_yzdy~awuRi_PhXYp\bwdÜöèâúñnÅ{arlUbYpxi}ÅjÑàoö¢ìàïåR``@SM;Q:?U1ÇèdÆ¥Ü∆¬ïéÇHÖoñzù~ém|_ tZ pY q\ r_ rb`ÜKFg2G`64I(-A(0D+c}ZgÅ\QdFJX?8A.LUD)2".MXGNYHKTCcjZ<C3'3OaI/F).I&<]2;c1Ai7:[.4))'-@*-D'?Z7PqF7S*%8*6'0!(2)F\EcÇcX|`IrTqòy_áb_âYQvJ&&/=,5B08E1 -5>-0;*"1:R8OtKO}LPÄNMJMJK~FK|ELGH}GF}DIEPÅIJr@(	"%"")(6'6K8C_HOvWDnJ9a<Fd@Ra@éól±Ω}∑≈xÆΩl•∑aõØXiÄ&cwñ©Mµ≈b∑ _ó≠>{ì17NCXSb)jy>AYE`)Ca-gáXkèc°Ä©»π©…æá©òRtczòê≠«ƒ•¬æ§√ª¢√∞kçriål`ÉcxúÄÇßÜQvM4Y-@e::a5@j<:a5+K&47!:(=2G&8"=;<"= 9, 3'>$-F))D%(C"(C"3M*BX2OhA4T/:^:9\;6[9>cA1V4/U00V/2[12U+:Q'PP*älJ´yT∞vF≠m0¢_Æi¥k∑j≥d∫l¿s!¡~'œô9Ãî3“à/±_¡l÷ä6–ò9∫ì*“∏G“√NÀ¡HÕ«M≈øE“ŒQ–—QŒ—PŒœOÕ…K“»O“ªK”ßDæá*œô9⁄≠F’∫GŸƒO“¥D÷§CÃy-øUŒU(Àb+⁄ûFﬂ√Vÿ…T«¡GÀ…NœœS——UœÕRÀ≈K”ÀO’œSœ…M“»Oœ∆M”œT‘÷Y–÷X—◊[“÷[“ÿ^œŸ^–⁄_—÷^œ“]œ“_Ãœ^–”b—‘cŒ—`Œ—`  ZÃÃZÀ V≈ƒN«»P ÃQ««M≈≈K≈√J√æFΩ≤>≈∏Eº∞@¡µGº∞Bπ≠A∂≠F≥´H©†C•üGöóFâåEO\$5K%A=;B%E5+%&/%C(N)V#S$T$T-\(1_10Z4+U/'P&#J"I%H#A25(C ?d1Eq6Fr3?m-;i+8h*4e$3f$4g$6f(-Z#$O6c,:g.5e'+Y'R*Q(O%L*Q,U2^)2`/4]30Y1/X.3\09b6FoCMsLDgF(E')C*+G0:WA3S;3U:2V:1U9/Q6,N3-O4.P5.O2-N1/P5.O4-N3-K1-K1.L2/M30N41O71O70N40N40N42P61T62U72U72U51R5/P11R3/P13R34Q27P0CS.fh9èäP´§^µÆ^µ∞\∏¥Y∏µXπ¥X¥®R≤°Oª™XΩ¨\ª¨[π≠[º±aªÆ_∂§X∞ùQº¶[∏§[∫¶_æ™cø®e¡•døõ_ΩéZ∂yM´eA¶]=ôR6ÇB)f2S/C.:2-1&6'@#AcBEkFAg@CiBEkDClD=h=;h=:d<0[0,[-;k;Ao@CpEMvVfév~†íyòí|õñxóëxñéfÖvOp[JnT@cK[~jsìàà•†è¨®í≠®è®¢uëÇTuZMrPRwUGoL;dDQx[jåq`~bE`A.B'"-47,.1(!$  !!!06Q25U00R/)K(&F!(H#(H#*J%.M+4T/0N(#?4&@.G'2J(.C"1A$.7"$+*-$%1?.3B-0?*+:'(;'+A*0C/'3% !'* !)*"##$'5&.;*/=0/C:}ëêj}ÑPcqû≥∆≤∆ﬂ´ª‹•¥’xÖ•p{óò¶¿õ©√ì°æwÖ¢áï∞~ä¢NZj\iqbppetoL[VSb_í†°`ko@GM2<>FUN[maWl]OdQ9Q98Q4:U6C^==X92M,3P1C`ALgH[sY&;(3E76H<5F<ixsL[V^mjÇíëdy|ë™Ø™≈–ú∏∆óÆæòÆºã¢®täà]pjizrîß°zçãhz|GY]Åêì§∞∞Üåäãëço{w`pmDWS<PDIZ:p|NãéWôó^¶ûoôçYeRkUqV sV rW qYlX k]ndwoA\3ZsKZkGM^<QfEVpKIm?Jp?RsFD`:(:"rm9G.'3BN8BN:FR>GP=?H77B1XjT!8#::R2/I&'A"4'&&5E+CS8K^@AQ4*:&,4&-# $&#-4,:M:jÜm[}dRy^xûÖcäkZÖXZT1+4@22=/6?.*3"'/ ,&8 NlJR|NM}IMJKÄJI~FI|CK|DEx?EzBG~DKÅCM}C1U)&	&$"/#2$5#1F3A]DA_C4Q37N1N\;íõn´∫y≠æp¶∑iü∞`ò®]zã=jx)Äé9°¨N§≤Pë£?pá/8R@]%Nl6Lm6@a*Cf0Ej7QwHfãboêsõ∫´ØÕ√pêÅYyjõ∂ØØ»ƒ®∆æ§ƒµóªü\Ç]Y|TbÇ]oëpdÜe;]8:^8Ae?9_8;d8@g;8Z5; :&?!)B"+D$)D!'E!"@"A&D"*D'+&4%-%7!, 4;P/E_:9W1:Z5<]>3V6>a@2U40T00V/7`6-R'7S*GK&mK/ühI∫SøÇI¶i&©i∂l#ßY∑jΩp ªpæ|%Œö7—ô8∆x#∑bøuﬁüB∏à"øù1”æK≈∂?∆∑B∆ºC ƒJœÀN–ÃN≈¡CÃ»JŒ∆J‘≈Pœ≥F»ñ7øá*÷¶D÷¥IŸ∆P’¬LÕ®>€õCøYÃT"ÀW&‘v6ﬂÆO‹∆V—¬K»¿DŒŒR–“Uœ—TŒŒR ÀL—–R”ÕS“»O“√N“√N‘…U’–Z“÷[–÷Z“÷[—◊]œ◊]œŸ_“◊a–”`—‘c–“d‘÷h“÷gœ”dœ—cÃÃ\ÕÕ[ …S  R»…R»»P∆ƒM«≈N≈¿JƒΩI¡∑F¡µGª≠@¡≥HºÆCµ®@≤®F∞ßJ¶üE°úJíîKdn1;Q"2N(+I% @=$I/R(,L%9)(!;(J'$K&R'W$T$T*Y%-[-.X2,V0$M%$J!!H$G#A1##:9]/Fr7Jv7M{;XÖLRFCt3Ar0As.;l*/b +]As4Dw5:o)1d!*X#N*R)Q+S/Z":g.;j44]11Z00W+5\0;b5El@JpIRvR)F((B)6 <XB2R;4V=2V:0T8/Q6-O4/P5/P3/P3/P30R7.P7+M2*K0-K1.L40N60N60N6/O7/O7/P5/P5.O21S81U94V;2U71U9.S4.S20S31T60S30R15P/AQ-X]4Å{G®ù_∂¨dµÆ]¥≤[∏∑]π±\≥ßS¨óHπ¢Vø©]∫©[æ≥dæ≥dª´^∞úS∑úY¡£cºú_øõaøë_¡âZæyP¥jG°W:ÖC)n:$]9#K5=244.6+8&6"6": .M.EhGCiBCi@DmABm@7f8CrFGqK9c=0[.5c5:g<R~ZaápÄ¢îÖ§úÄùô}öñzóìÄõñtíàStcRs^JmYnêÄzôìà•°ñ∞Øî≠™î≠™å¶ùyñÑRrZLqRBiJLsX`Ñj_ÅfZ{\Cb@ 9&68-GG=55+##   !'8%4N13R0/Q.(J'&H#&H#)I$.L*0I,0I+4O,0L&&>1'95E+3A(1='+4!)1"PVL>D:$,)4$5B03B/-<)->+.D/1D1)3( #$&()-&-**"!, ,&!
+,"$4)(8-.%SgfÖöünÄéyåùâû±≠√⁄®ªŸ™∫€∞ø‡¨ª⁄©∂÷¶≥”°ÆŒ•≥–ñ§æq~èYhogvs^ncbreXl`rÖ{çèXglDOS5A?3@77G:8M>:Q=>WA@ZA2L3.K/7T6;Z:9X6IhFxëqjÅeUhUcug[ma`pfmyu;GC;JCNa]Ñù¢©≈”¨∆ﬂ†πÿ°µ÷û±œ†¥Õ°≤ƒtÄåmx~Çêëî¶™ü≥æè°µß∑Œ¶≤»hogpwJYVM_SBWDN_?tzJúõ[òè@îÜ.õã4õã6l\eSiWlV nV nXl^nhlm'rx8K^>N_?m|[SdBD]6Cb6Kv@QÅGRH[ÄT+B&M\Gjx_6D*CQ8BN6HT>>G44<-&1!WiS'>$:L4:L4#5$1.6'%+"*%0csX_pP-<%&-<@2')$!!'%+3(-;,4J5cf`ÇgQx[KrWV}^QzPIlD),:+.8-7?2)/!/5'+1%!,$8UuPN|KG}CF{CG}CH~DE{?Ex=Fz<H~BLÇFPÇEKvA/J',&(*!0$3#2/ 3 "8#+A*-A(6F+P^={Ü[û¨n£≥jö™_óß^yàE_k+yÑBr|5q}+ç8oÅ/cy0Ig+Be/Ho:bäVKr=Ag4Hp>LqEdá_hâjâ¶î≤–ƒfÖvháx¨»º©≈πï¥§Ñ®éà∞ãT{OGg>Gc;G`@>Y86U5=_><_>;a<<c7<a6'F$5";*C&,G(.L*/M+*H$&F!&F!&E#(B%!%$37L->X3;Y38X3@_?8Y:7Z:2U41T34Z53\2.U)5U,?K%_G+ç`Cµ~U¡ÖQßp/™n(±k%ßZ∏o øw%ºqæ{$…ë2«ä-∞^∑b√Ç(◊£@µè$…Æ=ŒªC∫Æ4≈∂?»ºD…¡E ƒHÀ≈I…¡EÃƒHœ√K‘æNÃ©A≈é1Àì6–¶B‘∏K÷≈Q–πG⁄™H«z,∆TÀQ"¬[ ⁄é@ÿ≤M÷≈Q æFÕ«KŒŒR“‘W——UœÕRœŒP”œTœƒN ΩJœæL“¿P“≈S“ÀW””[“÷]—’\”Ÿ_”€b–ÿa”◊f”’g”’g–‘f”◊i”◊i—’gÀœ`Ãœ^œœ]ŒÕWÃÀUÀ T…»R∆¡L«¬M«¬M≈øM≈∫Nº∞Dø≤I¬µLªÆF≤¶B≤®I™£I•üKôöNw}=IZ$;V-7W21Q,$G'L#3Z.1X+5Z//R*46$C!.S*0Y-,X%'V&V"R&U-[,-W1*R/%K& D#H#F%>,')D!:^.Ah1Gp6Q|DLy>@q0Ct2>p+7j%7j'>s/H|:Dy5=r,8k&*Z&R,U.V!2Z%4_'9f-?l55_12Y-2W.5Z/8_3<e9GpFOwR5T5(D+!9#<U@5U>2T;2V:0T80R9.P7/P5/P3/P30Q4/Q8.P7+M2,M2,L4/M5/M5.L4.N6.N60P80P8/P52S83U:2T93U:1U90W:.U6/T3.S2/T3/T3.S2.O07P2?N-TV/sm=úìZÆ•b≤™_∏±`º¥cΩ±_¥°TµùSª£[º¶]ª´`æÆcæ¨bº§^ªú\ºì[¬ê_æÉYæzU∂kK≠]BìI0u8#[.F+:226*8(<##;!&>$#;!46!> <^=EiCAj>>i;?m>;j<FuKWÄ^ElM=e@3]7;gD`ãopïÑÄüóÖ§ûÜ£üsêåtëç~õñläÄTsdPq^JkZ{õé}úñé´ßó±∞ï≠≠ï≠≠è®•å¶õhÖsCgMNuZsñÇpë~XzaPqRFhC1L+%!#99/@@666,)) +>*1K.0O/'I&&H#%J!&K"-L*+F',+&=!0G++=%,%&"+&/%+ &?B9@C:!$!'4?/6C10?,0A.4G30A/#-" %&+-"02$+2  --'& ---,*)($" '.$0& 1)% UmoyèölénÅíã†≥©Ω’∫ÕÎªŒÔ∫ Ïµ≈Á£±‘ì†¬ÆΩﬁøÕÍÅç•eqÅvÖà`oh]m`gwjSh_wãâåù•ÉëöQ_bVb^GTJ4E5-?/+@/+B.1H4/F2+D.+G..M.-O.bÅ_c~]nÖiuàtqÉurÑxn}vkxq?LEDVJRiañ≤∂Ø ›§ºﬁ¶ΩÊß∫‰§∑ﬂ£µŸ¶µ‘âì¨mváÖíöçû¶¶ªÃ≤«‚•µ◊}ä≠ahÑY`piwwASECW>ÜîpååVêà@îÖ*îÅõáõä znpfb[g^r`p^
+ngrt+_l4fxFerTbqR\mME[78T+Gm<Fx=G}?J|ANxH3N/1C-HWBkybAO6JX>CM5;B0$*#N`J/7I31@-+6()1$=C76<02=-DQ=AQ45F&+:2;&5;-!#)%- '$3;R8JdGVuV<_>DgFMrPCkHHmKTxR =#6")5))1&HNB $8<.36+5=.0G-TvQEuAAy<Ay:@x9Cy;D{:D{:IÄ?LÉBQÉFOzE?*+#-"&0%&0%,8*%6#$8#73/%8$"3 "4-<%5C)SbAgvKÅêWãöWâôPéùXdo7dn<qyFgq<GW@TEZ!>Y"=^)Kp=Dj9]ÑUV|KV|KV|MMqEXwMwïqxñ~°¿∞[ymzôäß∆∂çØóaÜd[ÑZbã_=b6:Y0@X4AR2=P26Q2;]<8Z9<`:<a6:]54/'>",E(/J+2O02O0-L*)H&*I'*H$/H+#		
+)2I,6Q.:Z5=]8@_?:[<0U4,Q00S34Z50Y/1X,4W-6L%JI*qX9ùkFÆtF©s7¶m*Øl(¶`∂o!πq∏m¡w"∆É,∑oÆWªhŒë8¬ó1∏ö*…¥=ƒπ;ª≤1ƒº=»¿C»¿D ¬F…¡EÕ√JÃ¿JŒ∫I“≥I»û:…ë4Àî7»¢=⁄¿R“ªIŒ©?ÿñ@Ω` T"ƒR…z/‹™K–∂H–ƒNŒ≈LÀ«J ÀL–—RœÀP ¡H–∆M”«O…∏D…µD—ΩM◊«X’»Xœ≈T—ÀY–œY“÷^’⁄b“Ÿe“Ÿg‘ÿj‘ÿj“÷h—◊k”Ÿm”ŸmŒ‘fÕ—bÃ–_Œ—^ŒœZŒÕWÀ T «R»¡M∆øM»¬P≈øMƒºOº±G√∏O¡µOπ∞K¥™HØ¶IßüJûõLÜåFM\#=U%5T*2U--P(.S*7]6:c9-X+/Z,.X($N&M(O 'Q!+W&-\()X!%U!Q"Q,W)-U0*O-#E" B!C$B /
+	
+"!5,H 6W(=f,@n.Fw5Fy6Dw2Cv1Fy6L=K~;H{8Ex57h')W*V/X4["9`+4]%.["2_(6`05\04Y04Y07`49g9AnCHuLFiI"@&";%<U@5U>2T;1U9.U81U;/Q8.O40Q61R51R5/Q8.P7,L4,L4-M6-M6-M5-M5.N60P82O93Q94R:2R:5U=4V=3U<2V<.U8.U6/T3-R0-P/0S20S21S22O13L.>N1FP-ca:Ü|K¶ñ[∏•aº™bª´^∫™]¥¢X∂ûXª†]∏ü\µûZº£a¬¢e¿ô^ªÜT∫pMµ_D±[D£R=äF1g7!I09315.;!*:"6#: ": (@(":"248,I*GiF@i=8f56f4;j>TÄ]jíxaápRy^=dIKu]hè|xôêûôûòÄüô]|vgÜÄûòoçÉUteMl\Qpaùëjà~Ñ°úò≤ØîÆ≠í¨≠è©®ç®£vîäKm\ié|Ö¶õ}ùê_ÅiCfFDi>Hf@'6!''00&,,"&( 
+$.D-/L.+J*%G$(J%'L#)N%2Q/";&*5'&.#!"" %&--%..&,7)5C2/@-2C04E3+9*# )*"13(+2"%2!0"/$+/0#4$&4%&4%(2'%/$#/#.!,!+!*" \txsãïmÄèqÑïÇî®ßª”¥«Á©Ω‡±√È°∞◊KYÄGUzª ÎÆºŸKUnQZkvÑÖzâÑetm]mj[nrÖó°âô©î°±6EJ6E@CSFARB5F62C35F60A1)>--D0-F0&B)"@$ZyYoäiVoQf|ebub]occtj_oeN`RSjXE_Rôµπ∑–Ê•πﬁß∫Â©ºÁ•∏‚¨æÊ≠Ω·vÅ°T`xJZgNbkyì¢µÕÁ•≥⁄~Ü≠x}õëñ©áíñGWMAWBcsOÉÖTöëNïÖ-îôÖöãáÄ&VXNVPVi`ofqr0cp:Sh=YsLDX3BX2D]6Mi@;\/>f2>m6>p5Am81U),C&6E.7D0R`IAO5P_B?L2FR<#,&3!H\C)@&,=* ,$,!'/$*2%!,GV?4I*=U1?U18F,&/#&(0#4A/8L3XsTcÇbhåhróumìnPvQ>d=/X08^77\3&E#6$#+IOC )-6%4=,5B.3L.RwLDs=Bx:By8=t1Cz9E{=IAMÅCPÄFCn9/O&+ '5$*=')@&#: 45,?)*;((+8$@L4ZiJjxTrQ|âSvÑGes6N\)N[/NY/KX-J^-Nd5H_3=X->^/Ko?MsDPuI[ÅRgç^cà\PpGA]5màgkâoà®ìqêÅò∑ßÑ§å^ÅaRxO\ÉV@e:+N&5Q+<Q0@Q1<M-6Q26U57Y6:\78[3.L(+0,@'.G*/L-1P02Q1/N,+J(+J(,L'*E&#			%9-H%3S.6X39[8?a@4W6+P/-R13X6+T,.W-2W.1M';I(WQ/yW2ûoC®yA£p1•h'û[∞k ≤k±d∑jÀÄ/™_∑d∆{( ï7∑ï*ø™5¬∑;¡∫8Ω∏6√æ<∆¡A≈Ω@√π>»ºDÀºGÀ∑FŒ¥FÀ©>∆õ5Àñ6¿ê.Ã≠C‹¬T»™<◊•Dœ{2æT»V"Ãj+›°IŸ∏M‘√QÕƒKŒ»L»ƒG≈∆G—œTÕƒK≈πC æF“√NŒΩK–æN—¡PŸÃ\–ƒTÃ¬QÕ∆T“œ\–”^œ‘^“÷e“Ÿi‘⁄l“ÿl“ÿl“ÿl‘⁄p”ŸoŒ‘fœ”d–‘cŒ“aÀŒ[ÕŒY ÀVÀ»U…¡R∆ºM«¡Q√¿O¿πNæ∑MΩµPª≥P∑ØM±®I™†G£úKììMX`$7I4O&2R)/R*1V+7]4:e:5c5/].*Z&(Y")Z"*Y"+Z#(W!$S-\(+Z$'V#R M(R".T-*M, B"A"@#<&		,!=0U!6_%Eq6SÅCN|<Lz:SÉETÑFPÄBN>Iz9:k*._,Z1]4]!7`(1Z")U-X /Y'7^15Z16Z46_58e:=l@FsJLtR?$!=&9R=6S=2T<2V<2V<0S;0R:/O70Q61R73T91R70P80N6.L4,L5,L5/O7-M5-M50P83P:3Q93Q92R:3S;2R:2T;2T;.R6.S4.S2/T2,O..Q0.Q0/R1/P1.M.3M28L0GP1VV0uj<ôÖP≠ó]≥õ[∑¢_º£aΩù`ºö]øõ_ºï\ªí\¬ì_¬äYªvMµ^C•J7å=,x9'b7&J435*: *=!(?"(A#!:6#;!&>&5123 ;=_:Bi=6e14f37f<UÄbvúázúånêGiX^ÉrníÑyòízóì|õñ}úñlãÉYynyòêtîáVueJiWMl\dÑuXxkvñãîÆ´í¨´è©™ä§£ã•§vìékãÄÇ£òâ®¢Ü¶õgàsAfEGnBOoF(:"! !2 /G--J++J('I$'K%(N',R+4V3,F)&!& #% ! /1,,.)()$12,0/*"!%2>06D35C2/;-'#% #$+.%+1#%4#5#2# ).- 1#4"&4%*4)",!()+ +!* "xçíxéôpÉí|çùtÖóëß∞ƒﬂØ√‰Ø¡Á≠º„^lëLY|¡Œ}Ü£28NBJWZegtÉÄsÉÉpÑvàîzãù\hÄHUf?NQ.?7%7'/B/BP?1?.,8*8D6=K<4F6'<)*A-+D.@]AoäkfaZqWL_KRdVasg`rdfxhsäxôé± —ÃÂ˚¥»ÎùÆŸ£∂·•∏‚®∫‚ØæÂuÉ®>Li;L^6LYè®ºª–Î†¨“ÄàØuzöçì©ãï°Wee>SDJZ?msGß°c†ë<ñÉîÉéÇ^]=F;MFUaamj#cj4J[/A[8HgG;`,7^)5](2Z%/Z$,T +Q"'G,F#5H*6B*>F1DN6;E-:G-SbE=M0:M1$3/A)AX;<S7"04>3#8C5!0;O4Fb<Fg:PqD3O',<"$ !'*!/7*AS=VuS]ÉZ[É^ZÑ`\ÖcMwS;e=3^31Z03\08b4Dk>Dd;3)8C2!0"5,@$'A+I#KqBAn5?q2?r0Au5Ey;H{BM~GNzGNrF9T1,$	!.-@*)@&": 7%=%*@)%8$"%2 5A-^hPnx]juUmyU^k@L\-AT&9O!+=DY2Md:VoEG]77O+;W.Ed8KoC_ÉWQuGcáYUyM8V05N0MeKlàq}öÑuí~£√´`ÇaUwR8X39Y4(E&$? ,G(4M-4L*1K(/M)2R-5U09Y4:X6'@"!, 1/G-/N./Q.1S0.P-,N+-O**L')H()
+
+
+
+!0+D$*M%3X/2T1=_>>`?-P/-R1.V3'Q-5]80T.-K'.C"?I&_W0Çk?îs>£v=ûh,ù`!£^©_©]∞døv'•^µoƒâ-ªê*∏ú.¿≤8Ω∏:∏≥3øº;ƒ¡@¿ª;∆º@¡µ=ƒµ@«≥B ≤DÀ≠?»¢7¬ô/∆ú6«§<–∏Lœ∑Iøö0⁄öBƒ^ øLΩY◊ã?‹µP—¿NÀ¿J ƒJÕ«K¿º?…«L–ÀSƒ∑D∆∑D—∆P–«PœƒQŒƒQ— V‘ÕYŒƒQ…øNŒÀX”‘_“’`—÷b“÷g“ÿj◊›q”€n—ÿn—◊m‘Ÿr‘◊n–”h–‘f—’fœ”bÕ“^Œ—^ÃÃZÃ Y…√U»¿S«¡S≈¡S¡ΩRΩ∏RªµS∑±Qµ¨OÆ§K¢öG†öPpq719
+#3!6&A +K&=c::e87g75g21d,,_&+^%.a(0c*0c*/`))X$,Z).Z)+W"&S"M%P*Q%'K%A!@#>5	
+#)16'H8\.>d1Bi4Ho:Fn9Ju?Ju?Kx?Es56g%0a0b1b 5f$8f(-Z,X0Y.V"6].8\65[66\5:c;?iAGqKMuR.Q38!6O:8UA4T?3U=4V>1S;0R:.N7-M50R93T91R72P60N4.O4,N5,N6-M61N8/O71Q92R:2R:2R:1S81S:3U<3U<0R9/Q6/R4.Q1/R1,O/.Q1+P/+P/.O00O0.M.2O19R4>R/KS.c^6áqHôxK¶ÄO∑ç[Ωí_ªãZΩâY≈ã]¬ÅWøuPæjH∑^@©O7ä?*_5J5 >8"16,: (< '?%>,E''@"(B'-E+ 83042 =/Q,Ah;7f25e3;iB[ÜhmíÄwóätíÜXvj[{lnêÇuìãzóì}úópèâoèÑVvidÑufàwXydDgOIoVTzcQvd{ùèè¨ßí¨´í™¨à††Éùúyìêxïëäß£äß£Ö£ôUxbCkIEnBJoD!8!.&.#)	.D-.K-0N,.N)*L'(L&-S..V11V4/P1%=%& !"!"$$"$$")*%"!
+&.#2=-+6(% "#(!%0 )8#'9!$6*! &#-$2!,**)" $%$$ëì~ëò~éõÄêüyÜóWgw`uàè£ª±¡‚•¥’wÜ•vÅüΩ√„EIdFJVHMQBNN_oouÜén~ço~ëmyë[fÇ/<O,>>2H;6M9+A,3D1+8&5A-@I8GO@FQCEVF5J9'>*F_ISmR>W:@W;JaG;Q<[p]cxeg|k[ocxåä∞»‘…·˘À‡ˇ¡’˙¥«Ô•∏‚°¥‹∞¬ËØø„xâßGYqcxç¢∏–¥«Âü©ÕxÄ•wÄ°åó≥êú≤qäCSRAR?`jEôö`üìGòà0Üv\U=B4A1F=O]bor/Zc4?Q+5N.:W8Dt6Bt7@r7Ew<Hz=.["!G(D4G)>K1QYBT\DS`DP`CK^@YnMNhCC]84O,B]:6Q.*B""43B/"1I[C>U9PkHCd7@f39_.2Q(+!&'"*/(4A0TmP]Å[TÅVM{THvQCoL:g@5d65c5-V.7`66b1Am:MuC2S(2-A&IdARrIXyNY}OQwD>i18f(0a .^ 5e+Dp=>h:El@>^93+$)6%2D,)@$"9$<")A')?(/&'/"OVFkr`hpYX`HS\?P^=@U.<R+AW1Kc?Hb;NhA8P.2J(3M(A]5Fe;MnCStIStI?^5 ;)@&5M7e~hyï~à§çÖ°àIhFA_;<W48Q10I,(A$)B$.G'/J'4O,2P*1O)3Q-9W5(A# 4  '3K1/Q0-Q+,R-+Q*/S-6Z40V/+O+4S3)C(0)
+".B'+K&,Q(3U01S0EdB3U21T3)Q/-W37_<,N+4O.4L,7H&FQ)]\0sc2óyEól5óa%òX£^™d™e≠j¢dØxøì2Øê$π•2º¥8∑≥5Ø´-√æ@ƒº?øµ9≈∑=ª™4√Ø>»≤C»¨?…©<«£5«•7À¨@—πKŒºL»≠BŒû<«|)ºMæL«u+‡©N”∑L√∏B…√IÕ…N ƒHøª@ÕÀRŒ…S≈∏F≈µD‘…Uœ»SŒ«UÕ«U–œY—ŒYÀƒP ƒR—œ^—‘a—‘_—‘a“÷g”◊i‘⁄l“⁄m“ÿn“ÿn‘◊p“”m–—i”÷k”◊iŒ“cœ”dŒ“cÀÕ_ÕÕ_À«[»¡V≈¡U∆¬W¬ΩWº∏Tº∏W∂±U∞©O•ùJûñKÖÅA>D)5#106$F!=f<<j;6f26i0/e).d*2g/4i15j27l47h1*Y%+V(/Y+-W'%O$O%M&M%J@=";&	 + 46 978<!A#C*K &G"F7]*Ks>S~FBp2=k+7h&?r/<o*7j';m.=m/6d&5a&2Z%2Z(7]46\78^99b:<e;BkCJtPDiJ8 2N87T@5U@3S>5W?1S;2T</O8.N6.P72S80Q61O30N2-N3-O6-O7/O80P9.N70P82R:1Q93T91S83U<3U<1S:0R90R7/R4/R20S3/R4/R4/T5.S4.Q3.O20N20N21R55R4<Q2GP1^U6p\;|b=çmDóuH¢yM©vK≠qL±jJ©\@¢R7ôK4âE.j:$G8!7<%-=#*>#'>!&?#>&A ,F)+E*8R97Q8 8 4337(G'.S*8b47f25e3@mFcãpoëÄtíÜsëÖcÇsSsdqëÑrêàtëåxóímåÜQqdNp_FlWPv]Qx]CjM@lKJuW^ÖpÜ®öç™•ê™©í™™å§§sçäÑûõå¶•ä§°á°ûjà|JnTFnIDoAFm@.L*1E*0?(+6% %%.5O4.M-1Q,-O*)N%*P).V1-U2.V31T42O3+>($%& +,'"#$,$&&3"(:"&:&8 -!%( $2!.%" !.'ftuanto~Ö{âíbox=NV5JO7NVQduUdy@Od§Ø≈îò≥SUjCGRT[avÅáò¶Øâô©zãüÜîÆtõ`iÜ<IZ0C?+B0*B,/E.8J41>*:F0IR?OUGHPC\j[Zl\bwf\s_ggNfLOfLCZ@E]EkÉmYn]\nbPaYOaakÅé≤Àﬂ¡÷Û¿‘˜¡‘˛ºœ˘∂…Û∏ÀÛø—ı∫ÕÓ™Ω€°µ–¢µ’¶∂◊ß±’Éç∞àíµëüºî†∫ï¢≥dsx?ODHY9wÉSçãNÄy5VQ@? 7>DP 6G:JQ[ox?P\4;L,:S34O0LÇDNÑHXèV\ìYaòWQÑB,W8	3I%/?"0=!3D$6N*Hg>OrHTyMW}N`ÜUV~LBj8.O$6R*B]:=W4\vQZtO9X/Hi>@_3@a44U*2M*')!&  ""$,4)FWDXuWRzUHvOGuPHvQJzREvICsA2]/&J&:^:8c6=l8Eq<&Q(M!IpCSJN}FPÄFOCM~<:n&9m%/b!N9	930, 	!+6&0?('; "9-D(/F*,?)		;>5ei[aeTEJ6BG3GO:AO6BU7E];OiDD`:C_98S23L,9S0B\7B^6C_6Hg=Lh@4N+-%8"7M8D\FNgQSkUE]E9S6:U4<U5>V4:O.9N-6K*/G%-G$-G$+E"0J'5Q+8Q1/#/2O1/Q./U,5^64^69b:?h@;e=9c;?h>?e>8\8*I)2	!0/J)*M%*M%/R*;[6>];7Y8+N.6^;0U3/N.+D&/B&1A$8M&FW+X^2sh:Ég5â^'è\ûcú`§i°j¢s≠Ü'™ç'®î$≤ß1≤∞5±∞2±´/¿∂;º¨3ºß0Ωß0µû*ƒØ<∆Ø?ø°3…©<∆®8∆¨;∆µCÕ¿MÕΩL≈¶<œî:πcΩPªW€üG÷≥K»≤Cæ≤<Ã»MÕÃNøª@≈¡FÀÀQÀ…R√∏E√≥D–ƒTÕ∆TŒ»VÃ…T––X––XÃÀW–Œ]‘‘b—‘a–”^“◊c”◊f—’f‘ÿj”Ÿm’ÿo’ÿq‘’o“”m÷◊q’ÿo“’lœ’kŒ‘jÀ—gÕ–gÕœd «^≈¿X≈¬Y≈¬[øªXΩπX∏≥W±¨Q¨§Q†óLêãKIL.:(8%9!:*I'<b9?h<;j6;l4;n35k15j4=o>>p?=q@?sBAq?+Y(*S'+Q()N%)N#(O %L#I#G? ;-
+)8;!?!? @? ?<?>??!EGm:Qz@Gs6Ft6P~@Hx<TÜGAt2<q-Fz:Bt77g+6f*3c)2^)5`34\73[68a98a5=h;FsJKtR(J/1N88UA4T?3S>3U=2V<4V=3S;.N60P82S82S40Q20Q4/P5.P7/Q9.N91Q:1Q:/Q92R;3S;2S81R73S;3U<1S:/S90T:0R9/Q6.Q31R70R7.R6.R6/Q6.O4.N61Q93T95S76S7<U8AT6KY8V`>dhCif=rc8_8à\9ãT6ÉK2qC+c?'T>&D=#:?(0@&,@%(A#(C"'E#>*K,3Q74R:>YF8S@%A*%A*"@(;!&G*&J&(Q%0\+3b,5c2FpLlìxkå{nç~iàxKlYRsbtîÖmãÉnãÜvïêsíäNp`FnVAnO;iEDnJ?iEBpIP|[sôÇå¨üà¶ûã•¢ã•¢à¢üvëåôñä¢¢Éùö|óêTudBjHCnA?k:=g5<a5:Z3>Y:&9##+ *5$"1-)B%0O/-O,/Q,.Q)+Q(/X00X5.V4.S20S32T3.H+'5$$,/0(?>9762!(*33',-#$
+ &*7&(:"%< %9 .!$ -.,#
+ %/.$00,68KWWN]Z-A8-E8*D75IGASU]jrùß≥ek{Y^qgpò§¥´∏Àó¶Ωàò±Éì≠ë†Ωï£ær~òDP^;LBAT@9L8&7$/<(4A-<H2O[GDOAR\Q_m^hyiGZG<O;=S<E\BF\EF\GMeObwfTfZYhaVe`Wgg^sxzêû¢∑‘∑À¥≈Ò™ªÈ¥≈¡”˚¿œˆ¡—ıºŒÚÆ¿‰ß∑€ü≠“õßÕãòªàïµçò¥îú≥åï¶mzÄ8IA9Q9MeA`lFGP%8@3;Z]kn)DL>HES"etIFW5;N0?V9/H+OáJTãQXëZ\ñ\_òTYéJIu:@e2?Y2H`<_xP=Z.Im=TJNzGGvBOyGKvA<i25`*6W*Hg=Jk@NoBQrCHi:Dh8/P#Lh?8T,+L!-M$7&)#(!%*#6@5PcOTqSQyVRXTÄ\TÇ[Zâ_[à]IsE*O$2Q1AcBBk?HwCKzC4e-:i3QÇJLÇDKÑ@KÇ?MÑ@?u*8n >t(@u/Eu;Ak;2V0%B#2%! !  (,7&/>'&9/C(0D)0D)!0	
+	*-$OSEFJ927#"&!% )0?(G\=JdAB]:B`<?Z;=V8AY9BW6BW69N-.F$-E# 4+.@*8K75K63K57M65M3:R8=V8LdDI_;H\9EY4@V0@V2:R.3K)-E#3K)9S./I&,": 4V55[41\13`57d9;h??iA=jA?lA?lA?m?=h=;d<3R2,	)@$1O++K$*M%2R+9Y4:\;0S26[9,O./L-!5.<%$2/G%8S*F[2R[0eZ-u^,Öb*ça"ãZöhömùx ©è.§ì+®ú,≠¶1Ø≠4∞Æ3≥©0∑¶0µö'ºú+∫ú*º°0≈Æ<¿¶5¡£5≈ß9ø•6æ™7∆ªG∆ΩHÀπIÕßB«|+∫[∫Tƒp'‡∂R ∂E¡≤?«ºFÕ…N …K∏≤8Ã»M ÃQÃÃT»æK«ªM…øPŒ∆WŒ»VŒÕWœœW–—ZŒœZ““`““`Œ—^–’_”ÿb—÷b–◊e”◊h”◊i‘◊n”‘n”—l”—l’’q”’p“‘o–’o—”nÕœj–“mÀŒg…«`≈¬[∆¬^≈¡`¿ª]º∑[µØW≠ßS¶ùPôíNb`-07+:(<!%< $? /S-@i=?j<=l8Bt9@s8=o:>p?EtFDsGBsD@rABr@,W)+P')K&%G"$G'L!'L !G#G>6!
+!2#="!C "F $H"%I#&K"$H""F"BA==<(IZ~NW|FT{BbéS^ãP\âPYâOEw8>p1J|?Ew:;m0?q47i,4e-7e64^65^66_59d6:e7BoFLvR7\=)I16V?4T?3U=2V<2V:3W;3U</Q82R:3T92S60Q40Q6/O7,N6,N60P91Q:0R:/Q91S;2R:3T92S84T<5W>2T;1U;0S;/S90R9.P5/O7-O6/Q60R70P8.N6.N61Q93T94U:3T94U86W8=\=EdDMiCPe<S^3\Y.`Q*bG)[B$O?%E?%;A'5C)1C)-D(*C%)D#)G#,N+#E$3T7AaIHeQB]L9VD)F23P:.N7%E..P5/T2.W-.Z)2a-5c4@iGgärmå}nç~Mn[>_JDgSiäyhÜ|nãÜsêåuîåcÖuEmSErQDtN7d==jCKyRO{XxõÖè≠°â§ùÑüöÉûômàÉÑüöé©§ê®®å•¢á¢ôeÜs;c@9d7;g69e27c24[/Ac@;S9%(5##5%>!,I*)K(,N)/R*/T+2X13[61Y7.U6-R3.S2/R13P11D.*5%24)872/.*-0':>0VWG\]KIL7CH4,0"$#&**,+'%+%8$%=#$= #: 0
+'#20'!% $1'*<,)B,(A+-B36G?JVVdmrqxÇú§Ø¶≤¬âñ©Xg~ç®ï§¡Üï≤éüª¶∂–myìEQ]=ND9K50B,(7"0<&4@*-;$3@,9E7NZNn|o]n^TeSAT@?U>@V?AT@AT@TiVbwhoÄz\kh_kkYghew{_qqÇûî§»õ®‘öß”ú™—üØ”Ææ‚´ªﬂßπﬂ±√È≤øÈ•≥⁄êû√áî∂Åè™ö¶ºåî©V`lN[a5HB2N89V:9P43F&0?PZ%Ç=st.RU>E@O(CW4GZ>?S:6M35L2QáMVçTUéWSçSMÖDEy9*U-Q#*J!]~QgêVQ>@s1Dx8Hz=Bq:Ak9Bi:0V%5Y)Ih?Lh@OnDTxHRyD?f18Y*;9S.(D=c0Fq9Fo77[-2,9':E71<.IZHWoWWzYYÅ\YÉ[]à]bãaLqH5P/1H+?X:OmKCi@LxGK|D=p5KÅGLÇFJÅ@IÄ<JÇ;C{26n#>w*Az-?w.Ax5Gz?K|EIxD<f6!A%""!$ $"(4<--8'+:#/A'1D(/A')8!
+
+
+	'0FO:DN6EM6.2#)-4=,ES<M`DQiIE`?EbC@[<AZ<BW8@P5;G11=',)) /0?,4E2:M9:P;7O75M37O57P2BZ:BX4J^;K_:J`:I_9J`<F\8BU5L_?QiELd@6&	".#B";a:8b:4c76e93b67d;:g>7d;5b99f=@mD>k@<g<?gB7Z98.3J.1O++N&,O'-R)5Y58^9/W2.R.*C&"1.7&",@$3M(>Z2Ib:P\4Z[/hZ+qX"{Wík*íl#ís †ç/§ô0¢ö+®£.©§,¥´4®ó#Æì"≠á∏è#≤é Ωù0≈©;æ§5√§8ºù1ª£5Ω¨:¬∏E«ºI∆ÆBÃô=ΩeΩZ∏`‘ñ?÷ºN∆ΩF…¿I ¡HŒ∆J«øC¬∏?À≈KÀÀQ… R √Q…øP∆æQ ƒV»≈RŒÕWŒÕWÕÃXŒÃ[œœ]œœ]ÀŒY–’]Œ÷]œ◊^–Ÿb—ÿf–◊g”÷k’÷p’—n”œl’“q——o’’u—”rœœmŒŒlœœmŒŒl…«c≈√_√ø^¬Ωa∫µZ∑±[∞®WßûQúíM{v>38)4(8$;#<'D%5[49g98h8@p<Dw?At<?q@CrDEtF?n@?q@:l9@p<(R"*J%.L*)I"$G(K#&K $J%I>-*< $E&'J))O*)R*.T/0V1/U.-S,(N)(N)$J#"F #E $D.N'UvKnça[}KW~IWÇJ_äTJu?@m4<l2L|@Fx;>p3=o2:n06g/=k:8c64_46a67a39d7>i>IsMInL!D&6V>1Q:2V<2V<3W;3W;5Y?/S9/Q81S:2T91S81S:/Q8.N7.N73Q92R:0R:0R:0R90R91S81S82T;4V=3U<2T;0R91S:/S9/S9.P7-O6/Q60Q40Q62P60N43Q70Q63T91T62U54W78[;>cABhA<c6?e4Dd3D^.AS)@N*;H*:I,7G,3F*0G+/H*.H%&D (H#3U27X98V<6R;C^K@[J8TE1N<:ZE8UA+K60P85X:=e@.Y,.\-6c8JsSkézoèÇsìÜYziUvaHkSWxcdÉtkâÅqéârèäwóäPs]HqSGsP@lH9eAKwTOxZÄ°åá£ïà£öÖ†ômàÅoçÖè™•í≠®ê®®è®•â§ùoêAfE;d:6a3.Z),W,:d<HmLKgN( 3,F)*I''G"(K#0S+5[27_:6^;3Z;0T8,P4-R3.S25T46M1/<(24).-($##&'+<?.Z]HOT=YcKCQ:0C-,E/-K32P87U;>_D?`E?`EAaI@`H<\D0R7&G*$>%1
+	
+#&5"!2+
+
+((;''?%5!4!%5*-82:CBLTWÄâênxÑ`l|qÄìî§ªô©√xà¢Üó±£µÕZfÄ1=METM:K8:L42B(CM57A)-;$'6#*8)Q_RfsjcshXiYTgSKcKLdLK\IJ[INcRlÇvnÅpÇWefP^atÅâkyÜdsägrínsôX^Çt}úìû∫ï§¡ß∑ÿ∂»Ïø—˜∏≈Ô°Ø÷èúøÜëØyÖõäïßâï•ER[8GJ<QH/J76T<5O6)A=MtEòüiõûoZ[9=D%:J-=Q6DWA=S>BXCKaJPÜLKÅG@w>Dz@<s2<n/&M%J9_,XÉKSÖ@I}5At1Gy:Dq83^)1V*Bf:%IEd87Q*1I%A[4;Z02W$@e20O%-I!:V0@a4Iu:MÄ=H{6P|?"A'; 4A/(4&+7):K9HbIMlMSuROrJ@`90L&*=!2B(>V6Fd@FkBGsBDu>Cy=F~A?z8>w3?v2C{4@x1@x/F~5FÄ6B|2Az6D|;IÅBMÉEMÅC6a,,	),##&&*59+.5%*1!'3+9"1A'/?%(7 )6"%"%-"/7(;D1HR:KU<=G/%,QXH_hU]iS<L2K_CKdGG`C>U9AU:DT:6B,)0 % -&5)8!,:#6C/>K7;L92H12J27O58Q47P27O/:O.@T1Oc>VlF[qKbxT^sR^oO]qN]uQWqJ.J$;W1B`><^;2X1;e=9h<5f93d74c72a56c:6c:4a81^76c:>kB<i@9f=>hB?e@/L.'
+):'4O0/Q,0S+-R)1W09_8.T-2Q/&:%1*0"	,.E(4R.<Z4Hb;N^7OT+\U'iX$Äj0Üj)Üo#ïá/õì1ïé$£ù-•†+Ø§0§é´ã™ØÇ∞â æú1ø†4∏ô-ºù1∑õ.æ™:¿≥A¬∏G∆¥F«ü=∏v"∫TªSær$Ÿ´IÕºJ√¡F«√H…√I«ΩDæ¥;ƒπC»¬J……O≈∆N«ƒQ…√UÀ≈W∆¬T…∆SŒÕWÕÃX≈∆QÃ YŒŒ\ÕŒYÃ–XŒ÷\Œ÷\œŸ_Œ◊`–Ÿf“⁄k—‘k“”m’“q”œn’“s’’uÿ◊z—“t––p——q–ÕnÕ kÀ»g∆√bƒøc¬Ωbº∂`µÆ]≠§Y†ïSâÄGLI&0$4!5!: ;'I&>g?;h=7g7Bt?Dw?Cu@AqA?n@<k=<l<;k97g3<k7&M5,E'*H&%E $D%H $H$H!A."A")J+*O-)Q,+T,/X02Z50X30Y10Y10X3+S.*R-*P)(J%(H#,L'6V/@_6:Y/Bf6Lr?Dl:7_-1\':g0Q~EM}ABt9MDAt97h1BpA@k@5_75^47`49b6:c9HrJLtO2W61T61S82V<1X=2Y<1X;5Y?1U;/R:0S;2T;1S:1S:.P70P9.N73Q91Q91Q:1S;0T:1U91U91U91S:4V=4V=1S:1S:0R9/S9.R8.P7/Q60Q61R5.O4-N3.L2-N30Q60Q41R30S30S35Z9:b?@mD>o@9n::l78g39c58]25S15N03J.3G,/F*.G'-H%#A#C3U2CaE6T:&B+3O9:UD:WE7TB>[I<YG4Q=0P90R7DiG8a92[1JrMbânnêoèÑtîâmç~cÑqHlRAeKMn[gáztíäuìã~úêbÉpImQHqOAjH5^<HtQMvVpízcÇpÇûêÄúêuêáâ§ùí≠®í¨©ê®®ç¶£ä•ûÄüêNpU>d?5`3.\.8e>NxTOwULjP$!"51K.,K)&F!%H .S*<b;;c@7`@7[?1U;-P8,P6.S43T59R52A,/2')(##$ #")-9%AM5?M3?Q7:Q77Q8-O40W:;_C;bE@iI@iI?hJMvXOw]ZÄgbàoaÑlPpY8Q<(		#$5"#6 /
+
+" '';"#: /-"0#".$)2-+54NY]}áìåô©åùØî¶ºè†∫fwënÉòî¶º{â£"/?1B</B.5I.6I-<H00<&3B-*=*$5%L\Q^ndDTJDTGTgTUkVBU?7F1HWDVhXlÅx~íìpÉâfu|lyÇo{ánzänyçeoàvyò\`}bh~éö∞†ØÃπÃÌ¡—ı≠º„î¢…ü¨œÉé¨xÉôO[khvpÅâK]a?RPWle6N@3N;=YB,E%/BdrA¶∞ç∫ø®cgX=E69K5=T:6N8?VBgi^v`2i(9o1+^#-_"Fv83_ Bh+Nu6P~=Hy7?q,0^"J,P"=a3/P%4R,NlF;Z.Mj>$:=Q.*:':5M+LfA2Gc=Jn@Ju?H{8Bz1F{5XâH6Z*2L)/.9+LVM#-$1=17E4;J5ObFH]<H\93C&FV92J&LlC=d8=k:3d-H~BG@A|8=x4<u17n*;o-E|;LÉBNÖBD}9C{:C~>KÉFMÖHNÖDQÅG6Z.%$'-#(."/5'39+18(3;&.7"+7!".%1/:);H40;*.6'19,06*/5'28*9B/OYA5?'GP=9B/8A.GS=<L2CU;9K38J48G2CP<;D3' 3E+7L-8K/3C(8D,JV@AP;>Q;9R53L/3L.5L/<S7?V9CX7J`<TjFc{WdyXavUgxXdxUYsNDc:Bc8Gk?HmDEnDDnF=jA=jA;j>9h<4c5/^0-\02a56e97d;4a82a7:hA9gB8fA@jDGmH;^=#@$%/G/4Q21S0.S*)O&/U,3V./J'$3(/%(&5 0H(8T.D`:Ib;CU-HU*PZ(``*j^$vb#ã{.ìà/èá%ûö/•ü1©ù/¶ê#¶Ö§x´}∂ë)πñ.∂ê+µí*±í(∫¢4∑™:Ω≥BªØA√¶@…ç5¨V∏F∂M“ê<Œ´C«∫G∆ƒK≈√J≈øG¡∂Bæ≥?∆ºI ≈P√¿K¡¿J«≈T««WÕÕ]∆ƒS…»TÕÃVŒœZ∆…TÕŒYœ”[ÀœWŒ‘ZŒ÷\Œÿ^œÿaŒ◊d–ÿi–◊m—‘m”’p‘‘t——q”‘v‘ÿy’ÿ}“’z—“u—–tœÀpÃ…l…»k∆√f√æbøπaπ¥`≤´]¶úWïåSZW,37!. 26:"A)M'8b:9f;;k;EuADu>Ar;=o<9k:5g69i99i7:i5:i5.S'&
+-)@&)C&#A'G"%E#F!D?(K*)L+'L**P+)O(,R))O('P('P((R*-U0,T/*T.)Q,*N()K&(J%)I$*H$1O)<\3<`47\13Z.-T'<d2O|CQÅGDu>SÉOIyE;k;TÅZVÄ\5]:2X36\39`4:d6DoBKuM@jF/T3/T5/V91X=1X=1Y>1X=/V;.Q90S;1U;0T81U;1U;0R:/Q92R;2R;3S<1Q91U90W8/V71X;3W=4X>3U<1S81U90T8/S9.R8/Q80Q6/Q6.Q3/Q6/Q6-M5-N3/P5.O2.O00Q2/R25Z8=e@@k@6h70e1.c-5g29g88^53R04M/6M15I./F*2K--H%&D'G 3U0DcD3Q7,H/7S<0L69TA<WF?ZI>YH7R?1N8&F.8[=FiIMpOLoQdÖppêÅsìàoéÜrêÜeÜu>bF:aB<cHfâuqëÜpèáyóãeÑrIkRInM<a@7_<DnJFpLMuSPtXhâtjâyâ§õë™§ë™ßçß¶â£¢â£†Ü£ûÇ†î[|g=bC1[5AnEQ}ZR{[JrPCbC&)/C*1K.+J('I$#G!)O(;c>;dD8`E8[C2U=,O9/R:0T84U89S8/@-%-"!$ &!,"1'=(.F.1I11K04L28R96T<6V?5Y?7_D>dKDlRIqWIqWEpUNy^Q{e_Üqhç|lëÄiãziäwb~oMhW,C3"&"8!#9" 3 %''$&&8  4* #'.'-=<xäéÑíùÜñ¶âõ±~í´Üô∑]qåKbtnÉîñ¶Ω 0?!4.&<'1J*:R21D..A.4G4/D3&8*PbVpxP_X1A7QaTHWD<J39B-EQ;O`NpÑ{ë¶©é¢≠ë¢≤wÑïzÖós~êVasS[nèñ©cj|\etü¨øµ≈ÊÆ¿Ëï§œî°Àëû¡ï†æzÇódnzUdi_qqcwvZpmVkfh{wRe_5I>:S@5O6(==M2ü≠ûπƒæT^`.:83E58P61K0TnU}ôÇõÖ1c$4f'8h*>l.?k0Ir6T{<Lu3Ap,7i$0]+R(IFa>råiçßÑBY<F^>[uN)D8L);J+-;!0@%)>H`@.VoO,O%=h3Cu8Fy7OA\áO2V(;U2#5MXJ16/,1*270*2'EP?fr\ZiL6E&HW:@S3-G Bc88_21_.>o8G}AE}<A|8>y5>w3?s3=q3@s8Dz@JÄBKÉDC{<C}@IÄFMÖHMÖDRÜHMxC!A-$.#(0#3;,&,'.07%'.!(")1")4$" ($* & #*0"JS>Q[C:C.;D/GS=`nU@P56H.2+$2%1'#.DX<E_<<Q07J,?M4AO8SeOCZ@F_BD_@B[;:S38Q4=T7?W5C[7F^:NfDXmNexZuÖhyémsèiXxOKoCBi<Bm@AnCAnEAnE?lC=jA9h<:i=;h=9f;2a5/^26c::g>6d=0^96d@<jF:fBAkEFpJBgE%A(#/0J/2Q/*O&-S*-R'1Q*.F$#/*.  
+!#.';0J'7R/?]7A]58T+<X(G[(IKQGuj,Ü}2äÉ+õï5ûï0ùé'§ã&§Ç£y≠É!µí.¥í.∞ä'≤å)¥ï+∏¢5µ´<Ω≥Dºß>¬ñ7√t)≠G	±>Ω[÷üE√´?≈ºG∆ƒK¡øF∆¡K∆ºI≈ªH…√QÀ»U¡¿Lƒ≈P∆…V»ÕY»ÕY≈»S√¬N …U ÕX»ÀVÀœWÃ–X –VŒ÷\Ã÷[–⁄`œÿcœ◊h“ÿn–’o—÷r’◊t’÷x‘’w”◊x÷⁄|–”z––x””{ÕÃrœŒtŒ q«√h¿ºa¬ºd∑±[∂±`≠¶^úíWqk;@A!)3-.9%D")K&0V/<f>:g<8h6Ar;Bs;<m67g31c0.`-1c05e39h4;g4/R(!$6$? $B "B"B"E$I $H$#G#!E! F#I #J"K!)R(+U--W1/Y54\91[50X31W0,R+*N(,N)+J(.N)9Y2;[4:_66[22W,?g5Hs;Jz@HwAWáUN|NJwP_ãjiít:aB3X66[29`4<f8Al?KuMHrL4\93X70W:0W<2Y>1Y>1Y>/V;/R:/R:3W=0T80T:0T:0R:1S;2R;3S<4T=3S;3W;2Y:/V74X<2V<5W>4V;2T92V:/S71U;.R8/Q8/O7.P5.P5-O4-O4-O6-O61R71R50Q41T44W78]<=e@AkC9j;5j67l8;m::j::e8:\75S16O24K11H.3J--H%'E(H!1S.9X97T8=Y@<XA0I3/H3:UD?ZI?WG-H7,I5/L66T<=[ATrXPqVPrZgàwqëÜpèáuìãlã|GkQ7^?AhIU|amè~Uwg^ÄoRs^FhMBeE7\:5[6@iACmEEoG?gDFjNsîÅç®üè®§éß§á°ûÜ†üÑûõÉ†õùëbÉpCgM;dBFrNYÇbLuU?gB<^;,"40H.-J+'I&'K%)O&*S+:b?>eH;aH7ZD0S=,O;/R<1U;4V;5Q8$:%"-"*$/!+9(0A..D--J..L2/P5/O71Q92R;5VA7ZD8^G8`H<cNBiTIp[NxbPzbR|fWÅm`âwkëÇníÜgã}dâxfãyjçylåw\ycC_H0L3#?&6  , - .+&!)#5-!'.(^stpÑãê£±ê¢∂ï©¬sà•~ì≤|ë¨Uj<QbùÆ¿1BL%82,B-0I)4O.&>&9P>6K:*?0#7+Ui]m~vkzsdog?I>PYHJR=AE.IQ9CR=FZNZnoãü™î•∑{äùíü≤mxäR^jPZdòû™pvÇíö•±ºŒ¶µ÷òß–àï¡ìü…®≤’ñ†πyÖìiv|Tff]rmvçátçábwrQd`aqnBSM3I<7N<+@-*<,ÇìçqÅÅCPV5CD-B39Q9FcGhÖi~öÉç©ì5`(9e*@l/Dp3;d*8a)Gp4;d(?h,@j+Bj,?b,9T1iÅgü≥ögya,;$J\BbwX.5C)N\B/B$1F%Jd=UoJRiL8O54N37V4Fk@T{LY}OBa80!3)6"al\8>428.+1%#.FS?UdMGU<M[BKY?-@ 9S,=^1>e60\)>o8Cv;By6@y4?x4=u4Ey;Dw<NÅHH{B@v:Bz=Ay<D|?IEOÖIPÜHUâKQÄIC,*08++1#!)-/3%"&$'"%!19."!$=D4EN9KT?XaLLY?gvY7L+;U2C^=B]<5L0&"#"-:)[oTOiF@Z7<U5G[@M`JvåuSkSHbEKfEGeAFd><W6?X85O,:R0?W5@U6I\>[kPl|bsákZuRMpHHnECnCBoFAnGBoH?lE=lB<kA>kD?lEAkE?iC=jA6e;2`91_86b>:hC7eA8fB?kG;hA=jCDnH?gD)J+,#;!/M+0P)/T+1T,-H%4I*,5"(,'*1$;.I(2R-8[36Z.0T&9V(:L""*EBg`){u+çÖ0ëÅ)í{ö}•Ñ#°}©Ö$≥ì0≠ç*∞é-ßÖ#∞ï,Øù1∂Æ?ª≠B∂í1πx&∂R≤>´@ƒp(œ§E∫®:ƒΩHΩΩEººDƒ¡L√¿K√¿K≈ƒPƒ≈P√∆Q≈»Uƒ…U≈ÃXƒÕVƒÃUƒ«T……W« U»ÕU ŒV«ÃT…—XÃ÷\À÷\ÕÿbœŸh–◊m““nÃÃj—’t—◊w‘⁄z‘Ÿ{‘Ÿ{”÷{ÕÀtŒ…u’–|–ŒwÕÀtÕ…r∆¿læ∏dΩ∑a∑∞_≥´`ßü^ÇzIJH"6?$+:#,. >(K#+Q*/X09c;;h=;k7;n5;l47h02c,0`,,^).`+2d/3d-8d/*M#
+#4#A!??!A#F@==C!H$N (S&(U*'V,/]65_;5_;6^95^60X3/X0-S*-S*,N)+M(2U-<_7Be=9\4:_4?g5Al4Gw;IxAWÖVbåf^áikìyröÄIpS6^<6\58_39b6@k>HrJLvP>fC1Y74X<2V<5Y?3Y@1Y>1X=0S;1S;1U;2V</V9.U:/R:0S;0R92T;2T<2T<2V<3Z=6[<7Z<6X=7Y>6X=4X<2U71S80T:/R:/Q9/Q9/O8/O7/P5/P5-O6/Q80R90R92U70U63X97^?>fD?iC=l@<m>:k<9k:9i98f78a51V-3P12J0/F,0G+-H%*H"%E2R-5R3@Z?E_F2K5*C-.J45R@;WH:UD#>-(C24O>8P@3L9;W@B`FCdIY{chàypêÖqèásëÖZ}g7^A5];6_=FmPAiN>gIDmOJoPBeD1U13Y0?f:?i;?i;8a9SxYÇ£êå™†ä•†â£†Ö†õÑùöÇõó{ñçoé`ÅlDhNKtV_àhU~^@jF;f;?e<";+*C&*G('I(%I#,Q(7^28a9AiGFjP=`L7ZF/R>-P:2U=4W?5W>4R85$5",;(/B,-E-.H-.K/0N4-N3/O71Q:2R=4U@9ZG>aM<bM?fS@iWGp^MwcOyeW~iU|gT~j[Ñreã|kèÉkèÉgã}fãzgåzlé}iåxgàsdÜmQsX3Q7&
+!/  3 "5""5!.( /"1#"BXUuåíczàå£µö∞»Ñô∂vä´Åï∂~ì∞yã£;L^ëü¨Udg0A7.A-+D',G(&@'?VB3H9);/"6+Vj_bsimzqiskVYPHF7B?,EC,BH,>M05H40C=I[_nÄå}èù†∞¿csÄ]lsWbfÅÜåx{ÇÇÜèäê†ìö∑xÄ•qz°xÇ¶•ÆœvÄôtÖçÑòôeyzUihxéå|ïëShcM`\jytixs=LG7H@4F:)=1BVMFYSNa]FWQ/A3=U?RoSkàlÉúáá†ç'N+R.V2Z1X#2Z%3_$1]"9`)8^%>d)<^+>Y6]vY8L3<N6N\Ehx^@S7/4B)BR7F[:XrK[vME_:$8/LbM 8+H)6T2$=&
+,N]HYgPDP:KTCCL;0<(<J3O^GBQ:(3"5A-:H/&91I%4S)1W(/Y'?p8Cv;Ax7Ax5?x4Ax7Fx=9j2[ãWTÜQQÑKF|BBy?@w=G}CQÑKQáKUãORÑI'N!&.#),#%(57,,/$""#%,$07/!"% -.&>B4FM;PYD[eMO\@^mNUkGUqKLlECc>?Z;6%7!BQ>,&5"YkSf}`c|\ZsSE\BràqkÉk`x^KdGToNTrLNnGFb<=Y3;U06P+7O-7L+9L0<L1DV<KbFGeC?c=DmE@mF@lH?mH@nI@nG@oE>mC;hA6b>AkGBlH>kD:hA;iB:hC5a=7c@>jG=iF=iEBnJ@lH<iBBoH>fC0M//!?.N).P+1O-"9,<""+&*!*+-#7(A#(F$-O*5Z13Z-3X,9X/)%-BDab vp$Åo#âp ís †~'ótôx¶ä)üÉ"¨ã.§É$©ê+≠ö1∂ÆA∑§=≥Å(≠]≥A∞:´KÕä9 ™Eæ≥@∆øK∑¥?Ω∫E¬¡KæΩG√¬Lø¿K¬≈P∆…V¡∆RƒÀW∆œZ»—Z¡…R¡ƒS≈»W«ÃV«œV«ÃT«œV»“X ’]À÷^À’bÕ÷iÀ–iÕ iŒÀl—“t”Ÿy”⁄{”⁄}’ÿ}––xœ…u‘Õ|—ÃzŒÃy«≈r »uƒΩl¡∫jºµd∏±c´§^êãQUS*;@"1?&)<&10)I"+R&/U.3[66`8:h:9i5;l47h02c+3b,-\&)Y%+['._(/^(7c."F'"9'B!&D =!?>#C@<? E!K%P"$S%(Y,-]5.^80\97a=9c=7a95_73]50Y/2X/2T/-O*-P(8[3?_6=]4=a5=c4=e0Bm7Ht?KvHnòriêsmï{|¢âcäo6^<4Z34]38a5>i>DqHJwPCmI2Z83X90T85Y?3Z?2Z?1X=0S;0S;2V<0T:/V;/V;1U;0T:1S:3U<3U<3V>2V<4X>4X<6X=6X=9]A7[?2V:2T92T92U=1T<0Q</P;0P90P82P80Q6-O6.P71S;0R93W;1V74X<6]@>eF?iE>kB:i;>o@>p?;k;7g75c46_35Y5/L.-E++D'0K*3Q+%E8X3<W8>X;JdK2K58.G13P<>[I7RA";(+B22I90D8*A1)@,5O68V:OpUaÇomçÄgÖ{nåÄgàuRv\7_<4^6/Y5/Y52^:<fBEjHImI2V04Y.<c6;b35_1<e;aÜgÖ¶ìä®ûç®£á§üá¢ùyíåtçánâÄnç~gàwKnXX~eaàmRyZ6^93^0<f8.N)$? ,I**I)(J)'I&)K&<^9>b>>cB@cK:]I7XE.Q=3T?3V>6X@5W?.L4'A(+C+.D-.H--J.-K/1O5/O7.P70R:1R=4U@8[E;aLCiTCjUBiTFmXJt^PzdT~fT|dYÅgUgZÑnbâvgå{nêÇkçfãyoïÄuöàlí}gçvfçrfçndáiSoV,B-27!; "<!"8!0#5!.$oÉÇâü™ä°≥†∂Õ£∏”zéØÄî∑ñ∏î≥xä¢:JZbqxl{x<I@,=++A*%?$&?)8O=,@4%9.*>3PdYYmbxà~eleHIAIC7E<+IE,JM0YdFSbK1>4%33+:?;LTRcmM^eM]\n}zbjlchnt{Öáéûâê¨qwôirìenèw~õ_jÄbt~pÖäpÑãtàèf{Äg|}]qomÄ|Äèäáìènzz9EC5F>1E:>RISh_dxoK_T6H:;P=JgKa~bòÉwé~)REl3Bh+(N"D/T!=i./[1X#1V";a(6['5T*2M*6O/PdHZjO@P5PcE-B!8M.G\;Ia=Le>VlF0C#(87F/J^E6'>".E+ 1/>+TcPIXAxÜlM\?fvY@S3PdAYlL>N4"/%- 06(R_E9H)0/I&+K"3[)=l5At9Ax7?x4>w3D{:Gx@2a-bêaZàYWâTRáOOÑLBw?H}EMÇJRáORàNSÖJ;b3
+&(#%(!/2+-0'#$$% ##(!6=5&-%*+%@A98:-LP?_gRXbITaCZiH\pMYsNIgAAa<9T3-F&;T4@W:';"'9#DS>l{dxäplÄeQdNÜôÉtãqhc[rUZsSgÇ__{UTpH@\38S*?Z19S,4L(2G(/C'+B%5P1BdA@hCCmI@lIDpMCqLBpK=kD<kA=lB?nD<iB8d@9eBAjHAmJ>jG;gD=iF?kH<eC@iG@lI<hD?kGDnJ=gA@hC?a>.M+4+J*.K,/H+%!&1 #,$") ,!3!534:*I'4Y02W+3V,3
+"4
+am;äñVmp+k` w_àg$ùw0ábëq°ä-ûá*¢É)õy ¢à)≠ô6∂©C≥ô:µv)•H±<´;Æa–°E¡¨?¿∂C¬∏E≤´7Ω∏C¿æGºπD¬øJΩæI¡ƒO¡ƒQ¿≈Q≈Œ[≈Œ[≈ŒYº√Q¡√V√≈W≈ÃX∆œX∆œX«–Y»”[«’\«‘`À’dÕ÷iÀŒe«√`œ…i——q—’v”ÿz”ÿ|’’–ÀyŒ«w÷—Ä–Õ~ÕÃ| …w…∆u∆¿r¿πkπ±f±™bôìUjj6<H"+>"*=')?*%9 :.S(-V*1Y41Y62Z5=f<;g6:i23d,0c*._(*Y#+W$)U"(W!-Z#4_*!E!6(F$*J%*J#%E"B!A<!AA> J#N %S$&U''Z/)^4+]74c?7eA5a>7c?<f>:d<8a79_85[4/Q,-M(*J#>^5Gh=Cd9;_1:`19]/9_0Ah9Dn>T}QZÑ\]ÑewûÅyùÅ?dE5]85_79d9<i>ErIHuNMwS5^<3Z;1X;2Y<1Z<3\>1Y>0V=/R:0T:0T:0W<0W<2V<1U;1U;2V<2V<3W=2U=6YA6Z@5Y?4[@4\A4[@2Y>2V</R:3U=4U@1R?0Q<1S;0R91Q9/O7.P7.R8/S90T:2T90T85Y=8\@@dH=eC9d9>l;>n<9i78f76f67g7:h:8a7-O,)F((B%*H&2P,)I"2R+=X73M0IcJF`G,F-'@*/K59TA0G5!8$.C2-B1 2"!3#!3# 3$<"?[B[zhjä{jà|oékäxQsZ:`;7`65^4+T*.Y.8a7;d<BhA/T+1V+:a47a36a4JtNrñ|É§ìá•õä•ûÜ°öÖ†ôzîã`zqséÖ|öêuìâpêÉlç|cÜnKpQ4]5/[*3_,4Y..Q)/S/,N--J,)C(//G/=[?9\>9]C7ZB7XC0Q<4T=3U=6VA1Q:.L4+I1,H/.J1/L0.L0/M3-M5.P80S=/R>0S?4WA8^E=eJItXWd]ÖjJsUOxZS|^^ág[ÑdS|ZUÅ`ZÖg^âmuùÖ|°èÖßñYfgésqî|gçtgésdço`äf]áa^Ñ_`Ñ`RqQGbC?V9,E%"B'L#-S,/S/*I)$=$8'6!!$jxy~êúó©Ω¢∂Œ®ΩÿÉó∏àúøÅï∏Çïµfxê;KXFTWiuqU`Z6C9(:* 7#0G33J8'=0+A4?UHH^QRh\{åÑ|áÉ@B?E@:>6)LF.XT9ZZBQUDS[POXU7AB'24(35-<93D<wàÄäòôÄçïzàïéù∞áì´r}ôktëkuéowåS`qgzàÉö®í©ªú±ƒrÅîXisTff[njetomyuÄäã_ij4@>=LGOcZL`WK_TL`UH]NF]ITnSSoVjÉpuçCq3Hv6Is12\3Z#Aj2Lz9@n. G6X%Gl6Ad.=].<X/Fb:B\75M)*BLd@4L(;S3@X8BZ8DY8EU8N\BQ]GTbKHX>2D*/F*8O5/!27I3M_Ei|\Ka=Ka;Kd=4M&EX8-""' '-![gO5D'-4H,(B4U*;g2As8?v5<s0?x4H|>KuE&L#XÅY]à]ZäZXäUVàSNÉOL~KQÜPRÑOUàOSÖJ0X&
+ "%(!'-#%($%'(")*$&)"&+$05."%)*$?@8.0%-/"JL>hmYXaF_jLgwSWhDTlHHc@<Z67R16Q0>\8IdCHaC:N37F1_lX|ãtqÉkhzdxärsállÄd_tU^vV`xV\vQa}UNjAId9Gb7D_6;U.3K)-E%-F(GdEGmHAkG?hF<hG?kHEqNFtOAqKBpI?nD9h>:i??mF=iE:fC<eC?kGBnJ@lIBkIEoKDnJ>jF>lGAnG=gA<f>:c;:`76[2*L)%D"(E&%>!$"-$0$")('4476"?!,N+5[27^2+P$$C/D\mAsÑNPY"NJ[JkOÇb)yWîv-ôÉ0ôÅ+òx%ôy$õÇ(ßí5Æõ<∞å6≠c"†<¨8©A≤s$«ßD∏´;ª¥@∏¨<´†-Ω∂BΩ∏C∫≥?¿∫H¿¿N¬≈R¡ƒQƒ…U√ X¬ÀX√ Zæ¬T¡ƒYƒ»ZƒÕZ¬œY√ÕZƒ—]∆”]ƒ—]ƒ—_Ã÷fÕ’hÀŒe ∆c–Ãkœ—p—◊w“◊{”÷}—Ãzœ»x–…{’œÉ–ŒÅŒœÅÃÀ{∆√tƒærº¥kµ¨g¶°a|{EX_3@T1#;!$:%&<'#: ,J(2Y-/Z-0Z4.V40X55^66b17f01b*+^#+\%)X"+W$'S *V!-Y$5`+C9(H#*O$)P#%J#H!D#E !C??"G*T&,Z+-\.._2.a83e?6hC7fD:gF=iF;gC;e?=f>9_89]76Z4)H&(H#2R-Dd=Hg>Bc8:^25X..L&+I#-M$4Y.=d7GqCMvN]Ö`oíqPuS7_:7a99d9=j?AnEGtMMwS@iG4[<1X;2Y<0Y;2[=1Y>1X=1U;2T;1S:1T<1T<1U;1U;0T:1T<2V<3W=3U<7Y@5Y?2Y>3[@4]?4[>2Y>3W=0S;5W?3T?2S>3T?0R:0R90P80P80R9/S90T:2V<3U:1S84X<:^B@eF;c@+V(*Y%+\%,]&1`,4d25g65e50^0/U.(G''B#'B#.I(,J$+I#3N-&A":T9D`G6N6)A).G1.G2#8%4!)<)#6#+'(+"8!0J1FfQeÜuoçÅpéÇoé~Uw^6\7.W+6`2/Y+,S&3Z-5^2=d8/V*-T'1X)4^0@k@`äfwõÅ~üåÅüìá¢ôÉûóöëyïâdÄtÄûîÜ§úÅûôyóèsëÖcÑoGlM4\7.Y,1\./V*,Q(.R.-O./G/.+4L68V<5W<3U<4T=,L50N64R:3P:.K5*H0+I1*K0,M2/M3.L2+L1-O6-S:1Y?3[A2Z?BkMJvSHvQjñsä≥ìqöxMwOP{PQ~SUÇWQ~UMzQLyPSÅZXÑcçµöí¥£Ü©ïQx[WÅ]bäg[Öa^àdWÉ_RXfìlVÄZT}UVUZÅUWzPImAAh;FpBR}RlñngãgTqR2I--<'#%/''10@NWevÜváõì•Ωï®∆áö∫Çï∂zãßO^qES\Xbalvnt}x<GA#3)"6*'<-+B26&:QAKbRNeUUk^dum~äà;A?FGA?=0KF0e_GYS=^[J\^Sdib^c_?EC6A9-9+,8 yÖq¢Æ¨ØΩ∆≥ƒ‘≤¬Ÿ™∫‘ï§¡Ñí≠yÖücoá\kÇuâ°âü∑äüºñ™≈o~ìXfqUggWjdYjbUd]T`^V`a3=<9EAAPI>OEJ[SVg]Ui]QhV[u\\x_nÜvZre@x1D|3B{.Az-Cx0F{3F~3NÅ<A3V De.@a*?]+<Y+B_3>]1Ko?8^-5Y)3R))=!&85I-:L2 -'2!6A0JVB@L8JZ@:T1<Z68V4%@!+B&\sVD^7Fb9MiA9S0;O3 / .4*N\E,<!"24F.1C+&?=c4Bo6@r3Au3By6IxA0O-54U6aâdZàZXäWWâVYãZVÖWPÇQUÖQPÅIL~CNvD0)&+$'*##,4)$,25,23+%& #$#$05.!&&)"780<<4%%//%JL?joYYbEdoOtÇ_[kGEY6Gb??];:S5KdFMhIUrSb}^HaC1@)N[Gfv\qÅgk}coÅgnÅek~`dwY`uTbzXc}X[wOLh@D_6G`8Ha9AZ3>T04L*'B!GfDFnIEoKDmKClJBkI>jG=kF9iC:hA<i@9h>6e97f<8g=6c:3`74a:3`98b<7a;<f@9c=6c:4c92_42]2/Z/.W+/V)+P$&I#C-K'&?!-#0,8$&/")"? 'K'3W3@d@IoJMuPGrG6_3(O"!@#31>"@K)6@69C>!F7\FnT#âo2çu/ãq&åkís#óÇ)¢è3•ã4≤Ñ7•T°;ß:¶K∑Ñ1∂ü9∂´?ªµE©ú,®ò'ø¥A∏Æ;∏¨>ø∑HæºMæ¡Pæ¡N¡∆R√«Vƒ»Y¬∆XºøT¿∆\≈Õ`¡Õ]øÕ[√œ_≈—aƒ—_√œ_≈—c…“gÃ”iƒ…b ÃgŒ“q–◊w–◊x—÷z””}…¬r—»}”ÕÅœÀÅŒœÉ–—Ö »}∆¿v¿∏p∑¨jÆ¶gäâQZf8L^81H+ 7!4  35,K)2[/.\.-Z34];8`>3[66a42a-._'+]")X"(T(T!&U!&U!-\(6`.D"G+P%(R$$N%L"ID"H'M$E=%J!/X.3^34a6:hA=kG<iH=jKCnPBnM@iG?gD@fA@d>8\66X55T20O/,J(/M):X48X32R-3Q-,J&&?!#< ;"@.Q'@g8Dn<JtDV{OQvM:`98a9:c9<g<>k@GtKMwQIsO8_@3Z=3Z;2Y<3Z=3Z?3W=0T81S80R90R:0R:1S;1S;2S>4WA3V>3W=4V;6X=5Y=4[>3\>2[;2Y:2Y:3W=4V=3W=2V</R:/R:1S:0R91Q:2R;0R:/Q91S:1S:2T91S83W;;`A?gE9b:'U$%V%W%W(Y!)Z#+]*,^-.]/0Y/+M*(C$%> +D$-I#)E(B$? .H-=Z>+C)":"+C+&>(1.-)&$&!4!*B**F-1Q9dÖrqèÉpéÑpêÉcÜp=eC-V,1\.6`0+Q"-R&5\/8_2-T'+R#-Y(:f5FtFbåd\Édpì}|õåÉüìÇùîxîà_}qlä~ríázòêÄùòzòênåÄWxeClNGsOOyU@hC.R.*L)+M,/L0&7%):(8P83Q71Q92P8,J2/K20M1/K2-I2,J0)J/+K3,L40N6.O4/Q60T89eDFtOIvO=l@RÅSXäYKzLeígoôuT~XFvBI|AQÉHNGPÄNOÅNHzGM~Oeëmì∫üó∏ßaÇoR|XPQTÑRUÖQRÇPPQN|U|®ÖkísIqORTOOP~OUÄRLwJVÅVbèh_âelëonçnKcK0A.%)!/ *8D6@LBUcdsÅäjxÖ[h{{å†Çí©Åè©gsâ5AMEOQTYRilcnsov|-95%4-$8,$9*3#PgWXm^QfUcxiYk_GVQ>JF<H>AH8GF2c]G^VAXP=WTEjj^supsxqGP?RY:ãä\ljCsujçñùõ®ª§¥ŒØø‡∂…Í≤ƒË©π›ëüƒrÇ¶k}£uâ¨çùøxá§P`pN`dH[W^th^thZpdYhaP\X;F@;F@ALD?LCFSLIXQGYMCZH>WAMfPnâxC^OF{7F~7Ay0?y-;x+>{-KÖ8LÅ96]$5U#Ge1>Z'A]-9T'=Z.Fg:@h4<g14Z'3R($7#2'9!<K4 +*5%9D38E1".&5*D!+I#0N(0N*6Q.OjGEa8@\34N)2I,9K3# !#&.#9H3(:"2A*6E0$3 .Fg<Fq;Cs7Ew8I{@=d5
+ 	&8Q<cÑg\Ü^YàZXá[[ä`Yá`RÅWTÑTGxA@p6-U#2*).'-0)!$##+ &#)),##$))' !%'"25."%45-33+1.)43.FF<chTZcH_jJtÇ_ixWatTgÄ`C^?C\?MeKgÅfcÄb_|]<U7+:%BM<O]F\jQ`pUbuYdtWrÉcgzZ`sSi~]`xT\vOMg@F_8E^7Ka;I_9FZ7;P/$=GfFEjH<f@:d@<fB=gC<hD<jE>lE8e>5b;7f<9h<6f<1`62a77d;2_64a8:g>:e:5_78e:5d83b43a3-[,3^0-X*&P #M"I%I)I ,J$+F% 9$81#2 	0=W:EjHGqKEoGLvNMzQFsH5d62]/,Q&/
+ '/(0 '36#615+E7iW)xc,Çh+Å_èq)óÅ.ûä4ôz(£q*ï?õ9†B±j(ªò>™ù5µ±Eµ±C¶ö*∞£3∏Æ=¥™9∞•9æ∂Kº∫M∏∫LªæMæ¬QªøPæ¬Tø¬Yº¬Xø∆\¬Œb¡Õ_øÕ\√—b≈—c¬Œ`ƒ–b≈—e…“i«Œf∆Õf “mÀ’tÃ◊wÀ‘w“◊}–Œ{Ã≈wÿŒÜ”ÃÑ–ŒÑŒŒÑÀÀÅ∆√|√ºvΩ≤p±ßjôî]ci9I[3=W4!:0,*23R02[1*W,1^78b>:b@:_=8^55`2/`)*[#*V!(S'S %T &U!.])1]*I*T&.X*(T#)U$&R!"MH%P%)T)%P%F%K",U+3^34a86c<9eB;fH;fHBkKDmKBjG@fA6Z66Z4,N)*L))H&%D"#B #C'G"+J('E#&D"(C$&?"": ":  ;#A1T*;a24Z+8W.=]8<^;<a?9b:;f;=h=FpHLvPNxT?fG2Y<1X95Z;4[>3Z=3W;1U91S81S81S:2T;1S:0R:2S>2U?2V<0W:1V72W86[<2Y:4[<3\<3[93Z;3U:2T;3W;2V<0S;/R:1U;1S:0R:0R:/P;.P81S:2T;2T92T95Y=;`A@hE8c8)W&%V&W*[#)Z#(X$;i:<i>DnF>g?4V3.L*$=(?")D!(D&A%@"?!@]A$>#40H.-E-0)%$$#+ 6!.F0%A('E+[{dcÇsnåÄqëÑjçyTyZ-V.+V(2\,/U&(L/T(2Y,+R#+U%8d1:i5?m<DrDHpMiçqwóÇgÜtHiVHiXXxiiâ|pêÖvïçxïêoçÖdÇxWyhJrXVaVa8]>&I)(J)+M,+H,&&-C./H2,H/.J3-I0/L00M/0M1.J1-K1+L1,M2,N3.O4/R47\;9c?TÇ]jòqPUCtEMÇNWåXPQO|QWÅ[>k@At9D{8JÅ@NÅFdîbZâ[SÖTQÄTÄ©âàÆïè∞üQt^KxQNÄOLGSÜNJzH]å`oõzÉ´ê|¢âT{`ZÜc_çfdímpúxtûzXÑ`WÉ`IuRW]zõ~TlV+>+0 $5%0 #4";H6JVH]jcmxzcjr>FQHVaevÄeqGT])345<5VVJ^\O__WâãÜDMH(5.->41% 5&]tb:O>OdSYn_\pe4GA8LC7I;;J7@E1OM8mePpeQd]Ka]Qbc]ÜåÇOXCmqP}uDcX+[YJàçëéñ©zà£j{ôäùæ†¥◊ô´—âö≈êªzã∂yã±qÄ°csäEV`;MM4H?LbUWm`dzm]ndLYP?LBDPFDPF?JB3@94C<=QEBYGRkU\u_Zs`MhW@h4<g2/\%;m2?x4LÖ>TåC=n,-RB_/;U(7Q$A\/4Q%6R)7V,;_10T$1Q"=V.&68D.KYBFT=-:&4A-7F/3B+&3!,;&*>#(@ *D!+G!:[0Fe;:T-4J&;N20?(1@-*19*,2$$,#02C1<O;?Q;4C.(/<[2Ai5Cp9Hu>Ah;0
+"+=1?XEaÑd[Ö_YÖbYÜgcérjñujômPKKxA D ""$'(#$' !'!'# !#$"#!8;4+.%+.%,+&('#2.+=<7Z^OdlUV`EgtVjy\pÄcWnQ=W:OgMLfMYsZvêuYtU=T8(5$19.BH:PYFKY@K[@P`C`qQ\oOeyVi}Zf|Vb{SNg?G`9E[7EV4GV5@O22B'#5?W?CfF:d>=gA@mF@mF<jC=jC;hA@mFAnG:i?4c9:hA?mF;iD8f?<kA>mA5d88f8<i>7e76e74d40`02b0.^,%U!&W 'V &R"M%M(O 1X)1V*+O#7!='E!>`=EmHDnJAmICpIMzQGtI.^.0b-0_+,O%'
+#,0!38$')'%;4J:eL#vV%çm0íz2óÄ2öx.ñ` ê9ë4	õU∏ä<µ•E¨´?±≥F≠ØA´©:≤Ø>≥∞?∞¨>¥∞D∫∑L∏∫M∑πLπªMΩøQªΩRΩ¿WΩ¬[º√[æ«^øÀ_øÀ]øÀ]¡Õa¡Õa¬Œb√Œeƒœf≈–h¡…d√Õj»÷t»÷uÃ◊{Õ÷}—”œŒ|–ÕÄ’—à–ÃÖœÃáŒŒÜ««¬Ωy¬πx∂™n¶úgnoCO[3A[6>\:5'!/8U71W2.X06`8<d?;`>*L+,N+-R).])(W (S(S(R 'S %T,[%)U"'S 0\+.Z),Z)+Y()W)%S%$O$*U*-W/$Q(+V+0[.0[.+Y+/Z/.X0.X43\:/X65]:9_:2X33W1.R,'K%!E#H%H $F!%G"'I$(H#&E#)F'*G(&@#$>!&?"$= ";8:#> 911'A(>_B;`>8b::d<BlDLtOOwTGpN3\<3Z;3Z;2Y:3Z=0W:0W:0T81U92V:2V:0T80T81U;/V;/W<.W9-T52Y:4[>3Z=3Z;4[<5\=4[<3U:0T80W<1X=.T;/U<.U:/S9/R:/R:/R:/R:1U;2V<1U92W87\=9a??iE5b97e72`1+Y*8f7;i;8b:OwTUz[TuXXyZ7Y87V4)D% ;%@$B&D%C!?C`B(E)5/I.1I/3)%%%&'4*B,.H/'D(XuYIfPSr`uîÖlçz]d8^9/Z,3_.9`1'L 'M,R#-T'5_/;g4:i38i2:h7T}UeäiZ}_BgH/X6?hJoîÇvñâtîâtîâ_t_tkãÄléÄiã{aÑpFiQ,N3 A"!C")K*(J)9)A+#6#$ 0 *B,)E.+G0,J0.L0/N/2Q2/M1.L2-N3.P5.S4.V43[8R}RUÇWbéj≠âWÖaBrLMÅSQÖW}©ÖYÉ_MzQ>n>@v:C{:LÇH[çZs†yeënoõxYÇdë∑†vôÖhãwMuZFtOKQM~OHyJ\äe™åâØötñÜ°ìé∞†á¨öã∞ûã∞üï∑ßsïÑMu[ErQEsN{¢É}ùÖLcQ&8(0 .0%8%4C.JUDiphbgc]]]EGF3=</>;4C@-<5*6*3:*NK:TM;e]Ra]TAD;1;20=4"4(/avc;S=\sa_ui?TM9PH6PC5N9?U>ET==E.NL7h`MiaNb_PvwobiaQYJnpZaW4VI)HF7|ÇÇyÄêT`vJZqYkÉÜô∑ö≠Œ•∑›î¶Œí§ vÜßVf^n}Mab0C=,@50B6;MAQcWP]SIVLGUHP^OScXO_U7F?5F<?VDKdOSoXQjTJcNF_L1O)#C/O(>e8HyASáIOCH*J:S+3I"4J#:U*?\06U)(IHi<3R&Id9L`;<I//8#:C.4@*0>'7G-EU84D)#2"1!1 3":D^7@_3<X/?U1ScH@L61<+N[JYdTs{lÖç~qzi/<+7H8pÅq?N;$1(3#5B0AY9Hg>=a56Y/*E$*' /!_xbStYbÖmjêy{¢çiëvVÉZRÄOJtB"B
+$% "#!" !"%&!!#&(#!#,/&=C7+.#..&*'"/+(:94GK=^fQ[eJS`BWdJeuZQeI?X;LdL^v``yciÉhd^BY=/:,-2+17-7?09F2;K1AO5ET7K[>[oLg{XdzTQg@AW19L,7G*4A'>H06?**3 "/B^EHkKEmH>kD<iB=kD?mFAoH=kD5c<5e=9iAAoH;iD>nH=mE7g=4c7;j<;j<:h:Ao@6f65e38h6,\(*\'*]%*]%)Z"%T#P$P&U+Z$3b,7c.+V!&M4[.8c89h>;iB:hA?mF?nB-]-2b./b),[%!A (/:)+9"$2*6 +3'&
+A9SBjV#yg)êw5óq2ÖLé9ç8†k)Øì?®¢@¶©@´ÆE¶®=£•:≠¨@∞ØC≠¨@≤¥I¥∑L≤∏N≤∏L∑∫O∂πNµ∂N∑∫S∫¡Z∫¬[º≈\ª∆]ø»]æ«\æ«^¿»a¬Õe¬Õg¬Œh¿Ãh¿Ãj¬–o«◊u…ÿ{À’|À”~Ã–|ÕŒÄ––Ü–ÕÜ…∆ÉœÃâÃÀà∆≈Ç≈Ω~¡∑z¨üh~xHS[4EY6A_==\<'D%7!"*0J-1U12[33^39b82V2@6@.Z)'V &Q%P&P"N%Q(W!"Q'V"(W#+Y(.^./^0,[/)X.&S*0]4.[2(U,.\.1_12`23a31_10]22\64^81[3,U-+Q(&L#'M&#I"#G!&L#)N%(M$-Q+.R,)K&&H#(G%)F'&C%$A#'D&%@!%@!"=852'	$9U<<a@8b<:d>BlDJrMMuRNwU8aA3\>3Z=0W83Z;1X=/V;.U8/V92V:2V:1V70T81U;0W<1Z</X:.W73\<5^@3\<3Z;6]>5\=6[<4V;1S8/V;0W</U<.T;.U:/S9.Q9.Q90S;1U;1U;2V:1U91V78]><a@>gE6`<=gCMwSMwSLtRKrSNrVWyaXxaHdMNkO:\;8Z77U3(C"$?%@&B$B$C!@_?-J.6'A&!92('(2%8%4!":$,C//G/)C&=Z;9X96W<UvahärRwX5]81\.2^+1[+1X)#I(N*O#8_08d17f0;l5XÜUT}S>d?6[91Y6/[7HsUjå{ríáuìâqèÖbÇwlçÇpëàlåÅtîâ^n7YA%H*!B##E$,N-1S22T33R3-G.%;&),)A+)E.)G/.L21O3-K/0N2.O2.O4-P24[<JsQMwSDqJYà\dìipú{ÜÆîy§âpõt°Ärü~ã≤ó_ÜiKxQ<n=@w=D{BRÜUkõs|ßãÅ©ëÑ™ìV|gë≥¢é∞üoïÄy§ây§àx•Ñ´à~™â|§äç¥°Ö¶õÇ°õç¨¶ñµØé≠•é≠•êØ©îµ¨mèÅBiT8gEVÑ`vù~fÜnC_I+B01 .2)<(.@*;H4MUHPSHKMB:=2#/#!1$#3&%6&(7$+4C@-TM;YQDC?47:14>5)6,%7+/ Vm[Wn\f|oWki;OM8RIC^M@\C@Z=OcHZhQFI6]\JtqboocnsmS]ULTIDH9PI6TO<joháíñÇçügvçm}îÖó≠ò©√£∂÷ó©Õ†≤ÿ≠Ω·pûo~ï`p}^rpTh]/A5*<.,</<J=Q]Qbn`_m^hyibthYjbARL6JA?XEC_IUq[C\G:Q?6M;.B&.F&/F)5S/;e5>h81P'+%=CX7-@ AU0<W,Dd5Kp=:_,Ff5A^0Ka:3D$ )18&JQ?MYADT7Ma>CT25F&2>&8D.<L/;O,D]6PiAOhAReEYiNamYal\R]OP\NAL>?G<8@57?2,7)CMBnzlDO>8C23;.$,0=)=L5.=(-)8#6E04F01@-0>-,:+:H9VfYg}pQl]Z{fZÅbYÑYUÅPYÄQ5!""  !"% #!""$!384LQK16/*0$;?1*,/+6/'72.<94=?2ZbMYcHCP2FS9_oUG[?F]AKaLf{hoáohÇeb}\<S73?13:2/6.19./<+0=+3>-:C0?K3ScFSiEOe?CY51D&-;$!*   #%5(+D/<_?DlIBnJ?mH;iD7g?6i@7lB;nE;nE@pHAoH9h>0`65e;>nD<k?=l>BpA8f7:j:<l:.`-*\'.a)0c+1d,,]&%T#R$S'V +\$+^#3f+2e*,]&)Y'/^26f<:jB;kA5f7-_,0c+2e*.b$-X"3	'(7I1';1K(;Y7*H$5O(G^44AEKZT r](á]-}>Ö2Ö:ûr1•ê=ûò:ûû<§°@ûõ:†ù<™™F®©C¨ØH≠≤KÆµM≤ªR≥ºS¥ªS≤∑P≥≥O≥≥O∏ΩW∏øWª¬Z∏¡Xª¬ZΩ∆]ª√`æ≈eæ»gº»føÕkøÕl¿œp√“u«÷y…ÿ} ‘} “}Ã—ÅŒ—Ñ”’åÃÕá∆≈ÇŒÕå»…á∆¬Çƒ∫}≥®pèÖR[Z.DT/B[;?^>?a@=\<3M0.$( 8-O*1W.0Y-0Y/1W0-Q+'K'%J!+U'(T!'S &R%Q"N"N!P$S'X!-]+0`02b83c92`9,Z3+Y25b;.[0+Y+.^.0^//]/,Z,-[-.]//]/-[-(V((S&/Z-)R&#L"%N$-S*)R(/U,5[42X1+Q**N(-O*(J''F&&E&&E&$C#&D"$B=!<7+$ 
+!(,D.<_A8b>:d><f@GoJLtQPxVDmM1Y>1Y>3W;5Z;4X>1X=-U:/X:2Y<3W;/S71U92V<1U;1X;/V71X92[;5^>5^>4[<7^?9^?8\@6V>3S;3W=1U;2V<0T:1U;0T:1S;1S;1S;0T:0T80T82V:3W;9\>=bCAfGDkNHlRKnVUva\}jWwh[{lXwgHeQDbJ<Z>6X76X5<\78S0.E($8&?$?&D 6T2-G*32/,&),#6#2G62I7+B.0G5.F0$? 8V2/R*/S-:_>[ÉaCkF1\1.]),[%,X#0[&*N %I,P$3Z+2^+4c/NyLz£{LtO/W25_;=iFXÄepñÅÄûîÅúïÉ°ôÅüó|öíwñémåÑfÜ{cÅwGfV/Q8%H((J),K+%B#2O07Y61S0.M.)F*!;"$=''C*(D+*H./M32P61O5/P5.P5-Q5,S4BnJdëjTÅZN|UTÑ^x•Ñ†«≤ì∑©é∞¢É•óóª≠ñ∏®â™ô^ÅiHvQ<p@EyISáYZâg|®çä¥†ê¥¶ï∂´]}pÅ£ìmè~£íéµ£î∂®ò∫™ñ∏®ï∑©ïµ™Ñ£õä©§é≠®î±Øì≠™yóèeÖzwóålëÄIs]CoTUÇaoõx`âg]ÇcXx`?]E";%7"8!(>'-A(.@*2?-4@,7@+.:$ / 34(>)7I3'347$JI778*47,1=3/<2$1'%7+&>0HbU\sm~íëSfl:NOZqgQjWJdIJcEVmPas[VaQgodmrkÖÅVb`NZX_hcSZRFKDcliè†™ê¢∂é°øê£√ü∞Ãô™ƒñ•¬õ´Ãçü√™º‡¥√ÍéØwÖücsÄ_totà|I[M0@3,:-2@1ER@ivdsÅrrÇwåùïì¶¢ass8MH>YJEbNmàwPhZ9OC9MB/?$0C'*>"3N-6Y/$D"7&6EX<AT66I)>T.;V-Jj;Jl:Bb1;V)AW0GX6DQ7U\JLPAKRB\ePO_BThEO`<O_;dqULZ@:K+QeB4J$)??O4DR;9F44A03?3.:,>L;&3")3('/$6>319.HPEYaV19,/7*"(!'$*#.6+0;-4A/<K66C18E4EPBIUI:G=8J>NeSMiP\{YUuNOmG% ! "$ %!*,)ejfgng(-&06*6:+,-85&;5)61+;:5=?4UYHT\D6@'=F3O[GM_GEY@BUAZmZwçvfbSjM:N57C55?64@60>/3D2-<)#.#.)5!EU:=R15M)1F'(8&,</HdKGjJBkI?kG?mH>nF;nC>sGAvJ@sJ:jB2a75d8>oB>nF7g=?nB?n@8f8?m>?o?0b/1c03e27i46h31d,,]&#T#R#R(W ._')_!.f%3k*2h,-b,7h;=mEBrH8i<.`/)^(3i-1e'/a$)O'
+'/2I/FaB6T0=`8?e<3^3@i=Dk>;\/C]0JV(RN!bFj<q2u9îp4üå@úí=ôî9õï=êä2úõAß®K•¶H©≠L¶¨J´≥N∞ªU∞ªUØµQ≠≤NØØOµµU∑ºX∂ΩV∑ΩY∂ΩV∂ΩVºƒ_Ωƒdø»kΩ»jπ∆jºÀlΩŒpø–t¿–w∆‘|«‘|…—|«œ|ÀœÇÕ—Ö“’éÕ–ãÀÃäŒŒé«≈à¿ªÅª≤{ïéXbb0=I6O'9Y4@cB=`?7Y8$A",$'!:-M(,Q&*S',U+,R))O(,R++Q(/X,.X(0\+1`,1]*0\)/[*/^*1a-6f28j97h;9iC8gC7e@.\7/[76c<,Y..\-/],.\+)W(%S$*Z(.^,.^,*Z(*X).\-/Z,&O#(Q'.T-.W-2[15^6/X0'P(,R+/U.-Q+)K(*L)*I)%D"%D""D$G@%E #A#= '?%&>$(>'028Y<9a?:d>;e?CmGIqLMuROxX6_A0X=4X<2W84X<2Y>/W<.W9/V91U90T82V:2V<1U90W:/V70W85\=5^>5^>6^<7_=8]>8Z?4U:2R:4V=4X>0T:0T:1U;0T:1S;0R:0R:3U<2V:2V:2V:3X98]>=bCBfJSw]YzgXwgUqcNj^Lg`ZxneÅuA^L8V>3Q53U44X29[6D_<>P6"-&=!'B!*E$'@#1,*()-..2!-D20I64K9*C- >;[40S))P$5^6RzU>h@5`3-Y&+W")U -X#4Z))M/S'3Y*3_,9e4JsIPvO;d<+U-4`<Q}\yüàsïÑfÑxdÇx^|rhÜ|tíäpéÜiàÄcÉxXth:YG+M2(K*,N-.K,.%=#2O01P0.M-+J+(F*'E+'C*)G-*H.,J0-N31R70R7/V93\<5a=VÑ_pûwRÄ[KxWVÉd}ßèü√∑úªµì≤¨êØ©ó∂∞ò∑ØoèÇ]ÄjSÄ_OÅ[jôuzßàÜ∞öá∞†é¥©ï∂Øùº∂vïçOqcjéÄá´üî∏Æõ∫¥üº∏ù∫∂ô∂≤ô≥∞Äùõå™®êØ™à•°tíäYyjGiXEjXAhSJt\hîykñx\ÖcU~\ZÉabÜj]fIgO4P7+C+'=&)<&&8"(5#,9%0<&5C*%7!"53!7 0C-&5 -6#26'"(*2',9/%6,(8-"4(3K=Lf]kÄÅîõct~EW[J`TI`LMfISlNQhL^q[vÜyÅêâtÄ~ÄãçRadIYYcoomyyrÄÉî§±ô≠∆ë®»è¶»é¢≈†≥‘§≥‘ú©ÃvÉ¶brîØ¬„¥ƒËÉë¥jwóP]p\nneymYk]K\L,</.<-CR=ds^l}mnÄtrÉ{táÉdxw=SP<XIGdRqå}`ulATP8KI4H%-B!,E%1L)?]72L%4C$LY;UfDH\7H\7Ha:Jf=@\3Ib:Pf@EV4BQ2DN5OXCEK=HNBVYN[aSWcMbqTdrOL\8GX6_sPSgDTeC6F++9"6A1;G;TaWI[O@UD4J5AU:(:".9).4*4<14;3AF??D=.1(.1*#% #% %(!!$%'"*,'8=608-5@0BO=8G41B/'&2&,6-8C5=J81>*'4"%*#" "%'"&+' &""'*!24&;:(?<+51%66.560>@5NRDJN??C48;2@F<BM=CR?>O<EVCau\VhP=L77D34@6:G=;P=8R97Q60H00'.2D*+C#+D$.E),			
+	 ,"(:*,H/AiGBnJBoFFuKDuHEvI>oB5e;2a7<kADuH;l?8h@@pH?nD6e9@mBBpB5e51c27h9:k<9j;4d40`.,]&$U%T$S+Z#._'3i+.f%2j)2h*-`(<k?CqJ>mC2c41f2.e,6m3:m23`);!$5M54S4?`AEhG?e>=f<<g<;i;=h:8d33]-5\-9Z-A[.IT*NFV7b:áe5ó}@óÜ>ñã<öìEïèAúõKü°N£¶O¶©Pü¢G©≠O¨≥T∞µW®©K®ßK∞ØU∏∏`≤∑Y≤πY≥∫[≥∫Z±πV∏¿]º√dªƒiº…oª oº r¿–w¿–x¬“z¬–y√œ{ƒÀ{∆ }…ÀÄ ŒÑÕ–ã…ŒãÃŒèÀÀèƒΩÜø∏Ñ°ôhnp?FX$/M&L*Q%6\57[71S."A.'.*E&)I"'L!,Q(-S*,Q(-S*+T*.W-.W-/X,3^06a34b37e6<g9;i:;k;;l=<kA=kF>kJ=jK9eD.Z71[74^63^13a2.\++Y(*X'.\+-]),_'*Z&*Z&,\*0^-.W+(N'.R.-Q-5[4:c;0[0+V+-W/,V.*P++Q,-Q-)M)%G"'J"#F%J!(O#%K"*N((J'*L)-L,+H**B(/+.J1?bB;c><f>CmEGqKKuQOxVAjJ1Z<1X91X92Y</X:.W9-V80W:1U9.U81X90W:2Y<3Z=3Z=3Z=8_B6]>6]>8]<:_>8]<6[<5X:2T93W;2V:0W:0W:/V9/S90S;/R:0S;2V<3W=3W;6X=6[<7^?<cDCgKPrZbÅqiÖygÅv_ypVqhLh\Vpc^yjSoY/M10R13W19]7;Y7)8#
+,&:!"950/+*./!9!9#/6$$;)+D1!:$9-M&/T)&M!*P'GmFIrJ:c72\,%O&P)Q-T%+Q")M!.T%0X&2\*9`13]/2]/.[0DpLYÇdfâq^lQr_Z}iX{gaÇqkä{iá{aÅvYylFbS4T=,O1-P/1S23M0($0'?'*G++H,+G.,H/(F.*H0+I/,M0-P2-R30W8AjHLxTErKZàamõwló{qòÉcäwå∞¢ûΩ∑ù∫∂è¨®É†õuñçyùègåzQya^åppûÇÑÆòáÆúè≥ßî∑∞ïµ∞î≥Æï≤Ævïçfä~Åßöê¥™ñ∑∞†ø∫üº∫ûªπûªπíØ≠Ü£°~úörëãbÇuUxdKsX7bDAlQmóÅÅ¶î|¢çZÅfT|ZR{YYÇ`^Öj\g[}ePpX4M74 .#0&1#(3%/<+9F4.=*'8% 6!4!4 "3 '2"#'-=20$*:0-#)=2]rmet{vÑècq|BQTTfZ^q]PgM^u[J`Ivãzäûïë°†~ãëfu|GY]PbdqÄÉvÑçù∞ø°µŒùØ’ãû»ãû∆§∏›ò™–ú™—ö°ÕQXÇ<Kl©∫ÿ∑«Ëèù¿T]Ñ1<X>OWOb\QeYASE1A4,=-J[HZmY_tag|mdukj}wh|z;RL<XIB_MYqd[pkWikL]d=Q,<R.,F#8V2'E.H!GX6Sc?JZ5GY3G]70I"@\4Ic<;Q-?P.anRGQ8JS>GN>BH<CI?NVKZbUht`~çpn~ZZlDSj@XqIWkHXhM5A-19,'.'$/+p~~†≥Øö≤•á†ãHaD$8#.)/%$* 6<2/5+<?6AD=AB<.0+')&$% 11/==;220572AG;4?/(5#2A.0=,#/!!$%+!'!#*"$ %!#($!&  %--!01#31"12$/0(%& 34.BC;FGADE?<<:>@=@F<?G8=H7>L5O^AO^A=I35@03=48H=;T>2P42S62P40J1&>&2H1,C).H+2L/3I2%
+
+
+
+	>UAEfKAfEAiD?iA:g<7f:4c77h;;j@ApF;kA9i?AqG<lB8g=?nDBqE6e95d6:k<>oB8i<7f<4c50`0/_+&U*Y#)U ,[$,]%5k/2j+.f%1i*0c*5d87d=1^55d84h7>s?I~FQÇK4Z+	$ &'2EdEEjHAiF?iC<f>;f;8e:2`2.\..\-2`11_10]21Z04U*>P(LI&M?bL#wa0Én5ê~>ôãJùîOüõTúöO£¢RõùJôòE¶©R´ØX™≠T£°J®£O±∞]≤∂b¨µ\∞π^Ø∏]∞∑ZÆ∏X±ª[µ¿d∑ƒjº…qΩÀtª uΩœ{æ–|ø—}øÃzƒÕ~√ }»ÃÇ«»Ç… ÜÃœå…ÀåŒŒí…ƒç¡∑ÜÆ¶xÄTjzMGg53_*0^-;i;:d<+T,-S*'K%2)6"@&F%H (K#+P'+P'*P')R(+T*,U+.W+2[/4_25`39d7;f9@k>=l@@oEAoHAmJ>jI<gI7cB,U31[5+V+1\/3a0.\+2`//].:j86h3+](,^+1a//_-3a2.W-&J&)L+2U4;a:1Z2,W,3\46^9.S1-P/0R1-Q-+O)(M$/T))P$(Q%(S&*S)(N'+Q*,P,*M,(G(%?$+, 8 ?]A=b@<d?BkCDnHGtMKwSMvT6_?2[;0Y91X;0Y;/V7/V93W=3W=0W:/V70W:/V94[@3Z?4[@8_B9^?8]<9^=:_=8]<8]<4Y:3X94X<3W;2Y</V90W:.U81U;/R:/R:1T<1U;3W=4V;5Z;8_@?fGAeIFhPmå}wíâråÉjÑ{b}tRnb6PCSn]hÑn7U;-P/4X29^5:X6$
+-1./.,4#;!8(D+(D- 9$+D1#<)+C3!=':-M(0U,+R&#H/V*JpGCl@7a1/Y'&M#J(N$J&J)M+Q *R+S!&P%S"1_1GtMEnNLpV[}e^ÅidáofâqVycLm\^}ncÅuXwh;XD0P8-P0-S.8Z77T5.(%;&*D+)F*(D+*F-,J2,J0*K0,O1/T5.V40\8UÅ]WÉ_EqMR~[Ç≠èñª©†ƒ∏|†ñîµÆò∂¥ó¥≤ÇüõeÇ}pîày†éiê{Nx`fí{y§êé¥ßê±®î¥ØûæªõππêÆ¨à•°zôì~¢òÜ¨°éØ®ñµ∞öπ¥ï¥Øç¨ßÑ£ûå´•ûò`ÅvQscNt]FoQ8dCHuVlñ~Ü≠öåÆ†à©òW{_RzWZÑ`_àfaán_Çl[~h^ÄhWs]2I5 	$+)7&#6"42!2 *	( +8.!1&(5+%/>7}çå`mukwÉVck@NOXh]ZmZ`s`RgT\q`qÖyrÖÑìñèù¶Q_hEW[ew{wÜçpÄçßΩ‘ô∞–õÆÿö≠ÿß∫‰¶π„Ñï¿ï¢œÉá∂LQ{-8VûÆ»∂«Â°Ø“irõ6?`(6C3CC>OG2D8-?1-?/FYEKaLPgU{íÇãüîxåÉmÇ{>XM<YG?_JWqddytgzÄevÄCT0I_;*D!2P**J!7X-PlC6L%@Q-GX6RhB=V/@\4PjE5K'?S0FU8CP6:C.<E4<C;7A87C7DRAAS=YnOràa^zJMm<Gd80D(!.'/"%,$#)'*46@LZî¶≤®Ωæ§æ≥kÑn 6"--2+5;/7:/GJ?HK@;>5/2+)+&*,'&(%%'"8:5)+&=>9:9501,@C<.1*28..8-2?.5D10?**$!')$!#$,!&#!!& #% $&!%& -.&36+03(),###!312E@DGEH@>A???>@;9<3:<.OS:X`9P[3EO47@/.6+:H;@XB3Q51Q93T93T71P1.K-/L.0M12L30F1#
+
+,"+;.+@/;T>=\=9]99b8;f9;j<BqCBqE;j@=lBDsI=mC:j@=lB@oE6f<7h;=l>ArC>nD?oE:i=7f89g8+Y(.X(1[)1](-\%*[#+a'1i,3k.4l-2h..^.,Y.4a88e<BrHJ{NK{KNxJ#> %'$9&:V=IlLFpJ=gA;h?6c85c5/\1-Z/0]26c8:d<7a9.X0$O$&O#0T(4M%*99:KC_L$v^0èxDôÑKöäNöåKûñNîêFûúOß•X•ßT¢°O®•V®•V¨≠_©Æ^™≥`Øπc≠µ_≠∂]≠∏\≤øc≥¬g∏∆o∫»s∏≈u∫»yºÕ}ø–Äø–Ä¡Œ√ŒÇ¬»Ç… à≈√Ü»∆â……çÕÀíŒ«ì¬µà≤†xçÖ^l{RbÅWMxJMNJ~MK|MDtJ/^46e7.Y.
+.
+2!<$?#A%E &I!)L"(M")N#+R&*S',U)/X,.W-3\24]37`6<e;=h=<i@@mDAnGCmIAjH6_=,V2(R,,Y0&U',\,#S!/_-=m=5d6BqCCtE8l>5h=BsF8i:4b4+Q(%I#-Q-6Z62X1-V,0Y/5[44S40J1-E-,F+4V57]6*S)/X,-X-)V+-X++V+*S+,T/.T/'J)*I*": ,$3 14Q5>aA:b?=e@CmGHuNJvROxVClJ3Z;1X94X<4[>3W;2V:3W=3W=.U8/V92V<0T:4W?2V<5Y?6Z>8]>9^=:_>;`?:]?:_@6[<3X93W;2V:1X=1X;1X9/V7-T9-T9.U:/S90S;3U<3W=7[?;_C@dHHlP>`H^}nÄõíyîèqåábÄxdÇvKgY2O=A^H:[@+P.3Y24[/;[6*	&&+1-0G3<U@5R>/O8,I51N:6S?2O=5QB/L8+I/9[:2W.4[.(M!%L.U(4^.4`/4`-.X&$J%I$E"C'K(N'O'O'Q!+V(8f7<k?8e>?hFPtX`ÇjcÖmKoU?bJLo[cÉteÅsPl]4R:+N0.S2.T/;a8=]8$= ."8!(@('A((B)&C'*G+,J./P3/P3.Q3*R0-W39h>Zàaz£ÉWdkìyòæ©ûæ≥°¿∫ï¥Øê∞≠ú∫∫óµ≥ëÆ™MldXlmó^àp_âsv†åÇ´õòº≤Ñ§üë±¨õª∏†ææï≥±|õñ|ùñÑ•ûê±™éÆ©öπ¥èÆ©wòègç~bâwbáuU{fJrXJsU>jGfíqló{y†ãÜ™úã¨£ã®£á¶óOtULuMXÇ\dåjeàpdÖr`ÉocÑo]}hZub@UB#
+
+!-#6#4!4!!2""	
+	*5-$0&'3'#.7B4S^Xeqq\gmgqzQ\`HVVO`VK_SXlaQeZ7K@@TK_olbrrfu|HV_Q^djw}aku|âôßΩ’ô≤—Ø«ÎµÀÚ®ΩËåûÃÑñƒêûÀíô«RW}CMfô•ª∏…Á†Æ”s|£pvñFO`+6<+:7->6(:,2D4@UBE\HMdTÉôå~íáÄîâ{ìÖFcQ=]E=_FwîÇë´¢ÜôùsÖèHc6<Y-,M"1U)7].Ag8A`46O'2F!H\7QjB5Q(7S+A[6Ld@I]:BS3@O2MYA;G3:E7;I:QgP`z]XsTQlIVrIFf7Ii7Ee6%:$,#1"#3(!1.(;AH_eÇõòö∂®QoU5&7%AL>agYnrdFJ<,/$,/(03,.0+.0+%'"#("(-'572EFA12--.)=>989401,35016/.9+/=,4F08G2'4#'"!& %  #$$,!!)#"'!"$$&!%& "',%28,4:.'-#!!!+),:5<IDKA?D@@>ED??@2;9$EE#dh6ci9<C$29'39/:F<@UB9U<3S;0R92U71T4/P1-K//K23K5-@,
+		3J0AY?+	,*;+#;%)F*8Z7JpGItIDqFBoD?lABqG?nD7h;;l?;j@6e;4d:=mCCrFBqEDtJBrH8g;<k=4b31],9`16^,1](._'-`')_%.d*6n17o29o5-]+'U'6c:?lEFuKDsG@n?.U).$'*2K5MkQHmLEoK9c=6c:2_4.[0,Y.4^6?iA6`:3]7)S-$N&'U'/_/4b1-W%%F.E9CB@UI!j\-zh6Üo;éx?ôÖHõâI°ìR•õV£ôRûñN©¢\™¶_ßßa£ß]©≤c≠∂e™≥`™¥^≠∫b≤¿h≥¡j∂ƒo¥¿n≥æp∫∆zº øÕÇæÃÅæ Ç¡»Ñ∆»á »ç √å ¿ã √ç—«î√≤Ü®ñnìáavxSb|UYÇZVÜ\OÑVLÄROÉUOÇWH{PL}P9h<E'K%&H##C#C#C%H )L"+P%*O$,S'.U)-V*/X,/X.6\55[46_58a7:c9>h@AkC?iE@hE@eC,R-#I"-W/1`4/`16f67g77i8>o@@pFDtJDtLBuLCuOEuODtJ5d8+T,(L&2V23Y20Y16_76\55T4/ !+1T36_72]2-[--Z/)V+,Y.-W//Y3-U0)Q,)L+,I+30,>(1$A#;^>6^;8`;AkECpIGtMOyUOxV6]>3W;5Y=6Z>5Y=2V<3U<0T:0T:2V:4X>2V<3W=2V<0T:6Z>7\=8]<8]<9^=7\=8]>4[<3Z=4X<3W=2Y>2Y>1X9/V7-T7-T9/V;0T:2V<4X>4X>8\@>`EAcHEiMCeM?^NuìâÇùòyîèfÅzWsgVrcFcM(F.$E(,O.5[42W,8X12	$,+A,3,C1<WD>[I<[I@]K@]K>[I:VG<VI6Q@3Q9KmL6[20W*2Y*&M"I'Q!2^+0\)2\*-S"'H A A$H&L$L%M.X(0\+3a25e5ApDSÄYhèpjåsSu]6Z@LoW`ÉoZ{jUqb:WC0Q4.Q1,Q/3Y4=b98Z5)C&%=#(@('?'&@'&C'(E)+I-+L/2S41T4-R1+S.>kBRÅU`égû∆¨tôáÇ§îùΩ≤£¿ª¢øΩñ≤≥ï≥≥õππõπ∑ûΩ∑UwiHsXVÉdDqT^àp®ñâØ¢ô∫≥rëåí±¨ò∑≤î±≠Å†öjéÇníÜä´§í±´ì≤¨ñµ≠néÉ\Åp]áoYÑhOxZ>gE8e>9h>2b8`èkÑØîÉ®óå≠§é≠ßç™•`ÅpHpMMxMZÇ]bähhäreÜsbÖqcÜr_Äm\|g[waJ_N* "3! 6!"5"/
+
+ ,8.$.#'2$=H8hrgnxwdmrbmscntXceP_\N_YL`WH]V?TM7JD;LFQ`[cqqL[^KX^ov|fkqOQ]Y_oóßæ∂ÀÊª‘Û∑œıú≥ﬂç¢—è°—èùÃìú«JRv>F[åô™∑∆„öß…jsîsxïyÄêV_f/=>+<4'9+0E2<T>F_J\scjÄtg|sh~rtå|^{gNnVIkRhÖsê™°£∏Ωò¨∑Q}>=k-=m1?o55b+/U$9T+7M'@V/Kd:Jj;1R#9X/?Y4F^:@T1<M-ET5crSDT75G/SlNVyOOvGKrCIm?Gf=?[2A^0Pm?G`85O($>-K'5T46W:>_JEfSOp]Rt[@eC;]8OjIL`E5B.?G87;-14).1*.3-5:405/',&!& :<9>@=672?@;EFA672,-(-/,+0*,1*2:/,6+4?/8E3.;)%%#"(!)'""%&) #)$,#.  (!&$' $'   !$,2(&1!)4$%!&$$"(&'0+/ECFCCCBC;KI:WU<UU1QP ns3di/.1-/!6923:3:K;=T@7U=4V;5Z95X8(E))C*0H26K8,=+
+			/F,5X00W+&E%
+"
+)!4!B\ARqQNrNGmHAjBAlA;j<6g86g:8g;5b95b96f<=mCGvLJyOFtM=kDApF8g;9g80\+7a/5`+2a*._'1g+-c'1g+1g+2h,0e-;m:.]/8g=@oE;h=<j;;g60W*#F=567S=MjTGiN>fD9c?2\6/\3.[02\4<d?3[6&N) J$"O&-Z/6f4;l5:l18i(7e%:b&9\$0N8NNX&QMdM!{Z-ìm@òrAù|I£ÑN°áN°ãQ¶ï]ßùb¶¢c¶ßc¶¨bßØb™≥d•Æ]Æ∫h≥¡l≥¡l≥øk∞πh∞∑i∫¿vª√zΩƒ~∫¡}Ω√É¡≈à≈ƒã…¬åƒ∂Ö»∂ÜŒπå…≤àßçhäzVswRe{T\~YUÇ[SÉ[J}TQÅYQÑ[LVJ}TRÇZJyOGvJEsE1\/ I&K %J*M#+N$,Q%,Q%.U(-T',U)/X,.W-2[15^46_59b8;d:>h@?iA@eC:]<,N+ B'L#/X,4c73d76e9:i=:j@=pG?qKEtPEuOEtPHwSGvREuO?oG;h?/Z/-S,2X16_7<b=;Z:,D*
+&!> 1W21\1.\.,Z,*W,+X-.[41[57_<)Q,'Q+*P+*G).';"/C(4;9^<5_;4^6<i@BoFGtMNxTQzXAhI0W:3W=5Y?2Y>1X=3W=1U;0T:1U;3W=2V<2Y>3Z=2Y<2Y<4[<8`>7^?6]>6]@5\?3Z=1X=1X=1W>1W>1W>0W</V9/V;0W<2V:3W;3W;0W:2Y<7^A=aECgKDhLAdL5VCMl]séÖ}ñêmÑ~Tnc:ZE8X@*H,<$F%0R-/R*2P*(<!	')117!-F1:UD@[LD^QC]R@ZO;UJ;SF5M=*D+3Q/0U*,S$1X)0W(G J%Q*V#,W"2Z(*N %F>#D'K&N,T":d28d17c07e4>l>8b:?gDOsWVx`Qs[X{eMp\KlY>^G0Q6.O00R1/R16Y8<[91N/(B%&@%%=%%?&$A%'F'+J+*K.,M0,O1,Q/0X37b7CqCUÑXSÅ\†∆±ï∂´ô∏≤°æ∫ù∑∂ôµ∂î∞±ò∂∏ñ¥¥õ∫µä©°]ÉnDqPCsK9iCeísàØùé≤®ì≥ÆÉ¢ùèÆ®ì±©É°óLn]CmUR|då∞¢ñµ≠Ü§úzòå^ÅkPy[XÅ_TÅZDqF6f67g39k66j:\åf{¶ã^Érâ™üÑ•ú~†íbàqKuMR}P_ábdâjcÖlbÉncÜrdásaÇo\}jZzeWt^NeQ'8(&7'%8$%6$-#.&.:..6)FNAcmbyÑ~q|ÄtÅäsÄâdqw]klapmYifNa]H\ZDWS9JBIYO\lb`ohDPNdloÄ}ÑbXaMAKF>K@CTçú±Ω“Ô®¬ÁñÆ‹ù≥‰íß÷åùÀÉéªEOr5@Rzàï∏ƒﬁìúπglâkpÜlrÄMV]1?@';2&;(,B+0J/FbISk[\sidypezqc{m|óÜoåxtë}î±üzîã_v|`vÉOÑ<>v/?t0As46c*8\,-E!:O.G`8A^2Ee64U(@\6A[8:O0DW9K\<PaAAR2>Q1<Q2B^8Kq@Hs=Ai5>d55S-?[5UpG\wLE^4Ni>TpGEe<<_58\6<_>@cEEeMFgLGiHIhFOjIWkPXdPïúåKOA25,2703826;5160'.'',&&(%021130461CD?DE?56101,352,.+/1,16005/,4)%2!-:(1>-)(*'2" (  #(+"&, '/ !,&.#(0%!&&)"&)" #(!19.BM=3@.)4&"*#% **(0./?=>DFAAG;EJ3GK*TW,X[&lp3WZ%))11%7835:43?5:L<:V?<]@EfI0Q4&@'$:%2E24E3$
+&''9W5,V&%S"&M!6 '* $5H5@V?7Q8-J,DfEAg@AlA<i><i@8b<;^=<_>DlIGtMLyPKzP>mCDsIBqG<k?>l=.\+8d16e/6g0/b)4j0.d*2e,4g/4i16k5BtC:k<8g;2a73`51_10[-0Z,4[/1U/1S01O3?]EKkTCgM8_B9b@.X4/Y12\40Z4-U0%M*$L'%R+*Y-4d49l48l.9m+5j"3g2e 6g&0`$3\$:V#<JLE_I lO'vU,yX-Å`5âh;êqEúS£ã]¨òe´úc®†a¨©d≠≠e¨Æe∞¥j≤πl∞πj±∏j∞±e∂≤kª¥pø∑vø∑yº∂z√∫É…Ωã∆∏â¿≠Çº£z¿§}¥öuùâdàxVtqNcxQ_ÇZXÇ\O}VM{TSÉ[QÅ[HxRMYNÄZQÅ[RÄ[OUFwJ,[-(V((S&&M!$I&I&K )N")P$*Q%+R&,U+.W-/X.5^26_3:`7;a:>d?:^:0R1"D!=#C(M",U)5c5:i=4c99g@;kE<nI?qN>pMCrPFuQGtSJwVHwUEtPFtM;hA2X3(L(>cA@aB;S9"	
+3.P//X0.[0.\.-Z/-Z/2_62_85_;1Y6*R-)S-2X33M01-A&'>!!:<6[96`:4a89f=AnEErKMwQPzVMtU6]@4X>4W?1X=/V;3W=1U90R91S:2V<3W;3Z=3Z=3Z=4[>5\=8`>9`A8_@8_B4[>2Y>1X=1W>2X?2XA1W>0W<0W</V;/V91U92V:1X;2Y<5\?9`C<cFBfJMpXRu_Mn[Mn]Nj^Smd]tj]xiJjS:[@(G(=:#C*H".I&(?""%..-/34%>+6N@?WJ=TJ>UK;PG+A5%<* 8'B!*M#+R#.U&5\-+R#I"L#M&Q)Q)M%F= A#I)Q.Y$1\'3_*2^)0\+1\.9b8GoLJoPGiNTv^PrZEfQBdL5W<+L/.O0/Q02S47V7.K-&@#%?$%?$$>%#="&E&)J+*K,*K,)L.*O0.X4AnEEsECrDKzNoõzç≤°ñµØúπ∑®ƒ≈¶¿¡ä¶ßë≠Æú∫∫ï≤∞vïèqìÉ_álJzR8l>7j?rü~Ö¨ôå≠§éÆ©ë±¨ç¨§Ü¶ô`Ån@fM9fEXÖdoïÄtñÖlç|cÜnYÅ_JtLIwI=k<7g59k6>p;CuBLTgîsÖ¨ó~†í{úìÅ¢ófåwWÄ`QQXÉU_ádaÉh_Åh`Çj_ÇnaÑp`ÅpaÇqZ{fXzbZwaSjV1A4		'8($7##4"++8.(6)7?0<D7.91vÇÇxÑêwÉë|ÜênyS__Tc`N\\FXXYmn`ts7HB=MCN^SerizÑÉpuy_X`PCMH9@@5=88BHTd≥»„£Ω‚ï≠€ú¥‰ïß◊èù ^jíENk;CN|Öä≠≥√sxåY^qbhv_fn@JL.<<(912E2QgP<T:VoYc{m_vnnÉ~\qjd|omàypãzyîÉô¥•ôêe}ÅXowHÄ7F~7=r.:j,Hp;0O#&;AV7-I#8T,@Z52L)9R4;R68J4?N7NaCG\;-@"=P4CX9?W3QpDRsDKlA)H0K(>X5C[7Jb>E[7.A!.C$8P0JeB<Z6&A"6&;(.@0<Q>4G3:I6NWFdhYrtfYYM12*581382160/4.*/)).**,++-,(*'461CE@ORK57235245002-794794683-2,)0('1&-8(1>,+:%%4&3!$,"$,2(*0&&.!)'/"(0#%#)&)" %2<1MZI9F40;-%#% ,,*--+9;8BIA?L;@P6>L)EN#OU%Z`09;)*7617757965<52@1<R=?[B(D+%A*!9#(;'$2!&"!'),!35U.)U$(W#&Q#%K"!@ $<$+)4&$.#%8%JbHFcE6X7CeD?a@.K--C.:M9@ZAIjKOyQGtIErGHwM=mCGwM>o@*Z(9g6;k77j2.c+6m42g//a,;m:DxH?sC:k>7f:4d:+[1.\5/\3/\1.Y,/Z-1Z01Z24Y7?cGFjP;cI5]B6_A3\:,V0*T.#M'%O)(R,,Y2.[40_13e06i.;o-:o)2j!/g/d 1d"7i,4d*6_'1T2J;HBHLKQH!WE!cI(nJ*ÉT8òeFßzS®ÇUÆê\≤ùd≤üd≥•f≥©k≤™k∞≠h≥Æj≥®hπ•j∑úeæ†jø°oæüpøûs¡ûxøõw¨Öd§}^ü~_ãxW{XjvP^xQ^Ç\YÉ]M{THxPTÇ[RÄYK{UOYVÜ^N~XM{WRÄ\SÉ]L|TGwMEvI:i= K !G"F &H#'K%)O&)O&*P'+Q(.T+1W.5\07\1:\79X61N/(C$<; >(H!)L")P$/Z-8e:6c:6d=;kE;jF>mK?nL>pMEtRDqRIvWGtUFsRIuTIrP C#5@]AAW@#1 
+
+
+%?&2X32]2-\.1^30]21^75b;7a=3]9,T/.V14\7<^=BV=4C..>$0D(+B%=3X69c?7d=9g@>lEErKKuOQ{WQzZCjM5Y?4W?2V<1U;/V9,S4/S71U92V:4X<3Z=3Z;0Y;3\>3\<5^>9a?:aB5\?6Z>2V<2V<2X?0V=0X@/W=1X=0W:/X:0W:2V:2V<1X=2Y>4]?6_A:cE@fM[~jcÑs\~m_pmâ{D`R6SA<YC;[C=^A*I) ?89#>)C '?-
+
+/400 :'A&47!";()A3(>2+A5'=00!16$?$G&K)O .U&2Y*(R" J"J&N'M&J"C<@&M,V$*V!)U /\%/[&+U%0Y-HnGGoL<a@9^=GiNSuZHiN=^C.Q3'J*,M0.O04Q5*G+!;  :!; !;#="$A%'H)*M,*L++L-)J+*O.4^8N}SO~PCrFJxQç∏ö§∆∏íØ™à•°£¿æ¢æøä¶ßãß®ó¥≤ò≤ØpêÖbàqVÇ_@qD>rBFvLfìrê∑§ÉßùÑ®ûuñç|ùí°êFmRBkIFrNcèkPyWV_WÅ]OySM{M=k:4e.5h07l6<p?J~PeïosüÑÑ´òéØ§ò∑Øç¨¶wôãW~cMzQP~M\áYaÜd^Äg`Äi_h`ÅndásbÉrfÖueÑr^~iZzeWt`MhU4K9#(0"3! . .;1&4'/:,/90essyàèàî§irÉ]cojosZc`Va]YghRdhlÄá}êó:JJCOKJWN^iaö§¶Z^gWT_92:1(+40/>BEKXaëßø®¿‰°∏‰õ±‚èü–~ã∑LWw>EWKKK}zsìçèkinKPVGPUEOP8DB/;7(8.=N>nÅnXiYSeWmÅxmÇ}VigMa_\sk_yl^xkkÉvc{nd{s[tp[tq?v28o,6j*8h,<c."A/D#9M1,F#4O,5J)7J,FZ?CU?AM?JWFNaEMbC-@$<O3EZ;K`?@V06O',D .H#<T25M-EY=QeIYlPex\5H,0%:;S3I]B8J2+9(BPA6D7*39-egZ?@2BB666,782271271/40162495,1--/.%'&*,+:<9IKFRUN79413.-/*-.)461:<7463.0--2.-2,!)(5#3E-0B*$3%0#+'/"+1%%- !,*,4',4'"*# ().;*)4$%"-*2',1**1);G;=N<?S:=P0Q]7QY206 $)+14-,1+-4,3=2GVCD[A.H-2K59R<0H25H4&""'%!)B"=b60_+,\('W#%P"0V/3R2.D-"*!&",#>L;,?+ 6?U>7O7. -%2!%;&GfGMuPFsJO|Q?nB@sJExM<m>/a04f59k87n71h14k4;p<<n=<k=AqG@pH<jC:hA:hA:hC2`;.\73`97d;4^6/Z/.X0/Y58_@@gL:bH6^C1Z<-U3%M("J%&P*+U/-Y56c<5d:1a1.a(0g&7l(5j$1i 0h!/c!1e%8l.1c(,[$'T'O*L/K6H9C A@"K?%S;#b<'nB)ÄS6à];înGû}PüÉQ§äW£âV•éZ≤üe∞ùc•êYùÉPñwHôxKôzNôyPõyTóvSèrPÖlMÉlMpQzzXhvRWuOXÅYUÇ[FvNK{QOUGuNLzSSÉ]QÅ[JxQLzUP~ZM{WM}WN~XMÄWI|Q9i?%R'#L"$I &J$'K%(L&,P*+O),N)/Q,/Q,1T,/O*&C$2&3%> !?#A&F*M#)P$)R&/Z/5b94a:9gB<kI;jJApP<nKAsPEtTErSHsUEpRHsUIrT0S5=#%;&&
+*H,2Z54a82_43`74a:7a=8b>5]:.V31[59a<=c>;X98J23A*+>"0E&.F&$? .Q05_;:fB8f??mFCqJGtMMwSR{YNwW6]B2V<3W=0T8.U6,S40U60U63W;2Y<2Y<3Z=2Y<4]?4]?6_?8_@8_@7[?7[?1U;2V<1W>0V=0V=0V=0W</V9-V81X;3W;2V<3V>2Y>3Z=7`@<eG@hN\~mhàydÑwjä}nç~FeUQq\FfN,M2+L-)H('F$!A<6!9!:2 	#7765*G+;YA)G/ <& ;($<.2J<.F95(005"=$G!F$J$K)P#4^.*R E"H#I"F!B@%I,V$*V#*V!*V!-X#)T'Q!)P#4Z1:`;2Z56[9JmMEfI7U93T5+N.*M--N1,J.(B'6769"<#@$(G('J*'L*)L+,O.+N-(P-<i@WÜ\fïkP~YFrQëπ°£√∏î±¨\yuï¥Øí∞Æä®¶ì∞Æòµ±qèáaÇqYÇbN}S6j9AuEgïpiîxêµ§Ü™û{üìaÖwÉ•ïâ¨ñBkIMzQXÖZZá\JwLLzLN~NBr><m6:k31g+4j0;q?LTnù{Ü≤óä±üãØ£éØ¶ó∂ÆzöèX{eFsLDtDO~JZÖW]Ça`Çi_h`Äi^jcÜr_ÄoaÄp_Äm[|iVwdSt_MoWLiS9N=*&1&7%#1 !**;+'5&*P\RvÑÖâï°àî§EN_*0<Y^bekifonhvypÅâ}èù~éõMX^W`_R\TOYQ•Ø±íô£ttÄ43;&&&6;5PZYcryk}ìÇó∂àúøzé≥gwõQ`^k~IPXhe^{shÇwqojfSXT@LH;JC8G@-=3*7-<J=drefrhO\STe_UhdIYX6IEKbZZqgdznawkKbXTkaRlcXqkL}ECv=;q5?q6Fn9%F7Q,+C#.F&<Q0I]:AR22@'GRA7?4JREO\HXhM*=CX9AT6CV8VeHCR33D$7K(9J*:J-:I2FXBZqWH_BhÄ\*@':0@&8E1N]HO^G<K4"/+3$TUGjh[33'<>36925:4273+1--10.21.21*.-)-.#'&/10130GIDILE>C<).'/1,/1.350:<713./1,*,)')$"' "*+8&7I1-?%+(3#'2$%- !,%0#.+3$(. *0"'-!#& #'/$#.)7I/@T;*7&(9G6BS@CW<:M1#/ 	"(&1!$1 /FZAH_B7R1>[<:W;6R93P47M6 	 ((%+<\5Co<:m52g/.`+#S#.X07Z9/I0	$ #&.!+6&#0&4#'+4N5PsSFpLIwPFuK=nADyOBwK4h:3d55f76j99o=4j89o>CwIBsF?nD?mH?mI?mI=jI<hG>jI:gF5bA2^;6`<7c?1^7.X2.X45\=:aD7^C1X;(O0"J'#L$%O',V03]9:cA9f?3b43d-.b$*^1e#4i%/d 1e#0b#3e*/a&(W %R%P&Q&N(L-L#.F&2D*3?'6;$@>'E>$O?%^F*nO2yW4}[5Y2Ö[3çb8ß~RïsEÉf:}f:s`5te:tf?lc<_Z2opHitJgxN\rKc}V\{RMrIWÄVQ~UFuKIyOIyO@pFN|UVÑ_K{SFyPN~XN~XBrLEuOP~YM}WHzTH{RIyQDsIAl?-V*$J!'K%&J$)K&&H#&F!)D%&A"7.%'%>!$B  > C&K +R&-V,,W,-Z13`95c><kI>mM=nN@rO?pPGuXAoRFsTErQHtSIrRHoR3S;		!2S66`<7a;8e>5a=:cA;cA9a?0X53[69a>9^<7Z9?Z;JZ?8F,;S13M*(?"$= 1P14Y85a>8fA=kDApFFtMJwPMyUR{YFmP0W:2V:2V:1V70U6.U6/V91X=0W<3Z?4[@1X=4[>5^@6_?8_@9`A6]@5\?1X=0V=3Y@1W>/U</V;/V90W:-T70W:2V:3W;3W=2Y>3Z=7`@;dFBjP]niâ|låÅiâ~`~rRsbWxeQs[;]D)J-#B"#A%C!"@6131')#: ;8=!4T<BcP@aP1R?&E5-I;9SF3MB%?2 8(/3:)L$.S'"I!I#J.U&3[))Q$L"H D!E'M)Q%R$S(T)T*R"J&P.X&.X*5^28^5CiBPqR>\@3Q52Q2/P1/N/-J.$>%6466 :#@"'D&)H)(K+'L+)N,'O,)S-.[2CrFVÖ[|®á{¶ãcäuâ≠üüæ∏†ΩπháÅjãÑÖ®¢à®•õ∏∂†Ω∏oéSw]S}U>n>9n:G{Ms†|£éâ≠üåÆ†uöàfåwiåtcák@jBBpBJxIO}LHwCHwADw>:m25i+7m/6p50i4Rá]s¢ÇÄ¨ïâØ†£ôÄ°òä©£çÆ£V|eGsPHxFI|DP~MXÉXY~_Y}c\~f]g\g^Åi]~iZ{fZ}iX~iWzdQt\MpXMoWKhR8T=3-!4 /+1);%7F1ITCt{svÄÇéñ°Öåú~àîgq{ajqemonvygt|m{àxÉógnÄFHTCDF>A:JOIú§ßô°¨RXh17C'10ANGeutnÜoéduáN_qFXfM_kDU]O^cR[ZmhbwmcÅtl]VNIQF<LA?SG2F:.@4+8.'1(>E=Y^XJTLDQJGXP@OH;LDDXMPfZ[of^riOeYUlbVpg`zq3_.L{GDw?OÄHEp:%J6R*11E);N2RbEM[A3A*;F5IQF8@5KXFZlR4I*)>9N/>Q3=M2IY<ReENb?<K.'33>.7C5@S@TkQTlJMeA>Q3BR8/:)5@0=J6DQ==H828,STFOM@;=07:17<6273-10487043,0/(,+*.-/34-12*,++-,130HMG[cX"*6;49>8*/)24//1,13.')$)+&(*% %(1@+:L20"/.9),7&;H6+7#'3.7&/5'17+&)$' !$!#%2 );!=W48R/1(9&J[HGZDCW<(: " &(3#.:&)8!':D\<<T4)C 2M*@^<6U64S46S4:Q5
+)'!!%;$@e:<m68n45k1/d,(X&)W)8^9,D*
+!)
+!"'*! !)'2$!2LiMKpOKuQHvO<lBBuJF{Q:mB1b53d58i<7k=:oA7l@9lCBrJDqJBoH>lH:gF8eD<gIClN>gI6aE9dF?hJ9bB7`@9b@7_<0X52W84X<6Z>*O0#H&$J%(Q),U-4Y7;`?<dB0Z2/],/`(/c#-a0b#3e&.`!,^!*\!*\!&U'S&Q#M&N(O"'L##E$%C'$@))A++A,+=%0<$8=&B@'RG+n_>yiE|hCza9w[4y]5zc:n`9snF^a6\e:bmCL[2YkAYsFUyKLvHO}ONRCrHQÄVKzPEtJN}SCsI@pFM}ULzUEsNJzTK~UCsM>nHEtPRÄ\SÅ]N|XIyS@pJFvPFuKHvH7b4(Q% G C#E !C"B7+
+57Q43M20	5#= ;=#H&L#)R(,W,-Z1-Z31_:4c?>mMApPCrRBqQBpSFtWCpQGtSEqPFrQEnNDfK		+8Z?9b@<fB<eC:fEBkK>eH3Z;3[8:b?4\96[9<^=HaC`oRK\<C_95U.1L+-H)0Q24Y84];6d?:hA>lECqJFtMIuQO{WPyY7^?2V:3W;2W83X9/S7/V90W<2Y>3Z?1X=2V<3Z?3\>6_A7`@8_@6]@4[@2X?1W>1W>1X=1U;0T8,S6/V9.U:3W=3W;2V:3W=2Y<3Z=8aA<eGEmSX{gkã|qèÉcÅuPpaFiU>aI9]C4W96Y9/N,!? >:775 41',#< ;9=!*J3=^MEgYCeW?_P=YM>XM;UJ8PC/G76"34%H :a2/Y'#MI!K(P/W%(P"H!E#H&L$O#P%U%Q!L!I#K+V!0\)0Z(;e5Af;HlH9W;3Q72P42Q21P10M/*D+61469 =$A#'F'(I*)L,*O.*O-)Q.,Y2FuIM|PRXaåpòø¨ãØ£õºµùº∑ûΩ∏é≠•dÖ|¢õãÆßï≤ÆêÆ¶iäwX`FqD;k7>s?RÜXâ∂óßèÑ©óÖ™ògçvlìxbáhGoL<j<Aq?HxDK|ECs98j-1h'1i(7o0:q7HÅLAyLcît|ßìÇ®õÜ©¢å≠¶ä©£Ç°õbÑtIrTFuII|CH{BKyJS}WaÖi[~fVyaWzbX{c]f`Çj^ÅiYhV|eX{eTu`MnYJlTHhQB`H<U?'?'#9$,B+6N67M6;M5N\E[bPtwlÉáàzÖryÅlw}wÑåuÇàdostÖq}âmzã^f}AH[=@G79658/INGü¶¨gq}AJY,9B-<9^nkfxzqÇävÑë`nyET[ASUBUQ<PGK\TS^XmnisnjzsmIIA5?49K=AXH4K;0E6'7* EJCLSK4@6?ODRbWeujXi_O`XVg_eyp_tmyêäÖûõ~óî;e7JtFFr??k60X$)M0L$%=)=$>P:<K8^kWP]I7D2Q]Q[i\cvbLcGF[:0H$(@D^;5P-;V3Jf@MeC7E++4#07/)/+.72N\OZqURmJF`=;O3*%+!).'5:3ORKHKB=@5<@27:/8>48=7160495:?;495051)+*')(043/32*,+132,0/160<D93;.9A4:B7*2'16/14-581&)"')$$&!!&0;+=M36F+&3!1<+ER>-;$$01:'.5%/5'47.*-& 4<-6A1#%<P7LeE6R,1M',C&8O5<S96J1;M3(% / /!0*: >Q1Pf@2K$ 8,D$=X5?]97V46U3=[57O/$(?%>h:3f-2h.1g-1g-+^&)W&2W.2'("&'"# %&.!4E3TpWNsTIsOEsL>nFI|SDtL>nD5d:6g:7g=<lB7jA>nH@nJ?kH@hF?hF=iF=iH;gF7`B7_D<dI<dJ:bG>eJ@dJ<`F:^B:_@4Y8.Q3*M/-P0$I'DE&L'-P/-K/3Q58\81Z.-\&,^#.b$-_",\",[$(Z%W&W%T%Q%Q&P$K!F ? = <#;% <&"9%!9##9$)<&-?),>$>Q1Qg@ZtGXtC_wG\rCXk>Ug=TmEWvLHi>Fj<NsGHoBIsCKwFIwHGvHPÅT?rGJzRGwQDtLL|TAoHGuNIyQCsMIwSSÅ]IySAqKFtPN|XSÄ_O{ZVaXÅaEqN@nIAoJ=kD>mC?n@;i:#M>>B%H(K!(M"4Y.EkBCiB2S4$
+!.37!C%J!'P&+V+.[20]40^7/_76d@AnM=jKErSAnQFsVBqQEtR@mLDpO?kHHmN6"
+	#5'?aH:fE>gIAjLClNEnP6^C2[=3\:4^:6^;8^96U3>V6qÄcN_?>]48]2/T+,R)1Z24^80Z64`=;iD;iB@nGEsLIvOP|XS}YFoM0W80W:0W:3W;2V<3W=2U=5X@6YA4X>/V;5\?5^@6_A6_A6_A8_D8\B4ZA3Y@3[@0W<0T8/S7-T70W<0S;2V<1U9/V90W<2Y<5\?9bD=eJEmSNq]fávjâz]|lIlX;aH1Z:0X5-S.*N(*L'!@945!865 9";!<"==:9"B*.O<?_PCcX;YO=WN8OE7MA0D8/D5+B.74,O%4^.5a./^*$PJG$J*P$J!E#H!G$L$O"O KI$N)S!(R ,V$-W%/V'3U07V7.L20N6/P3.O00N2,H/$<&346 8 :#@"&E%(I*)L,-P0.Q1-P0+P..X2N{PRTKxQ]àlñΩ™é≠•ï≤Æò∂¥ó∂±ã™¢_t{üìÜßúñµ≠Ä†ì\g]ácIwI9i5@uASáWw•Älïwnñ{gèthëq_àfZÇ_BlD;k9Dw?Du=Ew<>p33g'/g&1l,7q7B{HgõtmûÄ{¶íç≥¶à´§à®£é≠®î≥≠}úîJo]EqMGyFK~FMJN{PMvT^ÇhbÑl[~fWzbWya\~f]g\~fY|dWxcVwdSr`OlZGdPB_K5P=.J4.G12N8=YCB[F3J6@O:]fQfhSgeVlibmniYb]DSPHZZZnouáãÅèòwáñxÖòlxé2>L3?;4@26A0EOD†´±IWb7EN,;@EUTtÑÉn|ÖrÄçtÇèsÅä^ptFYW:PC=TBM_QUbYblkfkoosvQWU*7.<QB;SC5N;2D6&6)$$/!AI:PXK3=2(6)evfàòãivo[gcgxrzèà{ëèáü£°∑¬òÆª0P+<^93V./T(6\-5V+6P-1E)-?)7E4+7)EQCZgVDPB|â®∏≠UkTRkMHb=RlE0L&8X15X07Z2>\65M-@N5%.16/&,(&,(9E;PfQLeHE^@!5%"$+-*//-:;6STNKNEFI>?E;=B;381381:<7;=85:6.3/')(%'&'+*-10.0//10,.-572ORGZ^OMVE:C2=E64</.4*7=3'-!"(!'!'  +6D-CS9$14A/;J3!/*6",5"+2"+2".1&'*!"CP>@O:$,=+NiJJjCFe<Db<=X7;U8;T75L21C)"4013 7<Q0RhB8Q).G '<,D"C_9<\38[15X.Bf8-G"!&C%8d32e*+a'/e+2h..a()X")N")"	!"!" "(+:'>V@@cEHrN>nFDtLH{P<lB;l?1`47h;4e88h>7g?@pJ>jIAjJAiG@hF;dB7`@8aA7`@<cF9`E0W<6]B;_C6Z>5W<5W<2U5.O0&G(!B#$G&#G#CCCA 270U,5_/.]&/a&/a&*Z *V!'S&U%T*V!(T#N JF?866 4 7$3 24!!6##;%%='#?&8Y:KqJKyKJzHHxDHxDItF@k>CpGIxN<m@=o>CuDAsB>rACyG?sCI}MAuGGzOIyQFvPGzQ@pHM}SIyOBrHOWTÇ[KyRGuNIyQKyRIwRJxTHtSOxZPy[JsSBnK6d?3a:4c97f:9d6,S&<:="G'N)S#/[*3a08f8?h@8	%/<"G&M!(Q%+V+.[21`64b;4`<7c@?kJ>kJCnPAnOCrPApN@mLAmJ?kGCkI8T;				*?0@cK<gK@kPEmSDlQ@hM2]A1\>6_?;dB7_<8[:=[99Q1rÇeGZ:Aa8:a42[/-X+.[01^50Z60Y7:fC;iE@nIDrKHvON{TQ}YR{Y9bB/X:1X=0W<4X>3U<2U=3V>4W?2V<2V:5\?5\?7`B7`@6_A8_B7[A2X?3Y@2Z?1Y>5Y=3W;/V;0W<0S;2U=1U;-T9.U:1X;2[=7`B;cHDjQ@cKCeMOoXOqYQu[LsTAiF5]8.T-(M$'I$#B 654565"=#A*J#+K$&F!<@#*J30Q>4TG=\T9WO4NE&;2!5)#5'$6&"7$3 ?6[02^+0_+2c,6g0'V  JEE!G#G#G!F"I!IJ%P/Y'.X&+U#+R#,S&+R%&K"(G')E,+I1/M51O3.L0.L2(D-3/27 :!> $C#&H'*K,+N.+N0-P2,O1(M,.X4KxQVÄX\Öc|§äç≤°é´¶uèåjâÑùº¥î≤®Ppciã{Ñ¶òê∞•tîÖZÅdXÖ\Aq?6g0>p;I{JN}SUÅ]ZÜbTÄ\\âb[Ö]UÄU9g99k6Cv=;m22d'2f(5k-5o25o5BxGmüy{©çÅ¨ôå≤ßåØ®å¨ßç¨ßë∞´ó∂∞iäGnYFrNCrDEuEGvHYÖbRy\OrZSt_X{c]g`ÄhXx`Xxa[}e^~g]}hXweSp^LgV=XG,G4!<):$$@)-I35R<6S?,E28K8MZF[`LZ]L[[Ocf]HUK:NC6MG4MJ{êìäú¶váóé£âï≠>LY7H@:M9:L67H8ë°°CRY3EG&88Öóózâåo}àp}çm{àuÉåvàåBWR2J:5N9MbQK\R[jm^ksnxÅlz}*=9CZP:RD4L<4F8(9)&4#4A08C27B1HSE&3"IWFvÑupyt^gd`lhqÄ}Ññòåü¶ë§≥öØ¬(<#$830I,IgA">36H0BQ:-:&3>00:/DKCS]Uåóìzä1I1ZuRHi<Gh;$G-Q+4]3@f=.L*3G+\hP#*-5&1<.0<.8F5GXE->+?Q;'4#!( -/,241352553>?:LMEHIAUXQdibZ`VQYNHMF6;4:<9687-10#""#(,-)+*%'&''%43.JF=VTEEH5<D/BK88C2:E5CN=9F25C,3?+4?.*5%)4$&3!IVB%49K5)8#&3&2%.+2"/6$1:'(1'2$,BT>7K2%1I/EgB?f:Be;@`9<\7<Z8@Z=7P3-A&/A'$72&@Ic<D^7,F%A(B.C"2J&<[/;a.=e1=j3?l3/S%&
+ 2".G2.L4,Q/6e13f+.a&1d)1d)3e*.^$0X&3	"$8;(CG09>(#/(;'DbHFpJ;l?6g:7k;0d4,`/,^--a0,`00d41d91a95a>:cC:b@8`>7_=3[90W8+R3-R1-P0&I)&I)$I(!F%#F&"E$$F#"D!"@"A!$F#!E!DDC DE,U)0_+-^',]%,]%+X!&Q)Q(P)Q(P%M HD@BC;!: 6!101 1!12!6#!6#%='+G07X;IrJIwIGyFAs@BrBDsG@oEK{Q;j<=m;;k7<n99n:>rA@tDAuGBuJGwMJyOIxNFvLIyOEvI9m=;o>=q@>p?;k;9i98g91b31b37f:9f?@iGBkKEnN;gF:hC=kD?lC?iA9_6!D56;D!K%Q(T!)W&0^-6a6"D#0#7$G'L!(Q%,W*.[05b9<iBAmI<hE6b>7c?9gC?lKAoKAoK@nJ=kG=kF:fB=bA0			/C7EhT@lSAmTDnV>iN4_D4_D9dH6bA4];7^?=`@B]>:O0exXMeAAd:6_33^1.Y,2]24^8/Y5.W56_A:fE>jGBpKGuPM{VQ}ZTÄ]HtS0[=.V;0V=3W=3W=5X@3V>3U<3U:6X=6Z>6]@4]=5^<7`>8_@7[?3Z?1Y?1Y?1Y?1U;1U;1T<1T<1T>1T<0S;2V<1X=0W:1Z<6_?:aDDkN>cD2U55X87Z99^=<_>=`?7[70R-'I$&D"#A853396 =#B %G"+P'-R)$J%,O13U=BdTDdYEcYB]TAXN'=0//.+49]9=g97f27g39l4>q9<l81`,&R!IC#G!EC F"H(P-X#1](3]+6].1V-'I&&E%"A"$B(%C+)G//M51N2.K/-I0";%016!> #B#$C#'I()K(,N-,M.,M2,L4+K3'K1+T4FrOw†Äã±òé∞†ö∫Øé©¢màÅ_táßöÜ•ñ`Äq`ÖsÉ®ñê∞£[|iLuSKzL>o88j/9l4fòeHyLPSHwIN}OWÜXZàZTÇS4b18k37j/0b'1e'5m.5o2>w@Zé`t¢~{¶ãÇ®ôâÆ¶ãÆ®èØ¨ë±Æã©ßá¶°†ó`Ñv]ÑojïyHtQKwSbémdäqZ}gSt_PrZSu]Uw^[|a\z`[yaWw_]zd[xbWr_JeR5M='@-;%9"6 <#*F/2O91N:)F2.G42I7=P=CTDN\OFVK;QD5OB3MDOhdÇóúáõ¶asáoòõßøP^k8HE6K:5K43I4i}t:MK3F@8KG~êíñßÆ~éõuÖî}äöyáíVio=SP1K>.I8E\LL`W\np]nvrÄãÉîúAV[Kda>XM7OA2D4*;)'8&+:'(7$&5"IVD9E1[dQhq`ltiglh[`\LPQ^cgnxÅèûàõ¨9F2%2  .%6#_wW%-?%6E.=I3.7$19,291CHBV]VEQGFWEQjLMlBQxCBk36
+5[2/V*(K#>W9BT:ht\-6!<E4GRA@M;CP>9F5$0";G9%/$/4024324102/11/:;6HGBLME5819>7EKANTJJPF*/(/1.021(,+"!#'("&%+-,%'$)*%?<7JF=JF:>A.HP;MVA7C/S_Kgt`ScI6F+=K2?M6*7#$1'4 IVB&83E+)&3&3%1,3#/6$2;&0<(0=,,=*0G+6&@#?^<HqEFqCDk??d;<a8<^99W59'>!';7,F!OkC<X/-I )E&D(D)C-I Af3Ep8Br6>p38j+9d/-	
+ $2%9P<:ZB6Z>3]97g35h-/e)0f*5h-8j-1c&.Y$$?
+??3WYCY]DRW@(4&=#MnO8b<7h;1b53g72f5.c/-b./d0,`/6j99m?,\2&T/>jG*V2#M)%M($J%!I&"G%$J%"F"!C  BBC D"F  C@=!?#E"!E"G GEH+Y(0a*1b*)\#(Y!*Y"&S!L#K$L"JGFEE H$I#F ;+D'!7 -.+-/2"5""5"#8%'>*(D-7X9HpKFsH@qB=n?BsFEuKDuH:j:5e16g/7h0;m8:o;>s?<p?@tF?sEEtF=l>:k>7k=3g71g53h44i51f20b/2d36h77k:7k;7h9;l?@mFDpLHqOKtRJwPJtNBjE3W1%G$625: E J!M$P$S+Z&0[-4V3)A'	&'@#)I"'L!'Q#(S&+X-0]4:d>CkIAfEDlJ<eC5c?7eA:hD?mH>lG;iD:jB7f<:d>,M.	4J>FhWBnWBnU@jR7bG9dI8`F6^D6_A>eFElO?`C5L0;N0_pPH`<>a98a77b73^36a66`8/Y5+T2/X::cE<hG@nJEsNJxSN|WQ}ZP}\8eF.Y=0X>2V<4X>2U=4W?3W=6X=8Z?5Y=6Z>6]>6_=6_=6]>5\?5\A2Z@1Y?4ZA1W>2U=5X@3V>1T<1T<1T<3W=2V<1X;3\>7`@<cDFmN>cA0V1.T-)R(*S)+Q(+P'+P')N%$I!D"B @"E#C9/N,8:%D$$F!(L&0V-/U03X99\DGhWFdXNi`C]R>VI+B24!1+"$@'FjFBl>:i55f/8k3>n:Aq=Bq=8d1*T"E!E"C"F(L.T#/U$0X&5\-.U(*O&(G'#@$#=$$='#?(%C+)G//M3/K2/I0*C-3029#B#&H'(J))L++N-,M.+L1-K3,I3)I4(K3+V8AmL}•ä£∆≤ó∑™°ºµ£æ∑[ymVyeuòÄcÜnOrZbäoÉ©ê}ûã]ÄhFpJAq?7i.<n1?r9dñaMNMNGyDEx@QÅMWáURÇN4e.1b*0c(/b'5h/9p6ByBbñht¢}hìwjê{wõèà®£ê∞≠è≠´í∞Æmåá[|uImaYÄmuüáy°ádåquùÇà∞ñuòÑ]~mZ{fXydSt_Su]Uu]Xy^Vv^Uu]Wt^Ur\RnXIeO>YF6Q>0L6+G0*F-)E,)E.-J4-J4*G3(C0/G78NA:NB=ND9MB7OB6PEG`Zrääâù¶àô©hxèÅè©õßøQ]k5EE/E8.G11J46L?5K?3G;2G>FZXcvzëõèü¨sÅéJXa8LM1HB(C4*B25K>OcZbtvdu}rÇèyçòKdiGa`AXR6J?(8+ .--+,/<(NZD[cLip^pvjnsl[ZVHDCMIJMNSoyÖwáó:H/'5+!/I[A#6DT9:F.FO:BI96;4@E?Y\U_eW_mVQdFOhATtEU@Hu44]%9_,8X)8S*8K/>M6[kQAQ7+7#'0!,7B4&.#,3+4;4'.'-2.465241+-*220997783BC=;>77<59>8:?8492%*#"'!"'# " $&%')(461/1,45/:;5<>3>@3=A3DK;W^L5>+JS@_kUQ_F>N42@)M[B4@(,: .<"AQ4@P3$4)$1(6-;$".#,&-'-!,"11J,2R-GlCMvJM{LL|JAl>Aj>Bk?Di>.N'0'B!(A!Hd>RnH;Y34R,2N(.J$*H"(H*N"4\*Fu>@s8@t67n-3j)=j3(F *+)!/"3H7=YC7Y@4X<0Z67g5=s9:q7;s6<r6<r40b%.[$,P$ 	%$@>2ON<LN98=)&42O0<e=5d:7h;8h>6g:1e5-a01c22d33e27i89j;6g:&V,HxP:j@H K GE FEE!C BD G!G FDB>=!EE!G"KH(T#2c+2d)0b'(Z'Y(Z&V#P#P$P LI K!L#N&N'M#C(C"-F)72+(),/1 2"!3#$9&&=)(D-4U:CkHGtKFuIArCHyLDuF7g5-^'/_%1c(5h/7j14j05j23h45i84i54h7:n>:n>4l;1i84j97m<;q@>tC;pB7l>:mB=pE>sG>sG8h>8g=;h??iA@iADhD>`=#A7328>"G J"N#O&R)U".X(.P+.	
+
+ &:!+F%(K!%O!)T'.Y.1[35]8@aDOmSTt\FmR>jI7fB3a<3a::g@9h>7g=5f96d64Z3/9OCGiXCmUAlQ9aG8`E9aG;aJDgQAeK<^C?aF=[A*>%AO5WfGBV3+I%2X19c;5b77d94a8/Y5-V4,U73\>;gF;iEAoJGuNL{QN|UO}XHuT0[=0X=2V<2V<1X=4[@3W;5Y=1V71V74Y:5];5^<6_=4]=3\>6]B;aH3YB4ZC0V=0V=5Y?4X>2V<1U;1U92V:1U;0W:2[=5a@<eEFnL=eB.V1/Z/,Z,-]+3c/:i54c/#O%Q0\'7d-9f/<h38b4!G6Y8=9#@!$C#&H%,O.7Z94W93U<=\J<XJE_T:QG)?2%<, 5"1++E,QsRHoC>j7:i3:k4:i5?n:Bn=>h88b2(O %I&G,P"1U'4X,.Q'*L'+J()F'%B$#=$";%";%";%$='$@)(F.*K0-K1,H/$<&/37!<$C#)K*,O.-N/,M0)K2*J5,I7)H6)J7)O8;gFIwSaân¶…µî≤®ü∫≥ê´§TudDkNVÄZGqI=jATÅZz£Åtò|V{\Q|Q:i56h-<n1At;dó_QÉPMLAw=Dw<OÄHSÑLL}E9j22d)7j/7j13f.GyF[ä^y£[ÑfOz\cãsÅ£ïÉ¢úé≠®ñ≥±ã®§iàÇpîÜIp]CnSkñzsõÅmìzqó~nî}dÖt_~o`o\{iSvbTwaUx`Su\Rt\Su]NnWJjSJjRGgOAcJBbK?_G<ZB:X>8V<3Q90N6.L4(D-0"7($5+'6/'3/&2.!4.6JHlÅÑwâìãö≠~ç§|ä§Åç•íù≥dpÄ,;>.C<1I9(D.+F34M:1H6+B2(=40DB<OSSdkDSZ/??*>5'>.$;'$9&'9+APIix{qÇänâ]qxSopF`]:MK(72$"$&'(*IS;NV?HP;r}mrxnaaYVOGOE<;62îò°yÇë<J0*8!*$/?N7HV=?K5YbOek]<B6:<7=?:MSI;D3DT7H^8A\3Fg8Lx;O{>1X#=].Pg;O_:AN4*6 M]CZhQ4@,*3"/7(2:-*/(05/,1--2./32021241)+(442<<:;;98:5OUK6>38=66;503,.3,/4..3/(*'$&#$&%241?A<BE>9<314)39-8>28>2=C7aeVFM;U\J>G23A*.<#1?&=K1=J..=:K+5I&BV30**7#;I25C,)! *5I.<Z6Af;ItFFtCGwGM}M@p@HvGJuGHrDJpA3T'=\3KiC8T.!?!?"@;::C6b/<m5=p59o1:r35m,:r1Du=/R*0!0!/ (=,>WB9YB3W=2V:*T.;k9E{AIÄFGÅFC{>F|>4h(,\ 1Y',	)(#1.%@>1./*>#3W33b68i<;kA7e>4b;1b51b33d51b33b45f74e87k=<lDGzQDwL%U+/Z/AD!ECA?@#H$K"IECC=;B!G!GH"N0a*5h-/e'.b$*^ +]"*\)Y&V%U%W"T#U'V'V,Y"+V!'K"B)F'+H*(E'*B(."%))+-0 "5"#8%#:($@*/P3@hEIvMIxLGvJGvH7g3*Y"-]#-]!2d)0c(0f*.d*0g08n:8n:8n:8l;;q@9q@9sA?uD=rD9n@;pB?tHCxLEzPDyOBwKCxL@tF=nA-Z//X.1U1/N,&A"5334:B#J J#M&R)U")U"+R#.N)$
+	
+5#C$K'P$*S).V16Y9G`JaxdbiKnVBmO=lH8fA2`92_64a63b61b31a/4]1'E#;QDGhUCkQ=eJ3[@8`E<dJ>dM>aK4V=:[@DbJ9S:+=%LZAQ^B0@#*4V3:d<8e:7d;6c:2\6/Y5-T5,U78cE;hG?mIDrKKzPO~TP~WRÄ[<hG1Y>2V<2V<1X=0W<2V:1V7-T5.U63X74\:4\:5^<3\<2[=3Z?8^E4ZA2X?1W>0W</V;2V<2V<2V<0W:.U81U90W:1Z:5a@<hEBnJ?iC1[30^06f2<q9Bx<H{@At94f+;m2As6Cw9Ey;Fw?Ap<,W*BhC'J*@!"A"%D%&G(*K.<_A<_A/P5+H2*E23K=0F9!8( 7% 5".$	
+-2O1<a8=d7?i7HtABn=Dn@>e8<c7>c8.S(+N$3V,2W,1V+1T,-L*(E'+E*'A($<&$;'#:&#<&!:$%?&#?&,J0-K1,J0&B)2058#@!*I*,M.,O1,M2.L4-J6,I7/J;,G8+G8)J5;gD]âfiêu§≈≤õπØûπ≤Åúì[|iIqN>l>4d2;k9CsCZá\^á_PyQOzL@o94f+;m2@s:Fy@H{CMÄGBv8@t6Fx;Gy<Dx:@t6=o2@r7?r99l4HxFMzOR|XEnLHuT[ÜjuóÜyôéyòí}úóiàÇwòè£ïaàuEpUNwYT|aOv[V}bZ}e]~m`odÄq\{kVwfWyhWzfTwaVwbWxcMoWGiQEgNCeLCgMDfMBbJ>_D=[A:X>9W=6T:2N53M4'=(,$!bvwvàíåù≠ãö±sô{á°uòÖç§o{ã).)<80H;+F50K82M:-D2%<,$:-%:1+>:,?=)96&7/$9($:%#6""3!(6))4.ALNant\nrShiSmjAZW%33 #AI4@H3DK9zÇstwlli`md[XL@IB8èíóÜéô<L2+:#*$/6B.6A04:0572794<>;5983848?72?.AV7PlD&D4W-LtBRyJHfBg|]N\9[bCdiR-5 GN<ir_/6$6?,:E4.9+/6.=B<;@:382.3/.3/154+/.>@=<>;>@=9>8NYK3@/5=2/4--0'-0)130241241.0-.0/463?@;lofioa/6&2;*7=/<?6@C:fh[X\N48*18(9B-8E+?L0=J,HV5ET3BV37O+3K'":"4@M9)4#&1 4?/(!),@%B]:@e:>i;>l>@p@DsEFuGJyKGvH@oAHtCT}CKq6Jl9%D%A&A 'E!(H#&F C$I-W'?q6<s28n09o1:p23k,:u5Bu=1S.("*.E38U?3W;,U52[9 M$1`,Dw>EzBHFG}CF|>8l*.a0]$ A#"&&"&$6P34\73d74d:5e;6d=7e@5c>5c<4b;3a:0`84d<5h?4g>BqMHwSEuO<jC:g>@$F!-K)/!; /"A$I $K JEBA<: C!DDI+Z$5h-5k-1i*1g)/f%-a#,` *]+^+]+_!*`"*`"-a!.`#2_(+S!$I$F#)K*,O.-Q-.M-2%%)(**+,13 4 #?('H--U2BlDJwNGuG7c2,X#-Z!*Z)[ ,_$0f*3j04m63l76o<<uB?uD=sB8p?2l:7m<@vEBwICxLEzNCxL?tH=rF<qE?tHCwIFwJ4a6H 90..028? E#M$N&P(T#*V%)S#-T(*H$
+	/$B&K (M$*N(3T5EaH[p_^sdNjTGiPBkK@nJ>jF<iB:d<0]2.]/.^..^,/[*,O', 5L<DdM=dI6_A6_A7bF9aF5]C6]B3U:1O5;S=3I28J2QaGCO7$"0O08a97d98e<8e>6^9.V30U4,S42Z?9dF@lKCoKIvON{RRTTÅXPyW4]?2Y>0W<1X=1X;3X91X9/X80Y93Z;4[<9^=:_>5^>3\>3Z?7ZB2Y>1X=1X=/V;0W<0W:1U;0T:.U:-T7/V90W:2[;3`?<jFCqLDqF:h9/a,=s9H~BH~@G{=Cw7Dx8Fz:Bv8Bu:Fy>Cv=Ar;9g6MwO0X5+P/&I+'H+(I,*K09YA>^F1R7*H.'@*(@*)>+#8%"7$4#'7)G%'J"4Y.9`4>c8<a8;a8:^8?^<.L*-O,9]73Y2.T-+O+*I)#="%?&";%";%!:%#<'!:$!;"!; (B'/L0/L0,F-!;"-.6#>)F(.L0,M2+K3+H2+F3/F61E90A7);/"6* <&2W6fèmê≥õ¢¡±¶¡∫ûπ≤õè[|gV~YLzK4e.5f.9l3At<Et@FuA@o97h03e*9k0>q8<o4@r5Fx9>p1;n,=p.<o,K=TàH<n19k08k03i-;n6<n9:j83d5=mCEsOYÅipóÖrñåpìåbÉzwòèÑ®û~¢ñwôàW}dLsTKsQX}\Y|^Yyb`Äktë}cÄn[zjZzkWyi[}lXyhZ{hWwbNnWCeM@bJAcKBdKAaIA_E?[B<Y=:W;8U76P36P35L2.A+%$66Öô†{éúô™æ{â£r~òÇå•ckÇhpÖmvá)1/?>7KB0F98NA2H;';/ 2& 2&!3%$9*'<-%7'#6"$7!$6  /". ",#" &&0E<UodOhb7JH"#$*/6&JN?suhqqgkd^g^WWOBXVJbfg|Éâ8J02A*$/)1"0;+3;.*,)24359:<@?-10,2.4;34C0SkKUtK/R*5Z1Af;FhC[s[wÜsu}f}ÅjHK848'BF5gn\4;)09&6A1.9+6=6?D>5728:5/40/40043487=B>GIFFHG:A:HVE2A.$/!7=336-:=6685463794(*%)+(@@>YZURUNioajqaCJ85<,DG<OQFZ\QCE88<.8<-DL5IS8AN0ET3FU4J[9E]9A[6;V3-F&+?$,))-%4!!,?)?X8?b:Ah<;i;@oAHyJEtFPQRÉVQÇS>p?Cr<Mz9Hq/Rz>;	!@(F")I$*M%(K#&K *T$Du=?v58q-6o+7o.9o17o0:u5Ar;>	
+	*:-4P:1S8.W7-Y56c<,Z,.]'@q99o5:q7?u9Bx::o+3f#0`",P 
+
+	
+*+%$*2L12Z5,[/)Z-*Y/-[4.[40\83a<5a>2`<4b>6eA8jE5gB8gEFsREtR@nI=jC?$C#(A$#
+5'D%$I !HHFEA?<A"E!F$N 3d,6l.6n/6q17o.2j)/f%-a-a-a/c#/f%.e$0g&1e%/a&*V!$K'L#%I%+Q,0X34Z35W4/&&'*/.03 7!7! :!&D*.Q15]:=g?@mB@n?6`0+V!)T'W'Y']!+a'3j08q:9r=9r?9o>:p?AwFC{JBzI?uD8m?8mA<qECvKGzOF{OF{ODwLBuJFvLFuKCmE2V27+*-/5;@ G$N'Q(T#*V%*U'(R$+Q(.M+,		
+1&?!'E!*H&3P1E_FXo[Zo`F]MA^H?cG<eE8fA8d@9f?=g?8e:6d6/_-)Y')U$)P#!A,E/=^C4Y:4[<7`@6_A7`B;bE:^B9\>:V=9O:*<&DX=GZ>7E,#	&1S29_84_4/\57d=7_:2Z52W5.U60W<8`E>iK@lIErKKxOP}RSÄWUÅ^AmL2Z?/W<0W<0W<2V:2Y:2Y:/X82Y:5\=9^?:_@6]>3Z=3W=4W?0W<.U8.U:.U:/X:/V91U;1U;.U:/V;.U:1Z<5^@5a@;jFBrJIxJK{GDw<G}AKÅG[êXOÄIPÅII{>G{=@s:At<HzEBr>Ct=@p<HuJEoI@hE)Q/)L..O4,L4-M5/O7.O40N2)C(411#6#%6$)!"3!$<"'B#&D"*J%,O'2T/5W27[59[6:U6(E&4V59^<2Z5/T2)L+(G($>%%='";%#<&";&";%8"!;"8)C&,I--G,(@(#9"/1!;)F(-K/,M0*L1(H0*C0$9*"2',"'%"+2U4LtQÉ¶é†øØï∞©à£úháxVx_R{SJyE8g0:l/<p2<p2;n3@r7?q61c(5e+8j-<n3=o2:l-At2=n-6g%4g$;n)SÜCeòVGy:2d'/c%-c',b(.c+2g1CwFbíjcêqjî~z°è{°îzûîzûî|ùî†óÉ£òáßòrïHpNCkFSyT]Ä`Yz_\|eeÇncÄncpcÇsYyj^~oXyhXyf^~iXxaCeM>`H=_G@`H@`H?]CB_C?\@>X;=W:;U8:T76O2/F,&5" 	M_aãü®ç†±õ´¬zà¢|à¢Öè®rzè<DW-9E$170@?0D;1E:2H<,@5$5+!1&"/%/1"5 4/2!3"/&1#$4L<Ql[G\U"00
+
+8?-_`PebS^VK`ZN\YJJL><B>gqp>P69H1+8'$/!%,$'.''+*.23286.74/32/6/2:/ET?JbBFe<?c77].3V,/J+'8(8B9DJ>?C537)7;-5>+PYF9@0BH:-5**1*051/40/1.241241384154:@>:@<9>87<89@9DUC,=+)3(/4-492@C<8:502-350/2+RSM{|vGHC;<7PRMEH?ÑàySWFIK=LNAOSE9=/\^QglXYbGU`@HV5/@ GZ<JbBG`@A\;>Y82M,:3#<9/)D#"? -L*:Z56Z48a78e:DsGIzMGxKHyLPÄVTÖV?r:Cu8:i%Hu0Jv7"KA'J )N%+P'*O&,V&0_(By89u/8t,8s/7r08p1;s6=s7;g4,
+/A12P42Z78d@3a:;j>4d2-\%As65k-.f'2h*=q1;o-4g$0a 2X%	
+#-"$7#1T3/\1+Z,)X*)T)#N#*T,2^:7`>8dC4aB:iI8gG9hH3`?:gFCrP?mI?iE<74'
+1#@! EGHGFEA<CEG(S%<o7<r6<t7<t5:r12j)/h$/f#1h%2i&4k*5l+5l+3i+7h0,['#M)P$(N')R*-W/3]5:c96X5+$$')0!4! 3 7!9 #A%+N-6`8@mBCqC<j;8h60^-*T$"L#N+X!*]")_!/e)2i/0i27p;BxFCyH8n<7m<<rAG|NMÄUK~UG|REzPDwL?rG>sE@uIL|TO}VJxQ@jD=`@4Q56*.38;?B$K%O$P)U$'U&+Y+)T))O(/S/)H))?(
+%1(?#9M4M`LNcPI`LC^K=]F@dHBkK?kH=iE<fB:d>8e<8e:8f84b1-[*&R(O %H+94V51V43Z;7`@:cC:aB9^?6Y;8Y<A^B3I2/A+I[A=P4>Q30H(92V22X3*R-*R-2\84^81[50X5.V4,S62Y>=fH=iFBpKHvON|UP~YTÇ^P}\4_C-U:.T;1T<1U;4X>3W=3W;2Y:4[<:aD6]@7\=4X<3W=3V>2V<2V</V9/V9/V;0W<0S;0S;/U<.T;-U;2Z?4\A5`B:gFAqIHyJLGG}?LÇFNPÄÆáx°mïpJxGGzBBtANÄObëeIxJDtBJzHSÅSP}RMxKBkC<a@4V;,N3+M2+M21R5/M1-E+' &"-". $&)<()A')B$&A $B(F"/N,8X36X37W2/J+)F':]<:`;4Y7/R1)J+(F*%?&$='"9%"9%!9#":$#;%8#=")F*+G.)C*(>'/F, 77)C(-J.+I--N/6Y96W:*@+- %->b>MwQdãpôª™ñµ≠}ùíUxdJqRJxICr;1a%=o0As4Au79l1:m2:j.0`"6d&7g):j,<n/4g%6i'8i(2c!3f#?r-SÜC]êMJ};<p09o3;q72i/2i2:p>dón™è¶ì|¢ìÄ§ò~¢ñ†ó}ûï†ótíäpéÇjãzpì{IqNLtOPvQVyYWx]_ha~jeÇn_|jbÅq`o^}m[zjZygYzeUvaJkVAcK>^G?_G@`H>\B?\@B\?C`D@]A<Y=9V84Q32L/2F-#2ix}ïß≥ú≠øô©¿Çé®Ää•Éç¶p{è8DR$38(87-@:.B9/C81G;)=1#4*.# -#%3$/"5"60.0!0!.<S?LeP3B= '*1;"[^C\X=_YAkfPdcONRA>J>GWMKZC:I4/:*)&$*(/346<<CLI094/53284=H:O^I<U5+J!KlA2S(=\3/F)(6%-7,=C76<017+6>/>J4IW@*2#5;105/*/+(,+*.--/,02/5534635:6;@<;@<;@:7<84>5@S@+>*&0%*/(16/BE>7:3690EHAad[`aY671894886TTRGHCÉÜ{jn_fhZEG9SWH=A2DH9HP9M[:[kG?N/EX:FZ>B[=@Y;C^??Z;5P/-L*5W2?b:@c;>c:Bg<<c70W+,Q(4Z35]8:d>KxQN}SM}SI|QGwMK}LCv=<p.3eGv0@q/.^ .Y$/Y)-W'%O!!K;g4Dx:?x39w.3p*9t08s35o29q4Dw>:d4+%.F07Z:;e?;iB3c9=l>:j8/_%Ew8<s03j'5l+@t4?t04i%1b 3[&(	"$"(2Q2/X0(W)$T$)W)-X++U-)S-/X6<eG6aEBoR;gL8eH;hI6cBAnO>kJBlH;23,
+4#A"G"LKKIG+V(!LCE K .\-:o7=u8Ay<<t77o04l+6n-6n-7n-7n-:n.<p2<n33d,*X'%P#&L#,R+)R*0Y17b78c8<e;)M)/&%'*/25 ">%"C&0U3?iAArEAuDCuDCsA8h4,['&RGD*T"0_)2e,1g+4k10j0/h18n<CwFE{ICyH=rD9nBCvMK~UMÄWMÄWNÅXMÄULTFyNIvOOyUDnH"G%6-&-48=@C!H#M&P $P%S$%T&*Y--W/(P+*O-(I*-G,"3!		#(:$3D1>Q=<R=;W@=]E9`E6bA9eD9eB9eB=gC<f@<iB<i@<j<9g85c21],+S!&K;7.P/6[95];6]>6_?8`>>aC>_@5T5<V;4H/7I1?Q75I-D\<Ec?-Q+/U.,R-%K&*P+,T/0\8.Z6/Y50X6+R5-T77`B=iH=kGDrMJxSL{WO~ZTÅ`CnP0X=.T;0S;1T<3W=4V=5Y=3Z;6]>8_B6]@6[<4Y:2Y>0W<0W<0W:/V9.U8-T9.U:.T;0S;.T;/U<.T;2Z@3[@6_A<hGCqJIzMMÇLG}CQÉNbêk™éuúÅcäkIvKFvFIxNjòsw£ÇbémJwPaéclólTROzLPyMMrQ9^?8]<6[:.S12U4-O.-G*-!%-+<)*='(?%%< $=&A ,J(6U3:X61O-$A"2Q1=`?>cA6Y8.P/*I*&C'$>%";%!9##;%$:%$:%":"8&@'*F-)E.$='!7 5I0-C,(@&'A($A%)J+;^=DgF?^?.A+#.  #!&-O,aâf¶ãî∂•èØ¢ã´útöÅFpL@n=;m21c$9l*<o-=o0;o16j,7g)2`"8f(9g'8i(9j).a/b /b 1d!3h"@u/TáBQÑAEx5cóWiúdhùiTàXKQcñmx•ÜÜ≠õá´üÇ¶úÅ•õÇ£öÄ°òÉ¢öå¨°WvgTubImSKsQJtNU}XRwURuWVw\]}f\|e]}h_|hbÇmcÇp`m]|jZygZzeWxcNoZDeP?_H<\D;[C?]E>[?@]AA^B?\@=Z>9V85T53P15N12E/&	GUXõ¨∂°∞√ó¶Ωáì≠ã•Üí™Yfw9HO!42*=7-A8+?6.B7*@3-A5#4*)*&4%0!5"6.+-/-"
+1B01C3%0*&#1""3##6#&9%*='/A'8G*RX<PS6XX<fiN_gPHT@?P@<PDWdP3>-/:,*1)!& ).*.428><BHD173265?EAR^TÖòÑ6T2Cc>=X77<T2AT4*:&24;)4;+(1 4A-.@&CU=$/5<4/4.+0,*,+(*)00.01,32.43/;;99;8:<99>:7<63?3>T?4G1)4&/4-5727:3@B7`bU\_T9<3*,'1309;8;;9aa_[[YXZWEHAÉu_cRNRAW[JQXFR^FVgEThC=P4EY>CZ>D[?CZ>D[?<U83P17Y6;a:?e>BkACnCDrCBp?;g6+R&-Q+/T27\;IrPWÉ`RÇZQÅWFzLBt?@t67j':n&Bv.9n(1h%/c%.a&0b'1`)"Q9k0Bz99v08u/4q,8s38p36p5<s9IzC8_2(	(13Q5<dA=iE9gB5e=<m@:l93d,>p3G{;Cz7?v3>u1>s/2g!3e 8a'5+)6",;$%4$!-J,+T,)X*'[*+\--\.-Z10]62[9/X81Z<:bH?gOAiOBmQ>iK<gKAmLCmI544*+*H&$G!K!O$R!%U#(X&%U#<l<BqC1`4JL!9h:<s<=y=A{@9s68p38p19q28p1:p29m/;m0;h15_-*T&'P()N,-R0/U0-U09b::d<:d<:d<5]8,P,6(++.!4! 8  A"1Y4=l@BsDCwIJ~PK|O=o>7g3+\%%T JA"G,V(8g39l46m36p6;t=;r;:p<=sBF{MG|PCxL@tF?sEBvHI|QP~YQZUÉ^SÄYNxTEjH4X4>(#$,7=!E!G$K#M$N&R!$R#'V(*Y-/]61[5+S0'J)&E&)?(-
+ '6#1D.6P55S78[=:aB<eE=jI>lH@lKAmJ?kG;hA=jC;h?:d<;f;9d76`20W()N" B?)L,2W66]>6_?;bCChI=_D<Z>:U66M04H->P6=Q6,C&JeD>];7]6/X0,R-'M(-S..V10Z60\9.W5-V4,S6*Q4/X:9dF<iH?nLGvRKzVN}YRÄ\Q|^6^C/W</V;1U;2V<2V:4Y:3[95];5\=7^?4\:1X90Y90Y;1Z<1X9.U6,S4-V8,T9-S:,R9/S90T:/S93Z?2Y>8aC=iH@nIJzPSÑUOÄQYâ_y§àsõÅYÇbKuQGtIWÑ]gívuüâz°è}§ímì|só{qîsRxOLuIQzPJoMEjI?h@@i?;d81X,/T+'F$4(!#. '4#*9&&8"(<#%>!,G(6S4:S6,E('D&:Y:@cC:_=2U4*L+'F'#@$%?&";%":$%='&>(":$6 :!*D+)E.'@*$<&(;'.@*):'23'D&5X7BgEFiH?\@*;("-'*# !'A&RuW~°ãû¿ØÉ§ìpë~gãoQyTCr>6h+3f$8k(8k(7j'9m+:n.5g(/_!2b$2b$3a#/_!-`,`-d 4l%4l#>v-MÅ9PÑ<?p.UÖIlök|™ÖÄ≠ê{•çÅ©ëÑ´òÖ´ûÖ´†á™£Ö®°Ä°ö}úîÅüóÉ¢ìBdLAfE>kBBpBLwLOwRRwVSuZZzbYybUu^Tv^YybWyaWxcVwbWxcYyd\|g]}hQr]IlVAcK<^F;[D9YB;Y?=[A=[A=[?>[?=Z<6U64S43R33M2,?+%%:DMJWhtÉòìüµâò≠uÑó;KX3FD#7.(<1.B7.?5+?4%;.-B3(:.)"-2!5$8!5.--,+
+ "*/++%6#&<%%=%$<&$<&'?'-E+2I-7K0<N6>M6AP9BT<?R<;Q<8O=8P@HQ@/7(4</&+$%*$+0,/514:6.3//407<8>E>ESF}ì|GfD.N)0J- 7AT6TeE<K*2?!08!29'.:&2A,2D*8J2&1#05./4./40,1-)+(+-(0/*>;6<94=>9574=?<9>:3952>2E[D1H.4@2/5+05._bY}rOQD,/$),#&+'/40130KMJDDBHHF=?<KMHTXJ^bS\`OV]KW^LEQ9GZ:F[:DV<GYA@T;?S:;M74F0-C,0J-2V23\46`8<i@BoFBoDEuEBpAHoC@'K'0U4BiJR~[XÜaOUFwHDvA>n2/`Ew2Ex3:q-4m)5n*,c *a,` /a$:n.@y5:w16s.6s0:t76m3:q7?t<Fw@0Z*&H#0O-,N+>d?8e>:hA8h@3c9<m@<l<4c/0`&Dv7Dx6By5C{4Dy30e0d5a$%D ,);!-E%/F)':$*;5^41a1)],+\--^1.[01^54^:4];2[;2Y<4W?;^FCjOGoT@iK@iIAiD78"=$?$B%J!I'U$-])+['.`+9k88j99j;?pA?pC(W+-\0ArCB{FA|B@z@Ax><s9=s9=s9:p6>q99j36b/.X('N"(N',Q0,Q03X70U38`;>fA9c=8e>;hA?iC7_:<)&*/4(E)4\7BqEBvHG|NKÄRLT?sE?pA6h5(Y"%V&R="D%J!/X,>j9Aq?<q=AwCE{GAwE=sB>sEEzNKÄTI~PG{MDxJFvLIuQMyVUÅ]OyU3X6'I(<2)()'. >(L +Q"(R"'S"%Q %S"&T%'V(/^42`9-W1(M+%D%$<"$
+,.H-5V77\;=bC<eE;gD=kG>gG?fG@gHBgFAfE?dB8`;7`85^40Y-+R%%J'I$+M**M-4W77_=8`>;cA?dE?`C>X=AX<GY?@R8DV<CV:0H(EcA=_:6^91Y4+P.*M,.T//U00X52[9/X6.W5+R5+R5-T94\A9fG=lJCrNGwQP~YQZUÅ`FrQ/X:/V91U;2V:2W83X93Z;4\:5];5];3[92Z80Y9,X7/X8/X8/V7,S4,U5-V8-T9.Q9-Q7/S91U;1X=4[>5^@:fE?mIIwRaëkoùyz•á|§åÜÆîXÅ_?lCKxOeëntõÜ}£ñÇ¶úãØ•]qjãxjåqY|\QwRIoJFkJOwUAkCCnA@k=;f8<e=4W6"<!/"%)!.%4!(;%)@&4L2/B,(>'1K0:[<;^>6Y9,N-)H('D&"?#"<# 9#!9!!9!$<$64$<",F-*C-(?+%:'"3!-*-&>$6S5;^>CfEEfG>X? 1 #"#+C_HyöÖÇ•èwôÅcÖjQvTVSLyB@p2-`4g"6i$4g"4i%6j(=o0-_ 0`$.^"-]!(X)\-a/f"5m&8p'E}2Au+OÉ9Dv/Ky;RÄQ{ßÑâ∞õÉßôÑ•öÑ•ö~¢òÜ™†ãÆßÑ•ûzõîûñzòéaÇqCgK=gA?o?CsAJwLMuRRwXSu\Ss[Vv_Ww`Tv^Uw_Tv^Vx``ÇjXzbWw`ZzeXxcPq\LoYEgO<^F=]F9YB9Z?7X=:X>9W;>[=EbD9X95T52S42Q22J0$7$!!#$-+8CQ^duL_f5IJ-C7$;)#8)+?30B6&:."9),C3(<0. ).1"4*9"+:#%4!#2"1++(%*$!+(9')<((>'&@%!>"!;"#=$$<"-D(?O4>N49H36I57O97P:6O:2N82M:3N;28,06*8>4$+0*/4.9@807/"'!271FKDDOA2E1MgJ9Y4*J%2M.6<L2WfI<L(1?-77@+0;*.;)8G2/<('/$-2+-2,,1+(-'&+$.1(46+TPGXUL[\V05/5:45;7/830=3QgP1H.4A/GO@Çà|X[R,/&25,:=4(+$-/*24/BD?LNI9;6NQJMRKFI@X[PSWISWHOVD3:*6?,LZA?O4=L59F27C/6B.4A/,;(*=)/G-9[87`85_75b;AjHEoKJtNGpFMtHC!G (P+,V2BnJYábVÑ]RTQPCn86b%Dr2Du4<p.<s0;s,4l%.f.e!1e#8o,E|8Az59t0;v47o28o5<q9>s;Ex@?o;;i:@n@@n@9h::k<;l=5f94e8<k?=j?6a3 J@m2?r0>v/@z0E}46k#.a2^!,M" '%9(C 2P,4O.0
+4/O(:a4Dp?1_0.^.._2-^1+X-(U*+U-)S-*R/)N-'J*'J,.R68\@>eF<dA:c;C"GDD%O! P&['7l6:o93h20b/9j=>nD9lA@qD>oB:i=BqCFxGF|JDzFCyEBwABwADw?Ct=;k74b30Y-,R+)M)(N)*O-/T31V56[:5]:>fC>fC<fB<hD>jF<hD<dA8')*,#?&:]=FsJGwMOUK~SFyN:n@@sH:n@2f5'\&(Y!)X"G$H"(J'+J(0R/@d>KuMIxLEvGF|KG}LAyHAyJ@xKGRI~RH{PK{SMyVLuSMwSRzU*L+77553-)*6'G /T(*V%&U!%U!'W%(X(*Y+3b60]4(P+%G&": *	 (9'4L64P72S8=_D:cC:cA:_@7X=3O81J4*C-#?&%D%/S//X0,U)*Q$'L *M%+M*'I(0S27]84\73[62X3(E'!8#4!?N;JYBK[AHX=LaBB]:9[68^93[8,Q/+N.)K*-P//T32Z80Y7,U3,S6+R5,S8/V;8cE;hGAoKFtOL{QN}STÄ\U~\6]>1V70T81U94Y:5Z;2Y:2Y:4];4^:3[92Z80Y9-V60W81X93X70U4/W5.S4/Q8/Q8.P7-Q70T:0W:4[<5^>8dC<iHGtSbèrÄ™íÄßîjê{vûÑQ~W7h;?oEVÑ`póÇmëÉpëÜÖ¶õKm_fàxzõàeÜqVx`FhOAhMPyYAkE=jABqEGvLS^]ÑgIjO#=$)"'*&4#+<))8%2D.3M27V7<]>7Z:.M-*G('D&#="":"7! 8"7"8!55&=#(@($<&4!.)),$7!,B+/I05S9B`DEbF;S;,
+	0 `}gníxgèmPyQFp@LyBDq66g&/`0c 0c2e 5h#5h%6g&-]!+]")[ (Z'Y+\/b 4i%6k%Au-MÅ7Au+PÑ9Hz1J{9KzCoús~¶éÅ•óÑ•úÜ•ùÑ•ûà©¢èØ™|ùñUvmpíÑnêÄbÖqGnQ<f@:i=?n@JwNIqOJnRNrXY{bVx`ZzcZzeWxcWyaQs[Y{cZzcUu^Ww`Tv^LoYHkUFiQDfN?_H;[C:\A:]?8Y<7X9;Z;BaB?\>9X92U42U41S2/L00$*%$41$43$73/D;1H8+E,$<"%:')>-,@43$!8&-D2+B2 5&-/.*("$,!$%''&#&$2!':$&>&%=%&>('?'#=$%='$<$'9!9E-HJ4JH3BD.>G27M86R<2M:2M:2N88Q<+.%25,?B7!$$)"5<4>H=-8*!( 5<43;0FSBLeH=[9;[4@`9=X5(?"3C)XfL->5F"/>!.:",7&%0 4A/#.(.$,.)-2,271(/'(-&28.>?7PPHÇÇzDG@493=D=8?8-61)7*YpV6M0fu^q}i<E417).4(<?6=@7/2+/2+CF?LOH7:3MRKsyoCI?69.SUJOSDMQ@@G5CG8EL<HQ><J3CP<;H4EQ=*%2!/=,->,*@)?^?CgC>fA;eA<cDElMHpNGmHEkB/U,@i?DnFFpH@mDBqGLyPJsK8^5/S'Hn=S{GO|CGy<H|:?w.7o&4l%3k$3k$=u.Bz3@x1>w2;v48p39p6@u=@u?BwA;p:>s??sB?t@<q=<q=;p<:l;8j97f:7d93Y0>3^(?o1:q-:t*@z09q(-`1] 0Q"/	2!8#A/O&4W/="	01T*=g5<h38d1,S&*P)-U0,T1*S+(Q)'O*$J%#F%#E$!C""D#!B#"E$+Q,0V/*P)DHGJ/],+`,0f25k75k71f2.`/8h@AqK<oF?oEBrH?nB@qBFwHG{JEyHEwDCuBDtDCqB9g8/Z,*U**R-.S1/T3)Q/,T2/W55];5]:;c@@hF<dB@iG>jF>jF?kG7_:0(',/%H*@jFIyOJ}RN~VL|TAtI@sHFyP:mB?sC*_+)\#*[#*X''P&)K*+H*-J,0O0?bACmGGvLGwMKQKQG|PF{OGzQK~UO}VQ~WFnLOtSMrPCiD-L*77 ;!:5/.-2;%H 'Q#&T#*X'(V%*X),Z,0Z2(P+#H&;#
+!&#%,-;!2U72Z7/W4)L,4*($#8>`?8a94]10W*-R&,Q(*N()M')M'.S*-T(&O#%K"7*$0C/L^FM]CJY<atT@[86X35[60X5*O..Q1/P10Q20S33X70X6,T2-T5+R5-Q7-T91\>:fE?kHDqJHwMM|RRÄYTÄ\HpN1V71V70U63X93X91X92Y:5_;5_;4\:3[92Y:.W7/V7/V70U62W62W8/R40Q6/O7/Q8/S91U;1X;2[;4]=5a@=jIFsTjïzÅ®ïsòÜNv\KwV?mF@pFXàbiñwiëyTygW|koìÖgãqïâ|ûêjä{XweNoZLrYTaWÄ`JvSXÑaeêr_âqièzcÖm;W@-"%!-"0$3 1E,0J-4S38Y:6W80M/,F))C&#="":"!9! 8"7!9": #<":  8 2+)'',&9#'=&%?&!=&,H1=W>7M8'
+
+
+	9R=gälkìnP{M>k4;i+;i+3a!'W)Z.a,_0c 0c!2b$+[)X!)Z")[ ,\ /_!2e#8k)9n*Fx3J|39m"G{0Ey.?s+Dt6\äYgênwùàÅ£ïÖ¶ùá¶ûÅ†òrëânèÜfä~pîÜtñàzúãqò}gêpVÑ_FtMFrOClLDkNImSRv\Ux`Tu`VwbSt_Qs[JlTMoVTt]PpYMoWKnVHkSGjREhPCgMCeL<^C:_@;`A9Z=6W8:Y:<[<>[=9X93V64W62U40R1+E*1+ 0%&6,&8,#8'-E/.G**C%": &<'&;*."9%-D0)>/4%/"0*
+
+))& *!-+!4'?%&@#%?&#<&";%8"!:$#9");#;E-HG2ID.CE-;E-7M63O92O;4Q=7P:;T>),#+.#04&$'$)"-4,/;-3@/*7&#/!%1#;L9HaC-K%@_6Dc:Jf=2K$1D&N^A;O*.D1F' 2*7%'2":E5%- -2+.0+160181',%*/(2719>8rtoÑâÉ).*;A=DIEX_X_i`2@/XoRLdBL\??L2<F.?H3;D3GM?CI=BH<[aUgmc]`YQTMdg^be\58/:=2acVVZIEJ6]eNW^LEL<HN@BM<CR=?Q9?Q9,&&4%/=,)<(2J4EaHLmNJoNHmNAfG>cD=`@BfBCiBDmCBoDGtIJxJCsC0^0!E!4&?"KfGXxSUzNR}HK{=>v/8r(2k$/g 0e4i!6n%7o(:s,@y5:p2:q7By@@w@>s=>s?9o=<r@=s?<s<>u>:q8<q96h37g72]2C;"I;k16o+5q)<x0=v/.c/]0U!'F$@#>!A+N$0U)&I*)L$6b/>q81b*>h6=%>!%;&#;%*G+%D%>93.17"D,Q(2W,#H?"F -X+.\-)Y'2d12f52h62h62f53e41b3:jBBtNBrL=mE?oG>nD<kABqEGxIDtDBp?@k=8a97]80Y1-W/-W1.X41Z86_?,T20X66^;6`<8a?BjH?fG?gEFnLBlH?kG=jC'Q)<4,-:!<eCIyQMÄWK~UOYDtN@pHM}U8jDGzQIzM-_,*]$-`'/`)+V(*M,,J.*I*,K,-P02W6<fBKuQR~[O{XN|WTÇ]EqMMwQQ{UU{V1P1/L.0O/$F#<;==7669957"=@"G,Q&.U)/U,,R+(K*B"#D'8
+/": )5/N,'F&(
+7&>&$
+%
+-<'M(/Z/2]22[3 C")  9 7Z:8^71Z0-T((M"'M$)O&)P$+Q"+Q"*P!%L"G= =;,F+D]@L`DM\=izXD_<7Y42Z5.V1+P.-R00S3/R2/T50U64Y8-U3+R3)R4,S8+R7-V85a@<hECoKFtMJxQQZUÉ_T}]4[<.U6/W50X60X60X63[86^;6^;6[:4\:5];0X6/X8.W7/V73X93W;1T62S82S80R7-Q5/S7/V94[>4]=4a@<iHHuVqúÄtúÑU}bJwP;j>;j@bêkkìxgèt[Ñf?jLItYpöÜz†ïwöìyöèeÖvYzgSv`FnTR}bZÇgRx_kë|oîÉdàz_ÅsiàxNfV#1")(/$;!&A",L'3S.3R2.K--G,-E++D'&?"$<"":  :!#="$>#%?"'A$%?"-G,+E,#:&1,+-%8$$:%%='(A,*C.0G3-?/ !! 3 OlPV|SKwD;h-8d'7e'0^ $T%U)Y*[)Y-]!.["*Y"*Y#*Y#+Z$.]&2b&7i*=p.8m)Hz5J|3;p"KÅ3OÖ98n#9l'Gy:N~LVÇ^févróÜwôãaÅtgâ{wõçÄ§òÄ°ò}úîyôémè~nî}oó}UÄdKsXEmRElQGnSHnUSy`VycNq[NqYNrXImSImQImSJnTFmRElQGkQDhNCjOAhMBfL>bF;`A;`A<]@6W:6W:9Z=:Y::Y:6W86W84V51S22O1(@((%'- #4$&9%*A%,E'(A#(?%4-$<&.D/'9)1!0!/&(")--.3 9!;$<$#=$ <#:!:!#=$(?%9I/AK2AJ/;I/:N37O73O81O72P87P::T;&) DG>JN@03(6;45<44@25C27F10B,&7$F]C?[5'C(D9U-?Z1>W0EX:P`CPd?*C)A1H++=%,;&6A0'/".3-,1-/4..5.#(!271=B><A=fkg7=93957<6382492:B5ft]e{WG`9>O-JW;cmU|ÖpV]MTZL=C706(LUDDK;GJ?KNElodVYNAD;;>3HL=MQ@S[FRYGW^NHNBFLBBM?EWA@T9<P7/B,4B14B30>--;*->.:O<>X??`A<_?9^=4W70S34U6<_>?h@@mBFsHJxJK{I@n?"F 
+$19L8=U;6U3<c4Hu<Cx49s)/h!/g 7l$.c0h0h/g 7n*;r1?u9?v==s?<q=<p?=sA8n<<r@<r>:q8<q9<r8;n6;i8,U)A>C/^(;q37s-7s+=v/2g!,]3Z#-N)H"@$D'L!.U(*Q" F1[)8k29o14f+Dl:3 /!(97/Q.>33=!D(K!%JC>:D1\/4d45g69k:6j:5i;7k=2f83b68g=<kGApNEsOAoK>lG@nG>mCBqEBqC<j;5`2B9)J-5X83[90Y71]:2^=8aA4[<3[9<eC9b@@iGBkI?fGDkLEmKBkIEoK=jC7a93Y4+H*+/4R8JvROÇYPÇ\PÇ\M}W?oINÄZ@rL<kGSÉ]CrF.^./b*1d+.a).\+,R-*M-*K,-N/0S52W63X73[9BgF:b@GqMT|Y2X33W3EgDKjH2K-'@"#A @!C#E #C:;<@"A :!42!9!> @"E!D%I#'K'"E$$E&&D( <#2.M+2T/;2W.8_3.U)'M&7]66X56(G%7Y6:`;9c;8c67e79c;7]8+J+1*":"2Q28[:2[3*S)*P'(N%*P''P$'N'O,R!&J$HCA%G$*L+1P1:U6BZ:M^<m~\A]77Y43Y4)Q,(P-0U30U4.S2+P1*O01V70U6,S4+R3,S6*Q4,S61Z::cA?kGBoHIwPN|WSÅ]WÉbFoO.U6.V42Z81Y72Z73[86^;8`=5]:3[91Y70X6/V7/V73Z=7[?7[?2T91T61T6/Q6/Q60T81X97^A3\<5a>;iEGtSgîsdçoEoK?o?8j7@oElòumîwPwZMwS@lHWÑerûÖtöç~¢ñyõã[|gJnTCjM9dFBmOEmROw]Lr]X}laÉujä}pä}BVJ/;/$/!!!#%#4"$:#*E&(H#*M%.Q).L*'D%&>$$<"#<!;!; "<!< !>"$A#$A##@")F*0L34P73O9.G2*A-(>)%;&*@+&>($='*C.0I6+B0"2%#)2H1UySJvC>j/0\.\*W%R&S(U)V.["0]&*W (T%T %T )U")U *Z 4d(At27j'Dv/>r(7m!LÇ4Tä?@v+H|2QÑ?RÑGRÇRaälqñÑyõãjå~sïÖ{üë~¢òá®ü|öí]}pLr[JrXRz`Rz`Mu[Nv\JqVKsXFnTHpXV|eOrZLpVJnTGnQHoRNuZHoTDkPFmREiOGkQGkQCjOBiL?fI?dE=`B>_B:[>9Z=9Z;:Y:9Z;9Z;6W85V72T33P20H.!2" %-#7+B%+B%&= 2,'=&(>)"5"/ ."$$)"(/)-/227 9#;!#=" =!!>""?#'A&)A'2I-:M1:M/7N19R59S89U<:V==Y@?[BA[@;<6`aYLOD;>5*,'+0*+3(8E3ET=5I-=V8<Z64S)2Q%(B.F&5J)>Q3FT:O^AZkG8O%;V-:Y09S.3J-2?+*2%05/273493<A:+0)381WYT495-2.495FKDTWN]`Ugk\goZ^kMVlEC\2<M+R_E;B0BH:GJ?IOENTHgo`S_IKU=X_MFJ;bfX=@58>4EKAFL>CI;CI;/5)?A<EJD7>6?K=EVC=T:?U>7J49G67C58F5*8')'5&+A,/L.2V2/U.,P*(J''F'6W8:b?BlFIsOKxQJyKJxICm= C(&$3K12W.;g2K=<t+3m!6p$<t)5m"*d*b-e0g#7n-?u99p77m99m<;o?9m?8l>9m<9n:=r><n9;n66i17f22\.$F!?%K$0[-:l19p-3k$9q(9n&-^/W"6
+ >"@#F(M!-T%2Z(.Y#2b(:n02f&>n2<b3'!&+B&+K&)P$:d6JK.Z).Z)!L I??;?$M!-[-6e76g86j<9lA8kB8h@:hC8d@;gD@mNAnQDoSIrT@lK=iEAnG=jA;h=8f86a4&L#./0N67Y>7`@7c@9bB8aA7^?:aB<eE?hHDmM>gGDkLDkL@gHBkKGpNClJ>hD:]='?'!-LhOQ}ZRÑ^QÅ[M}W@oKGyTFzT:nHO~\IwRErG/_/2d/1d,1c.2b00Y1+P.-R01V46[:5Z97\:0V1,P,+O+0V/=a;+M(+I%0K*2J*/D%$<%C$F!(J%%G"<;C#J#G!;21!23!> @@ B&J$+Q*'M((N)-Q-&J&9/R*2Y,1[+0Z*4^.5_14_17b4:e79d6:d6;f9?j?=jA:g@8e<7d;8b<7a;4\73Y45W46X36\5/X.(Q')R()R((N%+Q('N"%L%K&J#D??#C&H%0R14U66U6<U7L]=sÑb@Z55X02X1*R-,T1,T20X5+S1*O0'L-+P12W81V7.S4.S4,P4,P4,S66]@=eCAiDFpJIwRN|WR~[R~]3\</V72Z83X73X71Y78_@6_=3]92Z71Y6/W4.V40U65Y=5Y=2W81V7/S7.P51S86X=5X:1V51X93[97`><hDFtOTÇ]SÄYGtI7i46h3ApBXÖ\_âeLvPErG?lCMyVXÉg]ÑoqóÇ\ÄdGlJ:b=8b:/\3,Z33_;4`=:fEHqSLpVQnXI^O'4*'$#! !%-&<%)D%'G"&I!(K#%G"&D""? !:89 =!@!$C$ ? >#@"$A##A%/M3>\D9V@5R<7T>3O9/H3*C-/H20I3(D.(C0.G4*A/1! 
++8U6Bi<<g/-[%Q&Q%P$O&Q-X".V!,W"+V!,X#'V"&T##O!M!P+[Gx6Hz3I{44h3iF|1NÇ8Cw-Gy0Ey1H{8XàTpô{|°ê~¢ñÜßû†ózõí†ôkäÇqíÅCjO?kGEsLLuSJqTKrUKrUNv[Nv\Lt\EmUEmUFlSIpUGnQHlRImSMpXMpXEhPHkSHkSKnVQu[EiOEiMGkOBeG?bDCdG>_@9\<;^>;\=:[<<^=8[:5V74U63P24L2->+(!#+&:!(?"&= 61%;$"5!2.' &(+"!!!% 1"8#0,0434!:#<'@#&@#(B%(B%(B%(B%+E(0I+1J,/I,/I,.H-.J10M17T8DaE;X:DG>SVM690@C:#% &(#4:0CK<ES<%8-F&?[5Bb3:Z++E '?(=8K-9I.8G*fuTF[49T);W.0L$5N.CP<2:-4936;5?D=:@639/17-X[T-/*(-)7<6JPDLPAPTEX]IafO=H(Mb;DZ3<K,EO7>D636-8;2AD;=C94<-MYCPZBT\GinZMTB/8',7',9(9F47B13;.*2'#062BLAESB<O;;Q:EXB9L88F72@14B3-;*#+2J07V40V-(Q%,Q(?1:V=>aA=eB?iECpIEtJIyIL{G@e9( ;Q:9[86b1Cu6F~7=u*;u(9s&6p$4n"+e)a/d 7k+Aw;7l47l8:n=7k;7k=5i96j93h43e01c.-`(0a*2^+)P#!C!C +Q,2[15d.9k,6k'6n%>s+0c .Y#8	 >!?$G*O#,S$-X#.["6h+8l,6j(@p20X$$#5.L(,S$*V#*[$$W1d+Cv=*]%*Z& K<>?'M$0[.5c56e97h;3f;5h?<nH=lH;iE>jI<hG@mPEpUGoUIqWIqV@lKAmI@mD:g>;h=9d77`6#E$&
+5;[C=dE@iI=fF?hH5\??fI>eHDmOBkMAjJElM?fGClLFoOEnNBkK;cA-N1#+B^ES|ZRÇ\N~XFuQBqOPÇ_:nHH|XO|[GsPHwM4c56h52d/3e02b0+X-*T..V31Y76^<5]:6^97]6/T++P%)N#,O%/O&2P*-E#%:2E',D".L&0S)&K AA#H$N ,U)2X/?2.-/ :"A@C&O%.W+*U*,U)3\0/Y+-W)2\,2^)2^)4`+2^+1],0\+2a-4c/5d07g56f6;l?:jB=kD7e@5b;5b;6`:1^52]24]13\0-V*+T(+V)+V+*S+$M%*P'&M #J!G"C=="@'B,J(1S21T47X99T5M`B^qQ>Z45X00V/,T/,T1/W4-W3(P-*O.+N0,O12U70U40U4.S4-R3-Q7-Q72V:9`A>fCBlFGsOLzUP|YUÅ^EnN/X82Z84Y84Y81Y74[<5^>3]93]93[81Y7/T3/T5.R6/S7/T5.S4.R6.P5/Q61T62U70U40U40X66`<;hAAoHKzPGvH?o=5g28j5EuEJxJJwLAoA9g86d6<iB>jGIrTNwWEnF:e80^/*Z*)X,)Y/5c>9gCHvQIuQBhC3R34!$"&$$*(&!$-";$B &F$D!A"A#A"=548 =*I*2S61R5)J-+H,$B&@#)J/2R:5U>8XA=]F<\G5R<.J3$@'&B)(D-,H2*C0*A/&;* 1!		
+(/G-@c;;a./X #K%M$L'O,T *R-S -U!,W"/[(/[*.\-(V',Z)0_+7g-Ev4K}6I{47k!8n#F|1I}5Hz3Fx/?s)Gz5OÅFXÑacäutòä£ôÖ¶üvïè}úîY{kIpU?iC?n@FuGMwQLtRJqRIpSNuZLtZKs[DnVCkQ@hNAiNDkNKrUMqWFiQEhPEhPBeMEhPEgNGkQEiMCgKGlMChIAdF?bD<_?<_?>a@=^?:[<;^=9\;5W63R34Q34N14H/&5"$*1!5#:56!5 3 2-"%$"*%2!#1 "3!$5#&9%'=($:%1/0275!8!9$= &?"&@#%?""<!#="%?"&@#&@#'A$*D)*D+,F-0J/1L-4M&7N$FL@IOC-3)DIB#&(+$>A8:@24=,-9%5E+CX7dÅUTqA$=0I"4N'6P+@U4?R2SfF]pPi}Z9O+6P-)@$6A16;4CHBGID:?839-4<-9A2KQG"%',(:?8AH8NVAU]HS[D=E.;E*K\:HY7XbIV]KHK@QTKJKC58/)/%)/#BJ;LSAQVBdlUBL34B(,@%1H.8Q47N4%4!$*1=1@N=@Q>8I6:M9CTA6G5:H;=J@>L=4E2!5/J'6[0/Y++V(-V*0U,8(1C3JgKJmLLvRKxQDsIFuIJxILsG!9 ">V>>b>8c52_(I{<Bz1;u)7o$5o#:t(9s'-e+`9k,?q66g0:l74f31c0-_.(\+'\(&[%)\$+^%,b&._'%Q B!A$C!.Q0.T-1[+4a*6i'5j"9q(5j&,\ @:!?'J )P!+U#(T*Z 5g*3g'8l*<q-/\!45=&L&R&X*]"-c'3j0:q7+c&2e,E?DB*S)3^33`52a76f<7j?4g>4f@;jH;hG9dF>iKAnQBmRIqYIqYMu[JrWBnKDpL@oE<k?<j<;f96_3@	*5U=AeI@iI?hH<eE*S5>eJ?fKCjO<dIBkM?hJDmOElMDkL@iK@gH/R2+@\ES|ZPÄZP[BqMN}[IxV>pMUÑbDqRKxWEuO4h:3h45j20e-4f17f:&S,+T2/X83\:5_96_76_31X)*Q"*P!,R#1U)4T+"<10H&1M'2Q',P"!GE"J)S!&R!(S%5`55]8!B%2)+6<?H)W&(X$*Y#(W!/[&+W"+Z&/^*-\&,[%,[%2^+-Y(/[*2^-/],0^-4d4;oA=pE8jD:jD8gC6d?6c<4a:2\4/Z/-X+)T'-X+-X+/X,*S)+Q*&L%*O&%J#HE=<#?&@0C%;O37V71T46Y98U6LaBF[:6V1/U.*P++S.0X5/W4+U1,T1-P/*K,'H+3T72U50U4.S4.S4-Q7.R8*Q44[<:b@<eC@lHHvQMyVR~[R{[3\<1Y71Y71Y61Y73[94\:2\81[74];3Z;/T5/T50R7/S7/T5.S4/R4.Q3.Q3/T51T60U60U43[94^:;hA>mC<k=<l:5e16f2<l:HxHDtDFtCAp<5e17e4;i:8f86c86d62b02b.2d13g70c89kFSÄcHsWDpM<iB8c89]7#;#&- ,/"#1"". #!-#<$B !? >!<!;#<7357(B'3Q7=[C?_GBbKDdM>^F2T9*M/.P54V=:\D:\D5VA*J3)J/"@$< "<!*D+*C-'@-,C1'<++			
+						#(!#/!/B,;V7+J!/P#$H$H+Q",R#)Q(R -U#+S!0X&/Y)/Z--[-/]/3a2FtEGv@Cq1Ds-<n'8l$?t,Dy1Dw2Fz2Bt+9m#@t,G{;M|PKvXaàuzõêÇ°õzôìVvgJqV>kB=m;BrBHvHLvPKrSMqUMqWKrWJrXMu]Lt\JrXAiO?gL>gIElODkNDkNBiNElQ@gLDhNCgKEhJChI?dEAhI@gHChI@eF=`B?bB@cC?`A<]>:\;9[:8W76U52O02O01K.-D*( %++#7#:40 2 2-,"3 #4" 3  1"3 #6 "8!!7"#9$&<'(>)%:'0,.-2223467!977 8 !9! 8$= )A'*B*,D,0H.1G#3AXd$RZMAI</4-@E>*-&,/&6908;028,9B1>K7@U6^{OLi;0I!C\57Q*7Q*Kd=RhDIY>BP6>M.CR33H'5G-+6&8=638127006,5=.6A09B1/5)),#).'@H;WcMKX>LV>NV?@H3GP;TbHUbHOVDAE7=@5AD946++.#.4(3;.8A04@,KT?gtZ;J->Q1AZ:2M.4R00M.+?&5G16I5EXD=P<7H56D38F5=I;)5)#.&4?7?M@7J65P/9]13_,-^',\*/Z,3U05'-8P8QrSV~YQ~UN}SN{PMxKEiC3$<T<>b><e91]*Bt7H}7@x-=u*=w+>{-?y,<t)3h 2g#/a"+\$2c,+\%'X!%W"&X#$Y#(]%-`(2e,2h.0c+&Q#"I%J!#H+Q*.T+(R$'S0`$7j'5m&:o+.^ B1 @(K!,S$+W$'S.]&4f)1e%7n*Av03c%;<B$N$T%Y,b$/g*2i/5l20h+.d*#T2`/(T#E&Q$/Z/0]42_83a:5e=;kC:jD6cB7dE8cE<gKAmREqXEoWJrZLt\Nv\HtSDpMGtMApF=l@<k=9g84_4C"#E*AeI@gH>fD5^<-T7<cHBhO?eLCjOAiNEmREnP?hJAjJ@iK@eF2P4-
+		*TmWSz[QZKzVHzURÅ_?nLJyWO~\GtUTÅ`L|V5i;.c/4i1.c+8m7FwH-\2%N,-V43]95_94]39`39_.0V#1U%3W)3Y*6Z.+G!;3O'3O&,K!+L(N&Q*U (T!#Q $R$(U*3]78`>*K.0)/;*O$(T#*Y#+\$&W(X,Y"%T*Y#,]&+Z$)X"/^(.Z')S#0Z*-X*)W('W'3d5<lB@sJ>mI;jF9hD4b=3`90]4.[0.Y.,W,,W,/Z//Z/.W-)R(-S,&L%+Q*)N%%JD; >&A$</?%;O4:Y:1V53V65R3`uTJ`<5U0-S,,R-.V3/W4,T1-U2,T1,O.,M.'H+0Q44W71V50U6/S7.R8-Q7,P4/T56]>6_=7c?AmIIuQLxUR{[BkM0W81Y71Y66^;:b@4\:3]92\84];1Z8/V74Y:6X=2T9.S4/T5/R4/R4.Q30S5/R41T6/W52\82_89f=?nB@p@2b.0`,6f4=m;Br@=m;Cr><k58i25d04c/0^-.^,3c12b03e49m?H{RWàhbêtkïjíxZÜc?iA8a58[3$;!$+9,+9,* .! , !% 3&?""=!<965!8623!:8!=$%F+(H01S:EhPGkQEiMAfG3X95Z;?fIFjP>aI6X?2S6,K,)F($>!&@%(B)$@*,E0+B0!3#
+	(*%)0('3%/A+)@$4*F *F+J!-M$*O#(P&P'O(P,S$)S%+T(.Y.1_18h8?m<Fu>Ky94c3e2f5k G|4I}5Ey1<p&>r(Aw,H|<aêbrùpïÉrìàrëãnçÖEhT?fG<j<@p>FqDIsKPxUKrSOsYMqWKrWIpUIoVMu]KsYEmS?gL>fK@gJAhICjMDkN@gL@gLCjOAeI>aC@eD>fD?gEAhI?fI@gJ?dE?dCAdD@cC?bB9\<9Z;7V64S32Q//N,/M+/I,)<&'%+,!7 66 411#5#6 1012 6! 6744 20,*+-+.,..224535446!9%=#$<$'=&(?%0AKQ	íï<CI?>C<381KPI/2)12*14+39/.6)8E4;M56O/`VKj@;U0,D$&>6N,PiB=Q.=K1DN6AK2\iM4C$BQ43?)4=,5=.4<-5=.4?./;'3<)'-;A5BJ;DQ=QdHDW9AO5GP;>D6GOB^iXLWFY_SkncUYK46(<@2<C32;*7D03B+*<"?R6ShI;S14N+&?#>;Y7;Z8D_>=Z;HgG9V81G0/=,)4&-5*/4-$ '-)(2)/7W27a12c,+`(0c+2`1:Y7,!,,38Y:DjEIsKJuJ>g=8]41P./C* 8P8@d@=h:<k5>p3F{7G6Bz/?y,<y,<y+=x(;u(7q%.f&Z&Z,^#/a&$W'Z!+^%,_',['5e3@r??q>EuCCq@Eq@@l;5c2-Y(+U#1[)2^)3c)5h&9l)5h&!N7A+P$-W',X%)X".]&:l10d"7n*Cx0$R<>E#O%V$Z-e(*d'0g-1h.1g-8k2;n6<m6-^'.])"M (Q)-U0/Y52^:6d?9eB>jG;hG7dE7bD;fJ>jQIu\Jv]GsZKw^IvYLwYHtQEqMGtM=mE:j@;j>9f;7a9"J'3V6@cC9^=4\:1U9?cIBeM?eL@gLFmRBjO=eJAiNBkMAjJAdF3P4-
+
+- C[EKpQQ}ZIySNÄZH|V?sML~YCrPLyXUÉ_IxN8i:0b/5h01f.6h3;k;)V+#L$*R-1Y45[48]2Cd7Aa04T#4S)6W,5Y+3W'2S&2Q%2O#*G%@0O#2Z(.]))W&&V&&U''V*&S*+X13]9>cA,M.0,:,S&*V#*Y#(W!&U*Y")U %T+Z$'X!(W#,X%/[((R")S%(R$&Q$&T&)Z+1b5=kD@lH<jF9gC9gC5c>2_8,Y0(U*+X-1^71^7,Y01[3,U--S,-V.&O'/W2-S,&M!D<!?#:'%6N87Z<3Z;2U7:W8tàeVjE5S-+O+-R0/T3.S2/W5-U2,T1/T3.S4,M0*K.2U51V5.U6+R5.R8/Q8/P5-N12U74Y83]7:d>BlHHqOJvULuW5\=1Y72Z76^;;cA5];4^:/\5.X4/Y5-U32W83U:4V;/S7/S7,N3/Q6.P50Q40Q41T4/W52\84a:;h=:h97f20`,2b.4f3=m;?o=;j6@o;4c/5d0/^*,['.^,0`0<k?M{TO|[\âlaçvqöàoïÜmíÅZÄiLvR@i?9^3*H&'
+ &2(".$$(( .$:#$;";$>#+E,6 7#7 4125N09 = A"D#+S1@iIMvVdãnbâjOyUNxTWÅ]ZÉaSz[PuVBeE)H&"@!?#>'A$*D+,E0.G4'<-$		
+		
+"&3"(9&3 9(A!+C!,F#)G!&J'O%O&P%O$N!K&M!'P$-X*Ap:6f,Ar1M:3e/a2f5k@v*J~4Au+=q&Bx,=s(I{>lôr}•çá©õ{öívïçuïà_ÇnGnS=e@EoGMrPNsRNuVKrUOsYNrXJqVFmRCiPFlUFnTFnSDlRCjO>eH=dGFjPFjPAeK?fKCjO<cH=bCAfG?gE>eF?hJ?hJ@iK>gG@hFAfEBgHAeI:^B7Z<5V75T42Q/,N+/N,-L*.H+%=#4$=(-H53P<+G1'C-8"%?&#;!3...,--.-..+,+)'&')(*(*+/13515536!9!$<$#;%%;$(;/<feûó#KQG<A:/4.<A;36/14+692/4-6>3AN<CW<?X8Hd>>Z45L//F*5L0>W9Ic>0H$0>%ZfP:G-HW8DS23B#=J0?M6;I27F/(:"+=#.@&<L2,8$)2!9F2>N4>V6EZ;GU;BN819*:B5LWG?J<HPEbe\xzmy{mGK:LSA<J17J.9Q16P-<V1A[6?[3<Z4D_<@^:7V46X31S.Ae?6Z6%B$)<(%1#.3,-/**,)+-*160*4)(;%?b:8g33f.1f.2b.6`21"*#7*H&2V00Y//Z-0Y-,U)0U*4R0-A("!7M8Ac><h7Bq;=o2?s1I~8F~3?y-@}0@}0B/A~.=z*5o#/g &[%Y*^+_!)\!(Y"&U!"K2]2EvIAuECuDHxFIyGK{IHxF?o=7e4'V".])*V!0]"5e'9i+0]$DC)S#.Z',['*Y#+Z$3e*/c#9n*=q)%S>=E"N%V$Z,d',f).e+.c+2e-:m57j2:m56i1:j6/].I!I$$N(+X1+Y2.Z63_<9gC>lH>jI@kMCoTFrYQ}bM{_HvZLz]LxWLxUJtPEqMCqJ<lD>mC:i?9f;:c9-O,<[95W64W7/R4?cI>aI?eLBiLAjL>fK>iM>iM@iKAfG7U;4
+$='LqRNzWO}XMYCwQDxRLÄY;mGLzUFtM=l@5e5/_-/a,5h03e09i7/Z-"K!(N'.T/4X25X.8Y,4T%*I(G*J!+L!*N -Q!/P!0P!0P!/L 5V+2\./^06e97g=6f>6d=/\5-Z31[56^9:^:#E",4'N!%Q(T$S'S+W"&R)U &U$S$P-W'%O$N 'N"$M!'P&-Z/7f<;kA@lH@iG=iH:fC7eA2^:/\5+X1/\34b;6b>/[7/\53]7+S..V1.W/+T,0X3.V1.T+ GB&F!-	)@.6W<5Z;3T7A\=ÑïsVgC5Q+,N+/R2-R1.S4,Q2-U3/V7/V9)P3(L0%J+2W82Y<.W9+S8+N6)K3)J/*K0)G-*K,-R02Z57a=?hFCoNGrT>gI1Z:4]=2[;:aD4]=2[9.Z6/Y50Z6.V4/T30S5/Q6/Q6-R3.P5-P2-O40Q41R50S50X62\85b;:g<6d30_).])0`,3c19i7;k75e15d0.])*Y%+Z&0`,2b28g;HvQ`ãoiì}mîÇsôåyùìlçÑfàwPtZ>h@8a5(M"2!
+($ %&0%"(+>*$:#7 :/K4+G0725124"== B!/T23]9CoKLxUS^lïwÉ¨å`âg^àdZÑ`{§ÇmîwV{\OtR5Y5&H%'F$.I(-H)+C+)>+*A/+@1 0#
+
+
+
+$3 #5%< +B&+B%)=!$<$?&F(O (R 'S"'S"'S"+U')O& I$P>m6=n-Cu0J|57i 8j!;o$7l9o!>r'Fz/Dz,KÅ5Ez2RÑIrõyÄ£èä™ùÅ°î|úçsñÇrì~mèvXz_CdG0N6GeMQsZLpVKoUMqWJqTJqVIlTEkRGnSHoTDjQEkR?fK?cGAeKFhOEiMAeICgM@dH>bF=bC<dB?fG=fH@iK?hJ@iI@hFChGEiMBfJ<`D7Y>4U84S43R2/Q.1S06X5:Y::X<<\E>_JEfSGiXBcP;ZH4Q;+G0'A(62!4 1-.--,.*))(&#%%''('()-16712345 7 8 "8#'9!):9Cîé ™ûX^R/5+).(5:6271')$79624/BH>:C2CV8H`<BZ6;S32D,.A--I0IgKJiG'E#(?%EY@=U57P)K`9FW3?O2@S7@X8<W4<Z6@`9;Y3A[8=Q5,<"0@&K]CDY:8M,>M0>K1?L89F27D0^iXKSFAD9SUJdfXaeT@J2CS6H^:QlCVrIYuLFb9Ea89X.+I#,L%:\77]49b8EnF1P0'?'$2#,3+-0)')$"6854922=/*A'Ch?=l86g08g10U)%E)	-*I 3W)3^)0\'-[*/],.Z).Z)2\,1T,&=#)*;(Aa<>h8=n79m/<o-@u1G|4E}4B~4CÅ4FÉ5DÅ1?|,8r%6o"8n#0h#["Y*[#&R>80S3IwRFyPFvLCsIFuKHvOIyOI}OEyH5j6)Y% L"J/W#7d+5e+$OF)U"/^(-^'-^'(W!-]#.`!6i&At/$R>?D"M!R*]"*`".d(/b)3f.8h47g37i45g27i46h56f4IH"O$%T&%T&%T((W-)X./]6.\71_;8eF>kL@nQFuUGvVEtRIuTLuSFrNDqJCoK@nI?mF;iB7d;=d8>Z2:S,3N-2O15V;=_F=aG?fK=fH>jIBoP@mL>jI<aB0L3/	
+		/K2PxVM{VN~XPÄZCuPI}VBwM<oD@qD7h9;l=3e42d30b/0c+3d-<j9:e8)R(&L%*P+-Q--S*+P%&I&I(K#'J"(K!%F)I 0Q&1U'2V(4Y-5\04a86d?9gC;hG=jK=jI6b?/[72\6/X0-S,%I#<"B$J J%O!M%O$N%O'Q$N$N*Q$&M  G%L "K*S),U-0Z29f?=kFAmI>jG:fE8dA4`=/[7-Y54`<6b?7c@8b>1[73_;2^:+U/4\7/X02[34\74\77]6)O&'K%:Y7#<	
+/!9U>3T75T5D]?ÜóuL]92M*-O,.Q1/T5.Q3-R3.U8.V;.V<-X=.V;3[@6^C7_E6^D3[A0X>+Q8"E->&7:'H))N,-U24^:8dA@lK?jN7bF9dH:eJEmUIqY9bD0Y9.W7-V6-U3-U3.S40S5/R4.Q1/P3-P0,O1.Q3-O4/Q6/V72[95a=:g</[*,X%.Z)0\+0\+.\++['-`(._(-^&.]&,[$-])3b4O}Ydèt\Üp`áujéÇvóåvóéY{kFiQ>fC4b45a0/V*3( 
+&*1)4;3&+&9&#;#7*F-6S=*F0424047>!F$;e?`åhlôxcêocèn_àhdço~¶ãiítÜ≠êeåowûÅê≥õmîyjìq`äfV{Y9[83Q/5N1%6#+&6)*:-+=-- 	
+
+((:$-A%,C&-A%$8"4 46<-T'*V%)W&+Y(-[*6a3.Y.(S(+Z&=o2@q/@r+@t,4hBv,;o$8m<q#>t&Bx*Cy+=s'G{3UÑMvõz†çkäzgàsbÜlOsWKmROmUPgU+=/*0"9P>MiSLlTMoTIpSHqSGnSFmRHoTJnTEhPDgODhN@dH@dHDhLBeGBeGGjLBeG?dE>cD<dB<eC@gHBiJBiLCgKEhJFiIFgLCdI?`E?`C7X;3R31P02Q/Ac@;^>8Z?@bJDfUEjYHl`JnbFhZCeU;\I2R;/K4-G..F0'<)0-..,-01+))%&%',*'(()-143/./0/12#4!&6)7EL≤©0µßLRD17+-2,9>:162 %!,.+=?:FLBJVBHX;E[76I+1C)2D.+A,=[CKmRAdC&H%$A#:U6;W1@\3E^4Mc<=R1:S3GgBMrIGmD=f::a5Dg=E`=+D$)=!AU98P0/D%AP3M\?9I/:J0cr[iw`EQ=S\KZaQdkYfoZesYkÄ_UnGE`7Da5dÉWgÜZ_~RQpFJhBJjE>b<7]4EpE6_5-L,.E+$5")5''/$$"',7)/<+0B,0K,GlCDn>@l74_*"F6 <4U*3[)2_(1a'-_$+['3a0.])1](3_,-R&6	(4S1=g7Ap97i,4f'4g%6i&Av0C|5C5FÄ4FÄ3C}0<v)>w*>w*8r%2l +d&Z'S=0+N0O{XK}XM}WDtNCrNHwSGyTI|SJSG}L>p=$SAC.V$6b-.Z%J+Z$-^',]&-^''V *Y",^!2e#Ex5M>=F"N#T+^#/b'.a&._(3c/1a/6f4/a.-_,*\).`-<l:K#Q"'U&(X&)Y'+[+.]//^22a75c<9gC;hG>kJ>mM?nL>mK=lH?kHAmI=jC<iB=jC9f?<iB8e<8e:;b6B_3=V.*D!/I,1O57Y@<cH>fK?kJCpO@nJ=kG4`<!F%-"	&',<_?NxTO}XK{UL|VFxRGzQ9m?:n>6j92d39k:-_./c2-b.,_'1b+3a2)T'*S)&O'&L'*P).T+-T((O#)P$.T+.T+-P&:5!?*M#-T'4]18e<7e@7fD9fG=jM;hK;hK7cB3\:-W1)R*$J#A=&F"G G%L"L%O$K*Q"$K#J&M 'L! E#H(N%-V,.Y.-V.-W10\88d@>jG?kH;gF6bA2[92[97`>;dB6b?:fC1]:4`<8d@/[71[54^8/Y15^68`;5]87]65[4.R.<^=;U:'	
+/"7P:6T86S5H`@Åêo>O+,G&+M,+P1,Q2/S7.U:.V<3^C7aI9cK:fK<hM>fN?gO<gL<fN>fN;cK8^E0T:"B*<!#F&'L+*R00Y95a@8eF=hM;eM9eN=iRCmYOva9aF1Z<6_A1X9.U6/W5/T5.S4-P0.Q1-N/-P0,Q0,Q2-O4.R6.U62[98b<4_4-W'*T")S!*V#*V#'V +\%-`',_&,_$3d,2c,2b28f?Lw\aãwbàyUymaÖyeÜ{gà}Km\=dG3]7/]/1\.5Z19)&# ''.&05.6=5",#' 5"&?))E.3P:3N;"=*21302!>"9\<<fBSÅZq°{}™çëº°è∑ùjêwsôÇûƒØâ¨òôº®ä´òÇ£ê†¡∞†√Øô¡¶é∑ôëµôpëtEdD7P2/  .!+=-*;+#&*9$/C(0D(+?#%71!3!5!58,Q(@k>4b4=j?IvM9c=KtR2\66e/Bt59j(2d4f0d1c6j<p%Cw,Cw,E{/E{/>t)K~<[áTX}^]gFhOEhJGlJHkJA_E"9%,#'! %$9(E\HPnVKmTFmRDkPElQElQEhPCfPCfNCgMDhLBfL=aE=`B>aACfFBeE?dC?dC>fD>fD?gE@hFCgKFhMHiLIfJJdIOgMGaFA^@;Y=4S41P00O/3U43V85W>8[G>cRDj[Ek`GmbDj]BfX>`O8YD7W@3O8-F1%<(!8$4!21-,)<(#6#,+&%'&&&'''&&'*+,--./0 1 1.- .
+MT†ô%π¨?B725*7:1<?805.#')&/1,.9+=J6J]A7J,4B)<J33E/6N8PnV/P5AbC@4Y04X,5T*?\0He9D`7>Z2IiDJpKHrLGqMFsLGtINyN@e<*M%-K)7R1*C%2G(?R4]mPBU7DW;\nT^pV`pU`pU_mSScH4H,BY<F`=Ga<QiGayUbÅWNoBJnB=`6/L-; ?FjFFlC<b98X35S19R45L0&8 $7!(?%!:&A"-H',K)1S.Ce@InCCk9$L+Q @1W&6a,5b+1`)/`(,\(+Y*0^/1`,2_(0\'&L4!$3Q/=d5<i22d%.`!-_ -_ -_ ;o-F{7NÇ:MÉ8JÄ5Bz/@x-=w*:w)6s%7q%3k$.a#SA#M'P~YO~ZL{WJyUCuPEwREwRGyTMYK~SFwH<j;@:A.S(4`/+['.^*-])+[',]&*Y#(Y!([ .b$:n,L>>H N'W#'Z"+^&([#/`)1`,0^-,\,&X%%W$)[&+['%T %Q&T#*X'+['+]*.`/4e66g:;kA?mICpOFsTHuVHuTJwVJwVLzVLxTErK@mF8g=5b93`78a78a76_38_28\04U*(F"1N/3Q58ZA8^E=hL@lK?mI:fB>kD*W04%0.O03E /U.&O%:c9DnFIvOKyTK{UH{RAtI;o>7l8/d0/d01f2.c/)],2g3*]%,\(1_1G"K#*S+(Q)*S)0W+,S&&M (R$+V)2[/4Y.=5$>!1P0:`;<i@>lE>mI<nK>mM@nQ<iL8cG5^@1X9.V3,R-'K' B>"B#C"F"I"I!H%J&K E F#I  E#H-S*/X.1W.1Z00[0.[26c<>jFAmJ>gG8aA2[;6]><cD=dE<dB=fD<hE0^:8fA6b>.[44`<3`9/\34^66_78a92X35[64Y8;^@@^D,E/
+*1J43P46O1K`Ao~]7H&,G(,M0*O0+T6-U:4\B:dL<hO=iR=iR>jSAmVCkSDlTDnVAmT?iS<fP?gMAiN?hJ=fF<eE:fE9fG;hK:hN:hN;gP=iR=hT?jVFp\Ls^7`B2Y:5\=/V7-T5-T5.R6/R4.Q1.Q1,O1*M/+P1-R3+P1,Q0-U34\9:c;+T(,S$)Q&Q'T(X)[ +^#/b',b&1d)@r=GvHDrMdèscçybàyfä~cá{Z~rVzlbávTzeT|a5a>8e>:c;4V59,($$''/$(.$*2'(*(A.2O;:UB6Q>(A.6"33211#@$:b@EqMQÄVWÖ`w¢áÆ”¬ß…ªâ™üÄ°ñûø∂ûΩµ¶ƒºüΩµÄûîò∂™å™û® º§ƒ∑¢¿¥íØùTsTB`>$;!( #4$5F6$2%'%2 -<%.B&0D()=""61 21124"D!RzUU~\IrTeçuEkVcâtW~_Bq=Ct39j(,^.`3e4c8j!5g@t*Ey1H|4Bx-@s0WÜPqúqNuVGnO9b:@i??d;4Q2,?,$"(2D4IeOIkRCjOBjOAiOAgN@fOAgP@fMCgMBeM@dJ=aE<aB>cD?dC?dC@eC?dB@eC>fC@eDAcHFdJFbIJaGO^GMYAR`FH\@=W:5S70O0/N/.M./M10P82S>4YG@dVGk]Ek^Fl]AgX?dR?bN>_J9YD2O9&B,!9#4"8!"8!4/3.)'$#!" ##$$"  "#"!$%&)-0-!0&52;RO ∂∞8/2)-0'?B958/,2($%'"05..;*N]H2A*/=&<H4>K95H4IaKKgP: ?^?6V1.R&4S'E^44M#=W0Ea9Hb=3Q-<_>>cD;_E<cFTÇ[FuI?h>-R)7V4=X9CZ>FY=M]@N_?ObBUjIXkO_rV[kNYjJWjJReEG^AG`CG`CIbDJ]APeFTnKEa;8V2-J++E*)C*0M1QpP.M+'G".L*5P1=X7D]?F]AF_B<Z86X31T,-R')P$0V-<a8Bg<0X$/Z$4_*,W"2_(5d-4e-2c,1a-,\*,\,/_-1b+2a*1^',P"!9.'&1O-7^/5b)/b ,`,` (X)Y'Y.`!<j*Hv6Lx;My<Iw9Ev5Bw3Bw1>s+6k#4i#0d$+Z&(U*N|WO~ZN}[O~\J|WEwRHzWHzWM|XN~XJ{NHvH1[-;7%G";f82b01a--_**Z&*[$*Y%%T&W1d)9k.D;?G N'W%&V"(X$*Z&,['+Z&%S"$T"(X&.`-5e3*Z&$S)U"*Y%,\(-_,/a./a05f7=nACqJEsOGtUGtULyZMzYO|[TÄ]R~ZKwSDqJCqJ>mC:g@7d;:e:8a57`44^01X+-R&*J#/M+8U97W?:`G@hM@lK;hA)V-/\1FsHCmE/T2"J'IvM<k?-^/7i88h45e33a3=j?EtJEuKDuH:n>5g46h3.`+3e01c01c0,^+1c0-`(*[$.\-&O%@/U0,U-)R&+U',S$#M$N'R$.Y+2Y,>48-J.;^>:d>DpLBpLCrPBsSArR;jJ6aC3\<0U6*M-"E$A <=!?!A!DD"GD!F CABB$I 1W.5^65^64]33\21\1/\36c<>jF=iH9bB4[<9`AAhK9`A>cD<a@?gD3_;4b>:hC3a:2_87c?4a:2_64^68a9<b;/U00U35Z;9[@=^C9U<+
+!9#1I/2I,K`?duS,?'D&*N2/V;3^B;fK?iQAmT>jQAmTBnWCoXDpYGqYFpXFpXAmTAkUEoYEpUDoQFsTGtSDqPBqQ@nR?mS=mU;kU?jV>iU@kXAlXKu_>fL0Y9/W50U6/T5/V70W8-R3,O1.Q30S3-P2*M/-P2+P1+P/-R1-U24\78a7#J)O*R'R)V)Y+[!.`%/b)1d+5h09j;O}XQ|`lìÄlíÖièÑhåÇkèÉfä|aÜt^ÑmHpUBkK:cAGoLAdD(E)0*("#"!&&%'#8':UD?[L:VG.I:(A."9%23134>AmIUÖ]ZàaVÑ`lî|†ƒ∂¶«¿°¿ª¶∆¡¢¡º•¬¿ß¡¿≠«∆û∏µò≥¨tíàzöçüíú∫Æé™õdÖfVvQ7R16,*$2#<J;-9+%2!(5$+:%,>&.B'/C')@#"6!5212014=EjIdãp`ÜqZ~pgàpëàhãuKvHJx:=k+6e!3a 1`/^2d6h!Au-K~9Bw1Av.Bu3JxGhíjkêobáfEnDDjABdA*B(+
+	!-B3KfSHiTDjQBhOAgN>dM>dK@fM?eLCfNCfNAeK>bF=aE>cD@eD@eCAdCAeAChF@eDBcF=[A3M42H1AO8GS;IV:GW:=W:6U6/N/.K-.K--J.+I/-M52UA5ZH;`O=dRBhYCjXBdSAdPAbO<]H/O8(F.&@'#="!; #="&>$)A)(?+!8&*&&#""!!!!$$ ! ! ##&'(+"20<A@ ¶°9+.'03,470;>7+1%&, .4*6>1JYD5D- --8(3;.2>07L9TkW0G32J2=W:6Q.-CFX2Td=0@(;AT8TdG.>!.B))>+5(6SAXÅ_HuL9_8'G"4M/+?&+:%=I3FS7GT6duUWjJ\lQ_oT\kNTcDHY7N_?DT:.?,.?-(9&,;$ZjP*9"$3!0- 1'=(VpU-J,(A$6)<&,?))<(.A+5H23L/=]8<b9<b9<c7=d86]00Z,3]+2a*6e.1`,'U$7h13f.7g54d2.`/+]*.`+1d,0c(3e*6c*"F()'&.L*7^/5e'.c+`(\)Y'W$V&V,W!%I-I!0H&0J':V0@a6Ci6Co2<m+;n)7k)3f-/a0IwPSÄ_P}^N{\P_O~\K}ZK}ZL{WO}XLzSJyMDp?(R"5;3^11a/0`,/`)+^&-^'-\($P"N1](7d->	8> I#Q"(V%&T#)W&)W&'S #R$S(X$-]+1a16d52b0-^',]&-`(-_*/c26j:@qDDtJEsLFtOHtQLxWJwVJwVJuWHtSIuQIuQHvRHvREsNAoH=kF=kD<k?:g<9f;6a43_.1X)*M#*H&:W;9W?=_F7^?0Z6<i@6c83a3LzLLyNQ~WO}VLÄRINEzF?t>4k1:p64f35e5;k;;m<;m<4f32d/4f1.a)3d-2b.2b0,\*.^*/b*)Z#0\)+R&8(J)1W0*S)'P$)S#'NH&R-Y&/Y)<76#="(G(;\=MrQHoPCoNFuS?qN;jF7eA-U3%H(@!:88;>>"BAAA C<<B#L$,R+/U.+V++V+-W/0Z22\4/\31^7:fB5a@1]<:cE?hJ;cH:aD>cD@eD<dA4a::hC8fA3a:5c<8e>3`97a9*S+4Z58\8+N-/R12U76Y;7Z<9Z=,F-#,*A'/D%ObBXkK'@ ,N34\B9cK<hO?kP@lQAmRAmRBmRBnSEqXFrYHrZHrZLv^FpXIu^Kw^HtYN{\LwYIvUGvVEsVDrVAoU>nV>nVAmV@lU?lWCoXOya2Z?/X6/W5.S4/T53X73[90U4,Q2-P2-P2-N3*M/+N0+N.,Q0-U3.X46`82[/G!I%M&Q'R)T-X 0\',['.`+7h9?mHZÖidãxníÜiåÖiåÖkåÖnèÑfàzWzdNuV<f@6a63Y24U6+E,.)+&##& , (&%$/,C1A[N?[O:VJ5OB7O?&=) 611='Q+5e;GzOYåajöt`çlqòÉÖ©ùî¥ØùΩ∫õπ∑á•£ä©§£¿æ´≈∆¶¿øëØßpêÅZ~dgéqãÆñÇ§ãqîtfãbBf:3R)&:&5 ,9(5@02:-)4$(3#(7"*>%*>#&:!"5 64421346<7X;hãujå|_Äw`zoéâmç~V{YJu@<h-3a /]/`2c!3e 5h#9n(@u/>s-Av2As6<k7Aj@OrQPqTHiJHiL@\E/F4#3)(!	-82QbZ:OFC_PDeP?fK>dK>dKAeKDhNFhPDgODhN@gL>eJ:aD=eC>fCAeA?c=AeA@cBBeG1R7&B+$>%(>'4H-DW9AV7:U67T51N//J+.H+,F),F+*H.2T<7]H6]J8_L9`N=bPCfRCdQCdQ>_J2R;-K3*H.*H,*H,&G**H,1O72O;3N=2J<%;.-!(&#$#$#$&#" !  !!$%%'*#.78 ïê2$)").'581>D:.4&'0,4%7B25B0/<*&1#+3((2'*8+G^JHaK"8#.A+7N2=R3(7YdBFR..<.A#FY=4A'5?'-9%!,)#8L@OwUDoD5X0"<)< 2@'3<'@H1S\A`kMUdETcDRaDP_BRaBM\;G[6L`=,+5F4"3!,>&TcL#.$,$,!%/$"0!GZF@V?3*;( /"/$0"!-,-'A$*M%%N"(Q'(Q%.X*3]-3]+3b,6g/:k41_0!O!;m:5g49h:3b4/a00b-2h.3i-2h*4h*6c,#G!	%*!?5]+5h&,d'^)])[&X#U#R)P!5"
+'7'H6_'3c'3g)5h01a19g@S\Oz\Q|`RbUÇcVÖeKzXIxTN|WN|WJyOFtECo>>!G*X)3c11a-/`)-`'._(1`,*V%D-U#8`,99A%K"+V(,X'&T#'S"$P#O$S(Y",\(2]/&Q$#L 1\/1_.2b.3e27k:>o@ArEFvLHvOGuNHuNEqM@lI>lH>kJEpRIuTMyVJvRDrNDqPHtQGsOAoJ<jC8g=;j><i@7b7<f87^13V.*I'3P22P43V81V4.Y.8f88h88h6Ao@BpBFuKTÑZQÑYLÅSG}KJÅJ=t:5l29n68j55e11a-4d06f25g23e00a*2c,/^*/],+Z&)Y%2c,/`)-Y$(O 59,P,+Q(%N"%O(O  H&Q-Y$2\*<#@!(@&&@%&C%-L-.O0'J,<cDFrO@nJ:fB5_;'J*;67!;8:<;>?@B>=!G +T,0Y/4Z31Z20]20]23`77a97a93]75a=6b>3_<9bB<eG<eG9`C<cF=bCAfE:b?;eA:fB5c>5c<6d=9c=6`::c;$J%(M++N-&H'(I*,O//R22U54U61N25% 7)>avUMeE6S5:aF=iP?kRAmTBnSAmRCpSCpSCpSErUHvZFtXIu\Ku]Is[Is[Q}dKw^HuXKxYNzYHuTEtTEsVDrVDrXCqWAoUBnWAmVBoXEqXLw\-V80Y7/W5,S4/T51V55Z9/W5,Q0-R3,O1+L1-N3,O1*M--R1/T20Z48c8,W) JJ"M"O#P%R(U(W#*X'2a3QXUÄb^Öpeâ{håÇaÑ}eÜiäÅhâ~Vxg<`F7a;7b71Z.)O&>-&)+'$"%#/##-$($$04M:?YN?ZQ;VM9SF8SD&?,52=<f>L|Rcñk]íhz¨áëæ°É≠ï†«µí∂¨áß§ùªªú∫∫Ñ¢†rèãÇüõù∫∏òµ∞ï≥ßjçuYÅ^S~S_áb`àcT}QKuEFq;Ci6+G!"65D/-8(+3&-5(,7'+8&-?)+>((;'#6""8# 6 646567< *H.Su]`ÅpRrgbÅ{lâÖcÅuTwWKrC8d)3a!1b!7h';l+7h':k*9l)<q->s/Cu6?q68d11Z.1S25Q8.G15N;8O?1E:.=6,92&1- )$	
+:C@LWS#2+-C6C^KBbK>`H=aG@dJCgKHjRBeMDkPAhM@gL>eJ<cD;cA?c?@b=?c?=`??bD9Z?'E-,H1(D+(B'4K.>U8:T77T66P31K./H+-F),E()C((F.3U=9_J9`M8]K8[G9\F>_JFgT?`K4V>/Q8,M20Q62U73V82T;4V>6WD4SC4PA6PC3K>*@3!3'-")'(%++($$$$#####$%$$( *44 ÖÅ*!(!!( 492?E9=F1?K3.:&.9)%-"07/0:1-7.+6.0B4OiP;U8#: 6H2-<'@N7@K-NY70;/>:T-7Q,0@#@J2+2 '-!)3D2HlFEl?:Y/1G!)8>H-DJ0PV:lsTR[>NV>NX?_lPYhIBQ2G[8RkA7R)1I'/F*&=#<T:G`@7K/*5$+1%-5**6*9J7N_L!/$0"&2$+6(#+ !)&)%<"/M+.S**T&0Y-/Z-1],2\*7a/:f3<l8Aq?6c8K"DqF;j>:i=2c46f48k37m/5m,6n-6i.1Y'=/$
+*78`.7k).h(a%\*\'Y"T$S'J 	'1L-5Z1.Z)(V%+Y*.Y.1[5FoMR{]S{`R}aUÇeUÇcQÄ^FvPGuNJxSJwPJxJEsB8f57g57l83h20c+*]%-^',]&,['-W'FD5[,9:"E(M$,S&(T#%Q L"N"P$T )Y%-\(1[-#H<7Y48^5=h=ErICsKEtJFuKErICpE;h=5b75b9?mFKyUM{WMyXMvVHtSIuRIvUMyXEnLDnJAmI?lEErKDqHCkF:c;7]4:_6:^8+M(&H'&H',R-.W-.\++\%1`,0_+5c2@n?;h=CrHOYM}WGzOFzJI~H7n59p7;q74g.._'.]'3b,2b.1a-._(0a*+['-]+,['%U!-^'3d-+Z$(R >,
+ B(L&%L $K'M H#N-X#3[)<*I)-J..M.,K,'F'$C$)G++L//R2:]=:]</P15,.62.9><=AHHB!J%N")R&*U(,U++V+,[/+Z.-Z1.[4.[4+X13]96`<8b>9a?;cA8_@9^?9^??dC>cB<a@8`=9c?6`<;e?7a;:`9:`94Z5$I'-R11V7*M-%H(!D$%H''J)*L+,K+$C#15)?i~]JeFAbE@hN@nTAoUAoSAoSAoRAnQDqTErUGuXJx[IwZIuZJuZKv[Kv[IuZKy\JyYP}\NzYIuTFsRGtUFrWFrYDpWCoTCoVCoTCqUHvYEpT0Y;/W5.V4,S4-T5.V4/W5/T5,Q2+P1(M.*L1,N3*M/+N0-P0/T24\79d7.Z%#PN!Q$T%W'X )\$)[(.]/8e>NwYLr[Qve]q]~sZ{rYzoZ|nXzjMpZ8_@5_94a6-W/E ;0)+,*.'!&(&!3"9QAAXN>XO:TK8RG1K>(C0">'6%O'SÇVVÖ[mùwÄ≠êó¡≠¢∆∫§≈æ¨À∆™»»ÆÃŒ≠…Ã´« °Ωæû∏µâ§ùsìàjå{iåt`àfWÇUR~KL{EK{ACs7Ar19j(6b%0T$(D7K2(5$&&&.!+3&/<+2@/4B1/@.0C/+A,&>(":"":"":  898!=$2R:BdL:[HQqb[ymMlZJnJGo=9i+<o,Dw4Fw6Iv;It<En6Bn3Br4@r3Ew8As8Gs@3Z.84  2&'8.3G<3D:0<80<8*96)51$/+ !?HC?JD4D97I;2G65L8@\F?_G?aH@dHAdLBeMCiPBhOCfNCgM@dH=bC<_><`<=_<>`=>aA;^@,M2-K12P6.J11K01K05Q83Q74Q5/L0-G,)A'(@&&>$%=%)E.3T?9\H;^J9\H5XB7ZD:]G<_I7ZD2U=1S;4V=5Y?6Z@5XB5XB9[J7YH5TE6RF9UI:TI5LB(<1 1'+!*!(*"*") '&$#$%&' ,, .)!!!+	:: ÖÇ3 &"=D=SZR=E6S\GBN61:'+3&(-',1-070/:2.>4G\MHbI6P3,C',>&,9'YeOkxZHS34A%8I)Ie<Hg=-C8G*3?'7@-5;-FS??]9Ij?AZ2@Q-7B$FO2afHahGY`>@J(=F+R_EYhIN_=GX8ZnKJe<Fb9LfC<U5+F'E`AEc?1I)%1&.!+5*5A3O^K&4# *#*"%/$0:/%&(0>-9R53S.0W+1[-2]/1_03b.4`-9c3Al>AoAHuJ?iE!K'HrN>kB7f<8g9=m;:m47n-6m*6m,-^&@:%@!*B( 6+&F7b-6k'.h)b(a*^%Y#W(W!%H -C,7Y80Y1*W,(S(*S+,T/4\9PwXR{]Q|`RbRbTÅ`P~YGuNFtMHwMGtIBrB=o<4i3-d--d+-b*-`(,_&-^'-\(-Y((O"C-R&;?%H (M"(O"!K$P#O!P$S'V"(W#*V%%L#F???3W3FnKKtRFpL=gA7`81\1-X+3`5@oEJxQKyTIwSHtSHtSMyXNzWIuR;gC5]:=b@InMKpOInMCfF8Y:$F% D ,P*+O)*N( D #G!"H+V(1`*+]"(Y!'X )X"1`,5c43`5?mFHvQL|TExMHzICxD6m48o54g,0b',[$,[%.]')Y%,['/_+*Z()Y'*X'&U!)Y%1b+1b*-Y&'L!+0*I'(K#%J&L!I K*U 3Y*<,K+4R60Q2-N/'I( A"$B&%C'%D%'F&"? 5/,2;=@!C%J!D F)R&)T&'U$$R#)T&(S&$O!)T'/Z/4^68g=5e;2`96c<3`9,Y2-U25Z81T41T47X;7X;4U87X;@cE;^@?`C+N.9^<<a?>d?(N)3W34X4.R..S12U73V83V82U5*M,"E$!C #E"&H#%H &I!'G .H#_yVGeIDhNBmRAoUBpTAoRAoRCqTAoRFtWFtWJx[Iz\Jx[HuXFsVLw\JuYKx[L{[N{ZN{ZMyXJvUHtSHtSGtWEqVEqVCoTBnS@nQ@qQJyW?kJ/V72W6/T3-R1-R1.S2/T3,Q2+P1*O0)N/*L1+M2*M/,O1.Q11T49^<2X//Z%,Y &X#U)[ +\$2e-?q>HyLRXT}]FlSAdP?aQBdT@bT=_Q<^P?aQ>aM;aH9`C6_=8d@9b@5\=3W;/O7 <&1.3)A)!4 """"'<-;SE>UK;UL:TK7RI0J=0M;,L4C"'V*TÖVUÖ[VÑ`hízôø≤§ƒ¡•√√®∆»©«…¨»À´« ØÀŒ¢øΩÅüólå}\ÇkWÄ`Q{UWÇTQÄJOEH{9H}7=r*<q)5i!0^-V2S(:S5.B)*9$$3 !.),#0(6%0>-4G47J67L97M87M67N44L4/I0/I0+G./M36W<8X@=]F?_JBbJJlGFn<<l0At2L=Iy;Ju=NvAHo:Cl4?l1@p2As4>p3HwAEoA3U2 :!&+!1B87H>3?;1=;.=:)96&52!-) )!2=5;F>6C9)7*)%%:);T?B`HAcJ?cI?cIBhOEkRDgOCfNAeK>cD:]=;^=;_;9]9<_?=`B2T9,M2/P53Q73Q71O50N6-K32N70L3,F+)C(&>$$;!%<"'?'*F04T?=\J:[H6WD3V@5XB3YB5XB5X@1T<1T<1T<4W?4WA1WB4YG9[J9YJ6TH6TH6TH9UI7OB4H<+=1"2(/% +%& $!  #$#((+- .&*BFkk- $%LRPLSK?G8AJ9,5$(."381(*',.-,20*5/<NBTkY<T>?Y>KdF?V9?Q9sÉi]nL4E#-;"-@$=\3Ef98W+SnEG[8HV<CL7\hRCV8NaA4C$HU7GR4T]>_dF_fD[h=DS*8G&K^>AV59Q/L_ACV8Hb=OkEIdAHcBC^?=[9LlE2M*%42=--:)LZK-9+!+ "'! %(2'8C5 (%,$&0%8I6?X89Y07\07a15c27g3:l7;k9?h<AjBKuOMvTFmN"I*FoO6b>?lCApB>n:=o47k+5i)4f)-Y&? =)F(/M11P1*I'@1\&3g%0i",e *c&^"Z(`'Z!#J36!0 *9O8?^?7a;/\3(U,'Q)+S.+S0GpNO{ZL{[M~`QbSÄaUÉ_O}XHwMCsIFuIBsD>p?5g2)^&/f,,b()_%-`%/a&+\%)X$'Q#'N!$KCC&K"$I!F G$N'S "Q%T *V#'S $N GDC?=$D*I))H)*I*.P/+O)-V,0]2ApFHvOGwQEtPHuTIvWNy[O{XIsO;e=7a9>g?.Q03O69R<*A-5!*(<&J$)L$$I BCE'Q!0\'0b'-_")](Z*\!-\&+Y(/]/5d:HvQM}UHwMGxI>s?3h02h,.a&-`%+]"(W!'V",X'+Y*&V&$T$*X)$R#&U!+\%/`(-\&+U';$";(H#&I'K&L H'Q1V*;*I)7U94U61T3,Q/)N,%H(!C""? #@!!<63;'L+6`<>hB6_7(Q)#I"$J#&O'*U*)W)'W'(X((X(,\,+Z,-[-+X/:g@<lD=mE3a:.\5+X/,V0)N,*K,"<!)A'3K3-E-8"1J4A]D@\C4N53<Y;A`@2T3$G&,O.+N-+P.+P/.Q30S51T60S3/R1,N+#G!(M$.S'*Q$.U(0W+9Y4FhGAhMBlTAmTDpUDqTBqQCrRBsSCtTN}]JyYJyYJ{[HyYHwWFuUHuXKvZJwXMzYP|[TÄ_NzYJwVHvRIwSItVErUFsVCqTAoR>oQBtQJ|WCoL/W42W51T3-P/,O/-P0,O/+N0,O1*O0)N/,O1+L/+N0,O1.S42U7:[<A/V'9f/,^#)]'Y9j3DtD?mFPyYKoUBdL8YD4UB8YF=`L=`L5ZH5ZH6\G5[D4ZC7]D6^D9aG9aG9aG<bI=cJ;aH=`H5Y?.P72S8 <%'#"%7)9QC:TG<WN<WN8VL4PD5TD7[A>hDNÄOUäVVä\VÖa`är¶ æ¶∆√ô∑πâ©®ã´™ëØØî≤≤ÅüùjãÇTzeLuWFuKBtC@s;Fy>Dx6Bw3?t.Dy1;q&9o$1g.`*V5[*9X/3N+-I#)E"=$= '>$+=')8%)7&*8'):(/@00A/7H5;N8AWB>V@?XB?Y@9V:;Z;9W;>\@EcIMlMIhF@e9Do9Dt8Fv8Cq3Cn6Dm5=h0=j/?m/Hy8>q/Gy:Cu:Bq;FqCAe?,I-0);-4D:5A=0<8/>;,<9'63$0.)#"!+#*5-'2*' 0#8O;>\D@bGAeI@gLJpWCiRBhOBfLAfG=bA9^<7]84\79a>=dE;]B,N5/Q81Q92S83S;5U>+K4'E-(D++E*)C($= ";&?"(A$%=%&?*9TC<YG:[H7XE3T?4WA5W?4V=2T;3U<2T;3V>3YB5[D4ZE5ZH7YH8XI9XI7VG7SE7RC4L<3J8.C4, "!! #$$&)--(32<'-)@J?.9+#)-3'/5+,/(13.,.-0453>:]m`<Q@.E3OfRkÉiVmQ9K5[jSTeE;L,8G0&:OkEZyOKg>B]49O);L,IS;PZBLY??L0>H/Q[BhqVYbGDJ0blJapEH[.8L'AV5D\:>V6DV<DV<>V6Ga>?X8.F&*A$KdDEe>>\6)@#(:"3D11?.% ' !&"%*$7B4;F8#*"&(*8'D[>A]7<]29_08b27e4:j6=m=ClDBgEHmLMrSAeIF)GnO4^:CpG?m>:k48j/6h+5g*2^) G<&C'+I-.O02T3/S-5Z.3^(2f$0i",h"'c)b$\%](["$K"@8,!&.#-@,:X<6`<3a:,Y0&P((P+(P-3\:KwVL{YK|\N|_P_Q~]QZLzSDtJFvLCtG?pA:l92g/0e--b**`&.a&.a&._(,\(0[-(S%&P"$K!H!G"G!H"I$N(T! ON!NJJHFBAB;866: B/X0?lAFuKGuPHwSJxTIwSIvUKwT>hB9d99d7=h:Bl> D+$!"!1+J*(M$&K"!FDB"I,V&,['._'.`#.b"/c#.b"*\!(W!+Y(,Z,7f<LzSQÄVCrFBtA7l63h00f,-c'-`%+]"&U&U!'U$(V'+Y++Y+%S$"P'V",]&-\(/V) @#
+*&A 'G %I&L H"I+N$;,F+=Y@6U63V5/U0,T/,R-'K'$C! ? => A"0U4>gE@nJ<hD5b;0Z4 I!"H#'M($N(&S*(W))[*(X((X(.]/.]1*W.7e>9iC;jF1a;*X32`;3]9,O/&C'0('"4$6K8+@-&0C-,E(*G)0R13V52W53X72W64W92U72U71T41T3/S/.T-4]16`2.Y+/Z-.Y.7\:>eF@kPCoVBnUEqVKx[CrREtTDuUDuUJ|YKzXKzXM|\HwWHwWEtTGtUJwXJwVN{ZR~][áfLyXKxWKyUIwSHuTFsTEtTEtTArR@qQCuRM|XJvS4\90U30S2-O.+M,,O/-P0,M0+N0)L.)L.,O1+N0+N0,Q2-R31T68T;2&I!>h8<k5Ct<3d--]+=j?8a?:^D6VA2R=0O=0P;2S>7ZB9\F4ZE2YD4ZE4ZC4ZC5\G>eP?fQ>eP=dO?fQBiT=gO<gL?gMCjOFjP?aH,L4:$),8P@>XK>ZN=XO:UL5SG6XG9aFGuQZä`dòjbílw§áàØú´œ≈ùΩºñµ∑ñ∂µïµ¥ïµ¥ö∏∏ë±ÆoêábàsTÄ_L}PJIF|BCz9By5C{2?w.?w,:p%5k 0f0d.\2Z%,R!,R#/U"2Z&5\/5Z/*H&#<&8")7&*6(.:.1=1)5)(4&.;*3A24E32D41F37M8=U=9Q7=U;E_DMgLGbC?_8Dl:Dq8>k09g);f.=h06c*6f*7g)=p.:m+Au3As8OÄHIxBMyHKpG/L- 8".@24C</>9+:7+:7)77&20 ,('!$#$ (+B.<ZB?_G=_FBeM?eLAgN?fK@dH@eF<a?8^93[68`==eC@dH2T9(J1)K00Q63U<2T<.N9'D.%A*$>%&@%)A'$= (A$'@#&=##;#+D16Q@8WE8XC6WD5VA5W?6X?4V=3U<2T;6Z@2X?3YB5[F7]H6YE8YH9ZI:YJ6RD5P?7P=7N:7N:4I:%7+! !!"%%&- .#2&3#1/9.8C5) %-2+9=/15'36/+0,177R[XZh[#5%3G;ZnbnÉp\o[nlqÄkQ]E-;!5G-3G,G\=LaB0C'8H+EV45D#\fM?I1VcGKX<NX?T^Env_FN9emXT^CdtMG\1@V0?T36J.1C)7F1<N68O2:R2XkM=M0M[ANaC:V0Ff=5S-4O,.B)*8'(#%'$6;5'/$>I;! )1@-@T9B\7@_5>b6:a4;f9?j?BjEDiG@eCDiG9^=#J+CkI9c?>kB6f65f/3e*4e-7c.!H<"?!%B&'F'-L-.M-*L)*O$0[&5i'/k#*f +g!(a&_(`)Z"#H"=#7 -$"#%+!*;)B^E:cA4b;1^3)T)&O'%M*)N-?fGHuTIxXLz]Lz]M|\N}YRÄ[O~TEuKCsI@qD<n=2g14i33e2/a,.a)/b*1b+1a/2a3/]/(S%#MH I"II"L#M$Q"R%U'X)Z'X#T QO$T MC;3/.5X7<f@=lBApFAoHHvQJvSJvSLxT7d;.Y,9e4>m9;j49e0A* ,D,-O*(O#$K!F!FE%O!,Z+.\+.^*/`(.a&-a!+_*\(Z'X +['0^/8e:ApFFuI?o?BtA9n81h/.e+,d%)_!+_!%V%T 'U$.Y+1\.*U'$P%Q'S *Q"&F7! 2%@#F"GEC%C.)3F3;U<8Z94Z30Y/-V,-S,+Q*'M("F"#H&5];<hG?jN?jN=fF7`>4^:'O*C!#H&'L*(P+'T)&U'*X**X*,Y.+X-*W.7c?9gC7fD8gE2a?:iG>iK'H-* $
+	%6#5O46W84Y71Y62W60U6.R6,N3+N0)L,*O-*T..[24c75d82a5.[2.Z65^@>iNCqWDrXCqUBpSAoRCqTDrUEsVDvSGyTM|XN}[Mz[HuVHuTGtSHuTIxVHzWK}ZM|XM|XJyWJyWTÅ`KxWHuTDsQDsQCuREtRApNGvTN}[MyX>gG.S2.Q1,M.,M.-P0)N-*M-(K+(K-(K-)K0)K0+N0,Q2-R38Z?,E/291S0Bk?JxG?m<0^/2\41V50Q6/O80P;-N9.O:.O:/R</R</U@0VA4WC5[F8^I8_LIp]Eo[BlX@jVAhVDkYAkWBlVGnYCkSCiPAhMCjMEiM<^C.L20#&3K;?YL?[O=TL0J?5UFBhSWÇg^ãnw§áâ¥ôóæ©â≠ü£«Ω•≈¿ùΩºõ∫º¢¡√†ø¡¢¡√§√≈¢¿¿ùªπîµ¨wúähëqTÅXPÇOK~EK?J;F~5D|3F~5<t)3l0f3d",X%P&Q*W1a%:l1@o8?i9/R*5)#'#  !(!(/'-7/1=3.:..</8F7<M;>Q>@VA?U@:U6>c7Bm79f+3a#3`'2_&/a&3f+2f(8l.8l,Cw7K|DGv?Et>Dp;LwB@e9)H($='0A74C>*96)53+77*64$0,*$# $6&;R>>[E>`G@dJ>eJ?fI@gJ@eF=bA7\:3[68`;=eB>cB:]?*K0'H-+I/0Q65U>.N9*G1$@*8"$='%?$(B%*C&*C&'@#%=#%=%'@+1M78UA9XF8WE5U>5U=3U=2T<2V<5Y?6YA6YA7ZD8[E:[F7XE5VE9YJ5TE5M?7J7;M7:P99Q;8O?(<0%""$$#%&&&'(),-!2'6#$3-5B1#0(%,$&,"AG9IP@;A5381-10DJH3?3-;,4F8L^PwàxWhVIXEM\G)7'7@T8>R65E+$2)*6 HU7^kMJT;?I0Q^BUbF[hL]jPT^EV`HamWiw]VmCD^1(A6K*6J."4-<'6E.@T8>S4FU8ZgKEO6N]@KcAJhBFj>:Z1+D'/@-'#("3508=7 (>H=!(!$.#4A/SfHLb<3M*6T07Y6?bADgGBeDBdC?bA>a@3X6<dA7_:7a94_25_/5_-2\,*Q$?!@&E%*I*+J*/N./N.-L*$G+U#2f&4m&-j$.k%(d'`,` #O"B$;!0$# "#$#/#;P==_D8b>.[2,W,%O'"J%%J).S2GnOHsUItVLyZKzZM|ZN|WRÄYHxP?oE@pF>o@3g6,a-(X(0^0-[,.\-1_04b43b80_5.Y,IG I!K J!M!M#S&X-`4g"3g1f1f(]8m'7n*,a*]"M?723V6IqN@oC7h98g=ErIErKBoH<i@*X*1_.8g15f/7h05b+8^/1
+
+	.F./S-&O#"L#J!H#J(S%-[,/_--]+1a/4e.3f+1e%-a!,^)[0b'0a*/_-.]/7f89i7:j8GyH6k76m40j-.f'+b!*^ (Y!&R(T#,W),W)%P"$P&M'J 1%%!:#C#HE@!<#
+
+&9&6P55W45Z12V0-S,)O((P+)Q,:d@CoNAnO=iNAmR=eJ7`@8b>0Z4BD"%J(,T1*T,(U*&S('T))V+*W,)V-5a=2_>2_@9hH8gG8fI@kO(J/	' 8" 	
+
+&(;'3P48Y:4Y82W82U7-P2+N0-N1+N.,T12_86d=4d<7g?6d=.\52`<<iLCoTDrVArUCqTBpSDrUDrUHuXKx[GyVHzUN}YN|XMyXGsRHuTHvRIxTJyUI{VI{VJ|WJyUGyTI{XUÑdN}]HwUEwRFxSDvQFuQDsQHwUO~^KvXJsU4Y:.Q1*K,*K,*M-'J*&I)&I)'J,)L.)K0*M/*O0.S4/T58Y<7!00#A%;a:Cl@?j=4]3/T2-P2/O7-M61Q<1R=.O:/P;0Q</R<3TA3VB4WC6YE;aL<cPOvcIs_DnZClZIr`Fo]BlXAkWFmXGnYFlUDlRBjOAiN?fK@dHB`F:V=-I37R?>ZK;WI1K>:+6YEmï{ñ¡¶öƒ¨ó¡≠®Œø´Ã√ß»¡éÆ©®»«©» •√≈™» ß≈«•√≈¶ƒ∆¢¿¬ú∫∫ë∞´á®ùgçtZÜcOÄSPÇMNÅFLÄ>IÄ<G6HÄ7@x-5m"1g/b(Y"R#S)[.b"9m/Dw>QNS|R8W80!"&!+ '3'-;.2@1/B,8V2@f7Al4;h-9f+3c'3e(1e'/c%8l.@t4Fz<Ev>Fu?L{DKzCDt:?k6MtH&E&)>/2A<.=8*64&20'31&2.("!!- 8O;@^F>`G:aD;dF=dGBgH>aA:_=<b=8^9<a?@eD=`@1R7*K0/M33S;4T?,L7&C- ='6  <%#=$%?$'?%(@&+D''@#$<"&>&$='%@-5P?<YG<\G9YB5VA3U=1T<5X@4W?3V>7ZB;^H<]H8YD3VB3TC6RD1F74?.?K5:L47O76R<4L<(=.-*)()+. /.!0 /00.#5(7$)8#5G1*<&"/$//7(?G8FO>GP?HQ@.4(.3-/4.,7)8G4?Q;BT>UdO5B.6E.5H,"7F^:PhD>S4CQ:NWDBI9U\JXdLcpT[jM`oR^lRYgMM]@evVYiEO_;H[;WoKCc4=].6N*F^<MgB8R//A'-?%7I/6F+YfLNX?<F.8F,7L-QmGEe<:Z3'B#9O8+9(,4)(-'!& $BLA%#!( )0(":B7WcKXgJ$4",2J43M47T84S3:Y99X87Y64X2/S-2T/2R-3Q-0N*(H#=!@'F$(L&.R,/S-2T1.K,4!C.X*.^"0g#0l$1o&&d'`%U$J"=#5! -#=TB<]B3[80Z2,V.#L$#I$(K*3V8EgLHoRMvVIvULzVLzVKyTJzRCsIBqG=nA6g8.]/*U*6\5-Q-,O.6Y8=bA;dB;gC/\3JH!J!K#O%T 1b*-a#0d$2g#2g!1g3l8q$5n!<t)>x.6s&5o%5j&&S)P#2#F%MsNIwH<n;5g42b20^0,W*/].-[*2`/8i21b+9j25f.<f61
+
+7O90T0%P%"M !J!J #L"*S'/Z,2`1+[+5c52b24d05h/9m/9m-3g'*^+_!-`%*]%)[&0`,4d2ApBGvH7i6>s;5l21i*,c"*^  LD(R$,U)&Q$&O##H"@/  0$D"G E> 9!+,=+5L26P36S42Q1/S//W2;dBEqPErUCpS@lQAmR:gJ7dE6d@7c?I!#L$"J%)Q,)S-)S+)S++X-+X-)X,'V,,Z54b>1^=8eF:gJ7cH;hK2[9@&I(2	
+	
+				+>+5M70N41R50Q4-N/,N--O./T25_;<hD9gB4d>9gB7e@1_;8gE@oOFuUDuWBsUEtTErSGtUFsTMxZN{\M|ZO~ZO{WP|XJvUErQFuQGySJzRL|TM}WL~XK}WHzTI{UFxSI{XHyYFxUFxSHzUCuODvPDvQHzWJyYKvZMuZ@gJ.S4*K.+I-(I*%F''H)&G('H+)J-)L.*M/+P10U46Y92Q2 8 46 ;+O+8^74X2.R.,O12R:/O8/O:2Q?/N<-M80P;1Q:4T?9VB:WC5VA6YC=`JEkVElYElZGp^Fo]Cn[@kXBlXCmWCjWElWElWDkVDkVEkVFlW@cM>^G<ZB<YC?\HA^J<[I-J868`Eoö~çµù~£ëxúéì∑≠¢√ºÄ†õâ¨®£≈ƒ¨ Ã´«Àß√«§¿ƒß√«õπªêÆÆ~ùòvïèiã}^àpWÜdNÅXKNQÑLMÅCLÄ>KÄ:I~6Cy.9m#4h-`([&Y#V+]-a#-`(WáWcëjkótX`;\?5(%* (''"*#&!-&9#8S0Ej7Ht9>j-/_!/c!2f$4h(2d%=o0Dv7Dv;IzBJ{D>o79k0>n4PzH9[65#(91,=5)83#2-'3/&0/$/+##(2I7<YC:^D9`C9`C<aB<a?<`<=c>7\:9^=;`?;^>2T9.P73S<:ZE4SA.N9)G/!?'=%$B*&B)%A(!:$":$$>%'?%&>&&<%$<&31":PC>ZK9XH7XE4U@2S>3T?6WB4V>6X@9[C:ZE9ZE8[E4T?7N>1?0>?-FJ3:H/3K13O85P=2K8(=,.&#"(((+./"1&5"(7")8!+:%)8!:N5*<$.;)5B1:E48D07B1<G6>G46>//4-6;5BM?Q^JRbHAT8CQ87G,>Q3;P/F`9Lh@<V/)>;G3BH:?E7GM?@I8FR>Q_FScIVdM^mV_oUiy\k{WGY3Jc<Gf<Dj7?c32N(0J'6T.A_90I)6M0>R68H-<H0LX@FT:9L.G_=A[6+I#?]9-H)?W=,?)*!( %*#(AM?))+7+) !<A;nwfmyc7F/#$<&/L.;#B ,L'4V14W/,Q&(K# >410$:#%=#-F)2M.3R05W49X6(F$+"@1U/*T&&S2d%2k&.j$)b(\$L >"6) '4*6M9:[@7\:0Y1(Q)$H"#E$(F*$@';YAOqVIrRKwTLxUJxTEuOGwOBqG>mA;j<2a3*S);!> $>%!=$'H-.R63\:4a8 KGH%N"3^09i58k25k-2i&.e!)a*d5o"6s#;x(=w*@}0=|-={.@z09m+:i2F"H?h>Br>;p85j20b--\(/],2`/3c1/_+/b*3f-3f-4e-*V#%G"5=U?0S2(R*(S('R'%O''P('P$,W*3a30_16e9-\01a1-])/b)8l.2f&1e%0d$0g&/e'+a%+^%6f2:h:N}Q@oACuD@uA;r95m.0d&&U=#H)N%$J!!G?1(#!#+="G!F<4		"+5;#F%6^<CoNFsTHuXDpUFrWBnS=kN9hH5dB7e@&S*"M"%N&#K&'Q+2\6-W1,Y0)X,'V*&U+'U.0^9.\84aB9fI:gJ:gH;gD+W33]7@
+"
+'
+
+	%#8%7Q81N2-J,+J*0S2@eC?hF?kH;iE9gC=iF1_;8eD>mKAsPCuRCtTEvVGvVFsTIvWMz[O|]Mz[O~\RÄ\NzVMyVHvREtPEwRHzTK{SK{QK{SK~UI{UGySHzTFxRFzVI}YFzVDvQHzTHzTEwQDvPJ|YJyYItXNv[JrW5Y=1P1,I*-H)(E&(E''F'&G*)J-(K-+P1-R12W6;\=+H,$<$":$";%$@'&H'0R/-O.-N/,M20P9/O:0O=0O=-L:1P>1Q<4Q;8Q<G\I?TA:WA8[E<_I=cN?fSAjXGp`HqaAlYAlYAlXCmYElYElYFmXCjWDkXHm\MraFhW?`M<\G9VB6S?4T?8XC6X@)P38fBVÑ`]Öj]Énhå~ä≠¶ôπ¥ë±Æï∑∂•≈ƒß≈«ß√∆ó≥¥â¶§Äûúzõîqïãqïá†¬¥sôÑTÅdRÑ^KÄTDzHI~FJ~@Fz:LÅ=NÉ;Dz/7k!0d+`(]'\'\&Z'Z-_*K|MQ~]_änkîv`áhGhI1K0/,- , *#-"&.##*"$ !& &*<$6R,Fg8Cj56b'6g&>r06i'7i*:k*9k,?q6Bu<YäSNHDu=Bq:Bn9InC!;"!6''8.*;3(70%1-$.-&0/#.*)#!$,C19V@8ZA6]@8]>7\:;a<<b=;`>;`?:_>;`A7Z<-O43S>7VD6UC2R=,J2#A)$B*'E-(F.$@)";&6"7!":"$<$%;$$:%%8%"#,D7<XJ9XH;ZH3TA1R=3T?4U@4V>?aI;[F7WB8YD8XC9QA3A0:=*>B+8H.3K12N72O91L91J7,A0-$#&'&&'*-"1&5 *9"-<'.@(2D*);#&4@2CR=<K45B.>J6AJ9@H9@G?7>7IQFQ\KK[A=P2<O1CX7BZ6Ic<Gd8>Z1,D 9L0+8&6>1>F;)0().'/6.:F:Q_P5C48F5ZhWL[FcoWqÄaQjBGi7>f1>f2@`79W37W2Ad<2R+7U/>Z4;P1,;&$3RhDQlC?[32N&#>=X7@Y;=V8@Z=5)(/'(4&=N<*-@,&4#!062OYNUdQ+B&,A.T-/X,+U',S&-T'-T',S&*Q"+P$-K'!8,% *'3%)7&2C01C-)<&!4 )%@!5U02X/&P"&P-Z#/a$2d')Y&P%C2& 
+
+"'<-9U>5W6-Q+#E  ?'A$1#5%@WELnSJqRLuUIuRGuPCsKGvJ?n@;k;5c4*U(83"8#04="6^<3^3"M "IE%K"8c5:l72h.1i(/h$.g"-f-i7v':y*;z+=z,B1@0?}0?{1Az5Bv64f+<k5?o;<r8;r82i/,c))\$*Z&/_-+[)0b-*_'.d*/e+0c+2^+7Z23!AZD/T2(U.+X1*W0'T-)S-&Q&.Y.6c87f:4c70_30_3!P"0`.:k4;l4;o1?s5;r17n+/f#-a#.a(8h8CrFHvO>nFGwM@tCBw?;n51`)<?'F$&F!?9.+-351+7A C:2 
+	'-7CjMErUEsVHvYFsVCoTAmR<jN8fI4cC2a=+X/"O$&Q&"L$%O)0Z4-Y5*X3&U+&U+#R(&T-.^8,[75bC:gH8cE=hJ?kJ:fC:hC"N*@*D)	
+
+(4(1D1-C,'A$*I*4W7FnLDkLDmMAjJ?hJ9dF7dEBoPDsSDvSDvSCvUCvUFwYHvYM{_UÉgSÅdO~^N}[P[N{ZL{YHwSFxSDxRG{TI|SI|QK~SLTH{RGzQH{RI{UH|VH|VFxSEwRFxRDxQDyOG{TP]CpQGpRLtYMuZCgK:U68P.4I(.F$(C$%D%%F)(I,)L.+P1.V44Y85S7$>%(@**B,+D./K2/M1-N1-N1,N3+M4*J3/L:2O=0M;+H63P>5R@6O:9L8FN9DM8@XB=_G>dM:dN<gS=hUDm]Fo_BmZ@kXAlY@kWBlXElWFmZFmZCjW@gUEi[FhZ?_P>]M:WE6SA1P>2S>2V<8a?JzPWã]Yá`^âkóæ´†¡∏¶ƒ¬•√√©«…•√≈†ºøíÆØkäÇdàzbâv\àoYÖjSÄc^ÜkT}]DtL>tC;t?;u;Aw;?v5>u2?v2Cx0Bx-6k#,b)a'_'_*_%Y(\+`(<p@JyW^ânhêxwùÑTyZGhK,D,. , "*$&&,"(.$(-&%*# "%" +"1+?$:T/Cd5Dm3M~=?p/4e$2d%2d%5g,Ar:TÉOQÄLN}IPKIuBQ{M?^<4'9),<1-<5)83#/-$.-!,(#.( +%'!"&0%9C8)3* +!$0&(5+(5+*!!$'<-8T>7Y@6[<3[86^9;a<<a?>cB:_@:]?8Y<-N11N84Q=4Q?2O;.K5)G/'C,)E.(D-";&"9%5!5!5#;#%=%!7 %8$+..F87RA9VD6UC4SA4U@4U@5XB7XC8XC6VA3T?6WD7VD3L91C-,<"5I.5N13O62P81N80L63L7)@.*&'&%&'),- 1%7!(9&(;%8H.,;& *2A.4C.5A-KTC<E439-=B;,3,6>3NYIHZ@H]>J]=J_>BZ8:T/:V.?Y49N/8J20=+>I;19. ')0)0:2;H?<I?@NAR`Q@N=4B1ERAN^DPiBIk99a,6`.?b:;Z8CeBCgA8]2=`6Aa8(C !53G.XrM>Z10O%QmE9S01J*;V5*E$>[<&>$*$.#9G67J6*A'.E+.)!(!%/'%5(1I19X6;b6;f98f76e10_+,X%)S!&P'Q*T"(M!+I%(-4R00U*-T'%O(R (R -X#4\*-R&(F"/		
+	
+ %$%%>(7V6+M(%E  >!</, 2$7S=KkSJnRLsTGsPDrKErGEsE9i95c22]/!G :43 07Y>>hD)V+!L!HCB*S'Aq?8n4/g(,e!,e!,e -i!3q&8v);x+;x+>{.<z->|/>z0Az3Cw5?q2As6As8:p46n//g**b%&Y %X *Z(+[),^),a)*`&1g-2e-5a.0U*- #>WA3X7.Z6,Z5-Y5/[7-W3)S-2_63a:>mC0`6-^10_51^51\1%P#1],=l6<o4:q07n*4k'3g%1e'0a*2b2FuIFtMHvOJyOMNFvD<k7A57??A&L'2X1:c;>h@=f>#I$@ D  B?91
+*'?)'E+&J.HqSCpS@nREsWGuYBmRBmR<hM9gJ6eC1a;-\2 M"(S('Q)'Q)&S,,X4+Y4(V/'U.&T-'W/.^8-\82_>7dE8eF6cD<iJ?lM;jF.^8.X2/P1		
+		
+
+$ 6-I07Y>GnQFmPElOAhK@iK;fJAnQCqTFwWEwTEwTCvUDwVGz[J{]_çsRÄdJ{]L}]QÄ\P[QÄ`P_GyTFzSH|VG{TJ}TLVI~RKÄVK~USÜ]K~UI{UJ|VHzUJ|WJ|WFzSByQByOFzSSÇ`?jLClNLsVMuZJnR<W6DZ6EV22F#)B"'D&(F*)J-+N0.S40X65Z9*H.(A+.F0-F02K53O8.L2,M2.O4,N5)K3)I4)D3*E6(C2(C2.J;2M<5N99L6FP8CO7?Y@@cK>fN<hQ;hS<gSClZClZEn\Cn[@kX@kWAkUDkVDkXElYCjWBiVBfXAcU:ZK8WH9UF5QB2Q?3U=6]@CoKVä\Xå\Zã^rü~¢…∑© √™»∆•¡¬¶¬≈¢¿¿à¶§zõî]ÇqNx`FtWDsSGvTXÖdUÅ`MyUDxHAxA>x>B|?D|=Cz9@w4=t0;p(9o$1g-e+d+d)a(`)^(\/d,>rBlövu†Ö}¢êÉ®ñtöÅNrV6R9$7#%/$ %!%$!& #,+C#>_2?f1Fq94a&4d&2b$-]!;k1N}GRÅMR~KGs@Et>XÇRcÜ^#= %8%/?2/?50?:+73!-) +'!,&%0*#.&&%)5)3?3/;/-9/0=31A64E;4E=%4-& 4#4P97X;4Y89^<=c>=b@=bA:_@;]B:[>.L2-K3-J4,I5,I5'B/&B,(D-&B+9"6!6!326 #;%$<$!9!$:%%6$ -%:+*A1,G64O@6RC5TB5VA5VC5VA4T?2R=2R=4U@6WD6S?6O94L25N15O22P62P81N82O92O91J7&;*+'$&('&*.0#4!#6"$7#:H11>,#(!*2%)1"EM>;A3PTF7:/:=4=C9=E8P]KPdHRgHGW</=$+:#7I1?S7;O45G14C02A.BO=$/!3>0:E72@1*:-+<,8I7GYCHW@>M88H;ObOzìsLkA9_05Z.5W6>_BGhIDfC;`5>c77^1)N%9JcFA\;&A?[3;W1;U2OjI0N*!?0K,,B+*%1%CTA 78O30+$&'3';U<BfBAl><l88j78j76e11]**V#)U 'S'S*U (M!$=
+	.E+4T--T%)S!(S.X&,S$!A1L)+D&.		
+1)D%/J),J&,L'$D!@ >(G%&F!?? >!;1*!3%1H8FaNMoVHpNFsLErIAnCCsC4d21_.+T("C$9"4'G0EnN3a:$Q& KH!H><7b4>n:8o51l,+d '`*a/f"5m&;s,=u,;u+;w-;w-?w0Bw1Au3Ar1?k.An3>p33j),b$(\$W'X!)X$+Z&,]&)Z#2c,.a)1d+6e17\17!?VB9^?3_<1]:0\94];/X6-W34`<3a<AqK.]3-\22_69c=*O-+
+B=d8<m6?s5<p.=q/8l*6h)/c#/a&5d0Al>EpES}ULyPMzOGuGE=H1\/@n@FsHJyMIxJBsD=qC?pA=k=<g:8^7'K%;70!9 2U7@eD<dB6b?CpODrUAoSEsWDrV>iN@kO?lO:gH6cB1_:0]4&S()T)*T,(U,)V/)U1.Z7-[6)W2)Y3*Z4.^82a=0]<5bC;hI6dG:hK@nQ<kI8fB6b?5W<						
+
+	-+D1FfNHlRJnTEiO?fI?hJCpQDsSCvUFzVFxUGyVDwVDwVFyZK|^O}`L{[J|YJ~XNÄ[O~Z_énQÄ`G{UE|UE|TH|UMYPÇ\LÅWLÅWH|UMYK}WJ|VJ|VI{UK}XJ|WI}VCzPD}RG~VUÑd8cG?gLIpSMvXKrS@bA<V3GW36F")A!&C%(F*(I,-N10S55Z95X:(D-.G22K6+D..G10L3-K3,L4.N6-M6)I4'D2&A0&>.%;.,D64O>3P>2R=6T<A[@EbFCeJDlR<hO:gP:gP>jSBlVAkU@iWEn\@iW@jVCjUCjUAhUAhUBiTDiWDfXEeX;[L8WH7SE4PA3P<1S:9`A?mHRÉVRÜVQÅYä∑ö†ƒ∏§¬¿°Ωæî∞±Ç†ûvóêfåWÅmYÖlWÖhFwWJ{[mô~á≤ófésS\OÄQE|EE|CHEKÉDIÄ=G~:Bw18m%3i0i/h.g-f-e.f.e!*a :m5:k<O{XßèçÆ£ã¨£â´ùpìKlQ1I1"-'&(#: -H'8X/=e1Am2Ky;Bn1;i+@m4M|EUÑN:i38g0Do:LlE@Y<(;'0@3*7.,84.:6$0,)#",$&1)$/'( !"!+ "."!-!(5+3C94GA5HD'74'#$"'-@-:T;6T88Z99\;:_>:_>:_@:\A8Z?.N6'D.,I3+F3+F3'@-;%$@'#A%<"9"6 348!";% 9##<&$<&%8%.($6(%:)%<,"8+*B46QB8UC4UD5VC4T?1N:3P<2R;4T?4T=6S=7S<4Q53P42P61Q91Q:/O81N:2M:/H5"7&&!.<-&)0 /0#4!&8"%7!6A0+6&!'/2+28.;A7CI?4:.@C8;>3CF;KQEEM@ZgUL`E=Q5,:!5>+;D37B11@+0B,'6#SbO*9$@O:;F65@0DRAESB=N>9J:3A09H3=L56E2GYMàùé£ª°Åü{9\2+P'-N/5V9?^?A`>7Z05Z.-W)7`47Z2=[9'B!%@?[5-I!(C"9T3NlH2P,#>+B(/#4$CV@(?#6M1++!+ (->,AcBBpB<n9:o77l64i35d0*Y#(W 'V'W)V'O)I #7	#*6O13V,,T")T/W#3Z+&I.G'*>%'
++>*=\:7^21X,,S&)P#%L!GCA@(K#*M%&H#+J(%B$7''"7(8Q<BcHFkJFnI?j?>l=?o=.^*.Y+(K*>#;#AeI<hD.]3L!II%L  EA*T&<k7:p67o05m,/h$+_)],a1f"6k'6m)8q,9r-;r.=q/=q/>p18f(:h*8j+3g',` (Z"S%T'V"'V"(W#+Z&.])/_+8i2;i86X3*!:Q?BdI8dC6bA6_?3\<2[9/X66b?5c?BrL*X1,[14c96`:!F%5$F%9_88f54g.:m26j,4f)2d%0d"-a!-_$-\&6a3ItIHrLLvPKzP!P$3`5BoDFuGFwHEyIAuE=q@<r@@vE=sB:l;3c3$O$866+!8#:_@AmJ@lI:hD=lJ@oO@nQCqUBpTBnS7bF@kO>kL;hI6cB0^9/\1%R'+U-1[3*W.%R+&R.)U24`=2`<1`>.];.];7fD3`A5bC<iL5cF6dH;iL;hI;hG=jI2Y<+	
+		'- "6#GgPGkQEhP>eJ?hJDpOGtUEwTI}YI}YFxUCuRDvSDwVFyXJ{[M|\J|YJ|WLÄZNÄZP[SÄaP_K}XH|UH|UH|UMÅ[VädNÇ[J~WH|VH|VK}WJ|VJ|VFxRHzTH|UG|RD{QJÉXLÉ[TÅb9aF=cJDkPJqTGnOBeE9W56J'2C'?$A"&G('J,-P22U76Y;)J-;$#<''@+$@),H/,J0-K3,L42O91N8*G3%@/'?/'>.$:-.F65P?2Q?0S=4W?9]AAfGBjOGrWAnW?lU>kTGs\NxbAkU@jV?hV?hVEo[CjUAhS@jVAhUBhS@bQ?_PDcT;ZK8WH9UF5R@4Q=0R97`BJxTUÖ_QÅ[_åmw°ã£ƒΩÇ†ûwïìkäÖaÖ{^Ñu^áufë}{ßêyßç`érsüÑÉ≠óqòÉVÅe\äf[å_UäVNÉMKÇHLÑGLÉBJ;@u-5k -f0i.g-c-e/h!/h#.e"-d#-`'1c08f?ZÖiyùëÜß†Üßûiã{MoTDaE+7)%*##$+'@".N%>d1Lu=Ho8Cl2=h0>k2]åVKzD=m3<i23V,*E&&9%'7**!)"+81&1+ )$( !+#$.% *"#$%!-#-=34DA4GE(74)%%!#.(!+"". %6$.F.8U99Z;8]>6]>:^B8Z?8ZA2R:$A+$@*$=(";&8#4:"A""@$=!:!89 ">%!='!='!:%$=($9&"4$% 1!$6& 5$0!5%#;-(C4/K<9UF8UC4Q?4O<1N84Q;3S<2R;5U>5S;2P6.O40Q64T<.N6.N7.K5,H1,C/1!*&&4%#1"("3##4$(6'%3")8%1@-$,,4'06*:=4GJA:@67=3<D9KQCV\N9?3QYLVaSO]LÖóDS<)2:A1BI9DM<LXD:I46I5YlX8K5?Q;MZF4A/)7&&4%'3)3?58D8CP?IVD4B1asgi~oaycFcD3S.,O'-L,,K,4Q2D_>9W14W-:d66b16[/@`704Ba89Y0"=#>2M*Hf@2N()B"$7#2AX<:S6"6*". "."!/ 6N6<e=<n;9n86k35j25h0._((Y!'Y(Z*W/W"?#;! ).'38V21W(.Y$0X&2X)&F3L,,@'#	 7M89Z;6_52]/+V(,W)(S%$M!"K!!J"'P(2[3=c:#J.T+/U,,R)+O)'D%/#/"$;)*F/4W7;d<:e7?n:4c-)U$'M&D#$K,ClJ8g=)X* N JH"L&P"*U'7c2>m9=p7<r49q0:r14m)/f#*_'\*^.b 0d$2i(4j,5k-6l.5l+5g(4f'0b#0b#+]%WN$P'S"(T#'S"*V%-Y(6d3:j:6a6:
+
+	7L=EeN>fK;dF;dF4]?7`@2[98d@:hD;iD'W//_73c96e;7a;+U/2Z5>h@=l@=o>@r?:l7)Y%0a)*]"/e'.d(*]",[%3_.=h=AkEEsLAqIBqGFuKCtG@qD?pCBsFBsD;m<:p?5k:0d31c2*Y+"M"F<+-5W>AlNDsSCrR?mPDrU?pR=nQ>lP>lO;hK7bD?jL:gJ8eF4a@1_:/\3'T),V..[2-[40^7,Z5&R.,X5;fH5bE7eI*X<5cG2`C3`C>kN8eH7dG9fI7bF=jK;hI3_>1T67
+"3!#9$23)B-*C. 9$)1DfMCgMBhO?gLCpOHwSGvTHzWI{XI{XHzUFxSGyTGyTJ{[P_N}[MZL~YLÄYOÅ\N}YMz[LyZKzVJ|VL~XLÄYNÇ\PÑ^MÅ[KYKYI}VJ~WI}VI}VJ~WG{TI~TG|RG|RMÇXOÅ[JvU.U:<_G?bJCjOCjM@eF7X9,G&"<"=$A"'I(+P/*Q22W8-N1 <#46 7!&B)+I/,J0-K3-K31M6.J4'B/&?,%>+'>,$;+'B1.K9.O:.T=3Y@6]@<cF@kPIv_>kTBoZAlXCmYGq]Ho\DkXBiV@jVFp\BiVCjWDkXFmZAgRAdP@_O@_O9XH5TD5TB3S>3S>3V>@mPió{Å≠îÖ∞úïæ¨}£ñê∞´vñë†óeäy^àtfê|ÖÆúã±¢ë∑™í∏´ë∑™èµ¶qóàlñÇ\àmeîp^èb\é]SàROÑLOÖKMÅCDy39o$/h/i0j0j)a-e<t3IÅB6l.4h**`$2h..c/;kEjî~Ç®ùç±ß[}mGkO<Z>':' !#% $&!!# $	"4%> )G!LmBCd7;_/Go;@k6MyHM|H@q98g0:a2'E!2,&##0'%0*#$!(!")"% !+"$/''3/.:8&2.'#""*0G37U=7[A4[@3Z?6Z@5W>4T<)G/;$7!7!8" :!;!> &E%%D%"@$ <#!=$$@'$A+&C- ;(";(&=+$9(*."7&"7$2!06&!8(5(&>06NA8RE8P@3O93O93P:1Q:4T?4T?2R;/P5/P32S62S6+L1,J0,H//G/+A,&9%&7'*8)%3$*'5($0&&"&(0!.6)?G:KQEGJ?47.17+3;.19*QZIKTCIRAP[K<J9DUBdv`+8$KTCLRDNUEOXGDM:DR;9L6BXA0C-;M7VePVeP2C0+>*$5%/!/ ?M<N]H1B/RgTaxdD^C%D".N)/R*-O**I'1L+1L+1L)?_82W,9`33X,MmD2P,PnH>b67[/>\89T37R/<X2/N%4P*$;*A'5N0AX;* .%1%#1"$7#6S5>i<8m74k44i14f1._('X 'Y&Z*Z/X 3T%%?%7!#&.#&+69Y05[,1Y'1W()I $?0D+"1
+(1O37`84b40`0.\-(V(&Q&!K#'Q+3]7<f@CmE0[0H(Q)3\4.Y.5^48]4%C!%,/6!'F'9_8;g63b,2a*)X"&Q$I!9eA>lE3b6'W'!O!!LI#M)U$*X'.Z),[':k48n46n12m-0h'2k'4k(5i'.b"(\'Z(^",b&/e)0f*0f(0d&/c#,^!)[*\%U!M"N&P #O*U'*X)6d5:h:<i>:`;5 7L=CcL>dK<dI:bG7`B5^>2[9:d@;gC6d?*X13c;1a76f<+Z.(W+6c8:i=ApDArEDxHDxGFvFHxDCv=?u9;q30d&)[ )U .X*/Z/5b9;j@;j@8h>8i<8i<8i<4e61c24f56j:5i99m<?q@BrB=k=6a4.R,"<#,5V;>gIDsSDuWFtXEsWIw[DuXBpS>lO=jK5bA:cE?jL8eH5bC1^=0\80]4(U*-Z17d=2`;,Z5+Y4-Y5.W5.Y;:eJ>jQ.\B5cI7eI1]B:eI:eI6aE8cG7dG;hK8eH<gIAiG!?#(/0/5!>"!?%"@(!A)%E-+I1(D.;%=_F=dIBmQGtUHzWHzUI{VL~YJ|YI{VHzUGyTI{VI{VK}ZL~[OÅ\OÅ\OÅ[NÄZNÄ[M|ZKzZJyYKzVSÉ]PÄZXädRÜ`PÑ`QÖaLÄ\J~XI}VJ~WH|UG~VF}UG{TI~TLVMÇXLÅWQÑ[ClJ D(4V><^FAeKAhK>eF7\;)K* ?"=&D"&I(,Q0.U65X:<"323 :!+I/,J0*K0)G/,J2+G0)B-&?*#<)#:("9'#;+$A-,L71T>1Y?3[A5]B9aF:fK<jP;kS@mX?kTBlVJq\Ip[FmZCmYBlXCmYAkWBiVElYEkVDgSBcP?^N<[K8YH3TC2Q?/O:.O:.T=qõÉè∫¶ö¿≥¢»Ωß √¢≈øzöïà©¢Ç¶ö|£ëÉ≠ôá±ùìπ¨ï∏±ñ∂±ó∑≤ö∫∑ó∑≤äÆ§ê∑•}ßèw§É]åbXàXXäWTáOPÉJI}??r-6l 2k4o2l2j,d-d 6n1^îZMÄH3f-/b'2h,7l45i;VÇgy¢íâ≠£oëÉJnT;\?6 )'&(*'%$+##(""
+	,"6"=2P,*E"<4T+Fk?Bi=GqCIxB7f05_-*J#1*##"/&(3+#""!),E25U>4W?3W=6Z@7W?5S;1O7%A*;$!:$&?)'A($@'$A%'F&,K++J+#A%#A'%C+(E/(E1#>-%=-&>.&=+ 5$/%:'%:'!6#3  5$%:+ 2&-!3*';28L@9P@5N;6R<5R>6VA6UC4T?2R:/P30N22Q2/P3-K/+H,-G,.F,(>'0&" , (GRB<G74:0*-$9?3@F8EN;DP:Q]GS_IES<AP99P69Q9AT@=L9:E4?H7FL>MVET]HLZA>P8&:!1EXBSdQK]GQhL4O01N/#@"&@%MfIOhH1J*D]?A\;Bb9*N".Q'*M%)L"8[1?_81O)3N+B]:=X7/M)<Z6OoJ[}XTyP6]0%J>^5*H">Y6:V04S*2Q(5Q+7Q.D^;8L0+"."'1(#1",B-BdCBqC<s<:q:9n82`/#Q %V(\)[0]$%F";$8-<)% /9.  ,$8'@ 5U,7[/.R&,J&'B#/F*AS='	
+#) 7M8<_>3`53a20`0)W)$O$"O&3_;=iFAmLDpM@lH*W,J&P*9a>3]95_9:`9&H%--11/N/:`77c..`%+] (Z'V"+Y+:i?9h>-\.&V&#Q#"M G!K'S"(V%#Q $R!;k9@u??y?:v:3m04l-3j).e$,b&.d*/d,,b(%[!*]"-`%.a&,_$*^ (Z#S$T%R"L"L"I$N )W)1`24c5:g<8a9&E&'"""%4K9<^F:aF<cH;bG9`C5\=2Z87_<;eA2\6,Y2.]3.^46g:'X))[*4d47i85i88l;9m<>rAEuEHxFGxADu=<n12d%(X%R'Q&P"(S&.Y,,Y.+Z.*[,,].-^/.`/+`,+`*1c02d12d15g43c12`1/]/+T*:,),M0;dB;jHCtVFwZIw]Gu[Jx\Jx[ErSBoN9gC1_;:cE@kO5cG2`C0\;.Z6/\5.[2.[40^73a<2`;/[7/Y5-W3-V64\A?iQ6bI5aH:fM1]B6aE:eI3`C1^A:hL:hL9eJ=hLMoT9U<0/6$>#$A%#A%$B&%F+'G0(H1)I2*J3*G1-M86\C?jNHwWK[LÄZJ~WL~XNÄZL~YJ|WK}XG{UH|VJ~ZJ}\I}YKYNÇ[PÇ\QÉ]NÄ[L~YHzWHzWM|XZädZäd^çiUÑdcírXágL~[J~XLÄYLVJ}THWHWJ~WJUKÄVKÄTMÇVSÜ[AiF!B%&D,6V>=_F?fI?fG9^=)K*#B #>&C$*M-/T34W9*H,2.15%?$)G+,J0,M2'E-'E-%B,&B,(A,";&$;)#<)%@-*J5/P;2X?4_C4_C8aC:eG:gJ:hL<lRHu^DpWBlTGqYEoWCmWCmWCnZAlX@kWFpZJp[IlXDgS?aP>^O;[L6WF2SB1P>1Q<.O:6YCÅ£íúæ∞ï∂Ø°¿ªó∑¥ò∏µÉ£ûÖ®°çÆ•ê¥™ê¥™î∏ÆùΩ∏ûæª†æº†æºó∑∂úºπúº∑ï∂≠°êhêu^ãdXáYUÖSRÉLNÄEDv77l$4j7p!:u%8q$;q&3h -d 0h+BwAs¢tBrB:k41d+9k6EvIgîwz°èÑ®úzúérï}[|a3M4/-+-0"0)) & '!+" *!"- 4";/J+-
+!70K,;[6Af;JtDCo<?k:.S*4+$#(&1)# %-D24Q;2T;4V=5U>7T>2O9-J4$@*%A*,H1(D-%A*'C*&E&)H(.O0'H)#D))F0)F2'D2&A0(@0(@0(@0%>+1!8$#:&"9%3 4#$6&$4',!+$"!)6-8L@9P@9TA9VB9VB5U@3U<0R9.N6-K1/P30O0.K--H)+F'-F(&:!#8E43>.*2'17-@H;EP?LZAM]BGU<CQ8<J3:L4>U;'?'2C1?M<CP?GRAOZJQ\KP\FM[B8H.3G,FZ?DX?:K88K5;R5Fa>HfBEdBIfHLgHJeBGc=MhERpJSwKVzL8[31T,8[16W,<[2(F ;V3?Z9#<";PmOlãlë≥í_É_3X/0S);Z17Q,-G$0J'5O*9U/=\3JhBNhC2-!-!"."0 -G.EhGGvHDyE?t@7i6&Q#H'Y+] 0]$9_.0% /9F5'3%)&.*A'+D&,G$/M'.N'"@1$
+ 6RcP#	+3&!'6P59_80^/,\,&V&$Q&-Z17c?>jICnPDqRDpO0^9/^2L #M)1Z:1Z82^:6`::`9-J+"=:9A'L#*T"'T(U(U'V"6d5<i>4c7/^0$R#&Q$$O"F"K*U'-[,7f8DsGIzMLÄPJÄNFJE~G>u<8n48n4;p:=r<>t@<s<5j21d,.a)'Z"'Z!&Y $UN M!L G!H#M)T&,[-/`14e69h<&O'.'""",0I42T;5\?6]@8\@8\@5Z;5]:3[67_:.W//Y1,Y./`14h7,a+0e-2g/9n65j21h12g32g35g48h66g06g/3c'-]+Y(U&Q!H$K&P"'R%'U')X*)Y)*Y+.`/.c//d.3e03e04f13e25e33c31_1(S(!G"?#I$6`:3c=;mHEvV@qTBpVDrXHvZIwZJwXFtP8fA2`<:eG9dH5cG1_B.Y;/X6*W0(U,/\51^7,Z5,X4.Z6/[72\8-V4*S57_D;fK7cJAmV6bI1\AAlQ8dI0\A=kO5cG?kP<dJRrZ=W>&<%"9"<'D&(G(&G(%F)'H-'G0*J5+H2*G1*G1&H02Z@IwZK}ZE|UIÄXJÅYMÅZMZK}XJ|WJ~WJ~WI}WI}YJ}\J~ZMÅ[OÉ\QÉ]SÉ]NÄZK}XG{UI}WMYQÅ[Xác\ãgWÑc[äjWÜfK}ZJ~ZPÑ^SÉ]K}WIÄXJÅZLÄZLÄYMÇXLÅUKÉVXãbAiF(I*"@$*H.6W<=_D;`A5X7*I'&D"$? 'F&-N/2U71O3 =!1/3#=")F*(F,+I/+I/'E-'C,$@*#?)$=( 9$$;)%>+(C0/O83V>5]B6aC6cD9dF<gI>kL?mPAoUGu[GsZEpUFpXEoWBlTBlT@lUAmVBnWFpZKqZOr^HkW@aP>_N;\K7XG2SB4Q?1P>,M88YDZ{hmé}^Äp]qZ{pX|rà´§é±™î¥Øö∫µò∏µñ∂≥ùªªò∂∂õππú∫∫ûººö∫πüΩªöπ≥°êaàm\âb[ä\ZäXTÖNJ|?;o-5m$4m 8r%<v)Ay.?t,;p*2i&6n/:o9nùsRÅW:j8@q:GyFEtH_älÄßîâ´ùtñÜfâq]ÄbMjN6 3  1!0 !4!!2 -(("$(!+"+ /"6";.G*!7 ))2!:)G#7Z2IpD[ÅXJlI"8#+&$) )4,$  &-D24P:8U?6S=5R<0P91N8+G1&B,(D-)E.&B+&D,%C')H),M..O0,M2)I2*G5+G8)D3*E4+F7(C4(@0 9&#:&$;'$;'6$2!"4$#3&* %(-?39MA?VF>VF8S@4T=1S:.N7.L4,M0,M.0M/-J+0K(<V35L0+='$&1#2=/+6(9D68D61B/KbFNeH:N5.=&;H44A-?Q;+<)2@1>J>4@2?L;GVC@O<<I7TcNDV><P4@W:"9)=$7I1H]>C[;AX;9R5)A'.G*E`?RmJSqMKkF9Y22R+,L'*H$,J&9U/D^95O*Ga>4O.+F%'D%VsW_{bqätD\DC\?5M-3K+@T85G-K]CH[??W77R/:X2IgA%@01$7$43Q5InLFuIDvEBrB4b1$P&R/_#1^%'K0I)-#,=H7(0! 5D/-A(,C'$? &D"*J%*H$%C!"? 86":",D.H^I,=+,'"*'2=/%0"$2!3I2@]>6_3-[*&V$(X(1`4;iD?kJDoQGtWDqR6bA!M*=lB(W-$R.+X72_>4b>7c?8b<)N%3X-6^,%MB::"B%H%J+T(8c8:d<5b9/\1"P"'R%%P##J%N"*W,2a7?oGHxRHwSJzTK~UJSH}QKQKOH|LHyJAuE9o>6l;:n=<n;:l90b/-b,#X"!RM KGB!H+V(5e34h77m;6l;;o?4c7?+(&%-*C-*M/.S22W83X93W;5Z;6[90V12Z5)R*,W,/].1c.-d*+c&.f'.f'1g)2h,3i-/f,/d,0e-1d,1d,0c*-_"%W$T%R(PB!E&K"L#N (V(*X*1^38g96j95j62d/2d/2d11e45g65g64c54a62_4/\11_19j;8kB=qKCuR?pP=nQBsVFwZGxZJwXHvR?mH1_;5bC5aF6bI4`E/Z>.W7,X4+X10Z41[5/\52_80]6-[4,X4.Z6+W4*V56aF=gQEp\<gS1]F<hO>hP.ZA@lS7cJ<hMAiOD`I/E.+:%#5"9$>!#B#"C$&D(*F/+G1+D1(A.(D.,I3(J1=hLO~^M\KYKÇZKÇZOÉ]K[K[LÄZL~XMYK}XL~YM\M\OÅ\NÄ[TÑ^UÖ_OÅ[OÅ[KYJ~XLÄYNÄZTÜ`VàbTÉ_RÑ_PÇ_LÄ\J~Z\êlXägLÄ\LÄ\NÇ^OÇaVäfUâbQÖ^QÖ^[çg?kH/T3)J+%D%)G+5S7;X:4O0-E%*C#&A",K,1R5/M3%?&!9!506'A((D+&D,)G/*H0'C,'@*%>)&?*#:&!8$ 9&&A.,I31S;2Y<6_A7bD9fG:gH;hIAnQFsVFrWQ}dLv^GqYGq[EoWFnVDlTElWBlVCmWEmUFlWQt`No\EdRFeS>]K6WD1R?2O=3P>-L:/P;<^FIpSS}YS[Q|^[Ömã±¢û¡∫ö∫∑úºπüøæ°¡¿°øøõππô∑∑ñ¥¥ùªΩ£¡¡ô∂¥vïçhéy_àhYÜ]^å]^é\TÖMAu54k'6o(5q'7u*>z0=v1>u2?v5/g&0h)8o6PÄVeïo<m>7i6CuDGvLWÉbsõÉã≠ümè~GnOHmKJgI%;$"4$"3#./ 1!.!- ,&
+"'"."&4##6"%=#+E*!92.-0!8#<E_Bxïyoâp.C2. %"$ *""!!)#'0E45N93P:/O80P9/L6-I2)B,'@+(D.(E/+H2)G-+I-+I-/P34U:-M5,I5,I7-I:)E6/J;+F7*B4(@0%>+#<''>,!8&3""4$ 2$*!!% $1*1A66M=4P:2R;.K5/M5+L1,M0-J,-J+7U1Fb<;T6/F*(;%#(3%;F8:E7/;-4E5)?*E_BE`A.E)*<$<I51=)4C.)8%1<.6A3;F8AP=FXBAS;JYD(7"DV<<P4>V6E\?DX?SeMj}a6I-);!&:!8O5CZ>E^@7R/+I%#A(F$'E#(H#*H$3N+:T1?W5LdB*A$6O1!<3Q/B_AA[B.@03D22A,5D-)8!=L5KYB/?%%54H,6Q.1O)/M'=X5/H*/G-1G2.F.3T7FnKFuI?q@:j8,[',X#2]'7b*>d3/"$(%2 5B.4=,*5D1,C).G*3M07T5?];?\=8Q47N47M83F3/B/+=-)>-@UB7J7,'2$7B4$/!+6(,9(*-F)9[6/Y+(V%/_/7f:8f?;iEHuVHuXGtW@kO#J/*Q4FrN3c=*Y7.];3`A:gF<jF:g@+V+3_.9i/1a%*R"G61/0=1Z25_7:g>(V($R$)T')R&"K%N$-Z14b=?nJJyWJyYIxXHzUDvPEwRJ|VJ}TK~SJ{NH|NF{M?uD4h87h9;m<:l;5i8/c2*\'&U!$P!K J&Q#;k9@r??uA@vD=sB@tF<pB6e;%J)3+*0#?&%F''J)*M--R1+P10X67_<.W/0Y/&Q$)T&1a-2h.2j+.i).i)2j)5m.7o26n16n19q48n49l35h-.a&(Z"T!S'T)Q:9&F$K L"M)T'/Z/0]22c4/c21c24f36j96j9:l;8i:8g;6e93b6-^/6h5:n=:oEBvPDxTCtTArTEvYJ{^Iz\KxYJxTFvP3e?2`C5aF4`G2^C1Y>-V6+T2.V3,Q//T20Z6/\5-Z3.[40\8,X4)U1)U2,W;<fNIs_@kX5aJ;gPBlT/YA?iQ6bI;fKElQ6R9(?%"4 28!> >>!?#(D+'@+)B-)B-(D-4U:+R5Q~]NÄ]OÅ\OÉ]NÇ\PÑ^OÉ_MÅ]LÄ\LÄZL~YK}XK}ZM\RÅ_P]PÇ]PÇ]SÇ^TÑ^OÅ[NÄZK}XNÇ\NÇ\OÅ\RÑ_XäeVàcOÉ]NÇ^MÅ]NÅ`_íqZçlMÄ_NÇ^NÇ^OÇa_ìoXèhRÜ_Sáa^çi<eE7\=2U5-N/'F'+H*/H+-D'-B#+C!)F'2S4:[@0.6347(D-%C+%C+)G/*F/%A**C-$;'%<("9%!:%#<)'B/2R;7[A7^?7cB9fE;hI=jK=lLBpSErUNz_R}bMw_FpXEoWDnVEmUFnVMt_RydGnYCkSDkVGmVHiTCdO?^L=\J5VC2S@3P>1N<.K7-M6+P1<f@TÉUOÄQRÄYhìuÉ™òöΩ∂úºπüøæ°¿¬†ø¡å™™}õôå¨ßzõîxôíòπ∞Üßúbáu]àjWÖ^VÖWTÑRTÖNK~C8o,8q,:v09u-;w1A}7Bz9Bx:9q00h'0k)8o6>qHt£bêkEsLYá`^ågeép_ÖnzúãtóÉSz[DiG1K0 3 0#%3&"0#.!- - - ,,'$*%3$#6"%=%*D)631320.$7$G\Kavg/A5."&"!"$'-B12M:0M7,L5,I3,H1*C-'@+(D.+H4)I2(F.,J0/M30Q67W?3S<.N9*I7)H8)H8/K<,G8&>0)A3*B2(A.#:* 7'2!3""4$,%
++!.@23J87P;2K8/J7-K3,J0-K/,K+/M)6T0-H'(A#'@##6"!;C4.9+) )5+5E8;R>?\@7T5<S60B(-9#BN84@*4@*4?.>I87B1HV?=O5MaEDW;3F*FV9<O1+B%KbFOeN[oVo~gSaHFU>,>&<P5,C'1H+)A!*D!$?1*E$-P(.Q'1Q*Gb?JbB2E) 2$8.I(<Z49T12I- //:*5B.3@,)4$2=,SaH?O4-@$<T4?[57S-5N.1H+<U7-F)1$<&9Z=BlH9m?2h4+`(+\$1`)4_*+O!=X5#,3E+8J05@/#.!23K31O3>\@A]F=U?-@-+  ( 5B8GUF!6;4&.!;F5'5S/5Z/*T&+Y*6e9:hA=kGFsRGtWErUAnO:aF8$4Q=IpS=jI/`@6eE1^A<gI<iH9gB7d;9g8<n1-`#S%P"J<+	(83\4:g>6c8)W)'U'*U(-V,%N$$N&0Z64`?;fHErUIwZJyYL{YIxTFxUDvQDwNExMDwLFzLINE{I9o=;o>8i:7h98i<3d70`0.^,*Y%0a*7g37i4?q>?sB<r@=sBAuGAtK>qH:lF:hC4];#H)73=  A"#E$$G'&K*)R01[7;e?+V+*X)+[)1b+6i02i/2l14n38r7?v<>u;;r93j00g-/e)3f+7i./c%%Y#W"V"V&V$L00=$J!KJ#O&Q$/Z/4a84c76g:6j:7h98i:6f66e75d85d84e84e6;m<>rBAuNEyUH|XFyXGxZIz\J{]Ky\JyYJyWEyR8lE2cE3aE2^E0\A.W9+T4+P/ C##A%-N13X71Y61[7/Y5.X2-W1/Y5/X6.W92Z@DkVHr^<fP7aI@lS1[C8cH:eJ=eKElQ/P3&C%39"A!&H')K*(K*(I*'H+)E.)E.)G+&G(1Y7>jFPÇ]NÇ\QÖ^RÜ`OÉ]Sác[ånPÅaLÄ\MÅ[M\J|YM~^N_NÄ]OÅ\QÉ`RÑaVÖcTÉ_OÅ\NÄ[MZWâdVàeSÑdgñvközZãkOÉ_NÇ^KÅ]MÅ]UâeTáfSÜeTàdQÖaRÜbRâbQäaQà`Vàcfíq0R78X@9Z?5V90Q2.K,.G'2G(.C")C .M-7Z:<_A"C(*!;"9!>" <%&B,$A+'D.*F/&B+&B+&B+";&!:%!:%";&#>+/L87Y@7^?:cA;gD;hG=jI?nN>oO?pR@qTFtZIu\Iu^Jv]DpWEoWFpXGqYFp\Gq]HoZIp[AkSCmUAgP?bJ>_J>_J5VC2S@3P>2O;-J4*K01V4Q{S]ç]QÇSVÑ]kñzéµ£õæ∑¢¬ø¶∆≈¶≈«¶≈«ùªª~ùòhä|càv_áoZÖjVÉdM|XExM?uCBwCCx@Ex=Au5=v1Az5@y4>u2SäIJÄBBx:@w69r.2m).i'@w>K~Uu¢ÖÜ±ñ^àpdètz¢àWefåulì~WgmîwUxZ/G1!!&%&)+ ,  ," *!$!%#1" 3&>&*D)876!:$;!"5!$%"2'1A7%5*)'%(! %+!+B2,G4,I3*G1*G1(D.%A*%A*'D.+H2-J41N81Q:/O81T<5XB-N;*K8*K:)J9-I;.H;+C6*@4,D6+C5&</!8(3$0 #4$#1"&
+				"(*%3"+=-1C3,>2+?3.E3+G0+I-)J+*I)(G%.I(&A #>#:!02=,)"."-;.:L>=RA?W?=U;;O4;K1-;$JV>?L2HU;AJ7?H7>G4@N5DT:K^B>N1:J-<M-2E'/C(;R8PcMbt^ET=8F/9G08G0+=%#5#5"6C[92L'1-K)1T,0S)@^:JcE7I1@O<3A0 3$?7V-3O'%=,*5%=H75@/*2%+6&6D+K^@;P10H$Gc;>Z4%<#7,C';R62!9!+L/=eB9j;1f2/_+5a.3Y*3S*9-D** $3 5L01E))8# .3F2BZD>ZC4P9"9',&*3.WcW#*".3-%+!:E4'96Q.2U+-T(5^47c?DrNEqPJuWFqUEmRAhK3$&</OrZAlP7eH<jM8cH>fK?hH6_=6^;7b5:k3,_%X$U$R#NC!A*N(8a9<i>1`4&T&(V(*S)0Y1%O'#M'-T59`C<dJ>iNHsWLy\N{\LyZIxVDvQBuLBvHDwLPÜURàTIÄI<r>1g3;l=:k>5e;2b81b30b/.`+5j49p9<s<<r>@vD@vD=qA:mB:mD;oH<pI;mG=mG>lH7`>+R3D#A @B"'L-9bB@lI7a9(V(,\*0b-7j18n48o67q7;r;:q:6m63j31g31j35l25k/9k01c&+_*^(]&[(])YF
+-1:#I#N LM L$O"+V+/\3/`3/`37h9:k<@oA@mB8g=4c73d79m==sA?tFDxQFzVH|XBvRCvUFwYLz]Lz]KzZI{XEyR=qJ3dD1^A/[@,W;,U7,S4/R44.+D.,J0,O1/T3.V3/W4/Y5,V2*S1-T50W:4\BDlTDlT6`HGqY7cJ4^F;fK:bHDkP$E( ?:$C#,N-0S2)L++N.)L,'H)#A''E)*L+)O(<f>O~TQÖ^NÖ]Pá_OÜ_OÉ_VâhXâkQÇdOÉ_NÇ^N_M~^M~^M~^NÄ]PÇ_TÜcXägWÜdRÑaNÄ[PÑ^TÜaZåiYãh[åleìv_çpTáfPÑ`LÇ^KÅ]NÇ^RÜbYäjgòxbìsUâePÑ`NÖ^QâbTãdXácbãm58#'C-/K42N5/I,1H,8L04L,1L+6X78];3V67X;&D(&C'&C'(D+#?(%A+$?,%A+*C-%>(">'!=&!:%7"!:%!<)&C/.P88_D9bB9eB=iFAmL?lK@oOArRArTArUDrVDrXFr[Gs\EqXEqVFpXEoYDnZEo[FmXFpZAkS?iQ?eL<_G;\G9ZE3TA1P>1N:.K7/K5+I/6[9dèdr¢rXäY`égï¿¢ù¬±úΩ∂ùΩ∫¶≈«¨ Ã®∆»£¡øîµ¨YjR}_GuQ@sJDyM?wF@yFF|HIÄIIEDx8>u2D}8EÅ;F;D{8KÅCMÉEE{?G@=u48s1/j*=t=Xäd|®çâ∞ûà¨ûsòáà≠õoîÇaáruùÖjíxwûÅrîyCZF# &'"
+
+!-2%=%(B'!:!:$=#<&=#)<(+"(,#(&*/ 2"'"**A1+D1*F0*F0'C-(D-&B+(D.,I34Q;5R<1Q<0Q<3V@5XD8[G-N=+M<,M<+G90J=-D:+B80G=0H;)A4%;.!3'/!#4$6D7!( 		$'+3$$/$3 &4%#1$%!1$)>+.H/)G+*I*(G'(E&+F%(C"!:"6*9H1-?'-@*>Q=7H8"3#7H83D45C2ER>8F/P^DDS4.= )0 ,2$1:'9E/5A+@L6<J09H+4D)*<"3G.7J4@Q>1C-2A*-<%-<')6$1>,#.)4$"1:R0:Y0-M&2U-0S+5S/9P3-?)"."(4*2@39O:1O+/S'/N%'A!0+8&AN:1>**2#,5$7E.EX<=R1=W0@_68V0&= -1*>%>R9";.K/7Y8=h;3^0:a59W3#7$%7H5 . 1'8%*A'.G*32E/<M;9J:,>.'9+'7*'5($0& *!%&,(\gY"-$!#&'! #.6'4A-(<!-H'0O-:]<CjKIrRIrRElM7[?:ZB.G2
+-#BaOCkS=iP@lQBlT=eJIlN5V76W80T0+U%+[*\'[#V!R&N,R#1Z.7b76c8+Z.!N#!N#&O'0X3)S-&N+*N27ZB<bIAiOBiNCjOLtZMx\KxYGvRAtII}MUä\VåZQàQD~DHF7n71c23d55d8/`30a25i87m97p;:s>9r=6o::p>=sA=qA<pB:mB6k?5j@9kE>pK@oK@nJDpMAjH,V0B> )K0FmPBkK7d=*X**\+2g19n8:o9:o;:p<@uA?uACyG=sA6l:9o;9o50f*-a#*a )`*a(_+_,a,\E7BBE&N MLN&R!#N "P")V+0_30a2._2.]3/]6/^43d75i8:p<>wD@xIEyRI{VGyT@tNBvRFyXHy[GxZIzZJ|YGyTBtN7fD.[<,W;+T6)P1,Q2)J-/&- 7#)E.6W<4Y:/W5-V4/X6+W4+U1+T2-T74[@CiP<bKGq[;gN/[B:fM:dL>dK= <!> &E&(I*)L,*M-,O1,M0-K/&D( B!'L#:d6gídUÑXSÜ]TàbTàbTàdOÖaQÑcQÇdPÅcPÉbMÅ]L}]N_MÄ_NÇ^NÇ^OÅ^YäjXágVÖcRÑaOÅ^PÑ`VäfTÜcXäg`íoZãkXãjSácOÖaOÉ_QÖ_RÑ_TÜc]ãnfîw\ãkTÖeQÑcPÜbWég\êj^çkZÅf'%'()(16L5;U89X87Y84W63V5:]<7Z:+L/(I.&D,&C-$?,#?)$=(&?)";%";& 9$8%5"9&$A-(I4/U<7_D;fH=iFBnKNzYKvXGrTErSCtTDuWFtXGu[Er]Dq\CqW@nTBnUBnUBnW@lUEoYFpXDlTAgPAdL<^E:\D4U@3R@1Q<3P:3O9-I3+I/8[;ZÑ\VÜVQÉRWÜZnöyüƒ≥†ø∫ú∫∫ï≥µö∂π¢æøõ∫µvòäKvXDtL<p@BxFGÄMHÅNIÇOOÖSSáVI|D8l.8o,>w3C~:D;FÅ=C~:A|:HERâPCz@Ax>4n3;q=EwQz¶ãäÆ†ï¥¨Ö¶ùxôêÑ¶òÄ•îwùÜHoTRyZhäoE\J!.0+
+ 
+ +.#;!'A$$= 8%>&?!'>"$:#1'(''&*0!4!,#!!!
+(&;*+B.+D/(A,+D/+G1(C0+H4/L82R=3R@5VC4WC4VE9[J1SB-N=-L<1K>1K>,F;)C8,F;/I>.E;+@7#4,.$* !-#	 (-8')6"(7$#1" "!4!*B*,F+)F((E&'E#'E#'B!!: 4/. +$7I17K29P6;N8(6'".")5+7C9DNC,7&LZCScFL];.= )4=*IV<;I/$0:F0:F.7C+:H1'6!<M:4E25C2.?,-A(9M40?,*/7*&.! +#59S0:Z10U,.S*2P,;T6);#'4#!$- ':&;V54T+,K"-H%&:'9#<N6/>),5$.7&@L6AQ6AW3B\53T)?_8(A#22C0AR?8L36,C)0J-:Z51Q,6Q0+DQ@ )"6%<"-E+&>$)?*,?,!2"/"#/%%! $$)#%*$ %"'#U]P,4% #(+$$* -5&*9$0%<"*D)9Z?:\AChI5Z9A 6'$<&%-(J1;cH>fNBiTEjYLm\YtaQjT;W@.O0+R&-\%/b(^%]#X$R&Q.X*4_42_4'T)"O$"M"%O'2\6,V0)S/*N24X>9_F=cJ.R8@'1S;GmTHsU?oIBvHNÑRWç\QäUHÇHA{@RâOAx?-_.-^/0_3._0,`/5k98q>5n;:s@<u@:s>8q<7m;6j99m=:p?<qC:oC5gA7iDBqMCrNAnMCqMFtO6b>!H)@$:aF@iI1[5-Z/1c23h44i59n:BvFG{KCwG>rB=sB@vEDzICyE1h/*`$*`"-d#,c -d +b-d!.b )YH*O#*O$#F>%K#N$Q$S3b,%Q!M$O",Y.7d96e;3a:5c>2`9/`39m<?uA?yG@yLEyREyREyR?sLBvRGzYFyXI|[H{ZFzVFxSFvP=kG+Y5+T4+R3+P1*M/%C)'#%)6"-I20Q63U:5Z;1X90W81Y70X61V50U67[A9_FFnV:dL1]D7cJ>eP3V>67!> 'F'+N04W90S50S5/P3*K.'F'ABDn@lölUÑZSÖ_TàdYçiUâeOÖcPÉdPÅcPÅcPÅaMÅ]M~^NÅ`LÇ`MÉ_QÖaPÉbSÑfSÑfTÉcRÑaPÑ`OÉ_QÖaPÑ`TÜc]èl[çj^ínUàgRÜbPÑ`RÜbWâf\çmWÖhWÖhXágVágSÜeSâeVåhYãhbçoPrY
+ !!!##8%4N55T54U65X78[:9^<6[:1V7,M2(F.&C/$?,(A.%>)";%#<&!:% 9$8%6# =)&H0-S:4\B;fJDqRIvULyXMxZTaKvXGtWDrUEsVEsWJx^N{dIv_CqWEqXDpWGqYHr\BlTBlTEmUDlTAgNBeMBfL<^F7YA2S>3S>:WA5Q;,H2(F.,M.@iARÇPSÖRUÑXz¶Ö§∆∏£¬Ωö∏∏Ç††Å†õÄ°öcá{R|fJyWJ}RAwFD}JKÉRMÖTRáYRÜVVäY>p;8l.;r/;s2G>EÄ>GÑAEÄ@FÄCNÑPZé]BxD=t=0j05n9I{U{ßéã¨°|õïÜ•üZ{tpëàâ≠üyüäElQHmLJkN<QB 01,
+)-$<"'D()C&$=$=#<";6.''((((,/+  
+- );+)@,&?*)B-+D/(D.*G3.K71Q<4SA5TB7XG6XG9[K;]L1RA,K90K</I<,H<(D8)C:,F=1H@-B9(91 0&) '	$1/>',;&,9'+	
+(&9%'=&)A')C&&C$%C!(C"'B#86(:",;()6%6H28J4@S=/@-) '(2*1;2MUJAJ9BP9XgJN_=EV47F)<L/G]7,E*=!5E+*6 1=)%22A.#/!-9-,9/(9):R8?V<(%$)"!).,E(Bb;6[00T.+J(4M/6H0(5# ("$!,3B/);#-D'7R/6T.*E"%>3J..@**5$=D4HQ<>K/EY6<W.Ef9<_53N-PfOj|l~è~êz@R:0B,&8");%"4/>)#"%AL< (,>&(<!)?(1&<'%:'1!,#!"#("%)+&DJ>:B305.!&!$#)$,'4#-,!9#'C*,K+#G!,S'3]/C:c7(Q'#N#8e<F"1X=@_Pf|áõúàõóbwn3K=$D,.X0FyA;t/1n!+f&_%X#P(R .W+3^1+V)%P#!L!&Q&/\3+X/'T-+R3/V97^C:aF:\A.53S;;eA@qDLÄPTäVQäWLáO>z>@z=KÉF?v<2d1%W&)X*._02h64m:9o=8n<7m;5k97p;9r=9r=8n:5k92h65k::oA>qH:lF:iE>mKApP>mM>mK?mI7e@K(D',S4.V30[0<l<F{GI}MJÄOExMBuJEzNF{OH|NG{KBxF6l80g.0h+0f(/f%1h%.e"-d!/f#/f#,^!2^)Gn?-P&$D6$B$J%P&S$S"Q L LH'P&-W1.X4.Z61^79h<CuDBxF>vGBzMCzRE|TD{S@wO?uQAwUDzXF|ZF|XFzTGySGySBrJ-[4*R0*O0)L.)J- =!'''&+18#%>))E/.L4/M55S95V95X81V50U43Z;>gI6aE1]B5`E=cL$F.4;$B&&I+-P2-R3-R3*O0*M/(K+$E&> C"4\7\àdUÑ`QÖaSâeUâeTàdRÖdQÑePÅcPÅaQÉ`NÄ]NÅ`NÅbNÑdOÖcRÖdQÑcQÑeSÜgSÑdRÖdQÖaPÑ`RÉcRÉcUád[çj_énhówYälVâjTáhVàk[ån[ånWàjUÜhVäfXåhXåh_ìo]ëmbëoiítDbJ#"##*'>*4N53Q53T56[:7_=6^<4Y:0Q6(D-&A."=*%>+$;'":$":$!8$6!7$9&$D/*M52Z@8cG>kNLz]N}]M|\JyYL{[N{^IuZKw\Iw[Hv\M{aHtYKw\IuZHsXOyaMu]Mu]GoWDlTDlRBjR@fM=cJAhM:]E6YA2S>2R=4Q=.K5,H2*F-'E)1W0SÇNXäU^çcqúÄúΩ≤¶ƒ¬èØ¨kéáZÉqIw]Hy\J}\QÖaRÑ_OÅ\gôsTÜ`RÜ_[éeSáYDxG7l4<r4@y5=v2C{:HÄCj§jVçVOÖSlùpNRBvF>u>0j05n9NÄZà≤ööª∞â®¢éØ¶gãÅaázä∞°}§ëJqVJmM,I+#0&'(#"##""")-":$&B)+E*'B#&A"&A "; 7.'!$%&&&('%3&'9)'>*+D.)B,'C,'D..K51Q<1P>4SA8YH6XG9[K:_M<^M0Q>2N?.J;-I;+E8)@6-D:2I?+@7*>5!2((""*+=%);#.%1#",!# &"# . 125 !9!&@%'B#%@'B#(A!!8-+<)3D17H5(6%('.&0:1.8-CK>QZIP\FWfI7H(9J(>N1=P06P)/I".C$0@&&1 '/ 3>.4@2'1&&2()6,7I9;S;4L2!2*)!/1H.?\=6[22X/,N)!>*>%2A,7B2!# *!<G72=,+6%/>)/C(7P0=X59T1@W;>P:OZJfl^PXCCM4AR09R+A`6:Z1A^?\v]cueVdU;J7*9$4A/$/)4&*5'GRB%&0'.8/*5%:E4! -.@&2F+22"5"/"4$ 1!! $$"!!#("$&!14)FL>#+8@5!&"#+  +'4#%6#,B+5#B#4V17^29e4:i33f.8k36h35g49k:.]1;bC/N<PfdoÅÖzàã`pmdxo_|hBlFBwC>v7<x0?|/0m &^$W M%O/Y),V(#L !J(S(*W,/\3(U.,U32Y:4[>;_C9\>="8!+I/AkEEvGNÇQQáSLÖPGÇJ<x<>z<B|?Ax>7l6KO-a05k92k83i76l:8n<9o=;q=5n74m64m87m;8n=6k=4i=8kB<nHApL;jJ;iLCqTAnO:iE:hC1]9 H&>#I$3\4;j<9m=;pB=rFF{OKÄVEzP?tHDxJDxG3i71h15o50j/4l-3j)5l+1h%1h'5l+4k*+]",V$Ch=*H$3(1=)Q&S#S PN L JG!J"-U23[81[5;j>FwHDzI@xKAxNByQF}UC|Q:sJ>tP@vRBxVFzVEyUAuODvPFyPCtG+Z0*O-)L,'J*'H+;*-0/0311366: )G-2S42U41T31V45\=3\>1\@5]B4W?9 5='J,,Q22W80W8&N,)Q/(P-&K)$E&>'J*<cDVÅcVÖeSÜeRàfTàdSácSÜgQÑeRÉcRÉcRÉcOÄ`NÅbPÇeQÑeRÖfTáhSÜeUàiSÜgTÖeSÑdQÖaQÖaRÉcVágWâfXägdìsmõ~_çp`ëtYãn[çpZãnZãmXâkXãjYçiYèkZçl^ëpcïreíqoñy8T=!%$%%-+B.3O65S77Z<7\;9^?5X:2P6)E.%@-$<,$=*!8$"9%6 6"4 5"!>*&I1/W<5`D=jM?mPGvVJx[KzZK|\RÄcN{^Lx]TÄeSfJv]Hv\GsXJwZFqVHsXRzbKs[GoWIqYGoUEmSAiQ>fL<dJ:aF9_F4W?4U@5VA3P<,I3,H1)G-$E&1W2WÖVfñf}©Üñæ¶òº∞†¿ªüø∫uôèWÇnIz]H~^_ïu|¨íÄÆîÄ¨ìáµô]ålTÜaWä_KÅP6m65l2=u6Bz9=u49q2@w>eõiz≠Çr°}y¶Öw•ÅQÅWCwF2l27p;JyUx¢äì∑´ì¥≠ì¥≠ãØ•Ç®ùâØ¢söáOu\MnO'A& 
+!'%%"# ( +)-!9#%>(,D,*D)(C$)D#$=!8/*%%$$'$%# #$4''<)(@*(B)(B)%A**H01N81Q<0O=6UE7XG4VF5ZH@bQ6YE1P@.M=/K=)E7+C6+C60H;.F9*>30&%''9!-A&/" &",$)3(%2!!.,--05!99";'@"(?" 4#!.A++>*1B/!/!,+6(7B4:E5?J:BM<HV?AO54D'/?"5G-6H.9N//D#+;!)7  ()/#;C8 () "."6H8@WC0H2.F,5L2.G*75P/<[;'I&1S.2T/7U14.@*(5#9F4('1?0BM<5>-6<0/7*(*;(<S7<U7CZ>:K89C8BH>UYJW_HLY;5F$7O-9T3>]>=Y@3D2*6(%2 +8$4A/!,$/!2=/6C2#/!$%)=H7+8$/?%3G,(?"+B&(;%!/ #("3!$0"! "#%" '*!IM?3;.-8*#"."0>-->+)@&)C&CeB7`65c4=h;:h9;k9<n97l6:o97l87l88l;4e65d:1X90L=%:5?KKT^]Xe^\s_9a<K}LAv>Bz=@{;?|78t**d#X!O$L!E#F E+T*'T+-Z3)U11Z:4]?5\?4[<1V5=91T4SÄWMÅQNÑROÖQMÑMA{A8t8@|>;v6Ay:4k1!V )^*1g35k77m97m94j62k62i26m67n74m62k82g95h=8mC;oH:lG8jG=lLAoRDpUCoTFqS@nJ9eA3`9*R-G#I"6`8BrHBwKG|PJSC{NC{NF{ODyK?sB4i54j6:p<8q:7q78o58p34l-1i(1i*7o09m/!PB&D"3&"*+K"9_,+W#S"R$SN#OJH"H#-R01Y4BoFI}OG|N@wMB{RC|SD}TD{Q;rJCwQDxRDxTBtQAsPBtOExOCvK?sC+Z.#H&%F'%H($G'!@!#B#!B% A$+N0.S2,Q0(M,)L,"E%#F%A 928&G(0R1.P/1T31V52W83W;'K/<C"*R/1Y75^<6_=1]:/[7-[4-\2/Y3/R2>!%J+KtVTÅbUÜhTáfSÜeQácSâePÜfPÜfSÜeSÑdPÅaM~`OÅfRÑiVájVáiVáiXâkVâjUàiWÜfWÜfUádTàdSÜeWäi_ìoXåh_éncëtdív^èrWâl[çpZãm[ål_êp[ém[émYèm\ír[éo`ëqeíswûÅ,H1!&&$'*4"/H33O85S77X;6W:0Q40L3-I2&?,":*";(!:%6"6"4!27"%E./U<6aE<iLErSBsSFxUHyYK|\N}]SÅdTÅdQ|`YÑhXÑiMy`Kw^ItYJuZDoTFqVIs[Lv^Lv^Lv^EpUFqVFpX>iN:eJ:bG7^C1U;/Q90R:4Q;0M7-I2(F*"G%FpLjòsá≥íÅ©ëgå{gç~ê∂´ûø∏|†ñÑ≠ùw§èqûâå∑§ù√∏õ¡∂Ö´†jìÅXÜiQÑ[OÉS;u;2n04p0>y9@{;C{<8p3B{Deölâ∑öé∏¢Ö¨ôÇ™íhïtN~T;q??uDEwR^äqç≥¶í≤≠ó∂±ó∂±wòëxúí~£íY|f?]C8$ %))(%   (+,"7$4 &;(+A,(@&&?!$=!:1*$%&#$##!
++'9)$;'%=%&>&&>&'@*.J43P<2Q?0O?3RB3UE2WE6[IAdP4UD.N?.M>(G8)C6&A2*E61I;*>3&5.# !33G+-A(/&$"&'(!--,./)<(#;#63!4%< &=! 4-'=&(;%->+0>-&3"2?-/<(8G0:H1*: 4D)9L.2E'1D((7"&5 =M3;K1(6#/"+?G:)/#'/$+7)1B0=U=2L14'@#.I*8V4?b:Bg>5[4+Q*/S-+M(6T0!:/.;*<I8&5"#6"L]K*5%)/#),%$)" %%1%/B,BZ@<O9-<)&-%:?8BD7IN:ivZ9J*>R6;T7<]>7U9;N:;H6.;'5B.1>,+#/!COA,:)+ )8E37F/4H,4K.&?!4M/0D+&%3"-;* ,!" %!#($*-&=@5:B3'2""#1$1D14J30H0%B$&E%9_88h62g14f39k:8j9:n=9n::p<7m96j97k:4h86g:5b;1U;:)-&BNJ@PEF_I@hCHyJBwCAxA=w=;w9?|6A}3;s*)\"N!F!B#F-T(*U*-W1)S/1X;3Z=7^A0W81V5?!D$7_<SÇVQÖUJÄNKÅMMÑM=t;<v;=x8=x6:u54k1,c*3i55k75k78n:8n:9o;4m82k42i23i50i4/e42e:7jA7iC<nIDvSJyYEsVBpSCpSCpQ?kJ8d@6c</Y1&O' I"K#DnHL|TF{QCxNByOE|RF~QGR;q@4j66l8<r>AwC8q<:s<5o57q64l/4l/6n/<r67i.F"B3-"$*-H%UyK7_**W)Y+\$NMKHCC#M%DsGJ~PE}PCzPAzQB{RAxPAxN=tJCwPBvOAuO?qL?qLFuQEuM>rD<p@-\0C "E%(K+*M-)N-2W63[94\:6_=9c?:d@:d@;eA:b?9a<6^94Y82W6.Q1-N/(J)'I&*L'*N**M,,O/&K,(P.-W32\83\:2^;3_<3a=4b=1a93b85_7'J)4C$Q~_TÉcTÖgUàiTáfTähSâgPÜfPÜfQÑeSÑfRÄcRÄdRÇhTÑjYákZàk\ämYälXämWâl^åoYájTÖeSÜeTáhWäkbït]énZãm^åpfîx\çpVàkYãn_êraír]én]êoZên[ëq^ìu[êr`ìrfìtxüÇ:$#$())(,#:(1J53O84R84R81O5,H/*F/&?,!:'8%8#5!6"4!3$@)/Q88cE=jKLyZVÉdM|ZI{XK}ZK|\Lz]M{^Q~aP}`TcSdS}eT~fLv^Lw\GrWFqVEpUIs[OyaS}eLw\EpUGrWBmRDlRFnS8\B6X?1S;/O81N8/M5-I0&G*%M+rû{å∑ôâ¥ôröÇSzeP|e]àtnîÖá≠¢è∑¨îº±îº±öø∑§ƒ¡†¿Ωá™£hë[àiSáY?v?3m01o.6t1KÖHIÄFVåR?t<AzG[êfçπ†ìπ™|†îÖ¨ödèsSÉ[;q@BzIWãeQe|¢ïç∞™ëØ≠î≤∞}ùò^v]ÉnhãsMkS4 %" !!!! #$&+*,&!!$**$7$0,!2"&9%$;$;$<5-$%(%#""0 !6#&<'$:#&<%'?''C,1N85R>0M;,K;/O@0RA.Q=6YE;\K0Q@/P?)H8(D5%@1%@/.F8-A6+:3%*$/6.*.@(6J1$5".&%""!
+	 ,-+.!2"5!"5!/-*.#7'; 5)@&+B(8K7>Q=?N99I/9L.<O/1G#.D (@1K&2L'(@ &5"+,9%<H4&2-9#AJ7;F5?H70=+=O9<U80K,-K),E%5N.9T5:X64V3;a85^2/X,(O##F*H$$='8%'4#2@/:K8H_E.A+)$)#')$%*$',($0&<Q>G_G2C0+8',4)@F<@B4`hSUdGH[;'; 1I/:\;9[::Q77I1IXA@O89K5"4->+6G4(9'*!"."7F33G,6O/7R1.I&@[8#:   .&2$  !%*$-2,$&!.4*;C4!.!2 9O:9U<5S7.K/%C'%F'8^99i93h4.b1/c23g76j:7k;4j99o>2h72f84g<1d96f>3_;'I./+=12K8@aFBlHArEH~L>wB=xB<w=A{>FÅ=JÉ<G67j'J>&F.S'/X,'P()N,.P50R94X>4X<.Q3?GoJJwNSÑWVäZJÄOGÄMCyE<s:@w=<t5<t39q22i/+b+5k95k92k80i62h61g50i62k87m;<rA;sB;pB9lC<lF?mICqMCpQBoP?lK7fD4c?2b<0^7,Y0+U-%N&$M%!J"0X3IvOBuLDyOByOCzRF}ULÉY@xI3l98q<;q=AwE@vD>wB7r:7r86r63m26m3;s6>q67c.@$D/$#%"9<W62U+/V'/[&+Z##T!P#OH!FCMIzKH}OGRD{QCzRAxPCzPC{N;sFAvJBwMAuN=qJBtNFvPAqG<m@<m>2a5D "J(0U4/V7/X80\;/[:1]:1]:6_=8a?9b@:cA;dB<eC<fB:d@8b>7_<8^93Y2/T+)L"(K#%G"&I(,Q0.V4-Y5.Z64`?7cB4a@3a=0^:/]8/\3*S+E A+W4UÑbUÜfVáiWäkUájTÜiUájVàkVáiWÖhWÖhSÅeTÇhVÑjYám[âlYäj\ãk^åoXànYâo]ãq[âmVáiXâkWàj]éq{©çgïy_çqZãnZãnWàkWâl[çpaít_êr\èp[éo\íp^ît\ìt]ìsaïqgîstõÄ-"&,-++-%<*2K61M7.L4-K3*F/(A+$;' 7%5#3!25!5#?&3V8<eE>lHBpLMzYVÇaSÄaO~^N}]K|\M~`Lz]Lz]M{^SdVÇgVÄhQ{cLv^Jv]HtYGsXEqVDpUGqYKs[FqVCnSEmSCkQDjQEhP<`F8ZA5U=2P8/M5*H0)G-%F+)M1}§á|§â`ãoO|[FuQFxRJ|Yeëzú≈∑û√ª§«√°ƒ¿°ƒ¿£√¬í≤≠sóâlîz[âdNÇQ2l17t16r2=y;NÖLSÜN`è[TÑRH|LTÜ`ãµüé¥ßyüîå≤£^ânK}W7o>=wEaòqcìymñÜï∏±õπ∑ï≥±å¨ßbÜzOw\QxYRpX4!)&%%$" *00*"!%&&'+'8%+"$ .%6#';"$;6.&#&%%# %0"5!"5!7 %=%$>%*F//K51N</L:-L</P?.O<0Q>:[F?`K-P:-N;*G5&A0"=,)D3-C6)=2*#$)#-4,+5*5A5%1%'* " $,! &	*,+/"3 "3 .-*'(.$6)="/C(/C*-@,,?+;J5TcLQdF;P/BX4;T-7Q,1L),G$0G*.;)3>.:C2:F2>G4FR>KVEFSAFS?KZCG[@;T6E`?A_;>Y6)D!"=+J* D 2X/.X*(R$)N#&I!)G%&?"->+,:)%8$G]FE\B- *!(-)%'$&+%")"/;/DWD6L7+9(?J<6>1]cWy}naiTHX;H]>,@%+C)8W8=\<?Z;+B%/C(;O47K0&=!4K1$:#(;'-#$1=/EWA4K.8S071L)<W4$=$3 -$#/!% &(#"' !%*#',%-2+5=0-:)>Q>>WA;Y?4U8+I/)G+*H,9_:=l>8m91g3.d2+a0/c36j<6j<8m?4i;5h=5h=.a64d:1`6-U2/&4T==aE<hEAqIOÉUFL;t?<u>A{AD~AGÇ@FÇ<JÇ;4g%
+2 6+S!5\-#H@%C)"@(&F.*L1#F&*O-TÅXO~ROÄSRÜXD|KJÉP=t=>u<=t:@x9=u64l-4k26l88n=7m<4l;7m<8n=7m<6l;6l;7l>;pBBwI?tF<oD:jB9gB5c>5bA1`>/]92b<+^5-`5._2*Y-(R*#L$"H!!J"6`8FuKCvK@uIAxNG~VF}U>uK6n?;tA=vC?xE?xE=vC?zD7r:<w=7s77q66m38n46i0(R >#C6#+$:#4/O*8_3.X(*Y%$S%Q#M GG'W%LÅMJÄOIÅRF}SByOBwMBwKBwI>sE@tFGzOBwM?sLDwNAqG:k>6g86h71b3H!%N,1X94[<5a@4a@2_>4`?6bA5a@7^?6]>3\<2^=4]=2[90\92^:5_;7a;;a82W,+N$$G!C!C &I(+P.+U1.Z7.Z9/Z</\=/^<0]<0^:0]6/Y30Z4/[7CrNUádUÜfTáhWâlVàmTÜmTÜkYâoVájYákXÜjVÑjVÑjYámZàn^åo]ãn^åo`ér]äs]äu[àq\äpZàlWàkYämbêvw£åmôÇ]çsYämWàkZãmXäm[çp^èq`ës]ép]êq\ír]ìs]ít_ïucïriñuoñ{!,!1$/!,),'>..I6,H2*F/&B+#<&5!22 114=%/R4=eCFpLHtPJxSKwTO{ZTÄ_\àgSÇbO~^L}_K|^N|_Ky\O}abéskì{XÄhNzaMy`IuZIuZFrWEqVDnVGoWEpUCnSCiPBhOBeM?bJ=_G8ZA3S;8V>-K3'E-&D*$B(+K3dàn]ÑiQ}\L|TMÇTKÉRPÖ[ió}ò¡≥†√Ω§ƒ√£¬ƒ£√¬èØ¨uñçgçxbémWÜZ>s=4o/>y9HÇHaóc[è^YâYUÉRHvG?sCDvPÜ∞öèµ®å±©ìπÆnïÄM|Z9qD?xK[émy¶è{§ñë¥≠ç≠™üöà´§\ÉpKwVFnK8T=0 '%''((%$ +!2 /+%  #('*#4!#("0!!2 130+%#$#!! ).2"5":"'?'(A+,E00K80M;-L<,K;,M:0Q<:\DAcJ5W?-N9*G5(C2"=,%=-&>.%;.&6,#%!#$+$#*# "'
+-5*36/&*-0 3%6#"3 .!/('+'5"2)9);!$6):(1?0VbTgtc6C1)8!1F'2J*0I+1J-.G)/C(6A0CL;BI7FO<JUDCP?KWILZIGXEFZA8L11H,7N15N01L),L'%D"'I&'K%:_4)M!-Q%,L#+I#+D$0G+(:"&8 5N1UnQ"5) ' *,)*,)*/(2:-LYG9J7(9&)4&CK>IOCSYKt{kT]HFY=@W:5L0": %?$5R4=[71O+1J*7P0/H(/H*#= )A'-C,&7$$.#)1&P]L8J27N15P/27P04M-1.%2 %4!'6# -!!   ')$*0&&,"(0%$$)"05.19..:.;M?=UE:WC4T=0N6.J1+H,.Q05b7:o;2k6.g2-c/,`//`37g==mE:mD8h>8h>2b84e8/^00Z2;>`H=dI=hJAoKSÉYNÇRDzF7p9>wB?zB?{?EÅAKÑ?PÖA.b"D'W,V$>65044;@hCVÖYL}NSÑWLÄRE}NJÑQ6o86p5<v9<t7>v92i/6o83l94j92g90e95j@8kB>qH>qF:mB:k>5f90d41e50d6+_11b5:j@5e?4f@6f>-`51f:2g;,`20_1(S("K!EG!N#._2;pBBzMG|RG|R@uI6n?;sDA{I>xFA{I:tA=xB<w?<w=<v;9s8:t98r78o6-_*AB&F!< %/,#;#3M2'I&7^2,W)&P"$N  GF-])OÅLLÅMJÄNH}ODyMCxLCxJBvF9m<>rD?rGAtK?rI:mB5f91b31c01f2.b1"Q%)S/,U3.W73\<3_>4`?7cB7cB8cE9`C9`C9bD:cE8aC6_?6bA3_<2\82\61W0+P'#F=9> B%H'(P-)R0/X8.Y;0]@0]@-\<,[9,Z5/]82`;3b>MÅ]RÖdUàiTÜiUálUäpTÜmRÑiRÑiTÖhWámUÖmTÑlZärYâqZäp\än_çqbêvaëyiòÑ]åxdë|aéw^år]ãq_çsiñu¢ãeí{_èu[çpYãn]èr\ço\ço`ér]éq]éq`íu^ìu]ítaìvdïwgòxkòyjët!		! .!"2%/+)/ (?/-F1)B- 9#50.-0/6'I08_@GoLLtOVWVÄXVÄ\U~\U~\UÅ^WÉbQ~_O}`M{^O|]Ly\O{`^äqeåwW~iO{bKy]Jx\Kw\Mx]HrZFpXDnVJt\HrZNt[LrYEhP@cK<^F9[C7W?4R:.L4(D-(D+%A(*H0CdIW]VÑ]SáWSâWQâXRÜ_É∞ôö¬∑ü¬æ£¬ƒ†ø¡°¡æuôèZÅn\ái[ä`ML;q7>v9JÅHfölr§~p†zVÜ\TÑT?o=>t@J}RÉ≠ïïπ≠è≤´ï∂Øîµ™bâtBtOKYr†Ñâ≤†ë¥≠Ü©•É¶¢bà}ZÉqOz^IuQ>cA!8$*%#$%&'$%%%"*$2# 1*&!$&+#1  #'.&'1(+!&*+)(#"%# + 1!4"5$:%%='%>)-I31N:0O=1P@-L:/O:1Q:9YADfM3U=0M9*E4'@-%<*%<,3&/#($ !$0& *!*4+#("&, /002&9%0!0 -(#+$,/9 -: $1*<"(:"/=,5C4KWI8C5+6&<I5<O3!82(@&1J-4K10=,ZeUIR?DM::E5AM?9E7GUF>O=4E2=O9=O7?Q9:Q52M..M+0R1&J&5Z11V+)I /K%-H%'@""6,>(GYC&=!LgFFaB, +!& !& .0++1'=H7R_KBQ<3@.<D7JPDW[MNUEX_MJV@=Q6:Q51J-4&<%AY?@^:0N($?'A&?1J,0J//I.1J-6J1+:'(7$L[F3G,2M,5S13.I(,E%#%))%2 )6%*  "$!#%")*%25.*5%+8$#2%4!*2%(.$)0(+5-3C96J><TF6Q>4M83L6)E,+L->k@=q@;t?5p:3j3.c/-^/,[13c;?oI9iA9iA7g=3d7.]/7b7,O/$	?aI=cJ<gKCpOM{VOÄSIK=v?<u@>yCA|DB~BIÅ@IÇ=HÅ<<u1/a" K92/1;!B#7Z9LvPSÇVPÅRVáZL}PG|NFL4n49s88r5;u89p65l35k75k96l;2g90e9/b9-`7.a8-`5.a6/`31b54h80d40d47k;:n>5j<:mB4i=1e77l>2g9.c51b5+Z."L$D&O'(S(*Y-<m@CxJHÄSOÑZBwM<qC=rDF~OC{LD|MBzI>xE?zD7r:;v<:t9:q7;r8:q7>s=*Z(<!F%I:#%(.6CbB"F %J!*O& EF.\+NÄKI~HG|FCyGAwF?tF=sB?t@9n:9m<9o>:n@5i;1b3._0-_.1f26k74f5#P%&P*)R0+T4.W71Z:2[;3\<2[=3\>2Y>2Y>/W<.V;0Y;1Z:3\:3\:1Y6)Q,#I""F !A20<!@ B!F$#K)'N/*S5)V9/]@4cC7fD5d@4c?2dA8jGPÉbPÜdRàhRáiVàmUánTÜmRÑiTÜiUájXàpVÜnTÖoWàrYãr^évcëwaèufì~lôÖhîÉjñÖ|©ïkòÉcêyaéwbèxfì|jóÄfì|aëw_ëv]ètdïxdïx^èrdïxcîwbíx`íw\ëu]ítcïxeñyjò{mö{aàk"C(%>(%;& 3 .'#!(02-)'.$;)#<'51.,.-1"B+/V;9bDAjHJtPYÅ\bäeeçjgèl^ÜcW]U~^P{]P~aO}`Mz]Mz]Lx]P|cZÅl\ÉnNzaMy^Jx\O{`ZÑlT|dIs[FpXHrZHrZQy_Qw^IoVFiQ=`HAcK=]E1Q9/M5.J3-G.'A($@'(I,1[5RÅUYç\VåZTäYdñqëº©ù¬ªü¡¿¢ƒ≈ùºæÜ¶£`ÜwR~cM{VFxG=s97o2?w:MÉOÄ≤ç^åoYájTÉ_OÄS;o>H~MZåfÖØôóª±ë±¨ì≥Æ†óU|iFuUXâipúÖé¥ßôº∏ó∑∂â¨¶_ÖxPzbLxWLtR?]A/*! "%%&###   .!/,'#$&(#1 +(/'*/(*/($ !$&%&'##"
+&!/ 1!4 #6#$9&!8$&?*/J71N<1P>1P>.N90M7/O7CcK=]E1N:.I6*C.&=)$;)1+)"	
+$&#(*' 1;3EPJIRM* .0/2#6"&9%..&/-12414/3@F*DM0+?&0B*3B-1@-4C06C/3A*;I0CS6/B$-D('@#?Z97P3/A1[k^yávp}k/:)?J:8D67C7#-$#-"8E43@,2A,+='.D-'D&-O.6Z42W.$G&D .G''>$*&$2#/B.BZ@RmN(A#4A/@H;=E::B79?52:+LXD7E.@O8:G3PVHPTFMOAJO;JT<FT;>P8-A(3J0!8':$AU<AY95O,(B+C#(<#/#;#2L1.K,5P/0I+/H*<U5*E"%E ;]867U/6Q.%<.;) ')4&#.(! !.1*6>/-A%2N(6U,,F#,)# &"'"'4-7I=2G8-B/,D.(B))J+6`:;l?:rA9s@8n:4i54f5/^2/^42`;;iE=kGBpI1`68e<9c;1V43AdLAgP>fNDqTEsNPÅTIÄIC}B;u;=v?FHHÇHIÉHLáEKáAIÖ?;o-F911%B#$F%%J(DnJRXOUSÑWWá]FwJJÄO>t@5l29q4:q7;r8:p66k33h40d3)_.)_.)],(\+)]-)_.0f5,b14j95k:2g99n@>sE5j<7l><tE4i;2j;=rD5j<0e74e8/\5!K'@,T/0Z2-\0:k>ExMLÅUNÉWCzP=uHBwKG|PH}QEzNJQF|KE~K<wA7r::u;7q68o5:p6:l7@n?)T'?(O#%J#A
+!"(&<'48,I+#@" ?/X,L|JCv>=r:=r<=s?>tB9r=9r;4n43l50i21g3-c/*_+*\)*^-5i8=o>7f8#M%&N)(P.(P.,S4/V71X;2[=3[@5]B6\C7]D5]B3\>5\=7_=3[8-U0'M&#I  F B 9	 ,"="@"B'J)-R11X9/X:+X;'U8'V6*[;3b@7fD;jJFwWRÖdRàfQágTâkVàmUÖkSÉiSÉiVàkYãnZärXàpUánYãr[çt^évcêyfì~u†èv†ígëÉÅ´ùsùèfíÅeí}bí|cì}eïkòÅfì|_èw`êx`êxnúÇpûÑ_èubíxaëwaëyaëw`íubîwdïxfózgòznõ~]Ñi5W>5V;5S91O70L5.J3)C*$@)">'";% 9#2,$$*6"6 1--,.;%0S;6^C8eH;hK?lMIuT[Éagåmpìsqísiål\ÑbT}]P}^WÑgXÖhVÇgM{_M{aR|fYÉmS}eNy^My^Q}bMw_NxbIs[HrZHsXEpUGoWKs[GoUAgN<_G9]C7Y@1R70N6,H/0J/,F)'D&#E"0[.RÑQWåXYç\[å_nõzõ¡¥°ƒ¿£≈∆£≈∆úæøÄ£ùdç{WÑeJ{L8m5;s6:u5;u8D}Js¶Öà∏†oúÖYälFyP9nDcósÉ±óé¥ßó∫¥ñπµñπ≥tòåMwaHyYI|[¨òëπ∞ó∑¥ì±±ôπ¥wôãU|aJoPHdK5K60 *%#!  %% $ (',*-"%!%&$)&2$%0",1*+0*"'!   " 
+	
+$,/ 2"-#- 0  2""4$$6&#5%!6#$;'1J70M;2Q?,M:,L7-M63S;JjR3P:/K5-F1'>*$='$<&2+,
+	!&"#($$"4=<.76!+-0 1!4 &9%&9%!3%104:5>8=8;:@C&JQ2$6(:"5D/)8#,;&8G2BP90>$?N1?O25L09T5>\80M.6O9CZH_r^9K55D/9F4=J9(&*1);F6 -/>+,?)'?',I+3U29]7+M('G",G(#: - * ,D.MjLA[>(!.08-*1)4;3CK@_j\[hVcp\_nW6D-8A0KO@`dUcgVU_G?M4/>)'9#0C-.B)/@T;1E*!5(=/C'"5,&?).K/$A"3Q/,G&3N-8S0/M'+N&7\3*M#5X.VtP.E(,##.,7',7''/"""-2D*7U/6\-7]*1U'":+$%)%7''?')B%$A"!C" F!,Y.DuFBxG=vC<r>:o98j75e50_1,[1.\8<hEIuQ9eA?kG6`<8`>A$>aKEkV?gOAlP8fBM~QKÄJF}C>x>;u;?xAGÄIFÄFMâKNãFHÑ>;t/P=0%D")K('K'&N)FsLN|UHxNRÇXOUL}PNÇQ=t=7n48o5<s9<s9;q73h01c0-_.)],,b0.c/,a+0f40f4/e34j87m<2h7<qC>sE3h<=rF=uF/g82j;<tE5m>4i=8h>3`9I%7-U35_;-\2._29lAJ}TNÉYG|R>uKCzPG|RLÅWLVK~SKQFzLDzI<u@8s;9t:5o56m4:l74d2,W*#L"F1Z0'L##B )"$.70+$I GuD;n56l21f.5l35n79r;4p4.j.2l12l20j0-d+)^()^*1e4;m<?o?5c5%M($I'&I)'L++P1/V71X;2Y<1Y>6^C6]B5\A7_D8aC9a?0X5)O(&L%%J!"G"I B5 *"=!?!A$H$+P/,S43\>8eH6dH4bE1_B0^A2`C5cFOÄbSÜeQáePÜfUälZäpUÖkTÑlYâoWân]ètZärXàpXàp\éu_èw_èwbèxhïÄhìÇeèÅfêÇlñàhíÜtûêfíÅbë}eîÄhòÇkòÉdë|aëy`êxaéwfì|gî}dëzfñ~_èubízcìyaíucîweñyeñyiö|rüÇOv[4X>4V=0R7/Q6.P51R7-N3*K0*H.)G-*F-+D.'@*!8$0-7"7!0,,-8"-O78`F<gK<iL?kPBoRDoSJsUTx\cÖjméqrïwlërcäkXÅcP{_VÅeYÖjSÅeO}cOyaT~fS{cOz_Mx]Kw^Ku_R|fLv^HrZGrWFqVGoWIqYFnVBhO=`H6Z@1S:,M2.J1)E,+E*)C&'D&#E"?j<XäWVãWWãZWá]aéoïªÆ°√¬§∆«§∆«•ƒ∆òªµx°èWÑc?sB9p6?y>B|A<u>HÄS∞ìëæ™à≥¢~´îSÖb>rN~Æîå∑¶è¥≠ò∫πò∫πôº∏~§óMwcYäm]çsÑØûë∂Æë¥Æâ©§öª¥vòàZ~dFdH&;((9)+*(/+(#!!"'(43*+!%)%+"-"!%,2#:&)@,(?-$6(&# ' .!/" 1!"3#"3#!2"!3#&=+.F6/L:-L:-M8,L5-M5?]CDbJ/K4.G2)B-&?))C*%='/,#/###" "(/0 1!4!$7#*=)!4 !0&/33?6D7@7;8:=7>(7 *9"6E00=).<+3B/ET?FV<@P5=P4&=#:T7/N,8Z58Z79X8:T98O52F+BQ:-:(%&-%/6.7B2/>+6I31I/)H)-Q-5Y32T/+I'&A"!9$7!* '/!?\>A`@":")*2<1*0,-31\e`ÅãÉzÜx|ãx`nWN\E<I5.9(BH<cgYMVAAM7)8% 1(:$9M4.G*.F,(:$*3A(-=#';"%=%0N4+I-&@#,E(()@&4M-1O)/O(-P&9^35X.TrN0 !$%(3%$/'- 72R+2Y,1]*3^)3[)-M$4"/0;- ,$7!$?3V,1Y'.Z%0_)2b.:l7Dw?Bw?>u<=t;>s;>q97j22d/.`/,[1+W3<dBBiJ?hH:cE;dF)Q6=cNEkVGoW?jN4a@BpIQÉRH}GCzA:t:7p9AzCFÄFC}BGÇ@JÖA9u/)` O"L(O#*P''M(*T.AnGIyOBuJMÄUHxPL|RJ~M9p97q7:t9:t9>u;7m10f,/a,.`--a01e40f2.e.3g64h76l:4j8=q@>rB6j<8mA?tH:oC-e84m@;sF1i<2j=6i@4`=G%6'O-7c@6d?0`6,_4<oFI|SJ~W>uMH|UI}VLÄYKÄVLVMÄUKQEyKBxGAwE=s?<s<7m9:n=;m:.\-(Q'!J""K!5^4-Q+$C#5%  "++ %!CEq>8k02h*-e(+e(/i.5q55o20j-4k12i//i.(b((_(.c/7k:=n?@oA3^3%J("E%$E&&I))N-)P1)P3/X:2[=3\>3Z=3Z;8_@4\:/T2&L'$M%%N$'M$"H#J!C(	+!>!AD"F (M+/X8-X<.\@8fL?lU?mS<jP;iM<hMRÄdSÑfSÜeQÑeVàkWáoZápXàr[ãs[çt^êwZär[às]äu`êzaéybèzfì~kòÉbë}bë}cê|eëÄiìÖv†îsüêgìÇkóÜmôàÉØûgîÄaëybíxaëyeï}gîdëzjóÄp†àeï{dîzeìyió{iö}hô|núu¢ÖDkP7YA5X@1U;1S:1S:0P8.N6.L4,J2*H0'E-(D.)B-&?*%>)&?)(D-#<'3+.=%0R97]D9dI@kOFsVHuXFsVGrVHsWIqWKsYW~chåpmètnêukèsbâlZÅdXÄeS~bR}bS~cWeS}eQ{cQ{cOycSze]ÑoNx`FqVGrWKv[JrZNv^Ms^DjUBeO=`H4V=0Q64P7+E*'D(&C%&@#%D"Aj>UáVPÑSINKÄV\ãkñº≠¶∆√®«…ß∆…°æ¬Ç¢ügé|LyX:n=@w@B{H\îcH}Qbîqç∏§óΩ≤ì∏∞êπ´ZànFtZâ¥°ìª∞ê¥∞ôªºüæ¿õª∫xõîNwiÑØúç∂§yüímëárñäZ~rÅ•ó~†êXxc)B--". -), 3 !2 !/-'$%'#"),+. !($ ,& !% .)#%$%2$;'+D/-F3-D4+?3/"+#/#&!((*+,- /!2#%<,,G6.K70M9,J2.L2/M1JhN6T:-I2+D/'@*(@*)A+5 ."."! ! 5:6&0(&-  2"4!$7#%8$&9%&9%0 -*/20<2C8?9;;;@ 8A"7F/:I2.;'2?-0>-0>-<K6>N4AQ66I-.E+,F+#B ;`77\3#H&C%1J-6M1:L2 -(+0)2910;+0?*.D-+H*+M,5[40T.?6#<#9"&9%#1""."*!5J9PoO5W4 5"DTGZfXAMA7=;288ajiìûò~äÄcq`6D-1A'9H3AP=6<2<B69@.,8"%2!*8',=*G^D9S6#= %6$)<E0-;"3G.GaF1R5!B%/#9"%(;%.G)2P**H"2U+8]21V+;Y5,C'#&$1 0?*-D'3Q-0W*.Z)+\%3_*3^),P$*E"*"-,;(>U9OoFU}IK{AEy9@v8Ay:GzAEx?Dz>E{?By?Ax>Dw>Bu<:p65j44c5-Z30U63W;:aF8`E8cG3^C<bMBhS?gO?jN6bA8f?K|MMÇLG~GB|B:u=;v>D{BAx>>y9HÉ?2o)'c,^!&U,V()R(%N&+U/<i@DtJI|QCxLGwQL|RH|K1h18r86q7;u:7q68n20f,*[$%W"-_.0e10f2.e.4h75i89o=@vD=o>3d5<pBAtI:oC0h;8pC;tG1h>1h>4kA/a;D%6"G(;cA=kG8h@-`79lADwNF{QEySCzSKYJ~XJ~WJUOÇYMÄUI}OCwI=sB>tBEzF;p<$X'CwG9i9'U'/X0&O'(Q'6_52V0>93+&"' %@Gs@<o41i(1i*1l,.j.4p27q4/j*5l24k1/i.,f,1h17m9?pA>o@>k@/Y1"E$"C$#D%$G'*M--U32Y<7`B;dF>gI>eF>eF5];*R/%J($J#%N&&O%&L#'M$$K@!
+	*"? "E!F"H!"J%-V68eH4bH/_G3^J8dM;hQ;iODpWTÇfRÉeSÜeUájXäo[àqYÜqYâsZãu_ëx_ëxZät]äu_åwbèzbèzfì~hïÄfñÄcí~`ë|aë{dìeèÅiìáiïÜiïÜpúãqùårûèkóÜaëybíxbízcì{gîgîiñv£åfñ|gó}gìzkôkô}iö|mõ~v£Ñ=`H3U=/R:.Q9.P7-O6/O8,L5+I1*H0(F.'E-'C-%A+'@+%>)$@)+G0&B,:$/;%1Q98_D9aG<gLCnRNy]RbJwZHsWKvZLv^Lw\]Ök[Çg[}bfálnêupîxníviítV~cOz^T|aU}bR|dWÅiWÅkS}gT{fYÅiQ{cGrWFqVLw\HpXV~f\ÅoGmXEhTBeM>^G<Z@B^E4N3/L0*G+(B%'F$3\2TÑTMÉRNÜWXçcq†Äë∑®†¿ª¶ƒ∆ßƒ»tëïdÑÅ\ÉqCpO?sCAxAF~O{≤àv®É≠êóΩÆõæ∑úøπöø∑gí~;hQ®öìª≤î∂µû¿¡ßƒ»ò∑πdáÅwùíò¿µõ¡¥zûîaÖyY}oOvdZÅo|ûç^{i3",*+,0!4  1#4!/-*%$$"&&)#)%#/!'  #!")&7$$2!,"!0%>(.G40K8/G9-D4+@1$5%)#  "%')-!/!6&%>+-H5/K5.J3,J0/M17X;BcH.J3,H2)A+%=')A+,B-"3#' ',&&.# .!1! 3 4!#9$%;&+>*&9%."/*-1,9/F;>956;@ 9B#
\ No newline at end of file
Binary files gpu-rodinia/cuda/cfd/common/data/person.ppm and gpu-rodinia_new/cuda/cfd/common/data/person.ppm differ
Binary files gpu-rodinia/cuda/cfd/common/data/sponge.ppm and gpu-rodinia_new/cuda/cfd/common/data/sponge.ppm differ
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/cuda_drvapi_dynlink.c gpu-rodinia_new/cuda/cfd/common/inc/cuda_drvapi_dynlink.c
--- gpu-rodinia/cuda/cfd/common/inc/cuda_drvapi_dynlink.c	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/cuda_drvapi_dynlink.c	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,555 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * NVIDIA Corporation and its licensors retain all intellectual property and
+ * proprietary rights in and to this software and related documentation.
+ * Any use, reproduction, disclosure, or distribution of this software
+ * and related documentation without an express license agreement from
+ * NVIDIA Corporation is strictly prohibited.
+ *
+ * Please refer to the applicable NVIDIA end user license agreement (EULA)
+ * associated with this source code for terms and conditions that govern
+ * your use of this NVIDIA software.
+ *
+ */
+
+// With these flags defined, this source file will dynamically
+// load the corresponding functions.  Disabled by default.
+//#define CUDA_INIT_D3D9
+//#define CUDA_INIT_D3D10
+//#define CUDA_INIT_D3D11
+//#define CUDA_INIT_OPENGL
+
+#include <stdio.h>
+#include "cuda_drvapi_dynlink.h"
+
+tcuInit                               *_cuInit;
+tcuDriverGetVersion                   *cuDriverGetVersion;
+tcuDeviceGet                          *cuDeviceGet;
+tcuDeviceGetCount                     *cuDeviceGetCount;
+tcuDeviceGetName                      *cuDeviceGetName;
+tcuDeviceComputeCapability            *cuDeviceComputeCapability;
+tcuDeviceTotalMem                     *cuDeviceTotalMem;
+tcuDeviceGetProperties                *cuDeviceGetProperties;
+tcuDeviceGetAttribute                 *cuDeviceGetAttribute;
+tcuCtxCreate                          *cuCtxCreate;
+tcuCtxDestroy                         *cuCtxDestroy;
+tcuCtxAttach                          *cuCtxAttach;
+tcuCtxDetach                          *cuCtxDetach;
+tcuCtxPushCurrent                     *cuCtxPushCurrent;
+tcuCtxPopCurrent                      *cuCtxPopCurrent;
+tcuCtxGetCurrent                      *cuCtxGetCurrent;
+tcuCtxSetCurrent                      *cuCtxSetCurrent;
+tcuCtxGetDevice                       *cuCtxGetDevice;
+tcuCtxSynchronize                     *cuCtxSynchronize;
+tcuModuleLoad                         *cuModuleLoad;
+tcuModuleLoadData                     *cuModuleLoadData;
+tcuModuleLoadDataEx                   *cuModuleLoadDataEx;
+tcuModuleLoadFatBinary                *cuModuleLoadFatBinary;
+tcuModuleUnload                       *cuModuleUnload;
+tcuModuleGetFunction                  *cuModuleGetFunction;
+tcuModuleGetGlobal                    *cuModuleGetGlobal;
+tcuModuleGetTexRef                    *cuModuleGetTexRef;
+tcuModuleGetSurfRef                   *cuModuleGetSurfRef;
+tcuMemGetInfo                         *cuMemGetInfo;
+tcuMemAlloc                           *cuMemAlloc;
+tcuMemAllocPitch                      *cuMemAllocPitch;
+tcuMemFree                            *cuMemFree;
+tcuMemGetAddressRange                 *cuMemGetAddressRange;
+tcuMemAllocHost                       *cuMemAllocHost;
+tcuMemFreeHost                        *cuMemFreeHost;
+tcuMemHostAlloc                       *cuMemHostAlloc;
+tcuMemHostGetDevicePointer            *cuMemHostGetDevicePointer;
+tcuMemHostRegister                    *cuMemHostRegister;
+tcuMemHostUnregister                  *cuMemHostUnregister;
+tcuMemcpyHtoD                         *cuMemcpyHtoD;
+tcuMemcpyDtoH                         *cuMemcpyDtoH;
+tcuMemcpyDtoD                         *cuMemcpyDtoD;
+tcuMemcpyDtoA                         *cuMemcpyDtoA;
+tcuMemcpyAtoD                         *cuMemcpyAtoD;
+tcuMemcpyHtoA                         *cuMemcpyHtoA;
+tcuMemcpyAtoH                         *cuMemcpyAtoH;
+tcuMemcpyAtoA                         *cuMemcpyAtoA;
+tcuMemcpy2D                           *cuMemcpy2D;
+tcuMemcpy2DUnaligned                  *cuMemcpy2DUnaligned;
+tcuMemcpy3D                           *cuMemcpy3D;
+tcuMemcpyHtoDAsync                    *cuMemcpyHtoDAsync;
+tcuMemcpyDtoHAsync                    *cuMemcpyDtoHAsync;
+tcuMemcpyDtoDAsync                    *cuMemcpyDtoDAsync;
+tcuMemcpyHtoAAsync                    *cuMemcpyHtoAAsync;
+tcuMemcpyAtoHAsync                    *cuMemcpyAtoHAsync;
+tcuMemcpy2DAsync                      *cuMemcpy2DAsync;
+tcuMemcpy3DAsync                      *cuMemcpy3DAsync;
+tcuMemcpy                             *cuMemcpy;
+tcuMemcpyPeer                         *cuMemcpyPeer;
+tcuMemsetD8                           *cuMemsetD8;
+tcuMemsetD16                          *cuMemsetD16;
+tcuMemsetD32                          *cuMemsetD32;
+tcuMemsetD2D8                         *cuMemsetD2D8;
+tcuMemsetD2D16                        *cuMemsetD2D16;
+tcuMemsetD2D32                        *cuMemsetD2D32;
+tcuFuncSetBlockShape                  *cuFuncSetBlockShape;
+tcuFuncSetSharedSize                  *cuFuncSetSharedSize;
+tcuFuncGetAttribute                   *cuFuncGetAttribute;
+tcuFuncSetCacheConfig                 *cuFuncSetCacheConfig;
+tcuLaunchKernel                       *cuLaunchKernel;
+tcuArrayCreate                        *cuArrayCreate;
+tcuArrayGetDescriptor                 *cuArrayGetDescriptor;
+tcuArrayDestroy                       *cuArrayDestroy;
+tcuArray3DCreate                      *cuArray3DCreate;
+tcuArray3DGetDescriptor               *cuArray3DGetDescriptor;
+tcuTexRefCreate                       *cuTexRefCreate;
+tcuTexRefDestroy                      *cuTexRefDestroy;
+tcuTexRefSetArray                     *cuTexRefSetArray;
+tcuTexRefSetAddress                   *cuTexRefSetAddress;
+tcuTexRefSetAddress2D                 *cuTexRefSetAddress2D;
+tcuTexRefSetFormat                    *cuTexRefSetFormat;
+tcuTexRefSetAddressMode               *cuTexRefSetAddressMode;
+tcuTexRefSetFilterMode                *cuTexRefSetFilterMode;
+tcuTexRefSetFlags                     *cuTexRefSetFlags;
+tcuTexRefGetAddress                   *cuTexRefGetAddress;
+tcuTexRefGetArray                     *cuTexRefGetArray;
+tcuTexRefGetAddressMode               *cuTexRefGetAddressMode;
+tcuTexRefGetFilterMode                *cuTexRefGetFilterMode;
+tcuTexRefGetFormat                    *cuTexRefGetFormat;
+tcuTexRefGetFlags                     *cuTexRefGetFlags;
+tcuSurfRefSetArray                    *cuSurfRefSetArray;
+tcuSurfRefGetArray                    *cuSurfRefGetArray;
+tcuParamSetSize                       *cuParamSetSize;
+tcuParamSeti                          *cuParamSeti;
+tcuParamSetf                          *cuParamSetf;
+tcuParamSetv                          *cuParamSetv;
+tcuParamSetTexRef                     *cuParamSetTexRef;
+tcuLaunch                             *cuLaunch;
+tcuLaunchGrid                         *cuLaunchGrid;
+tcuLaunchGridAsync                    *cuLaunchGridAsync;
+tcuEventCreate                        *cuEventCreate;
+tcuEventRecord                        *cuEventRecord;
+tcuEventQuery                         *cuEventQuery;
+tcuEventSynchronize                   *cuEventSynchronize;
+tcuEventDestroy                       *cuEventDestroy;
+tcuEventElapsedTime                   *cuEventElapsedTime;
+tcuStreamCreate                       *cuStreamCreate;
+tcuStreamQuery                        *cuStreamQuery;
+tcuStreamSynchronize                  *cuStreamSynchronize;
+tcuStreamDestroy                      *cuStreamDestroy;
+tcuGraphicsUnregisterResource         *cuGraphicsUnregisterResource;
+tcuGraphicsSubResourceGetMappedArray  *cuGraphicsSubResourceGetMappedArray;
+tcuGraphicsResourceGetMappedPointer   *cuGraphicsResourceGetMappedPointer;
+tcuGraphicsResourceSetMapFlags        *cuGraphicsResourceSetMapFlags;
+tcuGraphicsMapResources               *cuGraphicsMapResources;
+tcuGraphicsUnmapResources             *cuGraphicsUnmapResources;
+tcuGetExportTable                     *cuGetExportTable;
+tcuCtxSetLimit                        *cuCtxSetLimit;
+tcuCtxGetLimit                        *cuCtxGetLimit;
+tcuMemHostGetFlags                    *cuMemHostGetFlags;
+
+#ifdef CUDA_INIT_D3D9
+// D3D9/CUDA interop (CUDA 1.x compatible API). These functions
+// are deprecated; please use the ones below
+tcuD3D9Begin                          *cuD3D9Begin;
+tcuD3D9End                            *cuD3DEnd;
+tcuD3D9RegisterVertexBuffer           *cuD3D9RegisterVertexBuffer;
+tcuD3D9MapVertexBuffer                *cuD3D9MapVertexBuffer;
+tcuD3D9UnmapVertexBuffer              *cuD3D9UnmapVertexBuffer;
+tcuD3D9UnregisterVertexBuffer         *cuD3D9UnregisterVertexBuffer;
+
+// D3D9/CUDA interop (CUDA 2.x compatible)
+tcuD3D9GetDirect3DDevice              *cuD3D9GetDirect3DDevice;
+tcuD3D9RegisterResource               *cuD3D9RegisterResource;
+tcuD3D9UnregisterResource             *cuD3D9UnregisterResource;
+tcuD3D9MapResources                   *cuD3D9MapResources;
+tcuD3D9UnmapResources                 *cuD3D9UnmapResources;
+tcuD3D9ResourceSetMapFlags            *cuD3D9ResourceSetMapFlags;
+tcuD3D9ResourceGetSurfaceDimensions   *cuD3D9ResourceGetSurfaceDimensions;
+tcuD3D9ResourceGetMappedArray         *cuD3D9ResourceGetMappedArray;
+tcuD3D9ResourceGetMappedPointer       *cuD3D9ResourceGetMappedPointer;
+tcuD3D9ResourceGetMappedSize          *cuD3D9ResourceGetMappedSize;
+tcuD3D9ResourceGetMappedPitch         *cuD3D9ResourceGetMappedPitch;
+
+// D3D9/CUDA interop (CUDA 2.0+)
+tcuD3D9GetDevice                      *cuD3D9GetDevice;
+tcuD3D9CtxCreate                      *cuD3D9CtxCreate;
+tcuGraphicsD3D9RegisterResource       *cuGraphicsD3D9RegisterResource;
+#endif
+
+#ifdef CUDA_INIT_D3D10
+// D3D10/CUDA interop (CUDA 3.0+)
+tcuD3D10GetDevice                     *cuD3D10GetDevice;
+tcuD3D10CtxCreate                     *cuD3D10CtxCreate;
+tcuGraphicsD3D10RegisterResource      *cuGraphicsD3D10RegisterResource;
+#endif
+
+
+#ifdef CUDA_INIT_D3D11
+// D3D11/CUDA interop (CUDA 3.0+)
+tcuD3D11GetDevice                     *cuD3D11GetDevice;
+tcuD3D11CtxCreate                     *cuD3D11CtxCreate;
+tcuGraphicsD3D11RegisterResource      *cuGraphicsD3D11RegisterResource;
+#endif
+
+// GL/CUDA interop
+#ifdef CUDA_INIT_OPENGL
+tcuGLCtxCreate                        *cuGLCtxCreate;
+tcuGraphicsGLRegisterBuffer           *cuGraphicsGLRegisterBuffer;
+tcuGraphicsGLRegisterImage            *cuGraphicsGLRegisterImage;
+#ifdef _WIN32
+tcuWGLGetDevice                       *cuWGLGetDevice;
+#endif
+#endif
+
+#define STRINGIFY(X) #X
+
+#ifdef _WIN32
+#include <Windows.h>
+
+#ifdef UNICODE
+static LPCWSTR __CudaLibName = L"nvcuda.dll";
+#else
+static LPCSTR __CudaLibName = "nvcuda.dll";
+#endif
+
+typedef HMODULE CUDADRIVER;
+
+static CUresult LOAD_LIBRARY(CUDADRIVER *pInstance)
+{
+    *pInstance = LoadLibrary(__CudaLibName);
+
+    if (*pInstance == NULL)
+    {
+        printf("LoadLibrary \"%s\" failed!\n", __CudaLibName);
+        return CUDA_ERROR_UNKNOWN;
+    }
+
+    return CUDA_SUCCESS;
+}
+
+#define GET_PROC_EX(name, alias, required)                     \
+    alias = (t##name *)GetProcAddress(CudaDrvLib, #name);               \
+    if (alias == NULL && required) {                                    \
+        printf("Failed to find required function \"%s\" in %s\n",       \
+               #name, __CudaLibName);                                  \
+        return CUDA_ERROR_UNKNOWN;                                      \
+    }
+
+#define GET_PROC_EX_V2(name, alias, required)                           \
+    alias = (t##name *)GetProcAddress(CudaDrvLib, STRINGIFY(name##_v2));\
+    if (alias == NULL && required) {                                    \
+        printf("Failed to find required function \"%s\" in %s\n",       \
+               STRINGIFY(name##_v2), __CudaLibName);                       \
+        return CUDA_ERROR_UNKNOWN;                                      \
+    }
+
+#elif defined(__unix__) || defined(__APPLE__) || defined(__MACOSX)
+
+#include <dlfcn.h>
+
+#if defined(__APPLE__) || defined(__MACOSX)
+static char __CudaLibName[] = "/usr/local/cuda/lib/libcuda.dylib";
+#else
+static char __CudaLibName[] = "libcuda.so";
+#endif
+
+typedef void *CUDADRIVER;
+
+static CUresult LOAD_LIBRARY(CUDADRIVER *pInstance)
+{
+    *pInstance = dlopen(__CudaLibName, RTLD_NOW);
+
+    if (*pInstance == NULL)
+    {
+        printf("dlopen \"%s\" failed!\n", __CudaLibName);
+        return CUDA_ERROR_UNKNOWN;
+    }
+
+    return CUDA_SUCCESS;
+}
+
+#define GET_PROC_EX(name, alias, required)                              \
+    alias = (t##name *)dlsym(CudaDrvLib, #name);                        \
+    if (alias == NULL && required) {                                    \
+        printf("Failed to find required function \"%s\" in %s\n",       \
+               #name, __CudaLibName);                                  \
+        return CUDA_ERROR_UNKNOWN;                                      \
+    }
+
+#define GET_PROC_EX_V2(name, alias, required)                           \
+    alias = (t##name *)dlsym(CudaDrvLib, STRINGIFY(name##_v2));         \
+    if (alias == NULL && required) {                                    \
+        printf("Failed to find required function \"%s\" in %s\n",       \
+               STRINGIFY(name##_v2), __CudaLibName);                    \
+        return CUDA_ERROR_UNKNOWN;                                      \
+    }
+
+#else
+#error unsupported platform
+#endif
+
+#define CHECKED_CALL(call)              \
+    do {                                \
+        CUresult result = (call);       \
+        if (CUDA_SUCCESS != result) {   \
+            return result;              \
+        }                               \
+    } while(0)
+
+#define GET_PROC_REQUIRED(name) GET_PROC_EX(name,name,1)
+#define GET_PROC_OPTIONAL(name) GET_PROC_EX(name,name,0)
+#define GET_PROC(name)          GET_PROC_REQUIRED(name)
+#define GET_PROC_V2(name)       GET_PROC_EX_V2(name,name,1)
+
+CUresult CUDAAPI cuInit(unsigned int Flags, int cudaVersion)
+{
+    CUDADRIVER CudaDrvLib;
+    int driverVer = 1000;
+
+    CHECKED_CALL(LOAD_LIBRARY(&CudaDrvLib));
+
+    // cuInit is required; alias it to _cuInit
+    GET_PROC_EX(cuInit, _cuInit, 1);
+    CHECKED_CALL(_cuInit(Flags));
+
+    // available since 2.2. if not present, version 1.0 is assumed
+    GET_PROC_OPTIONAL(cuDriverGetVersion);
+
+    if (cuDriverGetVersion)
+    {
+        CHECKED_CALL(cuDriverGetVersion(&driverVer));
+    }
+
+    // fetch all function pointers
+    GET_PROC(cuDeviceGet);
+    GET_PROC(cuDeviceGetCount);
+    GET_PROC(cuDeviceGetName);
+    GET_PROC(cuDeviceComputeCapability);
+    GET_PROC(cuDeviceGetProperties);
+    GET_PROC(cuDeviceGetAttribute);
+    GET_PROC(cuCtxDestroy);
+    GET_PROC(cuCtxAttach);
+    GET_PROC(cuCtxDetach);
+    GET_PROC(cuCtxPushCurrent);
+    GET_PROC(cuCtxPopCurrent);
+    GET_PROC(cuCtxGetDevice);
+    GET_PROC(cuCtxSynchronize);
+    GET_PROC(cuModuleLoad);
+    GET_PROC(cuModuleLoadData);
+    GET_PROC(cuModuleUnload);
+    GET_PROC(cuModuleGetFunction);
+    GET_PROC(cuModuleGetTexRef);
+    GET_PROC(cuMemFreeHost);
+    GET_PROC(cuMemHostAlloc);
+    GET_PROC(cuFuncSetBlockShape);
+    GET_PROC(cuFuncSetSharedSize);
+    GET_PROC(cuFuncGetAttribute);
+    GET_PROC(cuArrayDestroy);
+    GET_PROC(cuTexRefCreate);
+    GET_PROC(cuTexRefDestroy);
+    GET_PROC(cuTexRefSetArray);
+    GET_PROC(cuTexRefSetFormat);
+    GET_PROC(cuTexRefSetAddressMode);
+    GET_PROC(cuTexRefSetFilterMode);
+    GET_PROC(cuTexRefSetFlags);
+    GET_PROC(cuTexRefGetArray);
+    GET_PROC(cuTexRefGetAddressMode);
+    GET_PROC(cuTexRefGetFilterMode);
+    GET_PROC(cuTexRefGetFormat);
+    GET_PROC(cuTexRefGetFlags);
+    GET_PROC(cuParamSetSize);
+    GET_PROC(cuParamSeti);
+    GET_PROC(cuParamSetf);
+    GET_PROC(cuParamSetv);
+    GET_PROC(cuParamSetTexRef);
+    GET_PROC(cuLaunch);
+    GET_PROC(cuLaunchGrid);
+    GET_PROC(cuLaunchGridAsync);
+    GET_PROC(cuEventCreate);
+    GET_PROC(cuEventRecord);
+    GET_PROC(cuEventQuery);
+    GET_PROC(cuEventSynchronize);
+    GET_PROC(cuEventDestroy);
+    GET_PROC(cuEventElapsedTime);
+    GET_PROC(cuStreamCreate);
+    GET_PROC(cuStreamQuery);
+    GET_PROC(cuStreamSynchronize);
+    GET_PROC(cuStreamDestroy);
+
+    // These could be _v2 interfaces
+    if (cudaVersion >= 4000 && __CUDA_API_VERSION >= 4000)
+    {
+        GET_PROC_V2(cuCtxDestroy);
+        GET_PROC_V2(cuCtxPopCurrent);
+        GET_PROC_V2(cuCtxPushCurrent);
+        GET_PROC_V2(cuStreamDestroy);
+        GET_PROC_V2(cuEventDestroy);
+    }
+
+    if (cudaVersion >= 3020 && __CUDA_API_VERSION >= 3020)
+    {
+        GET_PROC_V2(cuDeviceTotalMem);
+        GET_PROC_V2(cuCtxCreate);
+        GET_PROC_V2(cuModuleGetGlobal);
+        GET_PROC_V2(cuMemGetInfo);
+        GET_PROC_V2(cuMemAlloc);
+        GET_PROC_V2(cuMemAllocPitch);
+        GET_PROC_V2(cuMemFree);
+        GET_PROC_V2(cuMemGetAddressRange);
+        GET_PROC_V2(cuMemAllocHost);
+        GET_PROC_V2(cuMemHostGetDevicePointer);
+        GET_PROC_V2(cuMemcpyHtoD);
+        GET_PROC_V2(cuMemcpyDtoH);
+        GET_PROC_V2(cuMemcpyDtoD);
+        GET_PROC_V2(cuMemcpyDtoA);
+        GET_PROC_V2(cuMemcpyAtoD);
+        GET_PROC_V2(cuMemcpyHtoA);
+        GET_PROC_V2(cuMemcpyAtoH);
+        GET_PROC_V2(cuMemcpyAtoA);
+        GET_PROC_V2(cuMemcpy2D);
+        GET_PROC_V2(cuMemcpy2DUnaligned);
+        GET_PROC_V2(cuMemcpy3D);
+        GET_PROC_V2(cuMemcpyHtoDAsync);
+        GET_PROC_V2(cuMemcpyDtoHAsync);
+        GET_PROC_V2(cuMemcpyHtoAAsync);
+        GET_PROC_V2(cuMemcpyAtoHAsync);
+        GET_PROC_V2(cuMemcpy2DAsync);
+        GET_PROC_V2(cuMemcpy3DAsync);
+        GET_PROC_V2(cuMemsetD8);
+        GET_PROC_V2(cuMemsetD16);
+        GET_PROC_V2(cuMemsetD32);
+        GET_PROC_V2(cuMemsetD2D8);
+        GET_PROC_V2(cuMemsetD2D16);
+        GET_PROC_V2(cuMemsetD2D32);
+        GET_PROC_V2(cuArrayCreate);
+        GET_PROC_V2(cuArrayGetDescriptor);
+        GET_PROC_V2(cuArray3DCreate);
+        GET_PROC_V2(cuArray3DGetDescriptor);
+        GET_PROC_V2(cuTexRefSetAddress);
+        GET_PROC_V2(cuTexRefSetAddress2D);
+        GET_PROC_V2(cuTexRefGetAddress);
+    }
+    else
+    {
+        GET_PROC(cuDeviceTotalMem);
+        GET_PROC(cuCtxCreate);
+        GET_PROC(cuModuleGetGlobal);
+        GET_PROC(cuMemGetInfo);
+        GET_PROC(cuMemAlloc);
+        GET_PROC(cuMemAllocPitch);
+        GET_PROC(cuMemFree);
+        GET_PROC(cuMemGetAddressRange);
+        GET_PROC(cuMemAllocHost);
+        GET_PROC(cuMemHostGetDevicePointer);
+        GET_PROC(cuMemcpyHtoD);
+        GET_PROC(cuMemcpyDtoH);
+        GET_PROC(cuMemcpyDtoD);
+        GET_PROC(cuMemcpyDtoA);
+        GET_PROC(cuMemcpyAtoD);
+        GET_PROC(cuMemcpyHtoA);
+        GET_PROC(cuMemcpyAtoH);
+        GET_PROC(cuMemcpyAtoA);
+        GET_PROC(cuMemcpy2D);
+        GET_PROC(cuMemcpy2DUnaligned);
+        GET_PROC(cuMemcpy3D);
+        GET_PROC(cuMemcpyHtoDAsync);
+        GET_PROC(cuMemcpyDtoHAsync);
+        GET_PROC(cuMemcpyHtoAAsync);
+        GET_PROC(cuMemcpyAtoHAsync);
+        GET_PROC(cuMemcpy2DAsync);
+        GET_PROC(cuMemcpy3DAsync);
+        GET_PROC(cuMemsetD8);
+        GET_PROC(cuMemsetD16);
+        GET_PROC(cuMemsetD32);
+        GET_PROC(cuMemsetD2D8);
+        GET_PROC(cuMemsetD2D16);
+        GET_PROC(cuMemsetD2D32);
+        GET_PROC(cuArrayCreate);
+        GET_PROC(cuArrayGetDescriptor);
+        GET_PROC(cuArray3DCreate);
+        GET_PROC(cuArray3DGetDescriptor);
+        GET_PROC(cuTexRefSetAddress);
+        GET_PROC(cuTexRefSetAddress2D);
+        GET_PROC(cuTexRefGetAddress);
+    }
+
+    // The following functions are specific to CUDA versions
+    if (driverVer >= 2010)
+    {
+        GET_PROC(cuModuleLoadDataEx);
+        GET_PROC(cuModuleLoadFatBinary);
+#ifdef CUDA_INIT_OPENGL
+        GET_PROC(cuGLCtxCreate);
+        GET_PROC(cuGraphicsGLRegisterBuffer);
+        GET_PROC(cuGraphicsGLRegisterImage);
+#  ifdef _WIN32
+        GET_PROC(cuWGLGetDevice);
+#  endif
+#endif
+#ifdef CUDA_INIT_D3D9
+        GET_PROC(cuD3D9GetDevice);
+        GET_PROC(cuD3D9CtxCreate);
+        GET_PROC(cuGraphicsD3D9RegisterResource);
+#endif
+    }
+
+    if (driverVer >= 2030)
+    {
+        GET_PROC(cuMemHostGetFlags);
+#ifdef CUDA_INIT_D3D10
+        GET_PROC(cuD3D10GetDevice);
+        GET_PROC(cuD3D10CtxCreate);
+        GET_PROC(cuGraphicsD3D10RegisterResource);
+#endif
+#ifdef CUDA_INIT_OPENGL
+        GET_PROC(cuGraphicsGLRegisterBuffer);
+        GET_PROC(cuGraphicsGLRegisterImage);
+#endif
+    }
+
+    if (driverVer >= 3000)
+    {
+        GET_PROC(cuMemcpyDtoDAsync);
+        GET_PROC(cuFuncSetCacheConfig);
+#ifdef CUDA_INIT_D3D11
+        GET_PROC(cuD3D11GetDevice);
+        GET_PROC(cuD3D11CtxCreate);
+        GET_PROC(cuGraphicsD3D11RegisterResource);
+#endif
+        GET_PROC(cuGraphicsUnregisterResource);
+        GET_PROC(cuGraphicsSubResourceGetMappedArray);
+
+        if (cudaVersion >= 3020 && __CUDA_API_VERSION >= 3020)
+        {
+            GET_PROC_V2(cuGraphicsResourceGetMappedPointer);
+        }
+        else
+        {
+            GET_PROC(cuGraphicsResourceGetMappedPointer);
+        }
+
+        GET_PROC(cuGraphicsResourceSetMapFlags);
+        GET_PROC(cuGraphicsMapResources);
+        GET_PROC(cuGraphicsUnmapResources);
+        GET_PROC(cuGetExportTable);
+    }
+
+    if (driverVer >= 3010)
+    {
+        GET_PROC(cuModuleGetSurfRef);
+        GET_PROC(cuSurfRefSetArray);
+        GET_PROC(cuSurfRefGetArray);
+        GET_PROC(cuCtxSetLimit);
+        GET_PROC(cuCtxGetLimit);
+    }
+
+    if (driverVer >= 4000)
+    {
+        GET_PROC(cuCtxSetCurrent);
+        GET_PROC(cuCtxGetCurrent);
+        GET_PROC(cuMemHostRegister);
+        GET_PROC(cuMemHostUnregister);
+        GET_PROC(cuMemcpy);
+        GET_PROC(cuMemcpyPeer);
+        GET_PROC(cuLaunchKernel);
+    }
+
+    return CUDA_SUCCESS;
+}
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/drvapi_error_string.h gpu-rodinia_new/cuda/cfd/common/inc/drvapi_error_string.h
--- gpu-rodinia/cuda/cfd/common/inc/drvapi_error_string.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/drvapi_error_string.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,341 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+#ifndef _DRVAPI_ERROR_STRING_H_
+#define _DRVAPI_ERROR_STRING_H_
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#ifdef  __cuda_cuda_h__ // check to see if CUDA_H is included above
+
+// Error Code string definitions here
+typedef struct
+{
+    char const *error_string;
+    int  error_id;
+} s_CudaErrorStr;
+
+/**
+ * Error codes
+ */
+static s_CudaErrorStr sCudaDrvErrorString[] =
+{
+    /**
+     * The API call returned with no errors. In the case of query calls, this
+     * can also mean that the operation being queried is complete (see
+     * ::cuEventQuery() and ::cuStreamQuery()).
+     */
+    { "CUDA_SUCCESS", 0 },
+
+    /**
+     * This indicates that one or more of the parameters passed to the API call
+     * is not within an acceptable range of values.
+     */
+    { "CUDA_ERROR_INVALID_VALUE", 1 },
+
+    /**
+     * The API call failed because it was unable to allocate enough memory to
+     * perform the requested operation.
+     */
+    { "CUDA_ERROR_OUT_OF_MEMORY", 2 },
+
+    /**
+     * This indicates that the CUDA driver has not been initialized with
+     * ::cuInit() or that initialization has failed.
+     */
+    { "CUDA_ERROR_NOT_INITIALIZED", 3 },
+
+    /**
+     * This indicates that the CUDA driver is in the process of shutting down.
+     */
+    { "CUDA_ERROR_DEINITIALIZED", 4 },
+
+    /**
+     * This indicates profiling APIs are called while application is running
+     * in visual profiler mode.
+    */
+    { "CUDA_ERROR_PROFILER_DISABLED", 5 },
+    /**
+     * This indicates profiling has not been initialized for this context.
+     * Call cuProfilerInitialize() to resolve this.
+    */
+    { "CUDA_ERROR_PROFILER_NOT_INITIALIZED", 6 },
+    /**
+     * This indicates profiler has already been started and probably
+     * cuProfilerStart() is incorrectly called.
+    */
+    { "CUDA_ERROR_PROFILER_ALREADY_STARTED", 7 },
+    /**
+     * This indicates profiler has already been stopped and probably
+     * cuProfilerStop() is incorrectly called.
+    */
+    { "CUDA_ERROR_PROFILER_ALREADY_STOPPED", 8 },
+    /**
+     * This indicates that no CUDA-capable devices were detected by the installed
+     * CUDA driver.
+     */
+    { "CUDA_ERROR_NO_DEVICE (no CUDA-capable devices were detected)", 100 },
+
+    /**
+     * This indicates that the device ordinal supplied by the user does not
+     * correspond to a valid CUDA device.
+     */
+    { "CUDA_ERROR_INVALID_DEVICE (device specified is not a valid CUDA device)", 101 },
+
+
+    /**
+     * This indicates that the device kernel image is invalid. This can also
+     * indicate an invalid CUDA module.
+     */
+    { "CUDA_ERROR_INVALID_IMAGE", 200 },
+
+    /**
+     * This most frequently indicates that there is no context bound to the
+     * current thread. This can also be returned if the context passed to an
+     * API call is not a valid handle (such as a context that has had
+     * ::cuCtxDestroy() invoked on it). This can also be returned if a user
+     * mixes different API versions (i.e. 3010 context with 3020 API calls).
+     * See ::cuCtxGetApiVersion() for more details.
+     */
+    { "CUDA_ERROR_INVALID_CONTEXT", 201 },
+
+    /**
+     * This indicated that the context being supplied as a parameter to the
+     * API call was already the active context.
+     * \deprecated
+     * This error return is deprecated as of CUDA 3.2. It is no longer an
+     * error to attempt to push the active context via ::cuCtxPushCurrent().
+     */
+    { "CUDA_ERROR_CONTEXT_ALREADY_CURRENT", 202 },
+
+    /**
+     * This indicates that a map or register operation has failed.
+     */
+    { "CUDA_ERROR_MAP_FAILED", 205 },
+
+    /**
+     * This indicates that an unmap or unregister operation has failed.
+     */
+    { "CUDA_ERROR_UNMAP_FAILED", 206 },
+
+    /**
+     * This indicates that the specified array is currently mapped and thus
+     * cannot be destroyed.
+     */
+    { "CUDA_ERROR_ARRAY_IS_MAPPED", 207 },
+
+    /**
+     * This indicates that the resource is already mapped.
+     */
+    { "CUDA_ERROR_ALREADY_MAPPED", 208 },
+
+    /**
+     * This indicates that there is no kernel image available that is suitable
+     * for the device. This can occur when a user specifies code generation
+     * options for a particular CUDA source file that do not include the
+     * corresponding device configuration.
+     */
+    { "CUDA_ERROR_NO_BINARY_FOR_GPU", 209 },
+
+    /**
+     * This indicates that a resource has already been acquired.
+     */
+    { "CUDA_ERROR_ALREADY_ACQUIRED", 210 },
+
+    /**
+     * This indicates that a resource is not mapped.
+     */
+    { "CUDA_ERROR_NOT_MAPPED", 211 },
+
+    /**
+     * This indicates that a mapped resource is not available for access as an
+     * array.
+     */
+    { "CUDA_ERROR_NOT_MAPPED_AS_ARRAY", 212 },
+
+    /**
+     * This indicates that a mapped resource is not available for access as a
+     * pointer.
+     */
+    { "CUDA_ERROR_NOT_MAPPED_AS_POINTER", 213 },
+
+    /**
+     * This indicates that an uncorrectable ECC error was detected during
+     * execution.
+     */
+    { "CUDA_ERROR_ECC_UNCORRECTABLE", 214 },
+
+    /**
+     * This indicates that the ::CUlimit passed to the API call is not
+     * supported by the active device.
+     */
+    { "CUDA_ERROR_UNSUPPORTED_LIMIT", 215 },
+
+    /**
+     * This indicates that the ::CUcontext passed to the API call can
+     * only be bound to a single CPU thread at a time but is already
+     * bound to a CPU thread.
+     */
+    { "CUDA_ERROR_CONTEXT_ALREADY_IN_USE", 216 },
+
+    /**
+     * This indicates that the device kernel source is invalid.
+     */
+    { "CUDA_ERROR_INVALID_SOURCE", 300 },
+
+    /**
+     * This indicates that the file specified was not found.
+     */
+    { "CUDA_ERROR_FILE_NOT_FOUND", 301 },
+
+    /**
+     * This indicates that a link to a shared object failed to resolve.
+     */
+    { "CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND", 302 },
+
+    /**
+     * This indicates that initialization of a shared object failed.
+     */
+    { "CUDA_ERROR_SHARED_OBJECT_INIT_FAILED", 303 },
+
+    /**
+     * This indicates that an OS call failed.
+     */
+    { "CUDA_ERROR_OPERATING_SYSTEM", 304 },
+
+
+    /**
+     * This indicates that a resource handle passed to the API call was not
+     * valid. Resource handles are opaque types like ::CUstream and ::CUevent.
+     */
+    { "CUDA_ERROR_INVALID_HANDLE", 400 },
+
+
+    /**
+     * This indicates that a named symbol was not found. Examples of symbols
+     * are global/constant variable names, texture names }, and surface names.
+     */
+    { "CUDA_ERROR_NOT_FOUND", 500 },
+
+
+    /**
+     * This indicates that asynchronous operations issued previously have not
+     * completed yet. This result is not actually an error, but must be indicated
+     * differently than ::CUDA_SUCCESS (which indicates completion). Calls that
+     * may return this value include ::cuEventQuery() and ::cuStreamQuery().
+     */
+    { "CUDA_ERROR_NOT_READY", 600 },
+
+
+    /**
+     * An exception occurred on the device while executing a kernel. Common
+     * causes include dereferencing an invalid device pointer and accessing
+     * out of bounds shared memory. The context cannot be used }, so it must
+     * be destroyed (and a new one should be created). All existing device
+     * memory allocations from this context are invalid and must be
+     * reconstructed if the program is to continue using CUDA.
+     */
+    { "CUDA_ERROR_LAUNCH_FAILED", 700 },
+
+    /**
+     * This indicates that a launch did not occur because it did not have
+     * appropriate resources. This error usually indicates that the user has
+     * attempted to pass too many arguments to the device kernel, or the
+     * kernel launch specifies too many threads for the kernel's register
+     * count. Passing arguments of the wrong size (i.e. a 64-bit pointer
+     * when a 32-bit int is expected) is equivalent to passing too many
+     * arguments and can also result in this error.
+     */
+    { "CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES", 701 },
+
+    /**
+     * This indicates that the device kernel took too long to execute. This can
+     * only occur if timeouts are enabled - see the device attribute
+     * ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information. The
+     * context cannot be used (and must be destroyed similar to
+     * ::CUDA_ERROR_LAUNCH_FAILED). All existing device memory allocations from
+     * this context are invalid and must be reconstructed if the program is to
+     * continue using CUDA.
+     */
+    { "CUDA_ERROR_LAUNCH_TIMEOUT", 702 },
+
+    /**
+     * This error indicates a kernel launch that uses an incompatible texturing
+     * mode.
+     */
+    { "CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING", 703 },
+
+    /**
+     * This error indicates that a call to ::cuCtxEnablePeerAccess() is
+     * trying to re-enable peer access to a context which has already
+     * had peer access to it enabled.
+     */
+    { "CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED", 704 },
+
+    /**
+     * This error indicates that ::cuCtxDisablePeerAccess() is
+     * trying to disable peer access which has not been enabled yet
+     * via ::cuCtxEnablePeerAccess().
+     */
+    { "CUDA_ERROR_PEER_ACCESS_NOT_ENABLED", 705 },
+
+    /**
+     * This error indicates that the primary context for the specified device
+     * has already been initialized.
+     */
+    { "CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE", 708 },
+
+    /**
+     * This error indicates that the context current to the calling thread
+     * has been destroyed using ::cuCtxDestroy }, or is a primary context which
+     * has not yet been initialized.
+     */
+    { "CUDA_ERROR_CONTEXT_IS_DESTROYED", 709 },
+
+    /**
+     * A device-side assert triggered during kernel execution. The context
+     * cannot be used anymore, and must be destroyed. All existing device
+     * memory allocations from this context are invalid and must be
+     * reconstructed if the program is to continue using CUDA.
+     */
+    { "CUDA_ERROR_ASSERT", 710 },
+
+    /**
+     * This indicates that an unknown internal error has occurred.
+     */
+    { "CUDA_ERROR_UNKNOWN", 999 },
+    { NULL, -1 }
+};
+
+// This is just a linear search through the array, since the error_id's are not
+// always ocurring consecutively
+inline const char *getCudaDrvErrorString(CUresult error_id)
+{
+    int index = 0;
+
+    while (sCudaDrvErrorString[index].error_id != error_id &&
+           sCudaDrvErrorString[index].error_id != -1)
+    {
+        index++;
+    }
+
+    if (sCudaDrvErrorString[index].error_id == error_id)
+        return (const char *)sCudaDrvErrorString[index].error_string;
+    else
+        return (const char *)"CUDA_ERROR not found!";
+}
+
+#endif // __cuda_cuda_h__
+
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_cuda.h gpu-rodinia_new/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_cuda.h
--- gpu-rodinia/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_cuda.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_cuda.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,1703 @@
+/*
+ * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+
+#ifndef __cuda_drvapi_dynlink_cuda_h__
+#define __cuda_drvapi_dynlink_cuda_h__
+
+#include <stdlib.h>
+
+/**
+ * CUDA API versioning support
+ */
+#define __CUDA_API_VERSION 4000
+
+/**
+ * \defgroup CUDA_DRIVER CUDA Driver API
+ *
+ * This section describes the low-level CUDA driver application programming
+ * interface.
+ *
+ * @{
+ */
+
+/**
+ * \defgroup CUDA_TYPES Data types used by CUDA driver
+ * @{
+ */
+
+/**
+ * CUDA API version number
+ */
+#define CUDA_VERSION 3020 /* 3.2 */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * CUDA device pointer
+     */
+#if __CUDA_API_VERSION >= 3020
+
+#if defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)
+    typedef unsigned long long CUdeviceptr;
+#else
+    typedef unsigned int CUdeviceptr;
+#endif
+
+#endif /* __CUDA_API_VERSION >= 3020 */
+
+    typedef int CUdevice;                                     /**< CUDA device */
+    typedef struct CUctx_st *CUcontext;                       /**< CUDA context */
+    typedef struct CUmod_st *CUmodule;                        /**< CUDA module */
+    typedef struct CUfunc_st *CUfunction;                     /**< CUDA function */
+    typedef struct CUarray_st *CUarray;                       /**< CUDA array */
+    typedef struct CUtexref_st *CUtexref;                     /**< CUDA texture reference */
+    typedef struct CUsurfref_st *CUsurfref;                   /**< CUDA surface reference */
+    typedef struct CUevent_st *CUevent;                       /**< CUDA event */
+    typedef struct CUstream_st *CUstream;                     /**< CUDA stream */
+    typedef struct CUgraphicsResource_st *CUgraphicsResource; /**< CUDA graphics interop resource */
+
+    typedef struct CUuuid_st                                  /**< CUDA definition of UUID */
+    {
+        char bytes[16];
+    } CUuuid;
+
+    /**
+     * Context creation flags
+     */
+    typedef enum CUctx_flags_enum
+    {
+        CU_CTX_SCHED_AUTO          = 0x00, /**< Automatic scheduling */
+        CU_CTX_SCHED_SPIN          = 0x01, /**< Set spin as default scheduling */
+        CU_CTX_SCHED_YIELD         = 0x02, /**< Set yield as default scheduling */
+        CU_CTX_SCHED_BLOCKING_SYNC = 0x04, /**< Set blocking synchronization as default scheduling */
+        CU_CTX_BLOCKING_SYNC       = 0x04, /**< Set blocking synchronization as default scheduling \deprecated */
+        CU_CTX_MAP_HOST            = 0x08, /**< Support mapped pinned allocations */
+        CU_CTX_LMEM_RESIZE_TO_MAX  = 0x10, /**< Keep local memory allocation after launch */
+#if __CUDA_API_VERSION < 4000
+        CU_CTX_SCHED_MASK          = 0x03,
+        CU_CTX_FLAGS_MASK          = 0x1f
+#else
+        CU_CTX_SCHED_MASK          = 0x07,
+        CU_CTX_PRIMARY             = 0x20, /**< Initialize and return the primary context */
+        CU_CTX_FLAGS_MASK          = 0x3f
+#endif
+    } CUctx_flags;
+
+    /**
+     * Event creation flags
+     */
+    typedef enum CUevent_flags_enum
+    {
+        CU_EVENT_DEFAULT        = 0, /**< Default event flag */
+        CU_EVENT_BLOCKING_SYNC  = 1, /**< Event uses blocking synchronization */
+        CU_EVENT_DISABLE_TIMING = 2  /**< Event will not record timing data */
+    } CUevent_flags;
+
+    /**
+     * Array formats
+     */
+    typedef enum CUarray_format_enum
+    {
+        CU_AD_FORMAT_UNSIGNED_INT8  = 0x01, /**< Unsigned 8-bit integers */
+        CU_AD_FORMAT_UNSIGNED_INT16 = 0x02, /**< Unsigned 16-bit integers */
+        CU_AD_FORMAT_UNSIGNED_INT32 = 0x03, /**< Unsigned 32-bit integers */
+        CU_AD_FORMAT_SIGNED_INT8    = 0x08, /**< Signed 8-bit integers */
+        CU_AD_FORMAT_SIGNED_INT16   = 0x09, /**< Signed 16-bit integers */
+        CU_AD_FORMAT_SIGNED_INT32   = 0x0a, /**< Signed 32-bit integers */
+        CU_AD_FORMAT_HALF           = 0x10, /**< 16-bit floating point */
+        CU_AD_FORMAT_FLOAT          = 0x20  /**< 32-bit floating point */
+    } CUarray_format;
+
+    /**
+     * Texture reference addressing modes
+     */
+    typedef enum CUaddress_mode_enum
+    {
+        CU_TR_ADDRESS_MODE_WRAP   = 0, /**< Wrapping address mode */
+        CU_TR_ADDRESS_MODE_CLAMP  = 1, /**< Clamp to edge address mode */
+        CU_TR_ADDRESS_MODE_MIRROR = 2, /**< Mirror address mode */
+        CU_TR_ADDRESS_MODE_BORDER = 3  /**< Border address mode */
+    } CUaddress_mode;
+
+    /**
+     * Texture reference filtering modes
+     */
+    typedef enum CUfilter_mode_enum
+    {
+        CU_TR_FILTER_MODE_POINT  = 0, /**< Point filter mode */
+        CU_TR_FILTER_MODE_LINEAR = 1  /**< Linear filter mode */
+    } CUfilter_mode;
+
+    /**
+     * Device properties
+     */
+    typedef enum CUdevice_attribute_enum
+    {
+        CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,              /**< Maximum number of threads per block */
+        CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,                    /**< Maximum block dimension X */
+        CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,                    /**< Maximum block dimension Y */
+        CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,                    /**< Maximum block dimension Z */
+        CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,                     /**< Maximum grid dimension X */
+        CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,                     /**< Maximum grid dimension Y */
+        CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,                     /**< Maximum grid dimension Z */
+        CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,        /**< Maximum shared memory available per block in bytes */
+        CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8,            /**< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK */
+        CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,              /**< Memory available on device for __constant__ variables in a CUDA C kernel in bytes */
+        CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,                         /**< Warp size in threads */
+        CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,                         /**< Maximum pitch in bytes allowed by memory copies */
+        CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,           /**< Maximum number of 32-bit registers available per block */
+        CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12,               /**< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK */
+        CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,                        /**< Peak clock frequency in kilohertz */
+        CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,                 /**< Alignment requirement for textures */
+        CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,                       /**< Device can possibly copy memory and execute a kernel concurrently */
+        CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,              /**< Number of multiprocessors on device */
+        CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,               /**< Specifies whether there is a run time limit on kernels */
+        CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,                        /**< Device is integrated with host memory */
+        CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,               /**< Device can map host memory into CUDA address space */
+        CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,                      /**< Compute mode (See ::CUcomputemode for details) */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,           /**< Maximum 1D texture width */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,           /**< Maximum 2D texture width */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,          /**< Maximum 2D texture height */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,           /**< Maximum 3D texture width */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,          /**< Maximum 3D texture height */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,           /**< Maximum 3D texture depth */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27,     /**< Maximum texture array width */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = 28,    /**< Maximum texture array height */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = 29, /**< Maximum slices in a texture array */
+        CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,                 /**< Alignment requirement for surfaces */
+        CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,                /**< Device can possibly execute multiple kernels concurrently */
+        CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,                       /**< Device has ECC support enabled */
+        CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,                        /**< PCI bus ID of the device */
+        CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,                     /**< PCI device ID of the device */
+        CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35                         /**< Device is using TCC driver model */
+
+#if __CUDA_API_VERSION >= 4000
+                                         ,
+        CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,                 /**< Peak memory clock frequency in kilohertz */
+        CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,           /**< Global memory bus width in bits */
+        CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,                     /**< Size of L2 cache in bytes */
+        CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,    /**< Maximum resident threads per multiprocessor */
+        CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,                /**< Number of asynchronous engines */
+        CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,                /**< Device uses shares a unified address space with the host */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,   /**< Maximum 1D layered texture width */
+        CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43   /**< Maximum layers in a 1D layered texture */
+#endif
+    } CUdevice_attribute;
+
+    /**
+     * Legacy device properties
+     */
+    typedef struct CUdevprop_st
+    {
+        int maxThreadsPerBlock;     /**< Maximum number of threads per block */
+        int maxThreadsDim[3];       /**< Maximum size of each dimension of a block */
+        int maxGridSize[3];         /**< Maximum size of each dimension of a grid */
+        int sharedMemPerBlock;      /**< Shared memory available per block in bytes */
+        int totalConstantMemory;    /**< Constant memory available on device in bytes */
+        int SIMDWidth;              /**< Warp size in threads */
+        int memPitch;               /**< Maximum pitch in bytes allowed by memory copies */
+        int regsPerBlock;           /**< 32-bit registers available per block */
+        int clockRate;              /**< Clock frequency in kilohertz */
+        int textureAlign;           /**< Alignment requirement for textures */
+    } CUdevprop;
+
+    /**
+     * Function properties
+     */
+    typedef enum CUfunction_attribute_enum
+    {
+        /**
+         * The maximum number of threads per block, beyond which a launch of the
+         * function would fail. This number depends on both the function and the
+         * device on which the function is currently loaded.
+         */
+        CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
+
+        /**
+         * The size in bytes of statically-allocated shared memory required by
+         * this function. This does not include dynamically-allocated shared
+         * memory requested by the user at runtime.
+         */
+        CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
+
+        /**
+         * The size in bytes of user-allocated constant memory required by this
+         * function.
+         */
+        CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
+
+        /**
+         * The size in bytes of local memory used by each thread of this function.
+         */
+        CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
+
+        /**
+         * The number of registers used by each thread of this function.
+         */
+        CU_FUNC_ATTRIBUTE_NUM_REGS = 4,
+
+        /**
+         * The PTX virtual architecture version for which the function was
+         * compiled. This value is the major PTX version * 10 + the minor PTX
+         * version, so a PTX version 1.3 function would return the value 13.
+         * Note that this may return the undefined value of 0 for cubins
+         * compiled prior to CUDA 3.0.
+         */
+        CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,
+
+        /**
+         * The binary architecture version for which the function was compiled.
+         * This value is the major binary version * 10 + the minor binary version,
+         * so a binary version 1.3 function would return the value 13. Note that
+         * this will return a value of 10 for legacy cubins that do not have a
+         * properly-encoded binary architecture version.
+         */
+        CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
+
+        CU_FUNC_ATTRIBUTE_MAX
+    } CUfunction_attribute;
+
+    /**
+     * Function cache configurations
+     */
+    typedef enum CUfunc_cache_enum
+    {
+        CU_FUNC_CACHE_PREFER_NONE    = 0x00, /**< no preference for shared memory or L1 (default) */
+        CU_FUNC_CACHE_PREFER_SHARED  = 0x01, /**< prefer larger shared memory and smaller L1 cache */
+        CU_FUNC_CACHE_PREFER_L1      = 0x02  /**< prefer larger L1 cache and smaller shared memory */
+    } CUfunc_cache;
+
+    /**
+     * Memory types
+     */
+    typedef enum CUmemorytype_enum
+    {
+        CU_MEMORYTYPE_HOST    = 0x01,    /**< Host memory */
+        CU_MEMORYTYPE_DEVICE  = 0x02,    /**< Device memory */
+        CU_MEMORYTYPE_ARRAY   = 0x03     /**< Array memory */
+#if __CUDA_API_VERSION >= 4000
+                                ,
+        CU_MEMORYTYPE_UNIFIED = 0x04     /**< Unified device or host memory */
+#endif
+    } CUmemorytype;
+
+    /**
+     * Compute Modes
+     */
+    typedef enum CUcomputemode_enum
+    {
+        CU_COMPUTEMODE_DEFAULT    = 0,  /**< Default compute mode (Multiple contexts allowed per device) */
+        CU_COMPUTEMODE_EXCLUSIVE         = 1, /**< Compute-exclusive-thread mode (Only one context used by a single thread can be present on this device at a time) */
+        CU_COMPUTEMODE_PROHIBITED        = 2  /**< Compute-prohibited mode (No contexts can be created on this device at this time) */
+#if __CUDA_API_VERSION >= 4000
+                                           ,
+        CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3  /**< Compute-exclusive-process mode (Only one context used by a single process can be present on this device at a time) */
+#endif
+    } CUcomputemode;
+
+    /**
+     * Online compiler options
+     */
+    typedef enum CUjit_option_enum
+    {
+        /**
+         * Max number of registers that a thread may use.\n
+         * Option type: unsigned int
+         */
+        CU_JIT_MAX_REGISTERS = 0,
+
+        /**
+         * IN: Specifies minimum number of threads per block to target compilation
+         * for\n
+         * OUT: Returns the number of threads the compiler actually targeted.
+         * This restricts the resource utilization fo the compiler (e.g. max
+         * registers) such that a block with the given number of threads should be
+         * able to launch based on register limitations. Note, this option does not
+         * currently take into account any other resource limitations, such as
+         * shared memory utilization.\n
+         * Option type: unsigned int
+         */
+        CU_JIT_THREADS_PER_BLOCK,
+
+        /**
+         * Returns a float value in the option of the wall clock time, in
+         * milliseconds, spent creating the cubin\n
+         * Option type: float
+         */
+        CU_JIT_WALL_TIME,
+
+        /**
+         * Pointer to a buffer in which to print any log messsages from PTXAS
+         * that are informational in nature (the buffer size is specified via
+         * option ::CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES) \n
+         * Option type: char*
+         */
+        CU_JIT_INFO_LOG_BUFFER,
+
+        /**
+         * IN: Log buffer size in bytes.  Log messages will be capped at this size
+         * (including null terminator)\n
+         * OUT: Amount of log buffer filled with messages\n
+         * Option type: unsigned int
+         */
+        CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES,
+
+        /**
+         * Pointer to a buffer in which to print any log messages from PTXAS that
+         * reflect errors (the buffer size is specified via option
+         * ::CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES)\n
+         * Option type: char*
+         */
+        CU_JIT_ERROR_LOG_BUFFER,
+
+        /**
+         * IN: Log buffer size in bytes.  Log messages will be capped at this size
+         * (including null terminator)\n
+         * OUT: Amount of log buffer filled with messages\n
+         * Option type: unsigned int
+         */
+        CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES,
+
+        /**
+         * Level of optimizations to apply to generated code (0 - 4), with 4
+         * being the default and highest level of optimizations.\n
+         * Option type: unsigned int
+         */
+        CU_JIT_OPTIMIZATION_LEVEL,
+
+        /**
+         * No option value required. Determines the target based on the current
+         * attached context (default)\n
+         * Option type: No option value needed
+         */
+        CU_JIT_TARGET_FROM_CUCONTEXT,
+
+        /**
+         * Target is chosen based on supplied ::CUjit_target_enum.\n
+         * Option type: unsigned int for enumerated type ::CUjit_target_enum
+         */
+        CU_JIT_TARGET,
+
+        /**
+         * Specifies choice of fallback strategy if matching cubin is not found.
+         * Choice is based on supplied ::CUjit_fallback_enum.\n
+         * Option type: unsigned int for enumerated type ::CUjit_fallback_enum
+         */
+        CU_JIT_FALLBACK_STRATEGY
+
+    } CUjit_option;
+
+    /**
+     * Online compilation targets
+     */
+    typedef enum CUjit_target_enum
+    {
+        CU_TARGET_COMPUTE_10 = 0,   /**< Compute device class 1.0 */
+        CU_TARGET_COMPUTE_11,       /**< Compute device class 1.1 */
+        CU_TARGET_COMPUTE_12,       /**< Compute device class 1.2 */
+        CU_TARGET_COMPUTE_13,       /**< Compute device class 1.3 */
+        CU_TARGET_COMPUTE_20,       /**< Compute device class 2.0 */
+        CU_TARGET_COMPUTE_21        /**< Compute device class 2.1 */
+    } CUjit_target;
+
+    /**
+     * Cubin matching fallback strategies
+     */
+    typedef enum CUjit_fallback_enum
+    {
+        CU_PREFER_PTX = 0,  /**< Prefer to compile ptx */
+
+        CU_PREFER_BINARY    /**< Prefer to fall back to compatible binary code */
+
+    } CUjit_fallback;
+
+    /**
+     * Flags to register a graphics resource
+     */
+    typedef enum CUgraphicsRegisterFlags_enum
+    {
+        CU_GRAPHICS_REGISTER_FLAGS_NONE          = 0x00,
+        CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY     = 0x01,
+        CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 0x02,
+        CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST  = 0x04
+    } CUgraphicsRegisterFlags;
+
+    /**
+     * Flags for mapping and unmapping interop resources
+     */
+    typedef enum CUgraphicsMapResourceFlags_enum
+    {
+        CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE          = 0x00,
+        CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY     = 0x01,
+        CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 0x02
+    } CUgraphicsMapResourceFlags;
+
+    /**
+     * Array indices for cube faces
+     */
+    typedef enum CUarray_cubemap_face_enum
+    {
+        CU_CUBEMAP_FACE_POSITIVE_X  = 0x00, /**< Positive X face of cubemap */
+        CU_CUBEMAP_FACE_NEGATIVE_X  = 0x01, /**< Negative X face of cubemap */
+        CU_CUBEMAP_FACE_POSITIVE_Y  = 0x02, /**< Positive Y face of cubemap */
+        CU_CUBEMAP_FACE_NEGATIVE_Y  = 0x03, /**< Negative Y face of cubemap */
+        CU_CUBEMAP_FACE_POSITIVE_Z  = 0x04, /**< Positive Z face of cubemap */
+        CU_CUBEMAP_FACE_NEGATIVE_Z  = 0x05  /**< Negative Z face of cubemap */
+    } CUarray_cubemap_face;
+
+    /**
+     * Limits
+     */
+    typedef enum CUlimit_enum
+    {
+        CU_LIMIT_STACK_SIZE        = 0x00, /**< GPU thread stack size */
+        CU_LIMIT_PRINTF_FIFO_SIZE  = 0x01, /**< GPU printf FIFO size */
+        CU_LIMIT_MALLOC_HEAP_SIZE  = 0x02  /**< GPU malloc heap size */
+    } CUlimit;
+
+    /**
+     * Error codes
+     */
+    typedef enum cudaError_enum
+    {
+        /**
+         * The API call returned with no errors. In the case of query calls, this
+         * can also mean that the operation being queried is complete (see
+         * ::cuEventQuery() and ::cuStreamQuery()).
+         */
+        CUDA_SUCCESS                              = 0,
+
+        /**
+         * This indicates that one or more of the parameters passed to the API call
+         * is not within an acceptable range of values.
+         */
+        CUDA_ERROR_INVALID_VALUE                  = 1,
+
+        /**
+         * The API call failed because it was unable to allocate enough memory to
+         * perform the requested operation.
+         */
+        CUDA_ERROR_OUT_OF_MEMORY                  = 2,
+
+        /**
+         * This indicates that the CUDA driver has not been initialized with
+         * ::cuInit() or that initialization has failed.
+         */
+        CUDA_ERROR_NOT_INITIALIZED                = 3,
+
+        /**
+         * This indicates that the CUDA driver is in the process of shutting down.
+         */
+        CUDA_ERROR_DEINITIALIZED                  = 4,
+
+        /**
+         * This indicates profiling APIs are called while application is running
+         * in visual profiler mode.
+        */
+        CUDA_ERROR_PROFILER_DISABLED           = 5,
+        /**
+         * This indicates profiling has not been initialized for this context.
+         * Call cuProfilerInitialize() to resolve this.
+        */
+        CUDA_ERROR_PROFILER_NOT_INITIALIZED       = 6,
+        /**
+         * This indicates profiler has already been started and probably
+         * cuProfilerStart() is incorrectly called.
+        */
+        CUDA_ERROR_PROFILER_ALREADY_STARTED       = 7,
+        /**
+         * This indicates profiler has already been stopped and probably
+         * cuProfilerStop() is incorrectly called.
+        */
+        CUDA_ERROR_PROFILER_ALREADY_STOPPED       = 8,
+        /**
+         * This indicates that no CUDA-capable devices were detected by the installed
+         * CUDA driver.
+         */
+        CUDA_ERROR_NO_DEVICE                      = 100,
+
+        /**
+         * This indicates that the device ordinal supplied by the user does not
+         * correspond to a valid CUDA device.
+         */
+        CUDA_ERROR_INVALID_DEVICE                 = 101,
+
+
+        /**
+         * This indicates that the device kernel image is invalid. This can also
+         * indicate an invalid CUDA module.
+         */
+        CUDA_ERROR_INVALID_IMAGE                  = 200,
+
+        /**
+         * This most frequently indicates that there is no context bound to the
+         * current thread. This can also be returned if the context passed to an
+         * API call is not a valid handle (such as a context that has had
+         * ::cuCtxDestroy() invoked on it). This can also be returned if a user
+         * mixes different API versions (i.e. 3010 context with 3020 API calls).
+         * See ::cuCtxGetApiVersion() for more details.
+         */
+        CUDA_ERROR_INVALID_CONTEXT                = 201,
+
+        /**
+         * This indicated that the context being supplied as a parameter to the
+         * API call was already the active context.
+         * \deprecated
+         * This error return is deprecated as of CUDA 3.2. It is no longer an
+         * error to attempt to push the active context via ::cuCtxPushCurrent().
+         */
+        CUDA_ERROR_CONTEXT_ALREADY_CURRENT        = 202,
+
+        /**
+         * This indicates that a map or register operation has failed.
+         */
+        CUDA_ERROR_MAP_FAILED                     = 205,
+
+        /**
+         * This indicates that an unmap or unregister operation has failed.
+         */
+        CUDA_ERROR_UNMAP_FAILED                   = 206,
+
+        /**
+         * This indicates that the specified array is currently mapped and thus
+         * cannot be destroyed.
+         */
+        CUDA_ERROR_ARRAY_IS_MAPPED                = 207,
+
+        /**
+         * This indicates that the resource is already mapped.
+         */
+        CUDA_ERROR_ALREADY_MAPPED                 = 208,
+
+        /**
+         * This indicates that there is no kernel image available that is suitable
+         * for the device. This can occur when a user specifies code generation
+         * options for a particular CUDA source file that do not include the
+         * corresponding device configuration.
+         */
+        CUDA_ERROR_NO_BINARY_FOR_GPU              = 209,
+
+        /**
+         * This indicates that a resource has already been acquired.
+         */
+        CUDA_ERROR_ALREADY_ACQUIRED               = 210,
+
+        /**
+         * This indicates that a resource is not mapped.
+         */
+        CUDA_ERROR_NOT_MAPPED                     = 211,
+
+        /**
+         * This indicates that a mapped resource is not available for access as an
+         * array.
+         */
+        CUDA_ERROR_NOT_MAPPED_AS_ARRAY            = 212,
+
+        /**
+         * This indicates that a mapped resource is not available for access as a
+         * pointer.
+         */
+        CUDA_ERROR_NOT_MAPPED_AS_POINTER          = 213,
+
+        /**
+         * This indicates that an uncorrectable ECC error was detected during
+         * execution.
+         */
+        CUDA_ERROR_ECC_UNCORRECTABLE              = 214,
+
+        /**
+         * This indicates that the ::CUlimit passed to the API call is not
+         * supported by the active device.
+         */
+        CUDA_ERROR_UNSUPPORTED_LIMIT              = 215,
+
+        /**
+         * This indicates that the ::CUcontext passed to the API call can
+         * only be bound to a single CPU thread at a time but is already
+         * bound to a CPU thread.
+         */
+        CUDA_ERROR_CONTEXT_ALREADY_IN_USE         = 216,
+
+        /**
+         * This indicates that the device kernel source is invalid.
+         */
+        CUDA_ERROR_INVALID_SOURCE                 = 300,
+
+        /**
+         * This indicates that the file specified was not found.
+         */
+        CUDA_ERROR_FILE_NOT_FOUND                 = 301,
+
+        /**
+         * This indicates that a link to a shared object failed to resolve.
+         */
+        CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,
+
+        /**
+         * This indicates that initialization of a shared object failed.
+         */
+        CUDA_ERROR_SHARED_OBJECT_INIT_FAILED      = 303,
+
+        /**
+         * This indicates that an OS call failed.
+         */
+        CUDA_ERROR_OPERATING_SYSTEM               = 304,
+
+
+        /**
+         * This indicates that a resource handle passed to the API call was not
+         * valid. Resource handles are opaque types like ::CUstream and ::CUevent.
+         */
+        CUDA_ERROR_INVALID_HANDLE                 = 400,
+
+
+        /**
+         * This indicates that a named symbol was not found. Examples of symbols
+         * are global/constant variable names, texture names, and surface names.
+         */
+        CUDA_ERROR_NOT_FOUND                      = 500,
+
+
+        /**
+         * This indicates that asynchronous operations issued previously have not
+         * completed yet. This result is not actually an error, but must be indicated
+         * differently than ::CUDA_SUCCESS (which indicates completion). Calls that
+         * may return this value include ::cuEventQuery() and ::cuStreamQuery().
+         */
+        CUDA_ERROR_NOT_READY                      = 600,
+
+
+        /**
+         * An exception occurred on the device while executing a kernel. Common
+         * causes include dereferencing an invalid device pointer and accessing
+         * out of bounds shared memory. The context cannot be used, so it must
+         * be destroyed (and a new one should be created). All existing device
+         * memory allocations from this context are invalid and must be
+         * reconstructed if the program is to continue using CUDA.
+         */
+        CUDA_ERROR_LAUNCH_FAILED                  = 700,
+
+        /**
+         * This indicates that a launch did not occur because it did not have
+         * appropriate resources. This error usually indicates that the user has
+         * attempted to pass too many arguments to the device kernel, or the
+         * kernel launch specifies too many threads for the kernel's register
+         * count. Passing arguments of the wrong size (i.e. a 64-bit pointer
+         * when a 32-bit int is expected) is equivalent to passing too many
+         * arguments and can also result in this error.
+         */
+        CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES        = 701,
+
+        /**
+         * This indicates that the device kernel took too long to execute. This can
+         * only occur if timeouts are enabled - see the device attribute
+         * ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information. The
+         * context cannot be used (and must be destroyed similar to
+         * ::CUDA_ERROR_LAUNCH_FAILED). All existing device memory allocations from
+         * this context are invalid and must be reconstructed if the program is to
+         * continue using CUDA.
+         */
+        CUDA_ERROR_LAUNCH_TIMEOUT                 = 702,
+
+        /**
+         * This error indicates a kernel launch that uses an incompatible texturing
+         * mode.
+         */
+        CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING  = 703,
+
+        /**
+         * This error indicates that a call to ::cuCtxEnablePeerAccess() is
+         * trying to re-enable peer access to a context which has already
+         * had peer access to it enabled.
+         */
+        CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704,
+
+        /**
+         * This error indicates that a call to ::cuMemPeerRegister is trying to
+         * register memory from a context which has not had peer access
+         * enabled yet via ::cuCtxEnablePeerAccess(), or that
+         * ::cuCtxDisablePeerAccess() is trying to disable peer access
+         * which has not been enabled yet.
+         */
+        CUDA_ERROR_PEER_ACCESS_NOT_ENABLED    = 705,
+
+        /**
+         * This error indicates that a call to ::cuMemPeerRegister is trying to
+         * register already-registered memory.
+         */
+        CUDA_ERROR_PEER_MEMORY_ALREADY_REGISTERED = 706,
+
+        /**
+         * This error indicates that a call to ::cuMemPeerUnregister is trying to
+         * unregister memory that has not been registered.
+         */
+        CUDA_ERROR_PEER_MEMORY_NOT_REGISTERED     = 707,
+
+        /**
+         * This error indicates that ::cuCtxCreate was called with the flag
+         * ::CU_CTX_PRIMARY on a device which already has initialized its
+         * primary context.
+         */
+        CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE         = 708,
+
+        /**
+         * This error indicates that the context current to the calling thread
+         * has been destroyed using ::cuCtxDestroy, or is a primary context which
+         * has not yet been initialized.
+         */
+        CUDA_ERROR_CONTEXT_IS_DESTROYED           = 709,
+
+        /**
+         * This indicates that an unknown internal error has occurred.
+         */
+        CUDA_ERROR_UNKNOWN                        = 999
+    } CUresult;
+
+#if __CUDA_API_VERSION >= 4000
+    /**
+     * If set, host memory is portable between CUDA contexts.
+     * Flag for ::cuMemHostAlloc()
+     */
+#define CU_MEMHOSTALLOC_PORTABLE        0x01
+
+    /**
+     * If set, host memory is mapped into CUDA address space and
+     * ::cuMemHostGetDevicePointer() may be called on the host pointer.
+     * Flag for ::cuMemHostAlloc()
+     */
+#define CU_MEMHOSTALLOC_DEVICEMAP       0x02
+
+    /**
+     * If set, host memory is allocated as write-combined - fast to write,
+     * faster to DMA, slow to read except via SSE4 streaming load instruction
+     * (MOVNTDQA).
+     * Flag for ::cuMemHostAlloc()
+     */
+#define CU_MEMHOSTALLOC_WRITECOMBINED   0x04
+
+    /**
+     * If set, host memory is portable between CUDA contexts.
+     * Flag for ::cuMemHostRegister()
+     */
+#define CU_MEMHOSTREGISTER_PORTABLE     0x01
+
+    /**
+     * If set, host memory is mapped into CUDA address space and
+     * ::cuMemHostGetDevicePointer() may be called on the host pointer.
+     * Flag for ::cuMemHostRegister()
+     */
+#define CU_MEMHOSTREGISTER_DEVICEMAP    0x02
+
+    /**
+     * If set, peer memory is mapped into CUDA address space and
+     * ::cuMemPeerGetDevicePointer() may be called on the host pointer.
+     * Flag for ::cuMemPeerRegister()
+     */
+#define CU_MEMPEERREGISTER_DEVICEMAP    0x02
+#endif
+
+#if __CUDA_API_VERSION >= 3020
+
+    /**
+     * 2D memory copy parameters
+     */
+    typedef struct CUDA_MEMCPY2D_st
+    {
+        size_t srcXInBytes;         /**< Source X in bytes */
+        size_t srcY;                /**< Source Y */
+
+        CUmemorytype srcMemoryType; /**< Source memory type (host, device, array) */
+        const void *srcHost;        /**< Source host pointer */
+        CUdeviceptr srcDevice;      /**< Source device pointer */
+        CUarray srcArray;           /**< Source array reference */
+        size_t srcPitch;            /**< Source pitch (ignored when src is array) */
+
+        size_t dstXInBytes;         /**< Destination X in bytes */
+        size_t dstY;                /**< Destination Y */
+
+        CUmemorytype dstMemoryType; /**< Destination memory type (host, device, array) */
+        void *dstHost;              /**< Destination host pointer */
+        CUdeviceptr dstDevice;      /**< Destination device pointer */
+        CUarray dstArray;           /**< Destination array reference */
+        size_t dstPitch;            /**< Destination pitch (ignored when dst is array) */
+
+        size_t WidthInBytes;        /**< Width of 2D memory copy in bytes */
+        size_t Height;              /**< Height of 2D memory copy */
+    } CUDA_MEMCPY2D;
+
+    /**
+     * 3D memory copy parameters
+     */
+    typedef struct CUDA_MEMCPY3D_st
+    {
+        size_t srcXInBytes;         /**< Source X in bytes */
+        size_t srcY;                /**< Source Y */
+        size_t srcZ;                /**< Source Z */
+        size_t srcLOD;              /**< Source LOD */
+        CUmemorytype srcMemoryType; /**< Source memory type (host, device, array) */
+        const void *srcHost;        /**< Source host pointer */
+        CUdeviceptr srcDevice;      /**< Source device pointer */
+        CUarray srcArray;           /**< Source array reference */
+        void *reserved0;            /**< Must be NULL */
+        size_t srcPitch;            /**< Source pitch (ignored when src is array) */
+        size_t srcHeight;           /**< Source height (ignored when src is array; may be 0 if Depth==1) */
+
+        size_t dstXInBytes;         /**< Destination X in bytes */
+        size_t dstY;                /**< Destination Y */
+        size_t dstZ;                /**< Destination Z */
+        size_t dstLOD;              /**< Destination LOD */
+        CUmemorytype dstMemoryType; /**< Destination memory type (host, device, array) */
+        void *dstHost;              /**< Destination host pointer */
+        CUdeviceptr dstDevice;      /**< Destination device pointer */
+        CUarray dstArray;           /**< Destination array reference */
+        void *reserved1;            /**< Must be NULL */
+        size_t dstPitch;            /**< Destination pitch (ignored when dst is array) */
+        size_t dstHeight;           /**< Destination height (ignored when dst is array; may be 0 if Depth==1) */
+
+        size_t WidthInBytes;        /**< Width of 3D memory copy in bytes */
+        size_t Height;              /**< Height of 3D memory copy */
+        size_t Depth;               /**< Depth of 3D memory copy */
+    } CUDA_MEMCPY3D;
+
+    /**
+     * 3D memory cross-context copy parameters
+     */
+    typedef struct CUDA_MEMCPY3D_PEER_st
+    {
+        size_t srcXInBytes;         /**< Source X in bytes */
+        size_t srcY;                /**< Source Y */
+        size_t srcZ;                /**< Source Z */
+        size_t srcLOD;              /**< Source LOD */
+        CUmemorytype srcMemoryType; /**< Source memory type (host, device, array) */
+        const void *srcHost;        /**< Source host pointer */
+        CUdeviceptr srcDevice;      /**< Source device pointer */
+        CUarray srcArray;           /**< Source array reference */
+        CUcontext srcContext;       /**< Source context (ignored with srcMemoryType is ::CU_MEMORYTYPE_ARRAY) */
+        size_t srcPitch;            /**< Source pitch (ignored when src is array) */
+        size_t srcHeight;           /**< Source height (ignored when src is array; may be 0 if Depth==1) */
+
+        size_t dstXInBytes;         /**< Destination X in bytes */
+        size_t dstY;                /**< Destination Y */
+        size_t dstZ;                /**< Destination Z */
+        size_t dstLOD;              /**< Destination LOD */
+        CUmemorytype dstMemoryType; /**< Destination memory type (host, device, array) */
+        void *dstHost;              /**< Destination host pointer */
+        CUdeviceptr dstDevice;      /**< Destination device pointer */
+        CUarray dstArray;           /**< Destination array reference */
+        CUcontext dstContext;       /**< Destination context (ignored with dstMemoryType is ::CU_MEMORYTYPE_ARRAY) */
+        size_t dstPitch;            /**< Destination pitch (ignored when dst is array) */
+        size_t dstHeight;           /**< Destination height (ignored when dst is array; may be 0 if Depth==1) */
+
+        size_t WidthInBytes;        /**< Width of 3D memory copy in bytes */
+        size_t Height;              /**< Height of 3D memory copy */
+        size_t Depth;               /**< Depth of 3D memory copy */
+    } CUDA_MEMCPY3D_PEER;
+
+    /**
+     * Array descriptor
+     */
+    typedef struct CUDA_ARRAY_DESCRIPTOR_st
+    {
+        size_t Width;             /**< Width of array */
+        size_t Height;            /**< Height of array */
+
+        CUarray_format Format;    /**< Array format */
+        unsigned int NumChannels; /**< Channels per array element */
+    } CUDA_ARRAY_DESCRIPTOR;
+
+    /**
+     * 3D array descriptor
+     */
+    typedef struct CUDA_ARRAY3D_DESCRIPTOR_st
+    {
+        size_t Width;             /**< Width of 3D array */
+        size_t Height;            /**< Height of 3D array */
+        size_t Depth;             /**< Depth of 3D array */
+
+        CUarray_format Format;    /**< Array format */
+        unsigned int NumChannels; /**< Channels per array element */
+        unsigned int Flags;       /**< Flags */
+    } CUDA_ARRAY3D_DESCRIPTOR;
+
+#endif /* __CUDA_API_VERSION >= 3020 */
+
+    /**
+     * If set, the CUDA array is a collection of layers, where each layer is either a 1D
+     * or a 2D array and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies the number
+     * of layers, not the depth of a 3D array.
+     */
+#define CUDA_ARRAY3D_LAYERED        0x01
+
+    /**
+     * Deprecated, use CUDA_ARRAY3D_LAYERED
+     */
+#define CUDA_ARRAY3D_2DARRAY        0x01
+
+    /**
+     * This flag must be set in order to bind a surface reference
+     * to the CUDA array
+     */
+#define CUDA_ARRAY3D_SURFACE_LDST   0x02
+
+    /**
+     * Override the texref format with a format inferred from the array.
+     * Flag for ::cuTexRefSetArray()
+     */
+#define CU_TRSA_OVERRIDE_FORMAT 0x01
+
+    /**
+     * Read the texture as integers rather than promoting the values to floats
+     * in the range [0,1].
+     * Flag for ::cuTexRefSetFlags()
+     */
+#define CU_TRSF_READ_AS_INTEGER         0x01
+
+    /**
+     * Use normalized texture coordinates in the range [0,1) instead of [0,dim).
+     * Flag for ::cuTexRefSetFlags()
+     */
+#define CU_TRSF_NORMALIZED_COORDINATES  0x02
+
+    /**
+     * Perform sRGB->linear conversion during texture read.
+     * Flag for ::cuTexRefSetFlags()
+     */
+#define CU_TRSF_SRGB  0x10
+
+    /**
+     * End of array terminator for the \p extra parameter to
+     * ::cuLaunchKernel
+     */
+#define CU_LAUNCH_PARAM_END            ((void*)0x00)
+
+    /**
+     * Indicator that the next value in the \p extra parameter to
+     * ::cuLaunchKernel will be a pointer to a buffer containing all kernel
+     * parameters used for launching kernel \p f.  This buffer needs to
+     * honor all alignment/padding requirements of the individual parameters.
+     * If ::CU_LAUNCH_PARAM_BUFFER_SIZE is not also specified in the
+     * \p extra array, then ::CU_LAUNCH_PARAM_BUFFER_POINTER will have no
+     * effect.
+     */
+#define CU_LAUNCH_PARAM_BUFFER_POINTER ((void*)0x01)
+
+    /**
+     * Indicator that the next value in the \p extra parameter to
+     * ::cuLaunchKernel will be a pointer to a size_t which contains the
+     * size of the buffer specified with ::CU_LAUNCH_PARAM_BUFFER_POINTER.
+     * It is required that ::CU_LAUNCH_PARAM_BUFFER_POINTER also be specified
+     * in the \p extra array if the value associated with
+     * ::CU_LAUNCH_PARAM_BUFFER_SIZE is not zero.
+     */
+#define CU_LAUNCH_PARAM_BUFFER_SIZE    ((void*)0x02)
+
+    /**
+     * For texture references loaded into the module, use default texunit from
+     * texture reference.
+     */
+#define CU_PARAM_TR_DEFAULT -1
+
+    /**
+     * CUDA API made obselete at API version 3020
+     */
+#if defined(__CUDA_API_VERSION_INTERNAL)
+#define CUdeviceptr                  CUdeviceptr_v1
+#define CUDA_MEMCPY2D_st             CUDA_MEMCPY2D_v1_st
+#define CUDA_MEMCPY2D                CUDA_MEMCPY2D_v1
+#define CUDA_MEMCPY3D_st             CUDA_MEMCPY3D_v1_st
+#define CUDA_MEMCPY3D                CUDA_MEMCPY3D_v1
+#define CUDA_ARRAY_DESCRIPTOR_st     CUDA_ARRAY_DESCRIPTOR_v1_st
+#define CUDA_ARRAY_DESCRIPTOR        CUDA_ARRAY_DESCRIPTOR_v1
+#define CUDA_ARRAY3D_DESCRIPTOR_st   CUDA_ARRAY3D_DESCRIPTOR_v1_st
+#define CUDA_ARRAY3D_DESCRIPTOR      CUDA_ARRAY3D_DESCRIPTOR_v1
+#endif /* CUDA_FORCE_LEGACY32_INTERNAL */
+
+#if defined(__CUDA_API_VERSION_INTERNAL) || __CUDA_API_VERSION < 3020
+
+    typedef unsigned int CUdeviceptr;
+
+    typedef struct CUDA_MEMCPY2D_st
+    {
+        unsigned int srcXInBytes;   /**< Source X in bytes */
+        unsigned int srcY;          /**< Source Y */
+        CUmemorytype srcMemoryType; /**< Source memory type (host, device, array) */
+        const void *srcHost;        /**< Source host pointer */
+        CUdeviceptr srcDevice;      /**< Source device pointer */
+        CUarray srcArray;           /**< Source array reference */
+        unsigned int srcPitch;      /**< Source pitch (ignored when src is array) */
+
+        unsigned int dstXInBytes;   /**< Destination X in bytes */
+        unsigned int dstY;          /**< Destination Y */
+        CUmemorytype dstMemoryType; /**< Destination memory type (host, device, array) */
+        void *dstHost;              /**< Destination host pointer */
+        CUdeviceptr dstDevice;      /**< Destination device pointer */
+        CUarray dstArray;           /**< Destination array reference */
+        unsigned int dstPitch;      /**< Destination pitch (ignored when dst is array) */
+
+        unsigned int WidthInBytes;  /**< Width of 2D memory copy in bytes */
+        unsigned int Height;        /**< Height of 2D memory copy */
+    } CUDA_MEMCPY2D;
+
+    typedef struct CUDA_MEMCPY3D_st
+    {
+        unsigned int srcXInBytes;   /**< Source X in bytes */
+        unsigned int srcY;          /**< Source Y */
+        unsigned int srcZ;          /**< Source Z */
+        unsigned int srcLOD;        /**< Source LOD */
+        CUmemorytype srcMemoryType; /**< Source memory type (host, device, array) */
+        const void *srcHost;        /**< Source host pointer */
+        CUdeviceptr srcDevice;      /**< Source device pointer */
+        CUarray srcArray;           /**< Source array reference */
+        void *reserved0;            /**< Must be NULL */
+        unsigned int srcPitch;      /**< Source pitch (ignored when src is array) */
+        unsigned int srcHeight;     /**< Source height (ignored when src is array; may be 0 if Depth==1) */
+
+        unsigned int dstXInBytes;   /**< Destination X in bytes */
+        unsigned int dstY;          /**< Destination Y */
+        unsigned int dstZ;          /**< Destination Z */
+        unsigned int dstLOD;        /**< Destination LOD */
+        CUmemorytype dstMemoryType; /**< Destination memory type (host, device, array) */
+        void *dstHost;              /**< Destination host pointer */
+        CUdeviceptr dstDevice;      /**< Destination device pointer */
+        CUarray dstArray;           /**< Destination array reference */
+        void *reserved1;            /**< Must be NULL */
+        unsigned int dstPitch;      /**< Destination pitch (ignored when dst is array) */
+        unsigned int dstHeight;     /**< Destination height (ignored when dst is array; may be 0 if Depth==1) */
+
+        unsigned int WidthInBytes;  /**< Width of 3D memory copy in bytes */
+        unsigned int Height;        /**< Height of 3D memory copy */
+        unsigned int Depth;         /**< Depth of 3D memory copy */
+    } CUDA_MEMCPY3D;
+
+    typedef struct CUDA_ARRAY_DESCRIPTOR_st
+    {
+        unsigned int Width;         /**< Width of array */
+        unsigned int Height;        /**< Height of array */
+
+        CUarray_format Format;      /**< Array format */
+        unsigned int NumChannels;   /**< Channels per array element */
+    } CUDA_ARRAY_DESCRIPTOR;
+
+    typedef struct CUDA_ARRAY3D_DESCRIPTOR_st
+    {
+        unsigned int Width;         /**< Width of 3D array */
+        unsigned int Height;        /**< Height of 3D array */
+        unsigned int Depth;         /**< Depth of 3D array */
+
+        CUarray_format Format;      /**< Array format */
+        unsigned int NumChannels;   /**< Channels per array element */
+        unsigned int Flags;         /**< Flags */
+    } CUDA_ARRAY3D_DESCRIPTOR;
+
+#endif /* (__CUDA_API_VERSION_INTERNAL) || __CUDA_API_VERSION < 3020 */
+
+    /*
+     * If set, the CUDA array contains an array of 2D slices
+     * and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies
+     * the number of slices, not the depth of a 3D array.
+     */
+#define CUDA_ARRAY3D_2DARRAY        0x01
+
+    /**
+     * This flag must be set in order to bind a surface reference
+     * to the CUDA array
+     */
+#define CUDA_ARRAY3D_SURFACE_LDST   0x02
+
+    /**
+     * Override the texref format with a format inferred from the array.
+     * Flag for ::cuTexRefSetArray()
+     */
+#define CU_TRSA_OVERRIDE_FORMAT 0x01
+
+    /**
+     * Read the texture as integers rather than promoting the values to floats
+     * in the range [0,1].
+     * Flag for ::cuTexRefSetFlags()
+     */
+#define CU_TRSF_READ_AS_INTEGER         0x01
+
+    /**
+     * Use normalized texture coordinates in the range [0,1) instead of [0,dim).
+     * Flag for ::cuTexRefSetFlags()
+     */
+#define CU_TRSF_NORMALIZED_COORDINATES  0x02
+
+    /**
+     * Perform sRGB->linear conversion during texture read.
+     * Flag for ::cuTexRefSetFlags()
+     */
+#define CU_TRSF_SRGB  0x10
+
+    /**
+     * For texture references loaded into the module, use default texunit from
+     * texture reference.
+     */
+#define CU_PARAM_TR_DEFAULT -1
+
+    /** @} */ /* END CUDA_TYPES */
+
+#ifdef _WIN32
+#define CUDAAPI __stdcall
+#else
+#define CUDAAPI
+#endif
+
+    /**
+     * \defgroup CUDA_INITIALIZE Initialization
+     *
+     * This section describes the initialization functions of the low-level CUDA
+     * driver application programming interface.
+     *
+     * @{
+     */
+
+    /*********************************
+     ** Initialization
+     *********************************/
+    typedef CUresult  CUDAAPI tcuInit(unsigned int Flags);
+
+    /*********************************
+     ** Driver Version Query
+     *********************************/
+    typedef CUresult  CUDAAPI tcuDriverGetVersion(int *driverVersion);
+
+    /************************************
+     **
+     **    Device management
+     **
+     ***********************************/
+
+    typedef CUresult  CUDAAPI tcuDeviceGet(CUdevice *device, int ordinal);
+    typedef CUresult  CUDAAPI tcuDeviceGetCount(int *count);
+    typedef CUresult  CUDAAPI tcuDeviceGetName(char *name, int len, CUdevice dev);
+    typedef CUresult  CUDAAPI tcuDeviceComputeCapability(int *major, int *minor, CUdevice dev);
+#if __CUDA_API_VERSION >= 3020
+    typedef CUresult  CUDAAPI tcuDeviceTotalMem(size_t *bytes, CUdevice dev);
+#else
+    typedef CUresult  CUDAAPI tcuDeviceTotalMem(unsigned int *bytes, CUdevice dev);
+#endif
+
+    typedef CUresult  CUDAAPI tcuDeviceGetProperties(CUdevprop *prop, CUdevice dev);
+    typedef CUresult  CUDAAPI tcuDeviceGetAttribute(int *pi, CUdevice_attribute attrib, CUdevice dev);
+
+    /************************************
+     **
+     **    Context management
+     **
+     ***********************************/
+
+    typedef CUresult  CUDAAPI tcuCtxCreate(CUcontext *pctx, unsigned int flags, CUdevice dev);
+    typedef CUresult  CUDAAPI tcuCtxDestroy(CUcontext ctx);
+    typedef CUresult  CUDAAPI tcuCtxAttach(CUcontext *pctx, unsigned int flags);
+    typedef CUresult  CUDAAPI tcuCtxDetach(CUcontext ctx);
+    typedef CUresult  CUDAAPI tcuCtxPushCurrent(CUcontext ctx);
+    typedef CUresult  CUDAAPI tcuCtxPopCurrent(CUcontext *pctx);
+
+    typedef CUresult  CUDAAPI tcuCtxSetCurrent(CUcontext ctx);
+    typedef CUresult  CUDAAPI tcuCtxGetCurrent(CUcontext *pctx);
+
+    typedef CUresult  CUDAAPI tcuCtxGetDevice(CUdevice *device);
+    typedef CUresult  CUDAAPI tcuCtxSynchronize(void);
+
+
+    /************************************
+     **
+     **    Module management
+     **
+     ***********************************/
+
+    typedef CUresult  CUDAAPI tcuModuleLoad(CUmodule *module, const char *fname);
+    typedef CUresult  CUDAAPI tcuModuleLoadData(CUmodule *module, const void *image);
+    typedef CUresult  CUDAAPI tcuModuleLoadDataEx(CUmodule *module, const void *image, unsigned int numOptions, CUjit_option *options, void **optionValues);
+    typedef CUresult  CUDAAPI tcuModuleLoadFatBinary(CUmodule *module, const void *fatCubin);
+    typedef CUresult  CUDAAPI tcuModuleUnload(CUmodule hmod);
+    typedef CUresult  CUDAAPI tcuModuleGetFunction(CUfunction *hfunc, CUmodule hmod, const char *name);
+
+#if __CUDA_API_VERSION >= 3020
+    typedef CUresult  CUDAAPI tcuModuleGetGlobal(CUdeviceptr *dptr, size_t *bytes, CUmodule hmod, const char *name);
+#else
+    typedef CUresult  CUDAAPI tcuModuleGetGlobal(CUdeviceptr *dptr, unsigned int *bytes, CUmodule hmod, const char *name);
+#endif
+
+    typedef CUresult  CUDAAPI tcuModuleGetTexRef(CUtexref *pTexRef, CUmodule hmod, const char *name);
+    typedef CUresult  CUDAAPI tcuModuleGetSurfRef(CUsurfref *pSurfRef, CUmodule hmod, const char *name);
+
+    /************************************
+     **
+     **    Memory management
+     **
+     ***********************************/
+#if __CUDA_API_VERSION >= 3020
+    typedef CUresult CUDAAPI tcuMemGetInfo(size_t *free, size_t *total);
+    typedef CUresult CUDAAPI tcuMemAlloc(CUdeviceptr *dptr, size_t bytesize);
+    typedef CUresult CUDAAPI tcuMemGetAddressRange(CUdeviceptr *pbase, size_t *psize, CUdeviceptr dptr);
+    typedef CUresult CUDAAPI tcuMemAllocPitch(CUdeviceptr *dptr,
+                                              size_t *pPitch,
+                                              size_t WidthInBytes,
+                                              size_t Height,
+                                              // size of biggest r/w to be performed by kernels on this memory
+                                              // 4, 8 or 16 bytes
+                                              unsigned int ElementSizeBytes
+                                             );
+#else
+    typedef CUresult CUDAAPI tcuMemGetInfo(unsigned int *free, unsigned int *total);
+    typedef CUresult CUDAAPI tcuMemAlloc(CUdeviceptr *dptr, unsigned int bytesize);
+    typedef CUresult CUDAAPI tcuMemGetAddressRange(CUdeviceptr *pbase, unsigned int *psize, CUdeviceptr dptr);
+    typedef CUresult CUDAAPI tcuMemAllocPitch(CUdeviceptr *dptr,
+                                              unsigned int *pPitch,
+                                              unsigned int WidthInBytes,
+                                              unsigned int Height,
+                                              // size of biggest r/w to be performed by kernels on this memory
+                                              // 4, 8 or 16 bytes
+                                              unsigned int ElementSizeBytes
+                                             );
+#endif
+
+    typedef CUresult CUDAAPI tcuMemFree(CUdeviceptr dptr);
+
+#if __CUDA_API_VERSION >= 3020
+    typedef CUresult CUDAAPI tcuMemAllocHost(void **pp, size_t bytesize);
+#else
+    typedef CUresult CUDAAPI tcuMemAllocHost(void **pp, unsigned int bytesize);
+#endif
+
+    typedef CUresult CUDAAPI tcuMemFreeHost(void *p);
+    typedef CUresult CUDAAPI tcuMemHostAlloc(void **pp, size_t bytesize, unsigned int Flags);
+
+    typedef CUresult CUDAAPI tcuMemHostGetDevicePointer(CUdeviceptr *pdptr, void *p, unsigned int Flags);
+    typedef CUresult CUDAAPI tcuMemHostGetFlags(unsigned int *pFlags, void *p);
+
+    typedef CUresult CUDAAPI tcuMemHostRegister(void *p, size_t bytesize, unsigned int Flags);
+    typedef CUresult CUDAAPI tcuMemHostUnregister(void *p);;
+    typedef CUresult CUDAAPI tcuMemcpy(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount);
+    typedef CUresult CUDAAPI tcuMemcpyPeer(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount);
+
+    /************************************
+     **
+     **    Synchronous Memcpy
+     **
+     ** Intra-device memcpy's done with these functions may execute in parallel with the CPU,
+     ** but if host memory is involved, they wait until the copy is done before returning.
+     **
+     ***********************************/
+
+    // 1D functions
+#if __CUDA_API_VERSION >= 3020
+    // system <-> device memory
+    typedef CUresult  CUDAAPI tcuMemcpyHtoD(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount);
+    typedef CUresult  CUDAAPI tcuMemcpyDtoH(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount);
+
+    // device <-> device memory
+    typedef CUresult  CUDAAPI tcuMemcpyDtoD(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount);
+
+    // device <-> array memory
+    typedef CUresult  CUDAAPI tcuMemcpyDtoA(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount);
+    typedef CUresult  CUDAAPI tcuMemcpyAtoD(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount);
+
+    // system <-> array memory
+    typedef CUresult  CUDAAPI tcuMemcpyHtoA(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount);
+    typedef CUresult  CUDAAPI tcuMemcpyAtoH(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount);
+
+    // array <-> array memory
+    typedef CUresult  CUDAAPI tcuMemcpyAtoA(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount);
+#else
+    // system <-> device memory
+    typedef CUresult  CUDAAPI tcuMemcpyHtoD(CUdeviceptr dstDevice, const void *srcHost, unsigned int ByteCount);
+    typedef CUresult  CUDAAPI tcuMemcpyDtoH(void *dstHost, CUdeviceptr srcDevice, unsigned int ByteCount);
+
+    // device <-> device memory
+    typedef CUresult  CUDAAPI tcuMemcpyDtoD(CUdeviceptr dstDevice, CUdeviceptr srcDevice, unsigned int ByteCount);
+
+    // device <-> array memory
+    typedef CUresult  CUDAAPI tcuMemcpyDtoA(CUarray dstArray, unsigned int dstOffset, CUdeviceptr srcDevice, unsigned int ByteCount);
+    typedef CUresult  CUDAAPI tcuMemcpyAtoD(CUdeviceptr dstDevice, CUarray srcArray, unsigned int srcOffset, unsigned int ByteCount);
+
+    // system <-> array memory
+    typedef CUresult  CUDAAPI tcuMemcpyHtoA(CUarray dstArray, unsigned int dstOffset, const void *srcHost, unsigned int ByteCount);
+    typedef CUresult  CUDAAPI tcuMemcpyAtoH(void *dstHost, CUarray srcArray, unsigned int srcOffset, unsigned int ByteCount);
+
+    // array <-> array memory
+    typedef CUresult  CUDAAPI tcuMemcpyAtoA(CUarray dstArray, unsigned int dstOffset, CUarray srcArray, unsigned int srcOffset, unsigned int ByteCount);
+#endif
+
+    // 2D memcpy
+
+    typedef CUresult  CUDAAPI tcuMemcpy2D(const CUDA_MEMCPY2D *pCopy);
+    typedef CUresult  CUDAAPI tcuMemcpy2DUnaligned(const CUDA_MEMCPY2D *pCopy);
+
+    // 3D memcpy
+
+    typedef CUresult  CUDAAPI tcuMemcpy3D(const CUDA_MEMCPY3D *pCopy);
+
+    /************************************
+     **
+     **    Asynchronous Memcpy
+     **
+     ** Any host memory involved must be DMA'able (e.g., allocated with cuMemAllocHost).
+     ** memcpy's done with these functions execute in parallel with the CPU and, if
+     ** the hardware is available, may execute in parallel with the GPU.
+     ** Asynchronous memcpy must be accompanied by appropriate stream synchronization.
+     **
+     ***********************************/
+
+    // 1D functions
+#if __CUDA_API_VERSION >= 3020
+    // system <-> device memory
+    typedef CUresult  CUDAAPI tcuMemcpyHtoDAsync(CUdeviceptr dstDevice,
+                                                 const void *srcHost, size_t ByteCount, CUstream hStream);
+    typedef CUresult  CUDAAPI tcuMemcpyDtoHAsync(void *dstHost,
+                                                 CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);
+
+    // device <-> device memory
+    typedef CUresult  CUDAAPI tcuMemcpyDtoDAsync(CUdeviceptr dstDevice,
+                                                 CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);
+
+    // system <-> array memory
+    typedef CUresult  CUDAAPI tcuMemcpyHtoAAsync(CUarray dstArray, size_t dstOffset,
+                                                 const void *srcHost, size_t ByteCount, CUstream hStream);
+    typedef CUresult  CUDAAPI tcuMemcpyAtoHAsync(void *dstHost, CUarray srcArray, size_t srcOffset,
+                                                 size_t ByteCount, CUstream hStream);
+
+#else
+    // system <-> device memory
+    typedef CUresult  CUDAAPI tcuMemcpyHtoDAsync(CUdeviceptr dstDevice,
+                                                 const void *srcHost, unsigned int ByteCount, CUstream hStream);
+    typedef CUresult  CUDAAPI tcuMemcpyDtoHAsync(void *dstHost,
+                                                 CUdeviceptr srcDevice, unsigned int ByteCount, CUstream hStream);
+
+    // device <-> device memory
+    typedef CUresult  CUDAAPI tcuMemcpyDtoDAsync(CUdeviceptr dstDevice,
+                                                 CUdeviceptr srcDevice, unsigned int ByteCount, CUstream hStream);
+
+    // system <-> array memory
+    typedef CUresult  CUDAAPI tcuMemcpyHtoAAsync(CUarray dstArray, unsigned int dstOffset,
+                                                 const void *srcHost, unsigned int ByteCount, CUstream hStream);
+    typedef CUresult  CUDAAPI tcuMemcpyAtoHAsync(void *dstHost, CUarray srcArray, unsigned int srcOffset,
+                                                 unsigned int ByteCount, CUstream hStream);
+#endif
+
+    // 2D memcpy
+    typedef CUresult  CUDAAPI tcuMemcpy2DAsync(const CUDA_MEMCPY2D *pCopy, CUstream hStream);
+
+    // 3D memcpy
+    typedef CUresult  CUDAAPI tcuMemcpy3DAsync(const CUDA_MEMCPY3D *pCopy, CUstream hStream);
+
+    /************************************
+     **
+     **    Memset
+     **
+     ***********************************/
+    typedef CUresult  CUDAAPI tcuMemsetD8(CUdeviceptr dstDevice, unsigned char uc, unsigned int N);
+    typedef CUresult  CUDAAPI tcuMemsetD16(CUdeviceptr dstDevice, unsigned short us, unsigned int N);
+    typedef CUresult  CUDAAPI tcuMemsetD32(CUdeviceptr dstDevice, unsigned int ui, unsigned int N);
+
+#if __CUDA_API_VERSION >= 3020
+    typedef CUresult  CUDAAPI tcuMemsetD2D8(CUdeviceptr dstDevice, unsigned int dstPitch, unsigned char uc, size_t Width, size_t Height);
+    typedef CUresult  CUDAAPI tcuMemsetD2D16(CUdeviceptr dstDevice, unsigned int dstPitch, unsigned short us, size_t Width, size_t Height);
+    typedef CUresult  CUDAAPI tcuMemsetD2D32(CUdeviceptr dstDevice, unsigned int dstPitch, unsigned int ui, size_t Width, size_t Height);
+#else
+    typedef CUresult  CUDAAPI tcuMemsetD2D8(CUdeviceptr dstDevice, unsigned int dstPitch, unsigned char uc, unsigned int Width, unsigned int Height);
+    typedef CUresult  CUDAAPI tcuMemsetD2D16(CUdeviceptr dstDevice, unsigned int dstPitch, unsigned short us, unsigned int Width, unsigned int Height);
+    typedef CUresult  CUDAAPI tcuMemsetD2D32(CUdeviceptr dstDevice, unsigned int dstPitch, unsigned int ui, unsigned int Width, unsigned int Height);
+#endif
+
+    /************************************
+     **
+     **    Function management
+     **
+     ***********************************/
+
+
+    typedef CUresult CUDAAPI tcuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z);
+    typedef CUresult CUDAAPI tcuFuncSetSharedSize(CUfunction hfunc, unsigned int bytes);
+    typedef CUresult CUDAAPI tcuFuncGetAttribute(int *pi, CUfunction_attribute attrib, CUfunction hfunc);
+    typedef CUresult CUDAAPI tcuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config);
+    typedef CUresult CUDAAPI tcuLaunchKernel(CUfunction f,
+                                             unsigned int gridDimX,  unsigned int gridDimY,  unsigned int gridDimZ,
+                                             unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ,
+                                             unsigned int sharedMemBytes,
+                                             CUstream hStream, void **kernelParams, void **extra);
+
+    /************************************
+     **
+     **    Array management
+     **
+     ***********************************/
+
+    typedef CUresult  CUDAAPI tcuArrayCreate(CUarray *pHandle, const CUDA_ARRAY_DESCRIPTOR *pAllocateArray);
+    typedef CUresult  CUDAAPI tcuArrayGetDescriptor(CUDA_ARRAY_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
+    typedef CUresult  CUDAAPI tcuArrayDestroy(CUarray hArray);
+
+    typedef CUresult  CUDAAPI tcuArray3DCreate(CUarray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pAllocateArray);
+    typedef CUresult  CUDAAPI tcuArray3DGetDescriptor(CUDA_ARRAY3D_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
+
+
+    /************************************
+     **
+     **    Texture reference management
+     **
+     ***********************************/
+    typedef CUresult  CUDAAPI tcuTexRefCreate(CUtexref *pTexRef);
+    typedef CUresult  CUDAAPI tcuTexRefDestroy(CUtexref hTexRef);
+
+    typedef CUresult  CUDAAPI tcuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned int Flags);
+
+#if __CUDA_API_VERSION >= 3020
+    typedef CUresult  CUDAAPI tcuTexRefSetAddress(size_t *ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes);
+    typedef CUresult  CUDAAPI tcuTexRefSetAddress2D(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR *desc, CUdeviceptr dptr, size_t Pitch);
+#else
+    typedef CUresult  CUDAAPI tcuTexRefSetAddress(unsigned int *ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, unsigned int bytes);
+    typedef CUresult  CUDAAPI tcuTexRefSetAddress2D(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR *desc, CUdeviceptr dptr, unsigned int Pitch);
+#endif
+
+    typedef CUresult  CUDAAPI tcuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents);
+    typedef CUresult  CUDAAPI tcuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am);
+    typedef CUresult  CUDAAPI tcuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm);
+    typedef CUresult  CUDAAPI tcuTexRefSetFlags(CUtexref hTexRef, unsigned int Flags);
+
+    typedef CUresult  CUDAAPI tcuTexRefGetAddress(CUdeviceptr *pdptr, CUtexref hTexRef);
+    typedef CUresult  CUDAAPI tcuTexRefGetArray(CUarray *phArray, CUtexref hTexRef);
+    typedef CUresult  CUDAAPI tcuTexRefGetAddressMode(CUaddress_mode *pam, CUtexref hTexRef, int dim);
+    typedef CUresult  CUDAAPI tcuTexRefGetFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);
+    typedef CUresult  CUDAAPI tcuTexRefGetFormat(CUarray_format *pFormat, int *pNumChannels, CUtexref hTexRef);
+    typedef CUresult  CUDAAPI tcuTexRefGetFlags(unsigned int *pFlags, CUtexref hTexRef);
+
+    /************************************
+     **
+     **    Surface reference management
+     **
+     ***********************************/
+
+    typedef CUresult  CUDAAPI tcuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned int Flags);
+    typedef CUresult  CUDAAPI tcuSurfRefGetArray(CUarray *phArray, CUsurfref hSurfRef);
+
+    /************************************
+     **
+     **    Parameter management
+     **
+     ***********************************/
+
+    typedef CUresult  CUDAAPI tcuParamSetSize(CUfunction hfunc, unsigned int numbytes);
+    typedef CUresult  CUDAAPI tcuParamSeti(CUfunction hfunc, int offset, unsigned int value);
+    typedef CUresult  CUDAAPI tcuParamSetf(CUfunction hfunc, int offset, float value);
+    typedef CUresult  CUDAAPI tcuParamSetv(CUfunction hfunc, int offset, void *ptr, unsigned int numbytes);
+    typedef CUresult  CUDAAPI tcuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef);
+
+
+    /************************************
+     **
+     **    Launch functions
+     **
+     ***********************************/
+
+    typedef CUresult CUDAAPI tcuLaunch(CUfunction f);
+    typedef CUresult CUDAAPI tcuLaunchGrid(CUfunction f, int grid_width, int grid_height);
+    typedef CUresult CUDAAPI tcuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream);
+
+    /************************************
+     **
+     **    Events
+     **
+     ***********************************/
+    typedef CUresult CUDAAPI tcuEventCreate(CUevent *phEvent, unsigned int Flags);
+    typedef CUresult CUDAAPI tcuEventRecord(CUevent hEvent, CUstream hStream);
+    typedef CUresult CUDAAPI tcuEventQuery(CUevent hEvent);
+    typedef CUresult CUDAAPI tcuEventSynchronize(CUevent hEvent);
+    typedef CUresult CUDAAPI tcuEventDestroy(CUevent hEvent);
+    typedef CUresult CUDAAPI tcuEventElapsedTime(float *pMilliseconds, CUevent hStart, CUevent hEnd);
+
+    /************************************
+     **
+     **    Streams
+     **
+     ***********************************/
+    typedef CUresult CUDAAPI  tcuStreamCreate(CUstream *phStream, unsigned int Flags);
+    typedef CUresult CUDAAPI  tcuStreamQuery(CUstream hStream);
+    typedef CUresult CUDAAPI  tcuStreamSynchronize(CUstream hStream);
+    typedef CUresult CUDAAPI  tcuStreamDestroy(CUstream hStream);
+
+    /************************************
+     **
+     **    Graphics interop
+     **
+     ***********************************/
+    typedef CUresult CUDAAPI tcuGraphicsUnregisterResource(CUgraphicsResource resource);
+    typedef CUresult CUDAAPI tcuGraphicsSubResourceGetMappedArray(CUarray *pArray, CUgraphicsResource resource, unsigned int arrayIndex, unsigned int mipLevel);
+
+#if __CUDA_API_VERSION >= 3020
+    typedef CUresult CUDAAPI tcuGraphicsResourceGetMappedPointer(CUdeviceptr *pDevPtr, size_t *pSize, CUgraphicsResource resource);
+#else
+    typedef CUresult CUDAAPI tcuGraphicsResourceGetMappedPointer(CUdeviceptr *pDevPtr, unsigned int *pSize, CUgraphicsResource resource);
+#endif
+
+    typedef CUresult CUDAAPI tcuGraphicsResourceSetMapFlags(CUgraphicsResource resource, unsigned int flags);
+    typedef CUresult CUDAAPI tcuGraphicsMapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);
+    typedef CUresult CUDAAPI tcuGraphicsUnmapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);
+
+    /************************************
+     **
+     **    Export tables
+     **
+     ***********************************/
+    typedef CUresult CUDAAPI tcuGetExportTable(const void **ppExportTable, const CUuuid *pExportTableId);
+
+    /************************************
+     **
+     **    Limits
+     **
+     ***********************************/
+
+    typedef CUresult CUDAAPI tcuCtxSetLimit(CUlimit limit, size_t value);
+    typedef CUresult CUDAAPI tcuCtxGetLimit(size_t *pvalue, CUlimit limit);
+
+
+    /************************************
+     ************************************/
+
+    extern CUresult CUDAAPI cuInit(unsigned int, int cudaVersion);
+
+    extern tcuDriverGetVersion             *cuDriverGetVersion;
+    extern tcuDeviceGet                    *cuDeviceGet;
+    extern tcuDeviceGetCount               *cuDeviceGetCount;
+    extern tcuDeviceGetName                *cuDeviceGetName;
+    extern tcuDeviceComputeCapability      *cuDeviceComputeCapability;
+    extern tcuDeviceGetProperties          *cuDeviceGetProperties;
+    extern tcuDeviceGetAttribute           *cuDeviceGetAttribute;
+    extern tcuCtxDestroy                   *cuCtxDestroy;
+    extern tcuCtxAttach                    *cuCtxAttach;
+    extern tcuCtxDetach                    *cuCtxDetach;
+    extern tcuCtxPushCurrent               *cuCtxPushCurrent;
+    extern tcuCtxPopCurrent                *cuCtxPopCurrent;
+
+    extern tcuCtxSetCurrent                *cuCtxSetCurrent;
+    extern tcuCtxGetCurrent                *cuCtxGetCurrent;
+
+    extern tcuCtxGetDevice                 *cuCtxGetDevice;
+    extern tcuCtxSynchronize               *cuCtxSynchronize;
+    extern tcuModuleLoad                   *cuModuleLoad;
+    extern tcuModuleLoadData               *cuModuleLoadData;
+    extern tcuModuleLoadDataEx             *cuModuleLoadDataEx;
+    extern tcuModuleLoadFatBinary          *cuModuleLoadFatBinary;
+    extern tcuModuleUnload                 *cuModuleUnload;
+    extern tcuModuleGetFunction            *cuModuleGetFunction;
+    extern tcuModuleGetTexRef              *cuModuleGetTexRef;
+    extern tcuModuleGetSurfRef             *cuModuleGetSurfRef;
+    extern tcuMemFreeHost                  *cuMemFreeHost;
+    extern tcuMemHostAlloc                 *cuMemHostAlloc;
+    extern tcuMemHostGetFlags              *cuMemHostGetFlags;
+
+    extern tcuMemHostRegister              *cuMemHostRegister;
+    extern tcuMemHostUnregister            *cuMemHostUnregister;
+    extern tcuMemcpy                       *cuMemcpy;
+    extern tcuMemcpyPeer                   *cuMemcpyPeer;
+
+    extern tcuDeviceTotalMem               *cuDeviceTotalMem;
+    extern tcuCtxCreate                    *cuCtxCreate;
+    extern tcuModuleGetGlobal              *cuModuleGetGlobal;
+    extern tcuMemGetInfo                   *cuMemGetInfo;
+    extern tcuMemAlloc                     *cuMemAlloc;
+    extern tcuMemAllocPitch                *cuMemAllocPitch;
+    extern tcuMemFree                      *cuMemFree;
+    extern tcuMemGetAddressRange           *cuMemGetAddressRange;
+    extern tcuMemAllocHost                 *cuMemAllocHost;
+    extern tcuMemHostGetDevicePointer      *cuMemHostGetDevicePointer;
+    extern tcuFuncSetBlockShape            *cuFuncSetBlockShape;
+    extern tcuFuncSetSharedSize            *cuFuncSetSharedSize;
+    extern tcuFuncGetAttribute             *cuFuncGetAttribute;
+    extern tcuFuncSetCacheConfig           *cuFuncSetCacheConfig;
+    extern tcuLaunchKernel                 *cuLaunchKernel;
+    extern tcuArrayDestroy                 *cuArrayDestroy;
+    extern tcuTexRefCreate                 *cuTexRefCreate;
+    extern tcuTexRefDestroy                *cuTexRefDestroy;
+    extern tcuTexRefSetArray               *cuTexRefSetArray;
+    extern tcuTexRefSetFormat              *cuTexRefSetFormat;
+    extern tcuTexRefSetAddressMode         *cuTexRefSetAddressMode;
+    extern tcuTexRefSetFilterMode          *cuTexRefSetFilterMode;
+    extern tcuTexRefSetFlags               *cuTexRefSetFlags;
+    extern tcuTexRefGetArray               *cuTexRefGetArray;
+    extern tcuTexRefGetAddressMode         *cuTexRefGetAddressMode;
+    extern tcuTexRefGetFilterMode          *cuTexRefGetFilterMode;
+    extern tcuTexRefGetFormat              *cuTexRefGetFormat;
+    extern tcuTexRefGetFlags               *cuTexRefGetFlags;
+    extern tcuSurfRefSetArray              *cuSurfRefSetArray;
+    extern tcuSurfRefGetArray              *cuSurfRefGetArray;
+    extern tcuParamSetSize                 *cuParamSetSize;
+    extern tcuParamSeti                    *cuParamSeti;
+    extern tcuParamSetf                    *cuParamSetf;
+    extern tcuParamSetv                    *cuParamSetv;
+    extern tcuParamSetTexRef               *cuParamSetTexRef;
+    extern tcuLaunch                       *cuLaunch;
+    extern tcuLaunchGrid                   *cuLaunchGrid;
+    extern tcuLaunchGridAsync              *cuLaunchGridAsync;
+    extern tcuEventCreate                  *cuEventCreate;
+    extern tcuEventRecord                  *cuEventRecord;
+    extern tcuEventQuery                   *cuEventQuery;
+    extern tcuEventSynchronize             *cuEventSynchronize;
+    extern tcuEventDestroy                 *cuEventDestroy;
+    extern tcuEventElapsedTime             *cuEventElapsedTime;
+    extern tcuStreamCreate                 *cuStreamCreate;
+    extern tcuStreamQuery                  *cuStreamQuery;
+    extern tcuStreamSynchronize            *cuStreamSynchronize;
+    extern tcuStreamDestroy                *cuStreamDestroy;
+    extern tcuGraphicsUnregisterResource         *cuGraphicsUnregisterResource;
+    extern tcuGraphicsSubResourceGetMappedArray  *cuGraphicsSubResourceGetMappedArray;
+    extern tcuGraphicsResourceSetMapFlags        *cuGraphicsResourceSetMapFlags;
+    extern tcuGraphicsMapResources               *cuGraphicsMapResources;
+    extern tcuGraphicsUnmapResources             *cuGraphicsUnmapResources;
+    extern tcuGetExportTable                     *cuGetExportTable;
+    extern tcuCtxSetLimit                        *cuCtxSetLimit;
+    extern tcuCtxGetLimit                        *cuCtxGetLimit;
+
+    // These functions could be using the CUDA 3.2 interface (_v2)
+    extern tcuMemcpyHtoD                   *cuMemcpyHtoD;
+    extern tcuMemcpyDtoH                   *cuMemcpyDtoH;
+    extern tcuMemcpyDtoD                   *cuMemcpyDtoD;
+    extern tcuMemcpyDtoA                   *cuMemcpyDtoA;
+    extern tcuMemcpyAtoD                   *cuMemcpyAtoD;
+    extern tcuMemcpyHtoA                   *cuMemcpyHtoA;
+    extern tcuMemcpyAtoH                   *cuMemcpyAtoH;
+    extern tcuMemcpyAtoA                   *cuMemcpyAtoA;
+    extern tcuMemcpy2D                     *cuMemcpy2D;
+    extern tcuMemcpy2DUnaligned            *cuMemcpy2DUnaligned;
+    extern tcuMemcpy3D                     *cuMemcpy3D;
+    extern tcuMemcpyHtoDAsync              *cuMemcpyHtoDAsync;
+    extern tcuMemcpyDtoHAsync              *cuMemcpyDtoHAsync;
+    extern tcuMemcpyDtoDAsync              *cuMemcpyDtoDAsync;
+    extern tcuMemcpyHtoAAsync              *cuMemcpyHtoAAsync;
+    extern tcuMemcpyAtoHAsync              *cuMemcpyAtoHAsync;
+    extern tcuMemcpy2DAsync                *cuMemcpy2DAsync;
+    extern tcuMemcpy3DAsync                *cuMemcpy3DAsync;
+    extern tcuMemsetD8                     *cuMemsetD8;
+    extern tcuMemsetD16                    *cuMemsetD16;
+    extern tcuMemsetD32                    *cuMemsetD32;
+    extern tcuMemsetD2D8                   *cuMemsetD2D8;
+    extern tcuMemsetD2D16                  *cuMemsetD2D16;
+    extern tcuMemsetD2D32                  *cuMemsetD2D32;
+    extern tcuArrayCreate                  *cuArrayCreate;
+    extern tcuArrayGetDescriptor           *cuArrayGetDescriptor;
+    extern tcuArray3DCreate                *cuArray3DCreate;
+    extern tcuArray3DGetDescriptor         *cuArray3DGetDescriptor;
+    extern tcuTexRefSetAddress             *cuTexRefSetAddress;
+    extern tcuTexRefSetAddress2D           *cuTexRefSetAddress2D;
+    extern tcuTexRefGetAddress             *cuTexRefGetAddress;
+    extern tcuGraphicsResourceGetMappedPointer   *cuGraphicsResourceGetMappedPointer;
+
+#ifdef __cplusplus
+}
+#endif
+
+//#undef __CUDA_API_VERSION
+
+#endif //__cuda_drvapi_dynlink_cuda_h__
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_d3d.h gpu-rodinia_new/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_d3d.h
--- gpu-rodinia/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_d3d.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_d3d.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,110 @@
+/*
+ * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+#ifndef __cuda_drvapi_dynlink_d3d_h__
+#define __cuda_drvapi_dynlink_d3d_h__
+
+#if defined(_WIN32)
+#pragma warning(disable: 4312)
+
+#if defined (CUDA_INIT_D3D9) || defined(CUDA_INIT_D3D10) || defined(CUDA_INIT_D3D11)
+#include <Windows.h>
+#include <mmsystem.h>
+#endif
+
+#ifdef CUDA_INIT_D3D9
+#include <d3dx9.h>
+#pragma warning( disable : 4996 ) // disable deprecated warning 
+#include <strsafe.h>
+#pragma warning( default : 4996 )
+
+/**
+ * CUDA 2.x compatibility - Flags to register a D3D9 graphics resource
+ */
+typedef enum CUd3d9register_flags_enum
+{
+    CU_D3D9_REGISTER_FLAGS_NONE  = 0x00,
+    CU_D3D9_REGISTER_FLAGS_ARRAY = 0x01,
+} CUd3d9register_flags;
+
+/**
+ * CUDA 2.x compatibility - Flags for D3D9 mapping and unmapping interop resources
+ */
+typedef enum CUd3d9map_flags_enum
+{
+    CU_D3D9_MAPRESOURCE_FLAGS_NONE         = 0x00,
+    CU_D3D9_MAPRESOURCE_FLAGS_READONLY     = 0x01,
+    CU_D3D9_MAPRESOURCE_FLAGS_WRITEDISCARD = 0x02,
+} CUd3d9map_flags;
+
+// D3D9/CUDA interop (CUDA 1.x compatible API). These functions are deprecated, please use the ones below
+typedef CUresult CUDAAPI tcuD3D9Begin(IDirect3DDevice9 *pDevice);
+typedef CUresult CUDAAPI tcuD3D9End(void);
+typedef CUresult CUDAAPI tcuD3D9RegisterVertexBuffer(IDirect3DVertexBuffer9 *pVB);
+typedef CUresult CUDAAPI tcuD3D9MapVertexBuffer(CUdeviceptr *pDevPtr, unsigned int *pSize, IDirect3DVertexBuffer9 *pVB);
+typedef CUresult CUDAAPI tcuD3D9UnmapVertexBuffer(IDirect3DVertexBuffer9 *pVB);
+typedef CUresult CUDAAPI tcuD3D9UnregisterVertexBuffer(IDirect3DVertexBuffer9 *pVB);
+
+// D3D9/CUDA interop (CUDA 2.x compatible)
+typedef CUresult CUDAAPI tcuD3D9GetDirect3DDevice(IDirect3DDevice9 **ppD3DDevice);
+typedef CUresult CUDAAPI tcuD3D9RegisterResource(IDirect3DResource9 *pResource, unsigned int Flags);
+typedef CUresult CUDAAPI tcuD3D9UnregisterResource(IDirect3DResource9 *pResource);
+
+typedef CUresult CUDAAPI tcuD3D9MapResources(unsigned int count, IDirect3DResource9 **ppResource);
+typedef CUresult CUDAAPI tcuD3D9UnmapResources(unsigned int count, IDirect3DResource9 **ppResource);
+typedef CUresult CUDAAPI tcuD3D9ResourceSetMapFlags(IDirect3DResource9 *pResource, unsigned int Flags);
+
+typedef CUresult CUDAAPI tcuD3D9ResourceGetSurfaceDimensions(unsigned int *pWidth, unsigned int *pHeight, unsigned int *pDepth, IDirect3DResource9 *pResource, unsigned int Face, unsigned int Level);
+typedef CUresult CUDAAPI tcuD3D9ResourceGetMappedArray(CUarray *pArray, IDirect3DResource9 *pResource, unsigned int Face, unsigned int Level);
+typedef CUresult CUDAAPI tcuD3D9ResourceGetMappedPointer(CUdeviceptr *pDevPtr, IDirect3DResource9 *pResource, unsigned int Face, unsigned int Level);
+typedef CUresult CUDAAPI tcuD3D9ResourceGetMappedSize(unsigned int *pSize, IDirect3DResource9 *pResource, unsigned int Face, unsigned int Level);
+typedef CUresult CUDAAPI tcuD3D9ResourceGetMappedPitch(unsigned int *pPitch, unsigned int *pPitchSlice, IDirect3DResource9 *pResource, unsigned int Face, unsigned int Level);
+
+// D3D9/CUDA interop (CUDA 2.0+)
+typedef CUresult CUDAAPI tcuD3D9GetDevice(CUdevice *pCudaDevice, const char *pszAdapterName);
+typedef CUresult CUDAAPI tcuD3D9CtxCreate(CUcontext *pCtx, CUdevice *pCudaDevice, unsigned int Flags, IDirect3DDevice9 *pD3DDevice);
+typedef CUresult CUDAAPI tcuGraphicsD3D9RegisterResource(CUgraphicsResource *pCudaResource, IDirect3DResource9 *pD3DResource, unsigned int Flags);
+#endif
+
+#ifdef CUDA_INIT_D3D10
+#include <dxgi.h>
+#include <d3d10_1.h>
+#include <d3d10.h>
+#include <d3dx10.h>
+
+#pragma warning( disable : 4996 ) // disable deprecated warning 
+#include <strsafe.h>
+#pragma warning( default : 4996 )
+
+// D3D11/CUDA interop (CUDA 3.0)
+typedef CUresult CUDAAPI tcuD3D10GetDevice(CUdevice *pCudaDevice, IDXGIAdapter *pAdapter);
+typedef CUresult CUDAAPI tcuD3D10CtxCreate(CUcontext *pCtx, CUdevice *pCudaDevice, unsigned int Flags, ID3D10Device *pD3DDevice);
+typedef CUresult CUDAAPI tcuGraphicsD3D10RegisterResource(CUgraphicsResource *pCudaResource, ID3D10Resource *pD3DResource, unsigned int Flags);
+#endif // CUDA_INIT_D3D10
+
+#ifdef CUDA_INIT_D3D11
+#include <dxgi.h>
+#include <d3d11.h>
+#include <d3dx11.h>
+
+#pragma warning( disable : 4996 ) // disable deprecated warning 
+#include <strsafe.h>
+#pragma warning( default : 4996 )
+
+// D3D11/CUDA interop (CUDA 3.0)
+typedef CUresult CUDAAPI tcuD3D11GetDevice(CUdevice *pCudaDevice, IDXGIAdapter *pAdapter);
+typedef CUresult CUDAAPI tcuD3D11CtxCreate(CUcontext *pCtx, CUdevice *pCudaDevice, unsigned int Flags, ID3D11Device *pD3DDevice);
+typedef CUresult CUDAAPI tcuGraphicsD3D11RegisterResource(CUgraphicsResource *pCudaResource, ID3D11Resource *pD3DResource, unsigned int Flags);
+#endif // CUDA_INIT_D3D11
+
+#endif // WIN32
+
+#endif // __cuda_drvapi_dynlink_cuda_d3d_h__
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_gl.h gpu-rodinia_new/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_gl.h
--- gpu-rodinia/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_gl.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink_gl.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,58 @@
+/*
+ * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+#ifndef __cuda_drvapi_dynlink_cuda_gl_h__
+#define __cuda_drvapi_dynlink_cuda_gl_h__
+
+#ifdef CUDA_INIT_OPENGL
+
+#ifdef _WIN32
+#  define WINDOWS_LEAN_AND_MEAN
+#  define NOMINMAX
+#  include <windows.h>
+#endif
+
+// includes, system
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+// includes, GL
+#include <GL/glew.h>
+
+#if defined (__APPLE__) || defined(MACOSX)
+#include <GLUT/glut.h>
+#else
+#include <GL/freeglut.h>
+#endif
+
+/************************************
+ **
+ **    OpenGL Graphics/Interop
+ **
+ ***********************************/
+
+// OpenGL/CUDA interop (CUDA 2.0+)
+typedef CUresult CUDAAPI tcuGLCtxCreate(CUcontext *pCtx, unsigned int Flags, CUdevice device);
+typedef CUresult CUDAAPI tcuGraphicsGLRegisterBuffer(CUgraphicsResource *pCudaResource, GLuint buffer, unsigned int Flags);
+typedef CUresult CUDAAPI tcuGraphicsGLRegisterImage(CUgraphicsResource *pCudaResource, GLuint image, GLenum target, unsigned int Flags);
+
+#ifdef _WIN32
+#include <GL/wglext.h>
+// WIN32
+typedef CUresult CUDAAPI tcuWGLGetDevice(CUdevice *pDevice, HGPUNV hGpu);
+#endif
+
+#endif // CUDA_INIT_OPENGL
+
+#endif // __cuda_drvapi_dynlink_cuda_gl_h__
+
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink.h gpu-rodinia_new/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink.h
--- gpu-rodinia/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/dynlink/cuda_drvapi_dynlink.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,26 @@
+/*
+ * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+
+#ifndef __cuda_drvapi_dynlink_h__
+#define __cuda_drvapi_dynlink_h__
+
+#include "cuda_drvapi_dynlink_cuda.h"
+
+#if defined(CUDA_INIT_D3D9)||defined(CUDA_INIT_D3D10)||defined(CUDA_INIT_D3D11)
+#include "cuda_drvapi_dynlink_d3d.h"
+#endif
+
+#ifdef CUDA_INIT_OPENGL
+#include "cuda_drvapi_dynlink_gl.h"
+#endif
+
+#endif //__cuda_drvapi_dynlink_h__
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/dynlink_d3d10.h gpu-rodinia_new/cuda/cfd/common/inc/dynlink_d3d10.h
--- gpu-rodinia/cuda/cfd/common/inc/dynlink_d3d10.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/dynlink_d3d10.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,303 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//--------------------------------------------------------------------------------------
+// File: dynlink_d3d10.h
+//
+// Shortcut macros and functions for using DX objects
+//
+// Copyright (c) Microsoft Corporation. All rights reserved
+//--------------------------------------------------------------------------------------
+
+#ifndef _DYNLINK_D3D10_H_
+#define _DYNLINK_D3D10_H_
+
+// Standard Windows includes
+#include <windows.h>
+#include <initguid.h>
+#include <assert.h>
+#include <wchar.h>
+#include <mmsystem.h>
+#include <commctrl.h> // for InitCommonControls() 
+#include <shellapi.h> // for ExtractIcon()
+#include <new.h>      // for placement new
+#include <shlobj.h>
+#include <math.h>
+#include <limits.h>
+#include <stdio.h>
+
+// CRT's memory leak detection
+#if defined(DEBUG) || defined(_DEBUG)
+#include <crtdbg.h>
+#endif
+
+// Direct3D9 includes
+#include <d3d9.h>
+#include <d3dx9.h>
+
+// Direct3D10 includes
+#include <dxgi.h>
+#include <d3d10_1.h>
+#include <d3d10.h>
+#include <d3dx10.h>
+
+// XInput includes
+#include <xinput.h>
+
+// HRESULT translation for Direct3D10 and other APIs
+#include <dxerr.h>
+
+// strsafe.h deprecates old unsecure string functions.  If you
+// really do not want to it to (not recommended), then uncomment the next line
+//#define STRSAFE_NO_DEPRECATE
+
+#ifndef STRSAFE_NO_DEPRECATE
+#pragma deprecated("strncpy")
+#pragma deprecated("wcsncpy")
+#pragma deprecated("_tcsncpy")
+#pragma deprecated("wcsncat")
+#pragma deprecated("strncat")
+#pragma deprecated("_tcsncat")
+#endif
+
+#pragma warning( disable : 4996 ) // disable deprecated warning 
+#include <strsafe.h>
+#pragma warning( default : 4996 )
+
+//--------------------------------------------------------------------------------------
+// Structs
+//--------------------------------------------------------------------------------------
+struct DXUTD3D9DeviceSettings
+{
+    UINT AdapterOrdinal;
+    D3DDEVTYPE DeviceType;
+    D3DFORMAT AdapterFormat;
+    DWORD BehaviorFlags;
+    D3DPRESENT_PARAMETERS pp;
+};
+
+struct DXUTD3D10DeviceSettings
+{
+    UINT AdapterOrdinal;
+    D3D10_DRIVER_TYPE DriverType;
+    UINT Output;
+    DXGI_SWAP_CHAIN_DESC sd;
+    UINT32 CreateFlags;
+    UINT32 SyncInterval;
+    DWORD PresentFlags;
+    bool AutoCreateDepthStencil; // DXUT will create the a depth stencil resource and view if true
+    DXGI_FORMAT AutoDepthStencilFormat;
+};
+
+enum DXUTDeviceVersion { DXUT_D3D9_DEVICE, DXUT_D3D10_DEVICE };
+struct DXUTDeviceSettings
+{
+    DXUTDeviceVersion ver;
+    union
+    {
+        DXUTD3D9DeviceSettings d3d9; // only valid if ver == DXUT_D3D9_DEVICE
+        DXUTD3D10DeviceSettings d3d10; // only valid if ver == DXUT_D3D10_DEVICE
+    };
+};
+
+
+//--------------------------------------------------------------------------------------
+// Error codes
+//--------------------------------------------------------------------------------------
+#define DXUTERR_NODIRECT3D              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0901)
+#define DXUTERR_NOCOMPATIBLEDEVICES     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0902)
+#define DXUTERR_MEDIANOTFOUND           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0903)
+#define DXUTERR_NONZEROREFCOUNT         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0904)
+#define DXUTERR_CREATINGDEVICE          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0905)
+#define DXUTERR_RESETTINGDEVICE         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0906)
+#define DXUTERR_CREATINGDEVICEOBJECTS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0907)
+#define DXUTERR_RESETTINGDEVICEOBJECTS  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0908)
+#define DXUTERR_DEVICEREMOVED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x090A)
+
+
+typedef HRESULT(WINAPI *LPCREATEDXGIFACTORY)(REFIID, void **);
+typedef HRESULT(WINAPI *LPD3D10CREATEDEVICE)(IDXGIAdapter *, D3D10_DRIVER_TYPE, HMODULE, UINT, UINT32,
+                                             ID3D10Device **);
+typedef HRESULT(WINAPI *LPD3D10CREATEDEVICE1)(IDXGIAdapter *, D3D10_DRIVER_TYPE, HMODULE, UINT,
+                                              D3D10_FEATURE_LEVEL1, UINT, ID3D10Device1 **);
+typedef HRESULT(WINAPI *LPD3D10CREATESTATEBLOCK)(ID3D10Device *pDevice, D3D10_STATE_BLOCK_MASK *pStateBlockMask,
+                                                 ID3D10StateBlock **ppStateBlock);
+typedef HRESULT(WINAPI *LPD3D10STATEBLOCKMASKUNION)(D3D10_STATE_BLOCK_MASK *pA, D3D10_STATE_BLOCK_MASK *pB,
+                                                    D3D10_STATE_BLOCK_MASK *pResult);
+typedef HRESULT(WINAPI *LPD3D10STATEBLOCKMASKINTERSECT)(D3D10_STATE_BLOCK_MASK *pA, D3D10_STATE_BLOCK_MASK *pB,
+                                                        D3D10_STATE_BLOCK_MASK *pResult);
+typedef HRESULT(WINAPI *LPD3D10STATEBLOCKMASKDIFFERENCE)(D3D10_STATE_BLOCK_MASK *pA, D3D10_STATE_BLOCK_MASK *pB,
+                                                         D3D10_STATE_BLOCK_MASK *pResult);
+typedef HRESULT(WINAPI *LPD3D10STATEBLOCKMASKENABLECAPTURE)(D3D10_STATE_BLOCK_MASK *pMask,
+                                                            D3D10_DEVICE_STATE_TYPES StateType, UINT RangeStart,
+                                                            UINT RangeLength);
+typedef HRESULT(WINAPI *LPD3D10STATEBLOCKMASKDISABLECAPTURE)(D3D10_STATE_BLOCK_MASK *pMask,
+        D3D10_DEVICE_STATE_TYPES StateType, UINT RangeStart,
+        UINT RangeLength);
+typedef HRESULT(WINAPI *LPD3D10STATEBLOCKMASKENABLEALL)(D3D10_STATE_BLOCK_MASK *pMask);
+typedef HRESULT(WINAPI *LPD3D10STATEBLOCKMASKDISABLEALL)(D3D10_STATE_BLOCK_MASK *pMask);
+typedef BOOL (WINAPI *LPD3D10STATEBLOCKMASKGETSETTING)(D3D10_STATE_BLOCK_MASK *pMask,
+                                                       D3D10_DEVICE_STATE_TYPES StateType, UINT Entry);
+
+typedef HRESULT(WINAPI *LPD3D10COMPILEEFFECTFROMMEMORY)(void *pData, SIZE_T DataLength, LPCSTR pSrcFileName,
+                                                        CONST D3D10_SHADER_MACRO *pDefines,
+                                                        ID3D10Include *pInclude, UINT HLSLFlags, UINT FXFlags,
+                                                        ID3D10Blob **ppCompiledEffect, ID3D10Blob **ppErrors);
+typedef HRESULT(WINAPI *LPD3D10CREATEEFFECTFROMMEMORY)(void *pData, SIZE_T DataLength, UINT FXFlags,
+                                                       ID3D10Device *pDevice,
+                                                       ID3D10EffectPool *pEffectPool,
+                                                       ID3D10Effect **ppEffect);
+typedef HRESULT(WINAPI *LPD3D10CREATEEFFECTPOOLFROMMEMORY)(void *pData, SIZE_T DataLength, UINT FXFlags,
+                                                           ID3D10Device *pDevice, ID3D10EffectPool **ppEffectPool);
+
+typedef HRESULT(WINAPI *LPD3D10CREATEDEVICEANDSWAPCHAIN)(IDXGIAdapter *pAdapter,
+                                                         D3D10_DRIVER_TYPE DriverType,
+                                                         HMODULE Software,
+                                                         UINT Flags,
+                                                         UINT SDKVersion,
+                                                         DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,
+                                                         IDXGISwapChain **ppSwapChain,
+                                                         ID3D10Device **ppDevice);
+
+typedef HRESULT(WINAPI *LPD3D10CREATEDEVICEANDSWAPCHAIN1)(IDXGIAdapter *pAdapter,
+                                                          D3D10_DRIVER_TYPE DriverType,
+                                                          HMODULE Software,
+                                                          UINT Flags,
+                                                          D3D10_FEATURE_LEVEL1 HardwareLevel,
+                                                          UINT SDKVersion,
+                                                          DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,
+                                                          IDXGISwapChain **ppSwapChain,
+                                                          ID3D10Device1 **ppDevice);
+
+// Build a perspective projection matrix. (left-handed)
+typedef D3DXMATRIX *(WINAPI *LPD3DXMATRIXPERSPECTIVEFOVLH)(D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf);
+
+// Build a lookat matrix. (left-handed)
+typedef D3DXMATRIX *(WINAPI *LPD3DXMATRIXLOOKATLH)(D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt, CONST D3DXVECTOR3 *pUp);
+
+// Module and function pointers
+static HMODULE                              g_hModDXGI = NULL;
+static HMODULE                              g_hModD3DX10 = NULL;
+static HMODULE                              g_hModD3D10 = NULL;
+static HMODULE                              g_hModD3D101 = NULL;
+static LPCREATEDXGIFACTORY                  sFnPtr_CreateDXGIFactory = NULL;
+static LPD3D10CREATESTATEBLOCK              sFnPtr_D3D10CreateStateBlock = NULL;
+static LPD3D10CREATEDEVICE                  sFnPtr_D3D10CreateDevice = NULL;
+static LPD3D10CREATEDEVICE1                 sFnPtr_D3D10CreateDevice1 = NULL;
+static LPD3D10STATEBLOCKMASKUNION           sFnPtr_D3D10StateBlockMaskUnion = NULL;
+static LPD3D10STATEBLOCKMASKINTERSECT       sFnPtr_D3D10StateBlockMaskIntersect = NULL;
+static LPD3D10STATEBLOCKMASKDIFFERENCE      sFnPtr_D3D10StateBlockMaskDifference = NULL;
+static LPD3D10STATEBLOCKMASKENABLECAPTURE   sFnPtr_D3D10StateBlockMaskEnableCapture = NULL;
+static LPD3D10STATEBLOCKMASKDISABLECAPTURE  sFnPtr_D3D10StateBlockMaskDisableCapture = NULL;
+static LPD3D10STATEBLOCKMASKENABLEALL       sFnPtr_D3D10StateBlockMaskEnableAll = NULL;
+static LPD3D10STATEBLOCKMASKDISABLEALL      sFnPtr_D3D10StateBlockMaskDisableAll = NULL;
+static LPD3D10STATEBLOCKMASKGETSETTING      sFnPtr_D3D10StateBlockMaskGetSetting = NULL;
+static LPD3D10COMPILEEFFECTFROMMEMORY       sFnPtr_D3D10CompileEffectFromMemory = NULL;
+static LPD3D10CREATEEFFECTFROMMEMORY        sFnPtr_D3D10CreateEffectFromMemory = NULL;
+static LPD3D10CREATEEFFECTPOOLFROMMEMORY    sFnPtr_D3D10CreateEffectPoolFromMemory = NULL;
+static LPD3D10CREATEDEVICEANDSWAPCHAIN      sFnPtr_D3D10CreateDeviceAndSwapChain  = NULL;
+static LPD3D10CREATEDEVICEANDSWAPCHAIN1     sFnPtr_D3D10CreateDeviceAndSwapChain1 = NULL;
+static LPD3DXMATRIXPERSPECTIVEFOVLH         sFnPtr_D3DXMatrixPerspectiveFovLH = NULL;
+static LPD3DXMATRIXLOOKATLH                 sFnPtr_D3DXMatrixLookAtLH = NULL;
+
+// unload the D3D10 DLLs
+static bool dynlinkUnloadD3D10API(void)
+{
+    if (g_hModD3D10)
+    {
+        FreeLibrary(g_hModD3D10);
+        g_hModD3D10 = NULL;
+    }
+
+    if (g_hModD3DX10)
+    {
+        FreeLibrary(g_hModD3DX10);
+        g_hModD3DX10 = NULL;
+    }
+
+    if (g_hModDXGI)
+    {
+        FreeLibrary(g_hModDXGI);
+        g_hModDXGI = NULL;
+    }
+
+    if (g_hModD3D101)
+    {
+        FreeLibrary(g_hModD3D101);
+        g_hModD3D101 = NULL;
+    }
+
+    return true;
+}
+
+// Dynamically load the D3D10 DLLs loaded and map the function pointers
+static bool dynlinkLoadD3D10API(void)
+{
+    // First check to see if the D3D10 Library is present.
+    // if it succeeds, then we can call GetProcAddress to grab all of the DX10 functions
+    g_hModD3D10 = LoadLibrary("d3d10.dll");
+
+    if (g_hModD3D10 != NULL)
+    {
+        sFnPtr_D3D10CreateStateBlock             = (LPD3D10CREATESTATEBLOCK)           GetProcAddress(g_hModD3D10, "D3D10CreateStateBlock");
+        sFnPtr_D3D10CreateDevice                 = (LPD3D10CREATEDEVICE)           GetProcAddress(g_hModD3D10, "D3D10CreateDevice");
+
+        sFnPtr_D3D10StateBlockMaskUnion          = (LPD3D10STATEBLOCKMASKUNION)        GetProcAddress(g_hModD3D10, "D3D10StateBlockMaskUnion");
+        sFnPtr_D3D10StateBlockMaskIntersect      = (LPD3D10STATEBLOCKMASKINTERSECT)    GetProcAddress(g_hModD3D10, "D3D10StateBlockMaskIntersect");
+        sFnPtr_D3D10StateBlockMaskDifference     = (LPD3D10STATEBLOCKMASKDIFFERENCE)   GetProcAddress(g_hModD3D10, "D3D10StateBlockMaskDifference");
+        sFnPtr_D3D10StateBlockMaskEnableCapture  = (LPD3D10STATEBLOCKMASKENABLECAPTURE) GetProcAddress(g_hModD3D10, "D3D10StateBlockMaskEnableCapture");
+        sFnPtr_D3D10StateBlockMaskDisableCapture = (LPD3D10STATEBLOCKMASKDISABLECAPTURE)GetProcAddress(g_hModD3D10, "D3D10StateBlockMaskDisableCapture");
+
+        sFnPtr_D3D10StateBlockMaskEnableAll      = (LPD3D10STATEBLOCKMASKENABLEALL)    GetProcAddress(g_hModD3D10, "D3D10StateBlockMaskEnableAll");
+        sFnPtr_D3D10StateBlockMaskDisableAll     = (LPD3D10STATEBLOCKMASKDISABLEALL)   GetProcAddress(g_hModD3D10, "D3D10StateBlockMaskDisableAll");
+        sFnPtr_D3D10StateBlockMaskGetSetting     = (LPD3D10STATEBLOCKMASKGETSETTING)   GetProcAddress(g_hModD3D10, "D3D10StateBlockMaskGetSetting");
+
+        sFnPtr_D3D10CompileEffectFromMemory      = (LPD3D10COMPILEEFFECTFROMMEMORY)    GetProcAddress(g_hModD3D10, "D3D10CompileEffectFromMemory");
+        sFnPtr_D3D10CreateEffectFromMemory       = (LPD3D10CREATEEFFECTFROMMEMORY)     GetProcAddress(g_hModD3D10, "D3D10CreateEffectFromMemory");
+        sFnPtr_D3D10CreateEffectPoolFromMemory   = (LPD3D10CREATEEFFECTPOOLFROMMEMORY) GetProcAddress(g_hModD3D10, "D3D10CreateEffectPoolFromMemory");
+
+        sFnPtr_D3D10CreateDeviceAndSwapChain     = (LPD3D10CREATEDEVICEANDSWAPCHAIN)    GetProcAddress(g_hModD3D10, "D3D10CreateDeviceAndSwapChain");
+    }
+
+    g_hModD3DX10 = LoadLibrary("d3dx10.dll");
+
+    if (g_hModD3DX10)
+    {
+        sFnPtr_D3DXMatrixPerspectiveFovLH        = (LPD3DXMATRIXPERSPECTIVEFOVLH)  GetProcAddress(g_hModD3DX10, "D3DXMatrixPerspectiveFovLH");
+        sFnPtr_D3DXMatrixLookAtLH                = (LPD3DXMATRIXLOOKATLH)          GetProcAddress(g_hModD3DX10, "D3DXMatrixLookAtLH");
+    }
+
+    g_hModDXGI = LoadLibrary("dxgi.dll");
+
+    if (g_hModDXGI)
+    {
+        sFnPtr_CreateDXGIFactory                 = (LPCREATEDXGIFACTORY)           GetProcAddress(g_hModDXGI , "CreateDXGIFactory");
+    }
+
+    // This may fail if this machine isn't Windows Vista SP1 or later
+    g_hModD3D101 = LoadLibrary("d3d10_1.dll");
+
+    if (g_hModD3D101 != NULL)
+    {
+        sFnPtr_D3D10CreateDevice1                = (LPD3D10CREATEDEVICE1)              GetProcAddress(g_hModD3D101, "D3D10CreateDevice1");
+        sFnPtr_D3D10CreateDeviceAndSwapChain1    = (LPD3D10CREATEDEVICEANDSWAPCHAIN1)   GetProcAddress(g_hModD3D101, "D3D10CreateDeviceAndSwapChain1");
+    }
+
+    if (g_hModD3D10 == NULL || g_hModD3DX10 == NULL || g_hModDXGI == NULL || g_hModD3D101 == NULL)
+    {
+        dynlinkUnloadD3D10API();
+        return false;
+    }
+
+    return true;
+}
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/dynlink_d3d11.h gpu-rodinia_new/cuda/cfd/common/inc/dynlink_d3d11.h
--- gpu-rodinia/cuda/cfd/common/inc/dynlink_d3d11.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/dynlink_d3d11.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,174 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//--------------------------------------------------------------------------------------
+// File: dynlink_d3d11.h
+//
+// Shortcut macros and functions for using DX objects
+//
+// Copyright (c) Microsoft Corporation. All rights reserved
+//--------------------------------------------------------------------------------------
+
+#ifndef _DYNLINK_D3D11_H_
+#define _DYNLINK_D3D11_H_
+
+// Standard Windows includes
+#include <windows.h>
+#include <initguid.h>
+#include <assert.h>
+#include <wchar.h>
+#include <mmsystem.h>
+#include <commctrl.h> // for InitCommonControls() 
+#include <shellapi.h> // for ExtractIcon()
+#include <new.h>      // for placement new
+#include <shlobj.h>
+#include <math.h>
+#include <limits.h>
+#include <stdio.h>
+
+// CRT's memory leak detection
+#if defined(DEBUG) || defined(_DEBUG)
+#include <crtdbg.h>
+#endif
+
+// Direct3D9 includes
+//#include <d3d9.h>
+//#include <d3dx9.h>
+
+// Direct3D10 includes
+#include <dxgi.h>
+#include <d3d11.h>
+#include <d3dx11.h>
+// #include <..\Samples\C++\Effects11\Inc\d3dx11effect.h>
+
+// XInput includes
+#include <xinput.h>
+
+// HRESULT translation for Direct3D10 and other APIs
+#include <dxerr.h>
+
+// strsafe.h deprecates old unsecure string functions.  If you
+// really do not want to it to (not recommended), then uncomment the next line
+//#define STRSAFE_NO_DEPRECATE
+
+#ifndef STRSAFE_NO_DEPRECATE
+#pragma deprecated("strncpy")
+#pragma deprecated("wcsncpy")
+#pragma deprecated("_tcsncpy")
+#pragma deprecated("wcsncat")
+#pragma deprecated("strncat")
+#pragma deprecated("_tcsncat")
+#endif
+
+#pragma warning( disable : 4996 ) // disable deprecated warning 
+#include <strsafe.h>
+#pragma warning( default : 4996 )
+
+typedef HRESULT(WINAPI *LPCREATEDXGIFACTORY)(REFIID, void **);
+typedef HRESULT(WINAPI *LPD3D11CREATEDEVICEANDSWAPCHAIN)(__in_opt IDXGIAdapter *pAdapter, D3D_DRIVER_TYPE DriverType, HMODULE Software, UINT Flags, __in_ecount_opt(FeatureLevels) CONST D3D_FEATURE_LEVEL *pFeatureLevels, UINT FeatureLevels, UINT SDKVersion, __in_opt CONST DXGI_SWAP_CHAIN_DESC *pSwapChainDesc, __out_opt IDXGISwapChain **ppSwapChain, __out_opt ID3D11Device **ppDevice, __out_opt D3D_FEATURE_LEVEL *pFeatureLevel, __out_opt ID3D11DeviceContext **ppImmediateContext);
+typedef HRESULT(WINAPI *LPD3D11CREATEDEVICE)(IDXGIAdapter *, D3D_DRIVER_TYPE, HMODULE, UINT32, D3D_FEATURE_LEVEL *, UINT, UINT32, ID3D11Device **, D3D_FEATURE_LEVEL *, ID3D11DeviceContext **);
+typedef void (WINAPI *LPD3DX11COMPILEFROMMEMORY)(LPCSTR pSrcData, SIZE_T SrcDataLen, LPCSTR pFileName, CONST D3D10_SHADER_MACRO *pDefines, LPD3D10INCLUDE pInclude,
+                                                 LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX11ThreadPump *pPump, ID3D10Blob **ppShader, ID3D10Blob **ppErrorMsgs, HRESULT *pHResult);
+
+static HMODULE                              s_hModDXGI = NULL;
+static LPCREATEDXGIFACTORY                  sFnPtr_CreateDXGIFactory = NULL;
+static HMODULE                              s_hModD3D11 = NULL;
+static HMODULE                              s_hModD3DX11 = NULL;
+static LPD3D11CREATEDEVICE                  sFnPtr_D3D11CreateDevice = NULL;
+static LPD3D11CREATEDEVICEANDSWAPCHAIN      sFnPtr_D3D11CreateDeviceAndSwapChain = NULL;
+static LPD3DX11COMPILEFROMMEMORY            sFnPtr_D3DX11CompileFromMemory = NULL;
+
+// unload the D3D10 DLLs
+static bool dynlinkUnloadD3D11API(void)
+{
+    if (s_hModDXGI)
+    {
+        FreeLibrary(s_hModDXGI);
+        s_hModDXGI = NULL;
+    }
+
+    if (s_hModD3D11)
+    {
+        FreeLibrary(s_hModD3D11);
+        s_hModD3D11 = NULL;
+    }
+
+    if (s_hModD3DX11)
+    {
+        FreeLibrary(s_hModD3DX11);
+        s_hModD3DX11 = NULL;
+    }
+
+    return true;
+}
+
+// Dynamically load the D3D11 DLLs loaded and map the function pointers
+static bool dynlinkLoadD3D11API(void)
+{
+    // If both modules are non-NULL, this function has already been called.  Note
+    // that this doesn't guarantee that all ProcAddresses were found.
+    if (s_hModD3D11 != NULL && s_hModD3DX11 != NULL && s_hModDXGI != NULL)
+    {
+        return true;
+    }
+
+#if 1
+    // This may fail if Direct3D 11 isn't installed
+    s_hModD3D11 = LoadLibrary("d3d11.dll");
+
+    if (s_hModD3D11 != NULL)
+    {
+        sFnPtr_D3D11CreateDevice = (LPD3D11CREATEDEVICE)GetProcAddress(s_hModD3D11, "D3D11CreateDevice");
+        sFnPtr_D3D11CreateDeviceAndSwapChain = (LPD3D11CREATEDEVICEANDSWAPCHAIN)GetProcAddress(s_hModD3D11, "D3D11CreateDeviceAndSwapChain");
+    }
+
+    // first try to load D3DX11CompileFromMemory from DirectX 2010 June
+    s_hModD3DX11 = LoadLibrary("D3DX11d_43.dll");
+
+    if (s_hModD3DX11 != NULL)
+    {
+        sFnPtr_D3DX11CompileFromMemory = (LPD3DX11COMPILEFROMMEMORY)     GetProcAddress(s_hModD3DX11, "D3DX11CompileFromMemory");
+    }
+    else    // if absent try to take it from DirectX 2010 Feb
+    {
+        s_hModD3DX11 = LoadLibrary("D3DX11d_42.dll");
+
+        if (s_hModD3DX11 != NULL)
+        {
+            sFnPtr_D3DX11CompileFromMemory = (LPD3DX11COMPILEFROMMEMORY)     GetProcAddress(s_hModD3DX11, "D3DX11CompileFromMemory");
+        }
+    }
+
+    if (!sFnPtr_CreateDXGIFactory)
+    {
+        s_hModDXGI = LoadLibrary("dxgi.dll");
+
+        if (s_hModDXGI)
+        {
+            sFnPtr_CreateDXGIFactory = (LPCREATEDXGIFACTORY)GetProcAddress(s_hModDXGI, "CreateDXGIFactory1");
+        }
+
+        return (s_hModDXGI != NULL) && (s_hModD3D11 != NULL);
+    }
+
+    return (s_hModD3D11 != NULL);
+#else
+    sFnPtr_D3D11CreateDevice = (LPD3D11CREATEDEVICE)D3D11CreateDeviceAndSwapChain;
+    sFnPtr_D3D11CreateDeviceAndSwapChain = (LPD3D11CREATEDEVICEANDSWAPCHAIN)D3D11CreateDeviceAndSwapChain;
+    //sFnPtr_D3DX11CreateEffectFromMemory  = ( LPD3DX11CREATEEFFECTFROMMEMORY )D3DX11CreateEffectFromMemory;
+    sFnPtr_D3DX11CompileFromMemory = (LPD3DX11COMPILEFROMMEMORY)D3DX11CompileFromMemory;
+    sFnPtr_CreateDXGIFactory = (LPCREATEDXGIFACTORY)CreateDXGIFactory;
+    return true;
+#endif
+    return true;
+}
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/exception.h gpu-rodinia_new/cuda/cfd/common/inc/exception.h
--- gpu-rodinia/cuda/cfd/common/inc/exception.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/exception.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,151 @@
+/*
+* Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+*
+* Please refer to the NVIDIA end user license agreement (EULA) associated
+* with this source code for terms and conditions that govern your use of
+* this software. Any use, reproduction, disclosure, or distribution of
+* this software and related documentation outside the terms of the EULA
+* is strictly prohibited.
+*
+*/
+
+/* CUda UTility Library */
+#ifndef _EXCEPTION_H_
+#define _EXCEPTION_H_
+
+// includes, system
+#include <exception>
+#include <stdexcept>
+#include <iostream>
+#include <stdlib.h>
+
+//! Exception wrapper.
+//! @param Std_Exception Exception out of namespace std for easy typing.
+template<class Std_Exception>
+class Exception : public Std_Exception
+{
+    public:
+
+        //! @brief Static construction interface
+        //! @return Alwayss throws ( Located_Exception<Exception>)
+        //! @param file file in which the Exception occurs
+        //! @param line line in which the Exception occurs
+        //! @param detailed details on the code fragment causing the Exception
+        static void throw_it(const char *file,
+                             const int line,
+                             const char *detailed = "-");
+
+        //! Static construction interface
+        //! @return Alwayss throws ( Located_Exception<Exception>)
+        //! @param file file in which the Exception occurs
+        //! @param line line in which the Exception occurs
+        //! @param detailed details on the code fragment causing the Exception
+        static void throw_it(const char *file,
+                             const int line,
+                             const std::string &detailed);
+
+        //! Destructor
+        virtual ~Exception() throw();
+
+    private:
+
+        //! Constructor, default (private)
+        Exception();
+
+        //! Constructor, standard
+        //! @param str string returned by what()
+        Exception(const std::string &str);
+
+};
+
+////////////////////////////////////////////////////////////////////////////////
+//! Exception handler function for arbitrary exceptions
+//! @param ex exception to handle
+////////////////////////////////////////////////////////////////////////////////
+template<class Exception_Typ>
+inline void
+handleException(const Exception_Typ &ex)
+{
+    std::cerr << ex.what() << std::endl;
+
+    exit(EXIT_FAILURE);
+}
+
+//! Convenience macros
+
+//! Exception caused by dynamic program behavior, e.g. file does not exist
+#define RUNTIME_EXCEPTION( msg) \
+    Exception<std::runtime_error>::throw_it( __FILE__, __LINE__, msg)
+
+//! Logic exception in program, e.g. an assert failed
+#define LOGIC_EXCEPTION( msg) \
+    Exception<std::logic_error>::throw_it( __FILE__, __LINE__, msg)
+
+//! Out of range exception
+#define RANGE_EXCEPTION( msg) \
+    Exception<std::range_error>::throw_it( __FILE__, __LINE__, msg)
+
+////////////////////////////////////////////////////////////////////////////////
+//! Implementation
+
+// includes, system
+#include <sstream>
+
+////////////////////////////////////////////////////////////////////////////////
+//! Static construction interface.
+//! @param  Exception causing code fragment (file and line) and detailed infos.
+////////////////////////////////////////////////////////////////////////////////
+/*static*/ template<class Std_Exception>
+void
+Exception<Std_Exception>::
+throw_it(const char *file, const int line, const char *detailed)
+{
+    std::stringstream s;
+
+    // Quiet heavy-weight but exceptions are not for
+    // performance / release versions
+    s << "Exception in file '" << file << "' in line " << line << "\n"
+      << "Detailed description: " << detailed << "\n";
+
+    throw Exception(s.str());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Static construction interface.
+//! @param  Exception causing code fragment (file and line) and detailed infos.
+////////////////////////////////////////////////////////////////////////////////
+/*static*/ template<class Std_Exception>
+void
+Exception<Std_Exception>::
+throw_it(const char *file, const int line, const std::string &msg)
+{
+    throw_it(file, line, msg.c_str());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Constructor, default (private).
+////////////////////////////////////////////////////////////////////////////////
+template<class Std_Exception>
+Exception<Std_Exception>::Exception() :
+    Exception("Unknown Exception.\n")
+{ }
+
+////////////////////////////////////////////////////////////////////////////////
+//! Constructor, standard (private).
+//! String returned by what().
+////////////////////////////////////////////////////////////////////////////////
+template<class Std_Exception>
+Exception<Std_Exception>::Exception(const std::string &s) :
+    Std_Exception(s)
+{ }
+
+////////////////////////////////////////////////////////////////////////////////
+//! Destructor
+////////////////////////////////////////////////////////////////////////////////
+template<class Std_Exception>
+Exception<Std_Exception>::~Exception() throw() { }
+
+// functions, exported
+
+#endif // #ifndef _EXCEPTION_H_
+
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/freeglut_ext.h gpu-rodinia_new/cuda/cfd/common/inc/GL/freeglut_ext.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/freeglut_ext.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/freeglut_ext.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,115 @@
+#ifndef  __FREEGLUT_EXT_H__
+#define  __FREEGLUT_EXT_H__
+
+/*
+ * freeglut_ext.h
+ *
+ * The non-GLUT-compatible extensions to the freeglut library include file
+ *
+ * Copyright (c) 1999-2000 Pawel W. Olszta. All Rights Reserved.
+ * Written by Pawel W. Olszta, <olszta@sourceforge.net>
+ * Creation date: Thu Dec 2 1999
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PAWEL W. OLSZTA BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /*
+     * GLUT API Extension macro definitions -- behaviour when the user clicks on an "x" to close a window
+     */
+#define GLUT_ACTION_EXIT                         0
+#define GLUT_ACTION_GLUTMAINLOOP_RETURNS         1
+#define GLUT_ACTION_CONTINUE_EXECUTION           2
+
+    /*
+     * Create a new rendering context when the user opens a new window?
+     */
+#define GLUT_CREATE_NEW_CONTEXT                  0
+#define GLUT_USE_CURRENT_CONTEXT                 1
+
+    /*
+     * GLUT API Extension macro definitions -- the glutGet parameters
+     */
+#define  GLUT_ACTION_ON_WINDOW_CLOSE        0x01F9
+
+#define  GLUT_WINDOW_BORDER_WIDTH           0x01FA
+#define  GLUT_WINDOW_HEADER_HEIGHT          0x01FB
+
+#define  GLUT_VERSION                       0x01FC
+
+#define  GLUT_RENDERING_CONTEXT             0x01FD
+
+    /*
+     * Process loop function, see freeglut_main.c
+     */
+    FGAPI void    FGAPIENTRY glutMainLoopEvent(void);
+    FGAPI void    FGAPIENTRY glutLeaveMainLoop(void);
+
+    /*
+     * Window-specific callback functions, see freeglut_callbacks.c
+     */
+    FGAPI void    FGAPIENTRY glutMouseWheelFunc(void (* callback)(int, int, int, int));
+    FGAPI void    FGAPIENTRY glutCloseFunc(void (* callback)(void));
+    FGAPI void    FGAPIENTRY glutWMCloseFunc(void (* callback)(void));
+    /* A. Donev: Also a destruction callback for menus */
+    FGAPI void    FGAPIENTRY glutMenuDestroyFunc(void (* callback)(void));
+
+    /*
+     * State setting and retrieval functions, see freeglut_state.c
+     */
+    FGAPI void    FGAPIENTRY glutSetOption(GLenum option_flag, int value) ;
+    /* A.Donev: User-data manipulation */
+    FGAPI void   *FGAPIENTRY glutGetWindowData(void);
+    FGAPI void    FGAPIENTRY glutSetWindowData(void *data);
+    FGAPI void   *FGAPIENTRY glutGetMenuData(void);
+    FGAPI void    FGAPIENTRY glutSetMenuData(void *data);
+
+    /*
+     * Font stuff, see freeglut_font.c
+     */
+    FGAPI int     FGAPIENTRY glutBitmapHeight(void *font);
+    FGAPI GLfloat FGAPIENTRY glutStrokeHeight(void *font);
+    FGAPI void    FGAPIENTRY glutBitmapString(void *font, const unsigned char *string);
+    FGAPI void    FGAPIENTRY glutStrokeString(void *font, const unsigned char *string);
+
+    /*
+     * Geometry functions, see freeglut_geometry.c
+     */
+    FGAPI void    FGAPIENTRY glutWireRhombicDodecahedron(void);
+    FGAPI void    FGAPIENTRY glutSolidRhombicDodecahedron(void);
+    FGAPI void    FGAPIENTRY glutWireSierpinskiSponge(int num_levels, GLdouble offset[3], GLdouble scale) ;
+    FGAPI void    FGAPIENTRY glutSolidSierpinskiSponge(int num_levels, GLdouble offset[3], GLdouble scale) ;
+    FGAPI void    FGAPIENTRY glutWireCylinder(GLdouble radius, GLdouble height, GLint slices, GLint stacks);
+    FGAPI void    FGAPIENTRY glutSolidCylinder(GLdouble radius, GLdouble height, GLint slices, GLint stacks);
+
+    /*
+     * Extension functions, see freeglut_ext.c
+     */
+    FGAPI void *FGAPIENTRY glutGetProcAddress(const char *procName);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*** END OF FILE ***/
+
+#endif /* __FREEGLUT_EXT_H__ */
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/freeglut.h gpu-rodinia_new/cuda/cfd/common/inc/GL/freeglut.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/freeglut.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/freeglut.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,22 @@
+#ifndef  __FREEGLUT_H__
+#define  __FREEGLUT_H__
+
+/*
+ * freeglut.h
+ *
+ * The freeglut library include file
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PAWEL W. OLSZTA BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "freeglut_std.h"
+#include "freeglut_ext.h"
+
+/*** END OF FILE ***/
+
+#endif /* __FREEGLUT_H__ */
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/freeglut_std.h gpu-rodinia_new/cuda/cfd/common/inc/GL/freeglut_std.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/freeglut_std.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/freeglut_std.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,547 @@
+#ifndef  __FREEGLUT_STD_H__
+#define  __FREEGLUT_STD_H__
+
+/*
+ * freeglut_std.h
+ *
+ * The GLUT-compatible part of the freeglut library include file
+ *
+ * Copyright (c) 1999-2000 Pawel W. Olszta. All Rights Reserved.
+ * Written by Pawel W. Olszta, <olszta@sourceforge.net>
+ * Creation date: Thu Dec 2 1999
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PAWEL W. OLSZTA BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /*
+     * Under windows, we have to differentiate between static and dynamic libraries
+     */
+#if defined(WIN32)
+#    include <windows.h>
+#    include <windowsx.h>
+#    include <mmsystem.h>
+#    define WINDOWS
+#ifdef FREEGLUT_STATIC
+#    define FGAPI
+#    define FGAPIENTRY
+
+#    pragma comment (lib, "freeglut_static.lib")    /* link with Win32 static freeglut lib */
+
+#else
+
+#        if defined(FREEGLUT_EXPORTS)
+#                define FGAPI __declspec(dllexport)
+    /* #                define FGAPI */
+#        else
+#                define FGAPI __declspec(dllimport)
+#   pragma comment (lib, "freeglut.lib")    /* link with Win32 freeglut lib */
+#        endif
+#        define FGAPIENTRY __stdcall
+
+#endif
+
+#pragma comment (lib, "winmm.lib")       /* link with Windows MultiMedia lib */
+#pragma comment (lib, "user32.lib") /* link with Windows user lib */
+#pragma comment (lib, "gdi32.lib") /* link with Windows GDI lib */
+#pragma comment (lib, "opengl32.lib")    /* link with Microsoft OpenGL lib */
+#pragma comment (lib, "glu32.lib")       /* link with OpenGL Utility lib */
+
+
+#else
+#        define FGAPI
+#        define FGAPIENTRY
+#endif
+
+    /*
+     * The freeglut and GLUT API versions
+     */
+#define  FREEGLUT             1
+#define  GLUT_API_VERSION     4
+#define  FREEGLUT_VERSION_2_0 1
+
+    /*
+     * Always include OpenGL and GLU headers
+     */
+#include <GL/gl.h>
+#include <GL/glu.h>
+
+    /*
+     * GLUT API macro definitions -- the special key codes:
+     */
+#define  GLUT_KEY_F1                        0x0001
+#define  GLUT_KEY_F2                        0x0002
+#define  GLUT_KEY_F3                        0x0003
+#define  GLUT_KEY_F4                        0x0004
+#define  GLUT_KEY_F5                        0x0005
+#define  GLUT_KEY_F6                        0x0006
+#define  GLUT_KEY_F7                        0x0007
+#define  GLUT_KEY_F8                        0x0008
+#define  GLUT_KEY_F9                        0x0009
+#define  GLUT_KEY_F10                       0x000A
+#define  GLUT_KEY_F11                       0x000B
+#define  GLUT_KEY_F12                       0x000C
+#define  GLUT_KEY_LEFT                      0x0064
+#define  GLUT_KEY_UP                        0x0065
+#define  GLUT_KEY_RIGHT                     0x0066
+#define  GLUT_KEY_DOWN                      0x0067
+#define  GLUT_KEY_PAGE_UP                   0x0068
+#define  GLUT_KEY_PAGE_DOWN                 0x0069
+#define  GLUT_KEY_HOME                      0x006A
+#define  GLUT_KEY_END                       0x006B
+#define  GLUT_KEY_INSERT                    0x006C
+
+    /*
+     * GLUT API macro definitions -- mouse state definitions
+     */
+#define  GLUT_LEFT_BUTTON                   0x0000
+#define  GLUT_MIDDLE_BUTTON                 0x0001
+#define  GLUT_RIGHT_BUTTON                  0x0002
+#define  GLUT_DOWN                          0x0000
+#define  GLUT_UP                            0x0001
+#define  GLUT_LEFT                          0x0000
+#define  GLUT_ENTERED                       0x0001
+
+    /*
+     * GLUT API macro definitions -- the display mode definitions
+     */
+#define  GLUT_RGB                           0x0000
+#define  GLUT_RGBA                          0x0000
+#define  GLUT_INDEX                         0x0001
+#define  GLUT_SINGLE                        0x0000
+#define  GLUT_DOUBLE                        0x0002
+#define  GLUT_ACCUM                         0x0004
+#define  GLUT_ALPHA                         0x0008
+#define  GLUT_DEPTH                         0x0010
+#define  GLUT_STENCIL                       0x0020
+#define  GLUT_MULTISAMPLE                   0x0080
+#define  GLUT_STEREO                        0x0100
+#define  GLUT_LUMINANCE                     0x0200
+
+    /*
+     * GLUT API macro definitions -- windows and menu related definitions
+     */
+#define  GLUT_MENU_NOT_IN_USE               0x0000
+#define  GLUT_MENU_IN_USE                   0x0001
+#define  GLUT_NOT_VISIBLE                   0x0000
+#define  GLUT_VISIBLE                       0x0001
+#define  GLUT_HIDDEN                        0x0000
+#define  GLUT_FULLY_RETAINED                0x0001
+#define  GLUT_PARTIALLY_RETAINED            0x0002
+#define  GLUT_FULLY_COVERED                 0x0003
+
+    /*
+     * GLUT API macro definitions -- fonts definitions
+     *
+     * Steve Baker suggested to make it binary compatible with GLUT:
+     */
+#if defined(WIN32)
+#   define  GLUT_STROKE_ROMAN               ((void *)0x0000)
+#   define  GLUT_STROKE_MONO_ROMAN          ((void *)0x0001)
+#   define  GLUT_BITMAP_9_BY_15             ((void *)0x0002)
+#   define  GLUT_BITMAP_8_BY_13             ((void *)0x0003)
+#   define  GLUT_BITMAP_TIMES_ROMAN_10      ((void *)0x0004)
+#   define  GLUT_BITMAP_TIMES_ROMAN_24      ((void *)0x0005)
+#   define  GLUT_BITMAP_HELVETICA_10        ((void *)0x0006)
+#   define  GLUT_BITMAP_HELVETICA_12        ((void *)0x0007)
+#   define  GLUT_BITMAP_HELVETICA_18        ((void *)0x0008)
+#else
+    /*
+     * I don't really know if it's a good idea... But here it goes:
+     */
+    extern void *glutStrokeRoman;
+    extern void *glutStrokeMonoRoman;
+    extern void *glutBitmap9By15;
+    extern void *glutBitmap8By13;
+    extern void *glutBitmapTimesRoman10;
+    extern void *glutBitmapTimesRoman24;
+    extern void *glutBitmapHelvetica10;
+    extern void *glutBitmapHelvetica12;
+    extern void *glutBitmapHelvetica18;
+
+    /*
+     * Those pointers will be used by following definitions:
+     */
+#   define  GLUT_STROKE_ROMAN               ((void *) &glutStrokeRoman)
+#   define  GLUT_STROKE_MONO_ROMAN          ((void *) &glutStrokeMonoRoman)
+#   define  GLUT_BITMAP_9_BY_15             ((void *) &glutBitmap9By15)
+#   define  GLUT_BITMAP_8_BY_13             ((void *) &glutBitmap8By13)
+#   define  GLUT_BITMAP_TIMES_ROMAN_10      ((void *) &glutBitmapTimesRoman10)
+#   define  GLUT_BITMAP_TIMES_ROMAN_24      ((void *) &glutBitmapTimesRoman24)
+#   define  GLUT_BITMAP_HELVETICA_10        ((void *) &glutBitmapHelvetica10)
+#   define  GLUT_BITMAP_HELVETICA_12        ((void *) &glutBitmapHelvetica12)
+#   define  GLUT_BITMAP_HELVETICA_18        ((void *) &glutBitmapHelvetica18)
+#endif
+
+    /*
+     * GLUT API macro definitions -- the glutGet parameters
+     */
+#define  GLUT_WINDOW_X                      0x0064
+#define  GLUT_WINDOW_Y                      0x0065
+#define  GLUT_WINDOW_WIDTH                  0x0066
+#define  GLUT_WINDOW_HEIGHT                 0x0067
+#define  GLUT_WINDOW_BUFFER_SIZE            0x0068
+#define  GLUT_WINDOW_STENCIL_SIZE           0x0069
+#define  GLUT_WINDOW_DEPTH_SIZE             0x006A
+#define  GLUT_WINDOW_RED_SIZE               0x006B
+#define  GLUT_WINDOW_GREEN_SIZE             0x006C
+#define  GLUT_WINDOW_BLUE_SIZE              0x006D
+#define  GLUT_WINDOW_ALPHA_SIZE             0x006E
+#define  GLUT_WINDOW_ACCUM_RED_SIZE         0x006F
+#define  GLUT_WINDOW_ACCUM_GREEN_SIZE       0x0070
+#define  GLUT_WINDOW_ACCUM_BLUE_SIZE        0x0071
+#define  GLUT_WINDOW_ACCUM_ALPHA_SIZE       0x0072
+#define  GLUT_WINDOW_DOUBLEBUFFER           0x0073
+#define  GLUT_WINDOW_RGBA                   0x0074
+#define  GLUT_WINDOW_PARENT                 0x0075
+#define  GLUT_WINDOW_NUM_CHILDREN           0x0076
+#define  GLUT_WINDOW_COLORMAP_SIZE          0x0077
+#define  GLUT_WINDOW_NUM_SAMPLES            0x0078
+#define  GLUT_WINDOW_STEREO                 0x0079
+#define  GLUT_WINDOW_CURSOR                 0x007A
+
+#define  GLUT_SCREEN_WIDTH                  0x00C8
+#define  GLUT_SCREEN_HEIGHT                 0x00C9
+#define  GLUT_SCREEN_WIDTH_MM               0x00CA
+#define  GLUT_SCREEN_HEIGHT_MM              0x00CB
+#define  GLUT_MENU_NUM_ITEMS                0x012C
+#define  GLUT_DISPLAY_MODE_POSSIBLE         0x0190
+#define  GLUT_INIT_WINDOW_X                 0x01F4
+#define  GLUT_INIT_WINDOW_Y                 0x01F5
+#define  GLUT_INIT_WINDOW_WIDTH             0x01F6
+#define  GLUT_INIT_WINDOW_HEIGHT            0x01F7
+#define  GLUT_INIT_DISPLAY_MODE             0x01F8
+#define  GLUT_ELAPSED_TIME                  0x02BC
+#define  GLUT_WINDOW_FORMAT_ID              0x007B
+#define  GLUT_INIT_STATE                    0x007C
+
+    /*
+     * GLUT API macro definitions -- the glutDeviceGet parameters
+     */
+#define  GLUT_HAS_KEYBOARD                  0x0258
+#define  GLUT_HAS_MOUSE                     0x0259
+#define  GLUT_HAS_SPACEBALL                 0x025A
+#define  GLUT_HAS_DIAL_AND_BUTTON_BOX       0x025B
+#define  GLUT_HAS_TABLET                    0x025C
+#define  GLUT_NUM_MOUSE_BUTTONS             0x025D
+#define  GLUT_NUM_SPACEBALL_BUTTONS         0x025E
+#define  GLUT_NUM_BUTTON_BOX_BUTTONS        0x025F
+#define  GLUT_NUM_DIALS                     0x0260
+#define  GLUT_NUM_TABLET_BUTTONS            0x0261
+#define  GLUT_DEVICE_IGNORE_KEY_REPEAT      0x0262
+#define  GLUT_DEVICE_KEY_REPEAT             0x0263
+#define  GLUT_HAS_JOYSTICK                  0x0264
+#define  GLUT_OWNS_JOYSTICK                 0x0265
+#define  GLUT_JOYSTICK_BUTTONS              0x0266
+#define  GLUT_JOYSTICK_AXES                 0x0267
+#define  GLUT_JOYSTICK_POLL_RATE            0x0268
+
+    /*
+     * GLUT API macro definitions -- the glutLayerGet parameters
+     */
+#define  GLUT_OVERLAY_POSSIBLE              0x0320
+#define  GLUT_LAYER_IN_USE                  0x0321
+#define  GLUT_HAS_OVERLAY                   0x0322
+#define  GLUT_TRANSPARENT_INDEX             0x0323
+#define  GLUT_NORMAL_DAMAGED                0x0324
+#define  GLUT_OVERLAY_DAMAGED               0x0325
+
+    /*
+     * GLUT API macro definitions -- the glutVideoResizeGet parameters
+     */
+#define  GLUT_VIDEO_RESIZE_POSSIBLE         0x0384
+#define  GLUT_VIDEO_RESIZE_IN_USE           0x0385
+#define  GLUT_VIDEO_RESIZE_X_DELTA          0x0386
+#define  GLUT_VIDEO_RESIZE_Y_DELTA          0x0387
+#define  GLUT_VIDEO_RESIZE_WIDTH_DELTA      0x0388
+#define  GLUT_VIDEO_RESIZE_HEIGHT_DELTA     0x0389
+#define  GLUT_VIDEO_RESIZE_X                0x038A
+#define  GLUT_VIDEO_RESIZE_Y                0x038B
+#define  GLUT_VIDEO_RESIZE_WIDTH            0x038C
+#define  GLUT_VIDEO_RESIZE_HEIGHT           0x038D
+
+    /*
+     * GLUT API macro definitions -- the glutUseLayer parameters
+     */
+#define  GLUT_NORMAL                        0x0000
+#define  GLUT_OVERLAY                       0x0001
+
+    /*
+     * GLUT API macro definitions -- the glutGetModifiers parameters
+     */
+#define  GLUT_ACTIVE_SHIFT                  0x0001
+#define  GLUT_ACTIVE_CTRL                   0x0002
+#define  GLUT_ACTIVE_ALT                    0x0004
+
+    /*
+     * GLUT API macro definitions -- the glutSetCursor parameters
+     */
+#define  GLUT_CURSOR_RIGHT_ARROW            0x0000
+#define  GLUT_CURSOR_LEFT_ARROW             0x0001
+#define  GLUT_CURSOR_INFO                   0x0002
+#define  GLUT_CURSOR_DESTROY                0x0003
+#define  GLUT_CURSOR_HELP                   0x0004
+#define  GLUT_CURSOR_CYCLE                  0x0005
+#define  GLUT_CURSOR_SPRAY                  0x0006
+#define  GLUT_CURSOR_WAIT                   0x0007
+#define  GLUT_CURSOR_TEXT                   0x0008
+#define  GLUT_CURSOR_CROSSHAIR              0x0009
+#define  GLUT_CURSOR_UP_DOWN                0x000A
+#define  GLUT_CURSOR_LEFT_RIGHT             0x000B
+#define  GLUT_CURSOR_TOP_SIDE               0x000C
+#define  GLUT_CURSOR_BOTTOM_SIDE            0x000D
+#define  GLUT_CURSOR_LEFT_SIDE              0x000E
+#define  GLUT_CURSOR_RIGHT_SIDE             0x000F
+#define  GLUT_CURSOR_TOP_LEFT_CORNER        0x0010
+#define  GLUT_CURSOR_TOP_RIGHT_CORNER       0x0011
+#define  GLUT_CURSOR_BOTTOM_RIGHT_CORNER    0x0012
+#define  GLUT_CURSOR_BOTTOM_LEFT_CORNER     0x0013
+#define  GLUT_CURSOR_INHERIT                0x0064
+#define  GLUT_CURSOR_NONE                   0x0065
+#define  GLUT_CURSOR_FULL_CROSSHAIR         0x0066
+
+    /*
+     * GLUT API macro definitions -- RGB color component specification definitions
+     */
+#define  GLUT_RED                           0x0000
+#define  GLUT_GREEN                         0x0001
+#define  GLUT_BLUE                          0x0002
+
+    /*
+     * GLUT API macro definitions -- additional keyboard and joystick definitions
+     */
+#define  GLUT_KEY_REPEAT_OFF                0x0000
+#define  GLUT_KEY_REPEAT_ON                 0x0001
+#define  GLUT_KEY_REPEAT_DEFAULT            0x0002
+
+#define  GLUT_JOYSTICK_BUTTON_A             0x0001
+#define  GLUT_JOYSTICK_BUTTON_B             0x0002
+#define  GLUT_JOYSTICK_BUTTON_C             0x0004
+#define  GLUT_JOYSTICK_BUTTON_D             0x0008
+
+    /*
+     * GLUT API macro definitions -- game mode definitions
+     */
+#define  GLUT_GAME_MODE_ACTIVE              0x0000
+#define  GLUT_GAME_MODE_POSSIBLE            0x0001
+#define  GLUT_GAME_MODE_WIDTH               0x0002
+#define  GLUT_GAME_MODE_HEIGHT              0x0003
+#define  GLUT_GAME_MODE_PIXEL_DEPTH         0x0004
+#define  GLUT_GAME_MODE_REFRESH_RATE        0x0005
+#define  GLUT_GAME_MODE_DISPLAY_CHANGED     0x0006
+
+    /*
+     * Initialization functions, see fglut_init.c
+     */
+    FGAPI void    FGAPIENTRY glutInit(int *pargc, char **argv);
+    FGAPI void    FGAPIENTRY glutInitWindowPosition(int x, int y);
+    FGAPI void    FGAPIENTRY glutInitWindowSize(int width, int height);
+    FGAPI void    FGAPIENTRY glutInitDisplayMode(unsigned int displayMode);
+    FGAPI void    FGAPIENTRY glutInitDisplayString(const char *displayMode);
+
+    /*
+     * Process loop function, see freeglut_main.c
+     */
+    FGAPI void    FGAPIENTRY glutMainLoop(void);
+
+    /*
+     * Window management functions, see freeglut_window.c
+     */
+    FGAPI int     FGAPIENTRY glutCreateWindow(const char *title);
+    FGAPI int     FGAPIENTRY glutCreateSubWindow(int window, int x, int y, int width, int height);
+    FGAPI void    FGAPIENTRY glutDestroyWindow(int window);
+    FGAPI void    FGAPIENTRY glutSetWindow(int window);
+    FGAPI int     FGAPIENTRY glutGetWindow(void);
+    FGAPI void    FGAPIENTRY glutSetWindowTitle(const char *title);
+    FGAPI void    FGAPIENTRY glutSetIconTitle(const char *title);
+    FGAPI void    FGAPIENTRY glutReshapeWindow(int width, int height);
+    FGAPI void    FGAPIENTRY glutPositionWindow(int x, int y);
+    FGAPI void    FGAPIENTRY glutShowWindow(void);
+    FGAPI void    FGAPIENTRY glutHideWindow(void);
+    FGAPI void    FGAPIENTRY glutIconifyWindow(void);
+    FGAPI void    FGAPIENTRY glutPushWindow(void);
+    FGAPI void    FGAPIENTRY glutPopWindow(void);
+    FGAPI void    FGAPIENTRY glutFullScreen(void);
+
+    /*
+     * Display-connected functions, see freeglut_display.c
+     */
+    FGAPI void    FGAPIENTRY glutPostWindowRedisplay(int window);
+    FGAPI void    FGAPIENTRY glutPostRedisplay(void);
+    FGAPI void    FGAPIENTRY glutSwapBuffers(void);
+
+    /*
+     * Mouse cursor functions, see freeglut_cursor.c
+     */
+    FGAPI void    FGAPIENTRY glutWarpPointer(int x, int y);
+    FGAPI void    FGAPIENTRY glutSetCursor(int cursor);
+
+    /*
+     * Overlay stuff, see freeglut_overlay.c
+     */
+    FGAPI void    FGAPIENTRY glutEstablishOverlay(void);
+    FGAPI void    FGAPIENTRY glutRemoveOverlay(void);
+    FGAPI void    FGAPIENTRY glutUseLayer(GLenum layer);
+    FGAPI void    FGAPIENTRY glutPostOverlayRedisplay(void);
+    FGAPI void    FGAPIENTRY glutPostWindowOverlayRedisplay(int window);
+    FGAPI void    FGAPIENTRY glutShowOverlay(void);
+    FGAPI void    FGAPIENTRY glutHideOverlay(void);
+
+    /*
+     * Menu stuff, see freeglut_menu.c
+     */
+    FGAPI int     FGAPIENTRY glutCreateMenu(void (* callback)(int menu));
+    FGAPI void    FGAPIENTRY glutDestroyMenu(int menu);
+    FGAPI int     FGAPIENTRY glutGetMenu(void);
+    FGAPI void    FGAPIENTRY glutSetMenu(int menu);
+    FGAPI void    FGAPIENTRY glutAddMenuEntry(const char *label, int value);
+    FGAPI void    FGAPIENTRY glutAddSubMenu(const char *label, int subMenu);
+    FGAPI void    FGAPIENTRY glutChangeToMenuEntry(int item, const char *label, int value);
+    FGAPI void    FGAPIENTRY glutChangeToSubMenu(int item, const char *label, int value);
+    FGAPI void    FGAPIENTRY glutRemoveMenuItem(int item);
+    FGAPI void    FGAPIENTRY glutAttachMenu(int button);
+    FGAPI void    FGAPIENTRY glutDetachMenu(int button);
+
+    /*
+     * Global callback functions, see freeglut_callbacks.c
+     */
+    FGAPI void    FGAPIENTRY glutTimerFunc(unsigned int time, void (* callback)(int), int value);
+    FGAPI void    FGAPIENTRY glutIdleFunc(void (* callback)(void));
+
+    /*
+     * Window-specific callback functions, see freeglut_callbacks.c
+     */
+    FGAPI void    FGAPIENTRY glutKeyboardFunc(void (* callback)(unsigned char, int, int));
+    FGAPI void    FGAPIENTRY glutSpecialFunc(void (* callback)(int, int, int));
+    FGAPI void    FGAPIENTRY glutReshapeFunc(void (* callback)(int, int));
+    FGAPI void    FGAPIENTRY glutVisibilityFunc(void (* callback)(int));
+    FGAPI void    FGAPIENTRY glutDisplayFunc(void (* callback)(void));
+    FGAPI void    FGAPIENTRY glutMouseFunc(void (* callback)(int, int, int, int));
+    FGAPI void    FGAPIENTRY glutMotionFunc(void (* callback)(int, int));
+    FGAPI void    FGAPIENTRY glutPassiveMotionFunc(void (* callback)(int, int));
+    FGAPI void    FGAPIENTRY glutEntryFunc(void (* callback)(int));
+
+    FGAPI void    FGAPIENTRY glutKeyboardUpFunc(void (* callback)(unsigned char, int, int));
+    FGAPI void    FGAPIENTRY glutSpecialUpFunc(void (* callback)(int, int, int));
+    FGAPI void    FGAPIENTRY glutJoystickFunc(void (* callback)(unsigned int, int, int, int), int pollInterval);
+    FGAPI void    FGAPIENTRY glutMenuStateFunc(void (* callback)(int));
+    FGAPI void    FGAPIENTRY glutMenuStatusFunc(void (* callback)(int, int, int));
+    FGAPI void    FGAPIENTRY glutOverlayDisplayFunc(void (* callback)(void));
+    FGAPI void    FGAPIENTRY glutWindowStatusFunc(void (* callback)(int));
+
+    FGAPI void    FGAPIENTRY glutSpaceballMotionFunc(void (* callback)(int, int, int));
+    FGAPI void    FGAPIENTRY glutSpaceballRotateFunc(void (* callback)(int, int, int));
+    FGAPI void    FGAPIENTRY glutSpaceballButtonFunc(void (* callback)(int, int));
+    FGAPI void    FGAPIENTRY glutButtonBoxFunc(void (* callback)(int, int));
+    FGAPI void    FGAPIENTRY glutDialsFunc(void (* callback)(int, int));
+    FGAPI void    FGAPIENTRY glutTabletMotionFunc(void (* callback)(int, int));
+    FGAPI void    FGAPIENTRY glutTabletButtonFunc(void (* callback)(int, int, int, int));
+
+    /*
+     * State setting and retrieval functions, see freeglut_state.c
+     */
+    FGAPI int     FGAPIENTRY glutGet(GLenum query);
+    FGAPI int     FGAPIENTRY glutDeviceGet(GLenum query);
+    FGAPI int     FGAPIENTRY glutGetModifiers(void);
+    FGAPI int     FGAPIENTRY glutLayerGet(GLenum query);
+
+    /*
+     * Font stuff, see freeglut_font.c
+     */
+    FGAPI void    FGAPIENTRY glutBitmapCharacter(void *font, int character);
+    FGAPI int     FGAPIENTRY glutBitmapWidth(void *font, int character);
+    FGAPI void    FGAPIENTRY glutStrokeCharacter(void *font, int character);
+    FGAPI int     FGAPIENTRY glutStrokeWidth(void *font, int character);
+    FGAPI int     FGAPIENTRY glutBitmapLength(void *font, const unsigned char *string);
+    FGAPI int     FGAPIENTRY glutStrokeLength(void *font, const unsigned char *string);
+
+    /*
+     * Geometry functions, see freeglut_geometry.c
+     */
+    FGAPI void    FGAPIENTRY glutWireCube(GLdouble size);
+    FGAPI void    FGAPIENTRY glutSolidCube(GLdouble size);
+    FGAPI void    FGAPIENTRY glutWireSphere(GLdouble radius, GLint slices, GLint stacks);
+    FGAPI void    FGAPIENTRY glutSolidSphere(GLdouble radius, GLint slices, GLint stacks);
+    FGAPI void    FGAPIENTRY glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);
+    FGAPI void    FGAPIENTRY glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);
+
+    FGAPI void    FGAPIENTRY glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings);
+    FGAPI void    FGAPIENTRY glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings);
+    FGAPI void    FGAPIENTRY glutWireDodecahedron(void);
+    FGAPI void    FGAPIENTRY glutSolidDodecahedron(void);
+    FGAPI void    FGAPIENTRY glutWireOctahedron(void);
+    FGAPI void    FGAPIENTRY glutSolidOctahedron(void);
+    FGAPI void    FGAPIENTRY glutWireTetrahedron(void);
+    FGAPI void    FGAPIENTRY glutSolidTetrahedron(void);
+    FGAPI void    FGAPIENTRY glutWireIcosahedron(void);
+    FGAPI void    FGAPIENTRY glutSolidIcosahedron(void);
+
+    /*
+     * Teapot rendering functions, found in freeglut_teapot.c
+     */
+    FGAPI void    FGAPIENTRY glutWireTeapot(GLdouble size);
+    FGAPI void    FGAPIENTRY glutSolidTeapot(GLdouble size);
+
+    /*
+     * Game mode functions, see freeglut_gamemode.c
+     */
+    FGAPI void    FGAPIENTRY glutGameModeString(const char *string);
+    FGAPI int     FGAPIENTRY glutEnterGameMode(void);
+    FGAPI void    FGAPIENTRY glutLeaveGameMode(void);
+    FGAPI int     FGAPIENTRY glutGameModeGet(GLenum query);
+
+    /*
+     * Video resize functions, see freeglut_videoresize.c
+     */
+    FGAPI int     FGAPIENTRY glutVideoResizeGet(GLenum query);
+    FGAPI void    FGAPIENTRY glutSetupVideoResizing(void);
+    FGAPI void    FGAPIENTRY glutStopVideoResizing(void);
+    FGAPI void    FGAPIENTRY glutVideoResize(int x, int y, int width, int height);
+    FGAPI void    FGAPIENTRY glutVideoPan(int x, int y, int width, int height);
+
+    /*
+     * Colormap functions, see freeglut_misc.c
+     */
+    FGAPI void    FGAPIENTRY glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue);
+    FGAPI GLfloat FGAPIENTRY glutGetColor(int color, int component);
+    FGAPI void    FGAPIENTRY glutCopyColormap(int window);
+
+    /*
+     * Misc keyboard and joystick functions, see freeglut_misc.c
+     */
+    FGAPI void    FGAPIENTRY glutIgnoreKeyRepeat(int ignore);
+    FGAPI void    FGAPIENTRY glutSetKeyRepeat(int repeatMode);    /* DEPRECATED 11/4/02 - Do not use */
+    FGAPI void    FGAPIENTRY glutForceJoystickFunc(void);
+
+    /*
+     * Misc functions, see freeglut_misc.c
+     */
+    FGAPI int     FGAPIENTRY glutExtensionSupported(const char *extension);
+    FGAPI void    FGAPIENTRY glutReportErrors(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*** END OF FILE ***/
+
+#endif /* __FREEGLUT_STD_H__ */
+
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/glew.h gpu-rodinia_new/cuda/cfd/common/inc/GL/glew.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/glew.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/glew.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,14457 @@
+/*
+** The OpenGL Extension Wrangler Library
+** Copyright (C) 2002-2008, Milan Ikits <milan ikits[]ieee org>
+** Copyright (C) 2002-2008, Marcelo E. Magallon <mmagallo[]debian org>
+** Copyright (C) 2002, Lev Povalahev
+** All rights reserved.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**
+** * Redistributions of source code must retain the above copyright notice,
+**   this list of conditions and the following disclaimer.
+** * Redistributions in binary form must reproduce the above copyright notice,
+**   this list of conditions and the following disclaimer in the documentation
+**   and/or other materials provided with the distribution.
+** * The name of the author may be used to endorse or promote products
+**   derived from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+** THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/*
+ * Mesa 3-D graphics library
+ * Version:  7.0
+ *
+ * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+** Copyright (c) 2007 The Khronos Group Inc.
+**
+** Permission is hereby granted, free of charge, to any person obtaining a
+** copy of this software and/or associated documentation files (the
+** "Materials"), to deal in the Materials without restriction, including
+** without limitation the rights to use, copy, modify, merge, publish,
+** distribute, sublicense, and/or sell copies of the Materials, and to
+** permit persons to whom the Materials are furnished to do so, subject to
+** the following conditions:
+**
+** The above copyright notice and this permission notice shall be included
+** in all copies or substantial portions of the Materials.
+**
+** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+*/
+
+#ifndef __glew_h__
+#define __glew_h__
+#define __GLEW_H__
+
+#if defined(__gl_h_) || defined(__GL_H__) || defined(__X_GL_H)
+#error gl.h included before glew.h
+#endif
+#if defined(__glext_h_) || defined(__GLEXT_H_)
+#error glext.h included before glew.h
+#endif
+#if defined(__gl_ATI_h_)
+#error glATI.h included before glew.h
+#endif
+
+#define __gl_h_
+#define __GL_H__
+#define __X_GL_H
+#define __glext_h_
+#define __GLEXT_H_
+#define __gl_ATI_h_
+
+#if defined(_WIN32)
+
+/*
+ * GLEW does not include <windows.h> to avoid name space pollution.
+ * GL needs GLAPI and GLAPIENTRY, GLU needs APIENTRY, CALLBACK, and wchar_t
+ * defined properly.
+ */
+/* <windef.h> */
+#ifndef APIENTRY
+#define GLEW_APIENTRY_DEFINED
+#  if defined(__MINGW32__) || defined(__CYGWIN__)
+#    define APIENTRY __stdcall
+#  elif (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) || defined(__BORLANDC__)
+#    define APIENTRY __stdcall
+#  else
+#    define APIENTRY
+#  endif
+#endif
+#ifndef GLAPI
+#  if defined(__MINGW32__) || defined(__CYGWIN__)
+#    define GLAPI extern
+#  endif
+#endif
+/* <winnt.h> */
+#ifndef CALLBACK
+#define GLEW_CALLBACK_DEFINED
+#  if defined(__MINGW32__) || defined(__CYGWIN__)
+#    define CALLBACK __attribute__ ((__stdcall__))
+#  elif (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
+#    define CALLBACK __stdcall
+#  else
+#    define CALLBACK
+#  endif
+#endif
+/* <wingdi.h> and <winnt.h> */
+#ifndef WINGDIAPI
+#define GLEW_WINGDIAPI_DEFINED
+#define WINGDIAPI __declspec(dllimport)
+#endif
+/* <ctype.h> */
+#if (defined(_MSC_VER) || defined(__BORLANDC__)) && !defined(_WCHAR_T_DEFINED)
+typedef unsigned short wchar_t;
+#  define _WCHAR_T_DEFINED
+#endif
+/* <stddef.h> */
+#if !defined(_W64)
+#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && defined(_MSC_VER) && _MSC_VER >= 1300
+#    define _W64 __w64
+#  else
+#    define _W64
+#  endif
+#endif
+#if !defined(_PTRDIFF_T_DEFINED) && !defined(_PTRDIFF_T_)
+#  ifdef _WIN64
+typedef __int64 ptrdiff_t;
+#  else
+typedef _W64 int ptrdiff_t;
+#  endif
+#  define _PTRDIFF_T_DEFINED
+#  define _PTRDIFF_T_
+#endif
+
+#ifndef GLAPI
+#  if defined(__MINGW32__) || defined(__CYGWIN__)
+#    define GLAPI extern
+#  else
+#    define GLAPI WINGDIAPI
+#  endif
+#endif
+
+#ifndef GLAPIENTRY
+#define GLAPIENTRY APIENTRY
+#endif
+
+/*
+ * GLEW_STATIC needs to be set when using the static version.
+ * GLEW_BUILD is set when building the DLL version.
+ */
+#ifdef GLEW_STATIC
+#  define GLEWAPI extern
+#else
+#  ifdef GLEW_BUILD
+#    define GLEWAPI extern __declspec(dllexport)
+#  else
+#    define GLEWAPI extern __declspec(dllimport)
+#  endif
+#endif
+
+#else /* _UNIX */
+
+/*
+ * Needed for ptrdiff_t in turn needed by VBO.  This is defined by ISO
+ * C.  On my system, this amounts to _3 lines_ of included code, all of
+ * them pretty much harmless.  If you know of a way of detecting 32 vs
+ * 64 _targets_ at compile time you are free to replace this with
+ * something that's portable.  For now, _this_ is the portable solution.
+ * (mem, 2004-01-04)
+ */
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define GLEW_APIENTRY_DEFINED
+#define APIENTRY
+#define GLEWAPI extern
+
+/* <glu.h> */
+#ifndef GLAPI
+#define GLAPI extern
+#endif
+#ifndef GLAPIENTRY
+#define GLAPIENTRY
+#endif
+
+#endif /* _WIN32 */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /* ----------------------------- GL_VERSION_1_1 ---------------------------- */
+
+#ifndef GL_VERSION_1_1
+#define GL_VERSION_1_1 1
+
+    typedef unsigned int GLenum;
+    typedef unsigned int GLbitfield;
+    typedef unsigned int GLuint;
+    typedef int GLint;
+    typedef int GLsizei;
+    typedef unsigned char GLboolean;
+    typedef signed char GLbyte;
+    typedef short GLshort;
+    typedef unsigned char GLubyte;
+    typedef unsigned short GLushort;
+    typedef unsigned long GLulong;
+    typedef float GLfloat;
+    typedef float GLclampf;
+    typedef double GLdouble;
+    typedef double GLclampd;
+    typedef void GLvoid;
+#if defined(_MSC_VER)
+#  if _MSC_VER < 1400
+    typedef __int64 GLint64EXT;
+    typedef unsigned __int64 GLuint64EXT;
+#  else
+    typedef signed long long GLint64EXT;
+    typedef unsigned long long GLuint64EXT;
+#  endif
+#else
+#  if defined(__MINGW32__) || defined(__CYGWIN__)
+#include <inttypes.h>
+#  endif
+    typedef int64_t GLint64EXT;
+    typedef uint64_t GLuint64EXT;
+#endif
+    typedef GLint64EXT  GLint64;
+    typedef GLuint64EXT GLuint64;
+    typedef struct __GLsync *GLsync;
+
+#define GL_ACCUM 0x0100
+#define GL_LOAD 0x0101
+#define GL_RETURN 0x0102
+#define GL_MULT 0x0103
+#define GL_ADD 0x0104
+#define GL_NEVER 0x0200
+#define GL_LESS 0x0201
+#define GL_EQUAL 0x0202
+#define GL_LEQUAL 0x0203
+#define GL_GREATER 0x0204
+#define GL_NOTEQUAL 0x0205
+#define GL_GEQUAL 0x0206
+#define GL_ALWAYS 0x0207
+#define GL_CURRENT_BIT 0x00000001
+#define GL_POINT_BIT 0x00000002
+#define GL_LINE_BIT 0x00000004
+#define GL_POLYGON_BIT 0x00000008
+#define GL_POLYGON_STIPPLE_BIT 0x00000010
+#define GL_PIXEL_MODE_BIT 0x00000020
+#define GL_LIGHTING_BIT 0x00000040
+#define GL_FOG_BIT 0x00000080
+#define GL_DEPTH_BUFFER_BIT 0x00000100
+#define GL_ACCUM_BUFFER_BIT 0x00000200
+#define GL_STENCIL_BUFFER_BIT 0x00000400
+#define GL_VIEWPORT_BIT 0x00000800
+#define GL_TRANSFORM_BIT 0x00001000
+#define GL_ENABLE_BIT 0x00002000
+#define GL_COLOR_BUFFER_BIT 0x00004000
+#define GL_HINT_BIT 0x00008000
+#define GL_EVAL_BIT 0x00010000
+#define GL_LIST_BIT 0x00020000
+#define GL_TEXTURE_BIT 0x00040000
+#define GL_SCISSOR_BIT 0x00080000
+#define GL_ALL_ATTRIB_BITS 0x000fffff
+#define GL_POINTS 0x0000
+#define GL_LINES 0x0001
+#define GL_LINE_LOOP 0x0002
+#define GL_LINE_STRIP 0x0003
+#define GL_TRIANGLES 0x0004
+#define GL_TRIANGLE_STRIP 0x0005
+#define GL_TRIANGLE_FAN 0x0006
+#define GL_QUADS 0x0007
+#define GL_QUAD_STRIP 0x0008
+#define GL_POLYGON 0x0009
+#define GL_ZERO 0
+#define GL_ONE 1
+#define GL_SRC_COLOR 0x0300
+#define GL_ONE_MINUS_SRC_COLOR 0x0301
+#define GL_SRC_ALPHA 0x0302
+#define GL_ONE_MINUS_SRC_ALPHA 0x0303
+#define GL_DST_ALPHA 0x0304
+#define GL_ONE_MINUS_DST_ALPHA 0x0305
+#define GL_DST_COLOR 0x0306
+#define GL_ONE_MINUS_DST_COLOR 0x0307
+#define GL_SRC_ALPHA_SATURATE 0x0308
+#define GL_TRUE 1
+#define GL_FALSE 0
+#define GL_CLIP_PLANE0 0x3000
+#define GL_CLIP_PLANE1 0x3001
+#define GL_CLIP_PLANE2 0x3002
+#define GL_CLIP_PLANE3 0x3003
+#define GL_CLIP_PLANE4 0x3004
+#define GL_CLIP_PLANE5 0x3005
+#define GL_BYTE 0x1400
+#define GL_UNSIGNED_BYTE 0x1401
+#define GL_SHORT 0x1402
+#define GL_UNSIGNED_SHORT 0x1403
+#define GL_INT 0x1404
+#define GL_UNSIGNED_INT 0x1405
+#define GL_FLOAT 0x1406
+#define GL_2_BYTES 0x1407
+#define GL_3_BYTES 0x1408
+#define GL_4_BYTES 0x1409
+#define GL_DOUBLE 0x140A
+#define GL_NONE 0
+#define GL_FRONT_LEFT 0x0400
+#define GL_FRONT_RIGHT 0x0401
+#define GL_BACK_LEFT 0x0402
+#define GL_BACK_RIGHT 0x0403
+#define GL_FRONT 0x0404
+#define GL_BACK 0x0405
+#define GL_LEFT 0x0406
+#define GL_RIGHT 0x0407
+#define GL_FRONT_AND_BACK 0x0408
+#define GL_AUX0 0x0409
+#define GL_AUX1 0x040A
+#define GL_AUX2 0x040B
+#define GL_AUX3 0x040C
+#define GL_NO_ERROR 0
+#define GL_INVALID_ENUM 0x0500
+#define GL_INVALID_VALUE 0x0501
+#define GL_INVALID_OPERATION 0x0502
+#define GL_STACK_OVERFLOW 0x0503
+#define GL_STACK_UNDERFLOW 0x0504
+#define GL_OUT_OF_MEMORY 0x0505
+#define GL_2D 0x0600
+#define GL_3D 0x0601
+#define GL_3D_COLOR 0x0602
+#define GL_3D_COLOR_TEXTURE 0x0603
+#define GL_4D_COLOR_TEXTURE 0x0604
+#define GL_PASS_THROUGH_TOKEN 0x0700
+#define GL_POINT_TOKEN 0x0701
+#define GL_LINE_TOKEN 0x0702
+#define GL_POLYGON_TOKEN 0x0703
+#define GL_BITMAP_TOKEN 0x0704
+#define GL_DRAW_PIXEL_TOKEN 0x0705
+#define GL_COPY_PIXEL_TOKEN 0x0706
+#define GL_LINE_RESET_TOKEN 0x0707
+#define GL_EXP 0x0800
+#define GL_EXP2 0x0801
+#define GL_CW 0x0900
+#define GL_CCW 0x0901
+#define GL_COEFF 0x0A00
+#define GL_ORDER 0x0A01
+#define GL_DOMAIN 0x0A02
+#define GL_CURRENT_COLOR 0x0B00
+#define GL_CURRENT_INDEX 0x0B01
+#define GL_CURRENT_NORMAL 0x0B02
+#define GL_CURRENT_TEXTURE_COORDS 0x0B03
+#define GL_CURRENT_RASTER_COLOR 0x0B04
+#define GL_CURRENT_RASTER_INDEX 0x0B05
+#define GL_CURRENT_RASTER_TEXTURE_COORDS 0x0B06
+#define GL_CURRENT_RASTER_POSITION 0x0B07
+#define GL_CURRENT_RASTER_POSITION_VALID 0x0B08
+#define GL_CURRENT_RASTER_DISTANCE 0x0B09
+#define GL_POINT_SMOOTH 0x0B10
+#define GL_POINT_SIZE 0x0B11
+#define GL_POINT_SIZE_RANGE 0x0B12
+#define GL_POINT_SIZE_GRANULARITY 0x0B13
+#define GL_LINE_SMOOTH 0x0B20
+#define GL_LINE_WIDTH 0x0B21
+#define GL_LINE_WIDTH_RANGE 0x0B22
+#define GL_LINE_WIDTH_GRANULARITY 0x0B23
+#define GL_LINE_STIPPLE 0x0B24
+#define GL_LINE_STIPPLE_PATTERN 0x0B25
+#define GL_LINE_STIPPLE_REPEAT 0x0B26
+#define GL_LIST_MODE 0x0B30
+#define GL_MAX_LIST_NESTING 0x0B31
+#define GL_LIST_BASE 0x0B32
+#define GL_LIST_INDEX 0x0B33
+#define GL_POLYGON_MODE 0x0B40
+#define GL_POLYGON_SMOOTH 0x0B41
+#define GL_POLYGON_STIPPLE 0x0B42
+#define GL_EDGE_FLAG 0x0B43
+#define GL_CULL_FACE 0x0B44
+#define GL_CULL_FACE_MODE 0x0B45
+#define GL_FRONT_FACE 0x0B46
+#define GL_LIGHTING 0x0B50
+#define GL_LIGHT_MODEL_LOCAL_VIEWER 0x0B51
+#define GL_LIGHT_MODEL_TWO_SIDE 0x0B52
+#define GL_LIGHT_MODEL_AMBIENT 0x0B53
+#define GL_SHADE_MODEL 0x0B54
+#define GL_COLOR_MATERIAL_FACE 0x0B55
+#define GL_COLOR_MATERIAL_PARAMETER 0x0B56
+#define GL_COLOR_MATERIAL 0x0B57
+#define GL_FOG 0x0B60
+#define GL_FOG_INDEX 0x0B61
+#define GL_FOG_DENSITY 0x0B62
+#define GL_FOG_START 0x0B63
+#define GL_FOG_END 0x0B64
+#define GL_FOG_MODE 0x0B65
+#define GL_FOG_COLOR 0x0B66
+#define GL_DEPTH_RANGE 0x0B70
+#define GL_DEPTH_TEST 0x0B71
+#define GL_DEPTH_WRITEMASK 0x0B72
+#define GL_DEPTH_CLEAR_VALUE 0x0B73
+#define GL_DEPTH_FUNC 0x0B74
+#define GL_ACCUM_CLEAR_VALUE 0x0B80
+#define GL_STENCIL_TEST 0x0B90
+#define GL_STENCIL_CLEAR_VALUE 0x0B91
+#define GL_STENCIL_FUNC 0x0B92
+#define GL_STENCIL_VALUE_MASK 0x0B93
+#define GL_STENCIL_FAIL 0x0B94
+#define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
+#define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
+#define GL_STENCIL_REF 0x0B97
+#define GL_STENCIL_WRITEMASK 0x0B98
+#define GL_MATRIX_MODE 0x0BA0
+#define GL_NORMALIZE 0x0BA1
+#define GL_VIEWPORT 0x0BA2
+#define GL_MODELVIEW_STACK_DEPTH 0x0BA3
+#define GL_PROJECTION_STACK_DEPTH 0x0BA4
+#define GL_TEXTURE_STACK_DEPTH 0x0BA5
+#define GL_MODELVIEW_MATRIX 0x0BA6
+#define GL_PROJECTION_MATRIX 0x0BA7
+#define GL_TEXTURE_MATRIX 0x0BA8
+#define GL_ATTRIB_STACK_DEPTH 0x0BB0
+#define GL_CLIENT_ATTRIB_STACK_DEPTH 0x0BB1
+#define GL_ALPHA_TEST 0x0BC0
+#define GL_ALPHA_TEST_FUNC 0x0BC1
+#define GL_ALPHA_TEST_REF 0x0BC2
+#define GL_DITHER 0x0BD0
+#define GL_BLEND_DST 0x0BE0
+#define GL_BLEND_SRC 0x0BE1
+#define GL_BLEND 0x0BE2
+#define GL_LOGIC_OP_MODE 0x0BF0
+#define GL_INDEX_LOGIC_OP 0x0BF1
+#define GL_COLOR_LOGIC_OP 0x0BF2
+#define GL_AUX_BUFFERS 0x0C00
+#define GL_DRAW_BUFFER 0x0C01
+#define GL_READ_BUFFER 0x0C02
+#define GL_SCISSOR_BOX 0x0C10
+#define GL_SCISSOR_TEST 0x0C11
+#define GL_INDEX_CLEAR_VALUE 0x0C20
+#define GL_INDEX_WRITEMASK 0x0C21
+#define GL_COLOR_CLEAR_VALUE 0x0C22
+#define GL_COLOR_WRITEMASK 0x0C23
+#define GL_INDEX_MODE 0x0C30
+#define GL_RGBA_MODE 0x0C31
+#define GL_DOUBLEBUFFER 0x0C32
+#define GL_STEREO 0x0C33
+#define GL_RENDER_MODE 0x0C40
+#define GL_PERSPECTIVE_CORRECTION_HINT 0x0C50
+#define GL_POINT_SMOOTH_HINT 0x0C51
+#define GL_LINE_SMOOTH_HINT 0x0C52
+#define GL_POLYGON_SMOOTH_HINT 0x0C53
+#define GL_FOG_HINT 0x0C54
+#define GL_TEXTURE_GEN_S 0x0C60
+#define GL_TEXTURE_GEN_T 0x0C61
+#define GL_TEXTURE_GEN_R 0x0C62
+#define GL_TEXTURE_GEN_Q 0x0C63
+#define GL_PIXEL_MAP_I_TO_I 0x0C70
+#define GL_PIXEL_MAP_S_TO_S 0x0C71
+#define GL_PIXEL_MAP_I_TO_R 0x0C72
+#define GL_PIXEL_MAP_I_TO_G 0x0C73
+#define GL_PIXEL_MAP_I_TO_B 0x0C74
+#define GL_PIXEL_MAP_I_TO_A 0x0C75
+#define GL_PIXEL_MAP_R_TO_R 0x0C76
+#define GL_PIXEL_MAP_G_TO_G 0x0C77
+#define GL_PIXEL_MAP_B_TO_B 0x0C78
+#define GL_PIXEL_MAP_A_TO_A 0x0C79
+#define GL_PIXEL_MAP_I_TO_I_SIZE 0x0CB0
+#define GL_PIXEL_MAP_S_TO_S_SIZE 0x0CB1
+#define GL_PIXEL_MAP_I_TO_R_SIZE 0x0CB2
+#define GL_PIXEL_MAP_I_TO_G_SIZE 0x0CB3
+#define GL_PIXEL_MAP_I_TO_B_SIZE 0x0CB4
+#define GL_PIXEL_MAP_I_TO_A_SIZE 0x0CB5
+#define GL_PIXEL_MAP_R_TO_R_SIZE 0x0CB6
+#define GL_PIXEL_MAP_G_TO_G_SIZE 0x0CB7
+#define GL_PIXEL_MAP_B_TO_B_SIZE 0x0CB8
+#define GL_PIXEL_MAP_A_TO_A_SIZE 0x0CB9
+#define GL_UNPACK_SWAP_BYTES 0x0CF0
+#define GL_UNPACK_LSB_FIRST 0x0CF1
+#define GL_UNPACK_ROW_LENGTH 0x0CF2
+#define GL_UNPACK_SKIP_ROWS 0x0CF3
+#define GL_UNPACK_SKIP_PIXELS 0x0CF4
+#define GL_UNPACK_ALIGNMENT 0x0CF5
+#define GL_PACK_SWAP_BYTES 0x0D00
+#define GL_PACK_LSB_FIRST 0x0D01
+#define GL_PACK_ROW_LENGTH 0x0D02
+#define GL_PACK_SKIP_ROWS 0x0D03
+#define GL_PACK_SKIP_PIXELS 0x0D04
+#define GL_PACK_ALIGNMENT 0x0D05
+#define GL_MAP_COLOR 0x0D10
+#define GL_MAP_STENCIL 0x0D11
+#define GL_INDEX_SHIFT 0x0D12
+#define GL_INDEX_OFFSET 0x0D13
+#define GL_RED_SCALE 0x0D14
+#define GL_RED_BIAS 0x0D15
+#define GL_ZOOM_X 0x0D16
+#define GL_ZOOM_Y 0x0D17
+#define GL_GREEN_SCALE 0x0D18
+#define GL_GREEN_BIAS 0x0D19
+#define GL_BLUE_SCALE 0x0D1A
+#define GL_BLUE_BIAS 0x0D1B
+#define GL_ALPHA_SCALE 0x0D1C
+#define GL_ALPHA_BIAS 0x0D1D
+#define GL_DEPTH_SCALE 0x0D1E
+#define GL_DEPTH_BIAS 0x0D1F
+#define GL_MAX_EVAL_ORDER 0x0D30
+#define GL_MAX_LIGHTS 0x0D31
+#define GL_MAX_CLIP_PLANES 0x0D32
+#define GL_MAX_TEXTURE_SIZE 0x0D33
+#define GL_MAX_PIXEL_MAP_TABLE 0x0D34
+#define GL_MAX_ATTRIB_STACK_DEPTH 0x0D35
+#define GL_MAX_MODELVIEW_STACK_DEPTH 0x0D36
+#define GL_MAX_NAME_STACK_DEPTH 0x0D37
+#define GL_MAX_PROJECTION_STACK_DEPTH 0x0D38
+#define GL_MAX_TEXTURE_STACK_DEPTH 0x0D39
+#define GL_MAX_VIEWPORT_DIMS 0x0D3A
+#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH 0x0D3B
+#define GL_SUBPIXEL_BITS 0x0D50
+#define GL_INDEX_BITS 0x0D51
+#define GL_RED_BITS 0x0D52
+#define GL_GREEN_BITS 0x0D53
+#define GL_BLUE_BITS 0x0D54
+#define GL_ALPHA_BITS 0x0D55
+#define GL_DEPTH_BITS 0x0D56
+#define GL_STENCIL_BITS 0x0D57
+#define GL_ACCUM_RED_BITS 0x0D58
+#define GL_ACCUM_GREEN_BITS 0x0D59
+#define GL_ACCUM_BLUE_BITS 0x0D5A
+#define GL_ACCUM_ALPHA_BITS 0x0D5B
+#define GL_NAME_STACK_DEPTH 0x0D70
+#define GL_AUTO_NORMAL 0x0D80
+#define GL_MAP1_COLOR_4 0x0D90
+#define GL_MAP1_INDEX 0x0D91
+#define GL_MAP1_NORMAL 0x0D92
+#define GL_MAP1_TEXTURE_COORD_1 0x0D93
+#define GL_MAP1_TEXTURE_COORD_2 0x0D94
+#define GL_MAP1_TEXTURE_COORD_3 0x0D95
+#define GL_MAP1_TEXTURE_COORD_4 0x0D96
+#define GL_MAP1_VERTEX_3 0x0D97
+#define GL_MAP1_VERTEX_4 0x0D98
+#define GL_MAP2_COLOR_4 0x0DB0
+#define GL_MAP2_INDEX 0x0DB1
+#define GL_MAP2_NORMAL 0x0DB2
+#define GL_MAP2_TEXTURE_COORD_1 0x0DB3
+#define GL_MAP2_TEXTURE_COORD_2 0x0DB4
+#define GL_MAP2_TEXTURE_COORD_3 0x0DB5
+#define GL_MAP2_TEXTURE_COORD_4 0x0DB6
+#define GL_MAP2_VERTEX_3 0x0DB7
+#define GL_MAP2_VERTEX_4 0x0DB8
+#define GL_MAP1_GRID_DOMAIN 0x0DD0
+#define GL_MAP1_GRID_SEGMENTS 0x0DD1
+#define GL_MAP2_GRID_DOMAIN 0x0DD2
+#define GL_MAP2_GRID_SEGMENTS 0x0DD3
+#define GL_TEXTURE_1D 0x0DE0
+#define GL_TEXTURE_2D 0x0DE1
+#define GL_FEEDBACK_BUFFER_POINTER 0x0DF0
+#define GL_FEEDBACK_BUFFER_SIZE 0x0DF1
+#define GL_FEEDBACK_BUFFER_TYPE 0x0DF2
+#define GL_SELECTION_BUFFER_POINTER 0x0DF3
+#define GL_SELECTION_BUFFER_SIZE 0x0DF4
+#define GL_TEXTURE_WIDTH 0x1000
+#define GL_TEXTURE_HEIGHT 0x1001
+#define GL_TEXTURE_INTERNAL_FORMAT 0x1003
+#define GL_TEXTURE_BORDER_COLOR 0x1004
+#define GL_TEXTURE_BORDER 0x1005
+#define GL_DONT_CARE 0x1100
+#define GL_FASTEST 0x1101
+#define GL_NICEST 0x1102
+#define GL_LIGHT0 0x4000
+#define GL_LIGHT1 0x4001
+#define GL_LIGHT2 0x4002
+#define GL_LIGHT3 0x4003
+#define GL_LIGHT4 0x4004
+#define GL_LIGHT5 0x4005
+#define GL_LIGHT6 0x4006
+#define GL_LIGHT7 0x4007
+#define GL_AMBIENT 0x1200
+#define GL_DIFFUSE 0x1201
+#define GL_SPECULAR 0x1202
+#define GL_POSITION 0x1203
+#define GL_SPOT_DIRECTION 0x1204
+#define GL_SPOT_EXPONENT 0x1205
+#define GL_SPOT_CUTOFF 0x1206
+#define GL_CONSTANT_ATTENUATION 0x1207
+#define GL_LINEAR_ATTENUATION 0x1208
+#define GL_QUADRATIC_ATTENUATION 0x1209
+#define GL_COMPILE 0x1300
+#define GL_COMPILE_AND_EXECUTE 0x1301
+#define GL_CLEAR 0x1500
+#define GL_AND 0x1501
+#define GL_AND_REVERSE 0x1502
+#define GL_COPY 0x1503
+#define GL_AND_INVERTED 0x1504
+#define GL_NOOP 0x1505
+#define GL_XOR 0x1506
+#define GL_OR 0x1507
+#define GL_NOR 0x1508
+#define GL_EQUIV 0x1509
+#define GL_INVERT 0x150A
+#define GL_OR_REVERSE 0x150B
+#define GL_COPY_INVERTED 0x150C
+#define GL_OR_INVERTED 0x150D
+#define GL_NAND 0x150E
+#define GL_SET 0x150F
+#define GL_EMISSION 0x1600
+#define GL_SHININESS 0x1601
+#define GL_AMBIENT_AND_DIFFUSE 0x1602
+#define GL_COLOR_INDEXES 0x1603
+#define GL_MODELVIEW 0x1700
+#define GL_PROJECTION 0x1701
+#define GL_TEXTURE 0x1702
+#define GL_COLOR 0x1800
+#define GL_DEPTH 0x1801
+#define GL_STENCIL 0x1802
+#define GL_COLOR_INDEX 0x1900
+#define GL_STENCIL_INDEX 0x1901
+#define GL_DEPTH_COMPONENT 0x1902
+#define GL_RED 0x1903
+#define GL_GREEN 0x1904
+#define GL_BLUE 0x1905
+#define GL_ALPHA 0x1906
+#define GL_RGB 0x1907
+#define GL_RGBA 0x1908
+#define GL_LUMINANCE 0x1909
+#define GL_LUMINANCE_ALPHA 0x190A
+#define GL_BITMAP 0x1A00
+#define GL_POINT 0x1B00
+#define GL_LINE 0x1B01
+#define GL_FILL 0x1B02
+#define GL_RENDER 0x1C00
+#define GL_FEEDBACK 0x1C01
+#define GL_SELECT 0x1C02
+#define GL_FLAT 0x1D00
+#define GL_SMOOTH 0x1D01
+#define GL_KEEP 0x1E00
+#define GL_REPLACE 0x1E01
+#define GL_INCR 0x1E02
+#define GL_DECR 0x1E03
+#define GL_VENDOR 0x1F00
+#define GL_RENDERER 0x1F01
+#define GL_VERSION 0x1F02
+#define GL_EXTENSIONS 0x1F03
+#define GL_S 0x2000
+#define GL_T 0x2001
+#define GL_R 0x2002
+#define GL_Q 0x2003
+#define GL_MODULATE 0x2100
+#define GL_DECAL 0x2101
+#define GL_TEXTURE_ENV_MODE 0x2200
+#define GL_TEXTURE_ENV_COLOR 0x2201
+#define GL_TEXTURE_ENV 0x2300
+#define GL_EYE_LINEAR 0x2400
+#define GL_OBJECT_LINEAR 0x2401
+#define GL_SPHERE_MAP 0x2402
+#define GL_TEXTURE_GEN_MODE 0x2500
+#define GL_OBJECT_PLANE 0x2501
+#define GL_EYE_PLANE 0x2502
+#define GL_NEAREST 0x2600
+#define GL_LINEAR 0x2601
+#define GL_NEAREST_MIPMAP_NEAREST 0x2700
+#define GL_LINEAR_MIPMAP_NEAREST 0x2701
+#define GL_NEAREST_MIPMAP_LINEAR 0x2702
+#define GL_LINEAR_MIPMAP_LINEAR 0x2703
+#define GL_TEXTURE_MAG_FILTER 0x2800
+#define GL_TEXTURE_MIN_FILTER 0x2801
+#define GL_TEXTURE_WRAP_S 0x2802
+#define GL_TEXTURE_WRAP_T 0x2803
+#define GL_CLAMP 0x2900
+#define GL_REPEAT 0x2901
+#define GL_CLIENT_PIXEL_STORE_BIT 0x00000001
+#define GL_CLIENT_VERTEX_ARRAY_BIT 0x00000002
+#define GL_CLIENT_ALL_ATTRIB_BITS 0xffffffff
+#define GL_POLYGON_OFFSET_FACTOR 0x8038
+#define GL_POLYGON_OFFSET_UNITS 0x2A00
+#define GL_POLYGON_OFFSET_POINT 0x2A01
+#define GL_POLYGON_OFFSET_LINE 0x2A02
+#define GL_POLYGON_OFFSET_FILL 0x8037
+#define GL_ALPHA4 0x803B
+#define GL_ALPHA8 0x803C
+#define GL_ALPHA12 0x803D
+#define GL_ALPHA16 0x803E
+#define GL_LUMINANCE4 0x803F
+#define GL_LUMINANCE8 0x8040
+#define GL_LUMINANCE12 0x8041
+#define GL_LUMINANCE16 0x8042
+#define GL_LUMINANCE4_ALPHA4 0x8043
+#define GL_LUMINANCE6_ALPHA2 0x8044
+#define GL_LUMINANCE8_ALPHA8 0x8045
+#define GL_LUMINANCE12_ALPHA4 0x8046
+#define GL_LUMINANCE12_ALPHA12 0x8047
+#define GL_LUMINANCE16_ALPHA16 0x8048
+#define GL_INTENSITY 0x8049
+#define GL_INTENSITY4 0x804A
+#define GL_INTENSITY8 0x804B
+#define GL_INTENSITY12 0x804C
+#define GL_INTENSITY16 0x804D
+#define GL_R3_G3_B2 0x2A10
+#define GL_RGB4 0x804F
+#define GL_RGB5 0x8050
+#define GL_RGB8 0x8051
+#define GL_RGB10 0x8052
+#define GL_RGB12 0x8053
+#define GL_RGB16 0x8054
+#define GL_RGBA2 0x8055
+#define GL_RGBA4 0x8056
+#define GL_RGB5_A1 0x8057
+#define GL_RGBA8 0x8058
+#define GL_RGB10_A2 0x8059
+#define GL_RGBA12 0x805A
+#define GL_RGBA16 0x805B
+#define GL_TEXTURE_RED_SIZE 0x805C
+#define GL_TEXTURE_GREEN_SIZE 0x805D
+#define GL_TEXTURE_BLUE_SIZE 0x805E
+#define GL_TEXTURE_ALPHA_SIZE 0x805F
+#define GL_TEXTURE_LUMINANCE_SIZE 0x8060
+#define GL_TEXTURE_INTENSITY_SIZE 0x8061
+#define GL_PROXY_TEXTURE_1D 0x8063
+#define GL_PROXY_TEXTURE_2D 0x8064
+#define GL_TEXTURE_PRIORITY 0x8066
+#define GL_TEXTURE_RESIDENT 0x8067
+#define GL_TEXTURE_BINDING_1D 0x8068
+#define GL_TEXTURE_BINDING_2D 0x8069
+#define GL_VERTEX_ARRAY 0x8074
+#define GL_NORMAL_ARRAY 0x8075
+#define GL_COLOR_ARRAY 0x8076
+#define GL_INDEX_ARRAY 0x8077
+#define GL_TEXTURE_COORD_ARRAY 0x8078
+#define GL_EDGE_FLAG_ARRAY 0x8079
+#define GL_VERTEX_ARRAY_SIZE 0x807A
+#define GL_VERTEX_ARRAY_TYPE 0x807B
+#define GL_VERTEX_ARRAY_STRIDE 0x807C
+#define GL_NORMAL_ARRAY_TYPE 0x807E
+#define GL_NORMAL_ARRAY_STRIDE 0x807F
+#define GL_COLOR_ARRAY_SIZE 0x8081
+#define GL_COLOR_ARRAY_TYPE 0x8082
+#define GL_COLOR_ARRAY_STRIDE 0x8083
+#define GL_INDEX_ARRAY_TYPE 0x8085
+#define GL_INDEX_ARRAY_STRIDE 0x8086
+#define GL_TEXTURE_COORD_ARRAY_SIZE 0x8088
+#define GL_TEXTURE_COORD_ARRAY_TYPE 0x8089
+#define GL_TEXTURE_COORD_ARRAY_STRIDE 0x808A
+#define GL_EDGE_FLAG_ARRAY_STRIDE 0x808C
+#define GL_VERTEX_ARRAY_POINTER 0x808E
+#define GL_NORMAL_ARRAY_POINTER 0x808F
+#define GL_COLOR_ARRAY_POINTER 0x8090
+#define GL_INDEX_ARRAY_POINTER 0x8091
+#define GL_TEXTURE_COORD_ARRAY_POINTER 0x8092
+#define GL_EDGE_FLAG_ARRAY_POINTER 0x8093
+#define GL_V2F 0x2A20
+#define GL_V3F 0x2A21
+#define GL_C4UB_V2F 0x2A22
+#define GL_C4UB_V3F 0x2A23
+#define GL_C3F_V3F 0x2A24
+#define GL_N3F_V3F 0x2A25
+#define GL_C4F_N3F_V3F 0x2A26
+#define GL_T2F_V3F 0x2A27
+#define GL_T4F_V4F 0x2A28
+#define GL_T2F_C4UB_V3F 0x2A29
+#define GL_T2F_C3F_V3F 0x2A2A
+#define GL_T2F_N3F_V3F 0x2A2B
+#define GL_T2F_C4F_N3F_V3F 0x2A2C
+#define GL_T4F_C4F_N3F_V4F 0x2A2D
+#define GL_LOGIC_OP GL_INDEX_LOGIC_OP
+#define GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT
+#define GL_COLOR_INDEX1_EXT 0x80E2
+#define GL_COLOR_INDEX2_EXT 0x80E3
+#define GL_COLOR_INDEX4_EXT 0x80E4
+#define GL_COLOR_INDEX8_EXT 0x80E5
+#define GL_COLOR_INDEX12_EXT 0x80E6
+#define GL_COLOR_INDEX16_EXT 0x80E7
+
+    GLAPI void GLAPIENTRY glAccum(GLenum op, GLfloat value);
+    GLAPI void GLAPIENTRY glAlphaFunc(GLenum func, GLclampf ref);
+    GLAPI GLboolean GLAPIENTRY glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences);
+    GLAPI void GLAPIENTRY glArrayElement(GLint i);
+    GLAPI void GLAPIENTRY glBegin(GLenum mode);
+    GLAPI void GLAPIENTRY glBindTexture(GLenum target, GLuint texture);
+    GLAPI void GLAPIENTRY glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
+    GLAPI void GLAPIENTRY glBlendFunc(GLenum sfactor, GLenum dfactor);
+    GLAPI void GLAPIENTRY glCallList(GLuint list);
+    GLAPI void GLAPIENTRY glCallLists(GLsizei n, GLenum type, const GLvoid *lists);
+    GLAPI void GLAPIENTRY glClear(GLbitfield mask);
+    GLAPI void GLAPIENTRY glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+    GLAPI void GLAPIENTRY glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+    GLAPI void GLAPIENTRY glClearDepth(GLclampd depth);
+    GLAPI void GLAPIENTRY glClearIndex(GLfloat c);
+    GLAPI void GLAPIENTRY glClearStencil(GLint s);
+    GLAPI void GLAPIENTRY glClipPlane(GLenum plane, const GLdouble *equation);
+    GLAPI void GLAPIENTRY glColor3b(GLbyte red, GLbyte green, GLbyte blue);
+    GLAPI void GLAPIENTRY glColor3bv(const GLbyte *v);
+    GLAPI void GLAPIENTRY glColor3d(GLdouble red, GLdouble green, GLdouble blue);
+    GLAPI void GLAPIENTRY glColor3dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glColor3f(GLfloat red, GLfloat green, GLfloat blue);
+    GLAPI void GLAPIENTRY glColor3fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glColor3i(GLint red, GLint green, GLint blue);
+    GLAPI void GLAPIENTRY glColor3iv(const GLint *v);
+    GLAPI void GLAPIENTRY glColor3s(GLshort red, GLshort green, GLshort blue);
+    GLAPI void GLAPIENTRY glColor3sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glColor3ub(GLubyte red, GLubyte green, GLubyte blue);
+    GLAPI void GLAPIENTRY glColor3ubv(const GLubyte *v);
+    GLAPI void GLAPIENTRY glColor3ui(GLuint red, GLuint green, GLuint blue);
+    GLAPI void GLAPIENTRY glColor3uiv(const GLuint *v);
+    GLAPI void GLAPIENTRY glColor3us(GLushort red, GLushort green, GLushort blue);
+    GLAPI void GLAPIENTRY glColor3usv(const GLushort *v);
+    GLAPI void GLAPIENTRY glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
+    GLAPI void GLAPIENTRY glColor4bv(const GLbyte *v);
+    GLAPI void GLAPIENTRY glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
+    GLAPI void GLAPIENTRY glColor4dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+    GLAPI void GLAPIENTRY glColor4fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glColor4i(GLint red, GLint green, GLint blue, GLint alpha);
+    GLAPI void GLAPIENTRY glColor4iv(const GLint *v);
+    GLAPI void GLAPIENTRY glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);
+    GLAPI void GLAPIENTRY glColor4sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
+    GLAPI void GLAPIENTRY glColor4ubv(const GLubyte *v);
+    GLAPI void GLAPIENTRY glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);
+    GLAPI void GLAPIENTRY glColor4uiv(const GLuint *v);
+    GLAPI void GLAPIENTRY glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);
+    GLAPI void GLAPIENTRY glColor4usv(const GLushort *v);
+    GLAPI void GLAPIENTRY glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+    GLAPI void GLAPIENTRY glColorMaterial(GLenum face, GLenum mode);
+    GLAPI void GLAPIENTRY glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    GLAPI void GLAPIENTRY glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
+    GLAPI void GLAPIENTRY glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
+    GLAPI void GLAPIENTRY glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+    GLAPI void GLAPIENTRY glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
+    GLAPI void GLAPIENTRY glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+    GLAPI void GLAPIENTRY glCullFace(GLenum mode);
+    GLAPI void GLAPIENTRY glDeleteLists(GLuint list, GLsizei range);
+    GLAPI void GLAPIENTRY glDeleteTextures(GLsizei n, const GLuint *textures);
+    GLAPI void GLAPIENTRY glDepthFunc(GLenum func);
+    GLAPI void GLAPIENTRY glDepthMask(GLboolean flag);
+    GLAPI void GLAPIENTRY glDepthRange(GLclampd zNear, GLclampd zFar);
+    GLAPI void GLAPIENTRY glDisable(GLenum cap);
+    GLAPI void GLAPIENTRY glDisableClientState(GLenum array);
+    GLAPI void GLAPIENTRY glDrawArrays(GLenum mode, GLint first, GLsizei count);
+    GLAPI void GLAPIENTRY glDrawBuffer(GLenum mode);
+    GLAPI void GLAPIENTRY glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
+    GLAPI void GLAPIENTRY glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+    GLAPI void GLAPIENTRY glEdgeFlag(GLboolean flag);
+    GLAPI void GLAPIENTRY glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer);
+    GLAPI void GLAPIENTRY glEdgeFlagv(const GLboolean *flag);
+    GLAPI void GLAPIENTRY glEnable(GLenum cap);
+    GLAPI void GLAPIENTRY glEnableClientState(GLenum array);
+    GLAPI void GLAPIENTRY glEnd(void);
+    GLAPI void GLAPIENTRY glEndList(void);
+    GLAPI void GLAPIENTRY glEvalCoord1d(GLdouble u);
+    GLAPI void GLAPIENTRY glEvalCoord1dv(const GLdouble *u);
+    GLAPI void GLAPIENTRY glEvalCoord1f(GLfloat u);
+    GLAPI void GLAPIENTRY glEvalCoord1fv(const GLfloat *u);
+    GLAPI void GLAPIENTRY glEvalCoord2d(GLdouble u, GLdouble v);
+    GLAPI void GLAPIENTRY glEvalCoord2dv(const GLdouble *u);
+    GLAPI void GLAPIENTRY glEvalCoord2f(GLfloat u, GLfloat v);
+    GLAPI void GLAPIENTRY glEvalCoord2fv(const GLfloat *u);
+    GLAPI void GLAPIENTRY glEvalMesh1(GLenum mode, GLint i1, GLint i2);
+    GLAPI void GLAPIENTRY glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
+    GLAPI void GLAPIENTRY glEvalPoint1(GLint i);
+    GLAPI void GLAPIENTRY glEvalPoint2(GLint i, GLint j);
+    GLAPI void GLAPIENTRY glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer);
+    GLAPI void GLAPIENTRY glFinish(void);
+    GLAPI void GLAPIENTRY glFlush(void);
+    GLAPI void GLAPIENTRY glFogf(GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glFogfv(GLenum pname, const GLfloat *params);
+    GLAPI void GLAPIENTRY glFogi(GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glFogiv(GLenum pname, const GLint *params);
+    GLAPI void GLAPIENTRY glFrontFace(GLenum mode);
+    GLAPI void GLAPIENTRY glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
+    GLAPI GLuint GLAPIENTRY glGenLists(GLsizei range);
+    GLAPI void GLAPIENTRY glGenTextures(GLsizei n, GLuint *textures);
+    GLAPI void GLAPIENTRY glGetBooleanv(GLenum pname, GLboolean *params);
+    GLAPI void GLAPIENTRY glGetClipPlane(GLenum plane, GLdouble *equation);
+    GLAPI void GLAPIENTRY glGetDoublev(GLenum pname, GLdouble *params);
+    GLAPI GLenum GLAPIENTRY glGetError(void);
+    GLAPI void GLAPIENTRY glGetFloatv(GLenum pname, GLfloat *params);
+    GLAPI void GLAPIENTRY glGetIntegerv(GLenum pname, GLint *params);
+    GLAPI void GLAPIENTRY glGetLightfv(GLenum light, GLenum pname, GLfloat *params);
+    GLAPI void GLAPIENTRY glGetLightiv(GLenum light, GLenum pname, GLint *params);
+    GLAPI void GLAPIENTRY glGetMapdv(GLenum target, GLenum query, GLdouble *v);
+    GLAPI void GLAPIENTRY glGetMapfv(GLenum target, GLenum query, GLfloat *v);
+    GLAPI void GLAPIENTRY glGetMapiv(GLenum target, GLenum query, GLint *v);
+    GLAPI void GLAPIENTRY glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params);
+    GLAPI void GLAPIENTRY glGetMaterialiv(GLenum face, GLenum pname, GLint *params);
+    GLAPI void GLAPIENTRY glGetPixelMapfv(GLenum map, GLfloat *values);
+    GLAPI void GLAPIENTRY glGetPixelMapuiv(GLenum map, GLuint *values);
+    GLAPI void GLAPIENTRY glGetPixelMapusv(GLenum map, GLushort *values);
+    GLAPI void GLAPIENTRY glGetPointerv(GLenum pname, GLvoid* *params);
+    GLAPI void GLAPIENTRY glGetPolygonStipple(GLubyte *mask);
+    GLAPI const GLubyte *GLAPIENTRY glGetString(GLenum name);
+    GLAPI void GLAPIENTRY glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params);
+    GLAPI void GLAPIENTRY glGetTexEnviv(GLenum target, GLenum pname, GLint *params);
+    GLAPI void GLAPIENTRY glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params);
+    GLAPI void GLAPIENTRY glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params);
+    GLAPI void GLAPIENTRY glGetTexGeniv(GLenum coord, GLenum pname, GLint *params);
+    GLAPI void GLAPIENTRY glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
+    GLAPI void GLAPIENTRY glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params);
+    GLAPI void GLAPIENTRY glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params);
+    GLAPI void GLAPIENTRY glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params);
+    GLAPI void GLAPIENTRY glGetTexParameteriv(GLenum target, GLenum pname, GLint *params);
+    GLAPI void GLAPIENTRY glHint(GLenum target, GLenum mode);
+    GLAPI void GLAPIENTRY glIndexMask(GLuint mask);
+    GLAPI void GLAPIENTRY glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
+    GLAPI void GLAPIENTRY glIndexd(GLdouble c);
+    GLAPI void GLAPIENTRY glIndexdv(const GLdouble *c);
+    GLAPI void GLAPIENTRY glIndexf(GLfloat c);
+    GLAPI void GLAPIENTRY glIndexfv(const GLfloat *c);
+    GLAPI void GLAPIENTRY glIndexi(GLint c);
+    GLAPI void GLAPIENTRY glIndexiv(const GLint *c);
+    GLAPI void GLAPIENTRY glIndexs(GLshort c);
+    GLAPI void GLAPIENTRY glIndexsv(const GLshort *c);
+    GLAPI void GLAPIENTRY glIndexub(GLubyte c);
+    GLAPI void GLAPIENTRY glIndexubv(const GLubyte *c);
+    GLAPI void GLAPIENTRY glInitNames(void);
+    GLAPI void GLAPIENTRY glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer);
+    GLAPI GLboolean GLAPIENTRY glIsEnabled(GLenum cap);
+    GLAPI GLboolean GLAPIENTRY glIsList(GLuint list);
+    GLAPI GLboolean GLAPIENTRY glIsTexture(GLuint texture);
+    GLAPI void GLAPIENTRY glLightModelf(GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glLightModelfv(GLenum pname, const GLfloat *params);
+    GLAPI void GLAPIENTRY glLightModeli(GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glLightModeliv(GLenum pname, const GLint *params);
+    GLAPI void GLAPIENTRY glLightf(GLenum light, GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glLightfv(GLenum light, GLenum pname, const GLfloat *params);
+    GLAPI void GLAPIENTRY glLighti(GLenum light, GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glLightiv(GLenum light, GLenum pname, const GLint *params);
+    GLAPI void GLAPIENTRY glLineStipple(GLint factor, GLushort pattern);
+    GLAPI void GLAPIENTRY glLineWidth(GLfloat width);
+    GLAPI void GLAPIENTRY glListBase(GLuint base);
+    GLAPI void GLAPIENTRY glLoadIdentity(void);
+    GLAPI void GLAPIENTRY glLoadMatrixd(const GLdouble *m);
+    GLAPI void GLAPIENTRY glLoadMatrixf(const GLfloat *m);
+    GLAPI void GLAPIENTRY glLoadName(GLuint name);
+    GLAPI void GLAPIENTRY glLogicOp(GLenum opcode);
+    GLAPI void GLAPIENTRY glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
+    GLAPI void GLAPIENTRY glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
+    GLAPI void GLAPIENTRY glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
+    GLAPI void GLAPIENTRY glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
+    GLAPI void GLAPIENTRY glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);
+    GLAPI void GLAPIENTRY glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);
+    GLAPI void GLAPIENTRY glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
+    GLAPI void GLAPIENTRY glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
+    GLAPI void GLAPIENTRY glMaterialf(GLenum face, GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glMaterialfv(GLenum face, GLenum pname, const GLfloat *params);
+    GLAPI void GLAPIENTRY glMateriali(GLenum face, GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glMaterialiv(GLenum face, GLenum pname, const GLint *params);
+    GLAPI void GLAPIENTRY glMatrixMode(GLenum mode);
+    GLAPI void GLAPIENTRY glMultMatrixd(const GLdouble *m);
+    GLAPI void GLAPIENTRY glMultMatrixf(const GLfloat *m);
+    GLAPI void GLAPIENTRY glNewList(GLuint list, GLenum mode);
+    GLAPI void GLAPIENTRY glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);
+    GLAPI void GLAPIENTRY glNormal3bv(const GLbyte *v);
+    GLAPI void GLAPIENTRY glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);
+    GLAPI void GLAPIENTRY glNormal3dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
+    GLAPI void GLAPIENTRY glNormal3fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glNormal3i(GLint nx, GLint ny, GLint nz);
+    GLAPI void GLAPIENTRY glNormal3iv(const GLint *v);
+    GLAPI void GLAPIENTRY glNormal3s(GLshort nx, GLshort ny, GLshort nz);
+    GLAPI void GLAPIENTRY glNormal3sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
+    GLAPI void GLAPIENTRY glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
+    GLAPI void GLAPIENTRY glPassThrough(GLfloat token);
+    GLAPI void GLAPIENTRY glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values);
+    GLAPI void GLAPIENTRY glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values);
+    GLAPI void GLAPIENTRY glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values);
+    GLAPI void GLAPIENTRY glPixelStoref(GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glPixelStorei(GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glPixelTransferf(GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glPixelTransferi(GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glPixelZoom(GLfloat xfactor, GLfloat yfactor);
+    GLAPI void GLAPIENTRY glPointSize(GLfloat size);
+    GLAPI void GLAPIENTRY glPolygonMode(GLenum face, GLenum mode);
+    GLAPI void GLAPIENTRY glPolygonOffset(GLfloat factor, GLfloat units);
+    GLAPI void GLAPIENTRY glPolygonStipple(const GLubyte *mask);
+    GLAPI void GLAPIENTRY glPopAttrib(void);
+    GLAPI void GLAPIENTRY glPopClientAttrib(void);
+    GLAPI void GLAPIENTRY glPopMatrix(void);
+    GLAPI void GLAPIENTRY glPopName(void);
+    GLAPI void GLAPIENTRY glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities);
+    GLAPI void GLAPIENTRY glPushAttrib(GLbitfield mask);
+    GLAPI void GLAPIENTRY glPushClientAttrib(GLbitfield mask);
+    GLAPI void GLAPIENTRY glPushMatrix(void);
+    GLAPI void GLAPIENTRY glPushName(GLuint name);
+    GLAPI void GLAPIENTRY glRasterPos2d(GLdouble x, GLdouble y);
+    GLAPI void GLAPIENTRY glRasterPos2dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glRasterPos2f(GLfloat x, GLfloat y);
+    GLAPI void GLAPIENTRY glRasterPos2fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glRasterPos2i(GLint x, GLint y);
+    GLAPI void GLAPIENTRY glRasterPos2iv(const GLint *v);
+    GLAPI void GLAPIENTRY glRasterPos2s(GLshort x, GLshort y);
+    GLAPI void GLAPIENTRY glRasterPos2sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);
+    GLAPI void GLAPIENTRY glRasterPos3dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);
+    GLAPI void GLAPIENTRY glRasterPos3fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glRasterPos3i(GLint x, GLint y, GLint z);
+    GLAPI void GLAPIENTRY glRasterPos3iv(const GLint *v);
+    GLAPI void GLAPIENTRY glRasterPos3s(GLshort x, GLshort y, GLshort z);
+    GLAPI void GLAPIENTRY glRasterPos3sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    GLAPI void GLAPIENTRY glRasterPos4dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    GLAPI void GLAPIENTRY glRasterPos4fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glRasterPos4i(GLint x, GLint y, GLint z, GLint w);
+    GLAPI void GLAPIENTRY glRasterPos4iv(const GLint *v);
+    GLAPI void GLAPIENTRY glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);
+    GLAPI void GLAPIENTRY glRasterPos4sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glReadBuffer(GLenum mode);
+    GLAPI void GLAPIENTRY glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+    GLAPI void GLAPIENTRY glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
+    GLAPI void GLAPIENTRY glRectdv(const GLdouble *v1, const GLdouble *v2);
+    GLAPI void GLAPIENTRY glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
+    GLAPI void GLAPIENTRY glRectfv(const GLfloat *v1, const GLfloat *v2);
+    GLAPI void GLAPIENTRY glRecti(GLint x1, GLint y1, GLint x2, GLint y2);
+    GLAPI void GLAPIENTRY glRectiv(const GLint *v1, const GLint *v2);
+    GLAPI void GLAPIENTRY glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
+    GLAPI void GLAPIENTRY glRectsv(const GLshort *v1, const GLshort *v2);
+    GLAPI GLint GLAPIENTRY glRenderMode(GLenum mode);
+    GLAPI void GLAPIENTRY glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
+    GLAPI void GLAPIENTRY glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
+    GLAPI void GLAPIENTRY glScaled(GLdouble x, GLdouble y, GLdouble z);
+    GLAPI void GLAPIENTRY glScalef(GLfloat x, GLfloat y, GLfloat z);
+    GLAPI void GLAPIENTRY glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
+    GLAPI void GLAPIENTRY glSelectBuffer(GLsizei size, GLuint *buffer);
+    GLAPI void GLAPIENTRY glShadeModel(GLenum mode);
+    GLAPI void GLAPIENTRY glStencilFunc(GLenum func, GLint ref, GLuint mask);
+    GLAPI void GLAPIENTRY glStencilMask(GLuint mask);
+    GLAPI void GLAPIENTRY glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
+    GLAPI void GLAPIENTRY glTexCoord1d(GLdouble s);
+    GLAPI void GLAPIENTRY glTexCoord1dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glTexCoord1f(GLfloat s);
+    GLAPI void GLAPIENTRY glTexCoord1fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glTexCoord1i(GLint s);
+    GLAPI void GLAPIENTRY glTexCoord1iv(const GLint *v);
+    GLAPI void GLAPIENTRY glTexCoord1s(GLshort s);
+    GLAPI void GLAPIENTRY glTexCoord1sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glTexCoord2d(GLdouble s, GLdouble t);
+    GLAPI void GLAPIENTRY glTexCoord2dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glTexCoord2f(GLfloat s, GLfloat t);
+    GLAPI void GLAPIENTRY glTexCoord2fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glTexCoord2i(GLint s, GLint t);
+    GLAPI void GLAPIENTRY glTexCoord2iv(const GLint *v);
+    GLAPI void GLAPIENTRY glTexCoord2s(GLshort s, GLshort t);
+    GLAPI void GLAPIENTRY glTexCoord2sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);
+    GLAPI void GLAPIENTRY glTexCoord3dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);
+    GLAPI void GLAPIENTRY glTexCoord3fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glTexCoord3i(GLint s, GLint t, GLint r);
+    GLAPI void GLAPIENTRY glTexCoord3iv(const GLint *v);
+    GLAPI void GLAPIENTRY glTexCoord3s(GLshort s, GLshort t, GLshort r);
+    GLAPI void GLAPIENTRY glTexCoord3sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+    GLAPI void GLAPIENTRY glTexCoord4dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+    GLAPI void GLAPIENTRY glTexCoord4fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glTexCoord4i(GLint s, GLint t, GLint r, GLint q);
+    GLAPI void GLAPIENTRY glTexCoord4iv(const GLint *v);
+    GLAPI void GLAPIENTRY glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);
+    GLAPI void GLAPIENTRY glTexCoord4sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    GLAPI void GLAPIENTRY glTexEnvf(GLenum target, GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params);
+    GLAPI void GLAPIENTRY glTexEnvi(GLenum target, GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glTexEnviv(GLenum target, GLenum pname, const GLint *params);
+    GLAPI void GLAPIENTRY glTexGend(GLenum coord, GLenum pname, GLdouble param);
+    GLAPI void GLAPIENTRY glTexGendv(GLenum coord, GLenum pname, const GLdouble *params);
+    GLAPI void GLAPIENTRY glTexGenf(GLenum coord, GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params);
+    GLAPI void GLAPIENTRY glTexGeni(GLenum coord, GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glTexGeniv(GLenum coord, GLenum pname, const GLint *params);
+    GLAPI void GLAPIENTRY glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+    GLAPI void GLAPIENTRY glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+    GLAPI void GLAPIENTRY glTexParameterf(GLenum target, GLenum pname, GLfloat param);
+    GLAPI void GLAPIENTRY glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);
+    GLAPI void GLAPIENTRY glTexParameteri(GLenum target, GLenum pname, GLint param);
+    GLAPI void GLAPIENTRY glTexParameteriv(GLenum target, GLenum pname, const GLint *params);
+    GLAPI void GLAPIENTRY glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
+    GLAPI void GLAPIENTRY glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+    GLAPI void GLAPIENTRY glTranslated(GLdouble x, GLdouble y, GLdouble z);
+    GLAPI void GLAPIENTRY glTranslatef(GLfloat x, GLfloat y, GLfloat z);
+    GLAPI void GLAPIENTRY glVertex2d(GLdouble x, GLdouble y);
+    GLAPI void GLAPIENTRY glVertex2dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glVertex2f(GLfloat x, GLfloat y);
+    GLAPI void GLAPIENTRY glVertex2fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glVertex2i(GLint x, GLint y);
+    GLAPI void GLAPIENTRY glVertex2iv(const GLint *v);
+    GLAPI void GLAPIENTRY glVertex2s(GLshort x, GLshort y);
+    GLAPI void GLAPIENTRY glVertex2sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glVertex3d(GLdouble x, GLdouble y, GLdouble z);
+    GLAPI void GLAPIENTRY glVertex3dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glVertex3f(GLfloat x, GLfloat y, GLfloat z);
+    GLAPI void GLAPIENTRY glVertex3fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glVertex3i(GLint x, GLint y, GLint z);
+    GLAPI void GLAPIENTRY glVertex3iv(const GLint *v);
+    GLAPI void GLAPIENTRY glVertex3s(GLshort x, GLshort y, GLshort z);
+    GLAPI void GLAPIENTRY glVertex3sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    GLAPI void GLAPIENTRY glVertex4dv(const GLdouble *v);
+    GLAPI void GLAPIENTRY glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    GLAPI void GLAPIENTRY glVertex4fv(const GLfloat *v);
+    GLAPI void GLAPIENTRY glVertex4i(GLint x, GLint y, GLint z, GLint w);
+    GLAPI void GLAPIENTRY glVertex4iv(const GLint *v);
+    GLAPI void GLAPIENTRY glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);
+    GLAPI void GLAPIENTRY glVertex4sv(const GLshort *v);
+    GLAPI void GLAPIENTRY glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    GLAPI void GLAPIENTRY glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
+
+#define GLEW_VERSION_1_1 GLEW_GET_VAR(__GLEW_VERSION_1_1)
+
+#endif /* GL_VERSION_1_1 */
+
+    /* ---------------------------------- GLU ---------------------------------- */
+
+    /* this is where we can safely include GLU */
+#if defined(__APPLE__) && defined(__MACH__)
+#include <OpenGL/glu.h>
+#else
+#include <GL/glu.h>
+#endif
+
+    /* ----------------------------- GL_VERSION_1_2 ---------------------------- */
+
+#ifndef GL_VERSION_1_2
+#define GL_VERSION_1_2 1
+
+#define GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
+#define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
+#define GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
+#define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
+#define GL_UNSIGNED_BYTE_3_3_2 0x8032
+#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
+#define GL_UNSIGNED_INT_8_8_8_8 0x8035
+#define GL_UNSIGNED_INT_10_10_10_2 0x8036
+#define GL_RESCALE_NORMAL 0x803A
+#define GL_TEXTURE_BINDING_3D 0x806A
+#define GL_PACK_SKIP_IMAGES 0x806B
+#define GL_PACK_IMAGE_HEIGHT 0x806C
+#define GL_UNPACK_SKIP_IMAGES 0x806D
+#define GL_UNPACK_IMAGE_HEIGHT 0x806E
+#define GL_TEXTURE_3D 0x806F
+#define GL_PROXY_TEXTURE_3D 0x8070
+#define GL_TEXTURE_DEPTH 0x8071
+#define GL_TEXTURE_WRAP_R 0x8072
+#define GL_MAX_3D_TEXTURE_SIZE 0x8073
+#define GL_BGR 0x80E0
+#define GL_BGRA 0x80E1
+#define GL_MAX_ELEMENTS_VERTICES 0x80E8
+#define GL_MAX_ELEMENTS_INDICES 0x80E9
+#define GL_CLAMP_TO_EDGE 0x812F
+#define GL_TEXTURE_MIN_LOD 0x813A
+#define GL_TEXTURE_MAX_LOD 0x813B
+#define GL_TEXTURE_BASE_LEVEL 0x813C
+#define GL_TEXTURE_MAX_LEVEL 0x813D
+#define GL_LIGHT_MODEL_COLOR_CONTROL 0x81F8
+#define GL_SINGLE_COLOR 0x81F9
+#define GL_SEPARATE_SPECULAR_COLOR 0x81FA
+#define GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
+#define GL_UNSIGNED_SHORT_5_6_5 0x8363
+#define GL_UNSIGNED_SHORT_5_6_5_REV 0x8364
+#define GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
+#define GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
+#define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
+#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
+#define GL_ALIASED_POINT_SIZE_RANGE 0x846D
+#define GL_ALIASED_LINE_WIDTH_RANGE 0x846E
+
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
+    typedef void (GLAPIENTRY *PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+
+#define glCopyTexSubImage3D GLEW_GET_FUN(__glewCopyTexSubImage3D)
+#define glDrawRangeElements GLEW_GET_FUN(__glewDrawRangeElements)
+#define glTexImage3D GLEW_GET_FUN(__glewTexImage3D)
+#define glTexSubImage3D GLEW_GET_FUN(__glewTexSubImage3D)
+
+#define GLEW_VERSION_1_2 GLEW_GET_VAR(__GLEW_VERSION_1_2)
+
+#endif /* GL_VERSION_1_2 */
+
+    /* ----------------------------- GL_VERSION_1_3 ---------------------------- */
+
+#ifndef GL_VERSION_1_3
+#define GL_VERSION_1_3 1
+
+#define GL_MULTISAMPLE 0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE 0x809F
+#define GL_SAMPLE_COVERAGE 0x80A0
+#define GL_SAMPLE_BUFFERS 0x80A8
+#define GL_SAMPLES 0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE 0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT 0x80AB
+#define GL_CLAMP_TO_BORDER 0x812D
+#define GL_TEXTURE0 0x84C0
+#define GL_TEXTURE1 0x84C1
+#define GL_TEXTURE2 0x84C2
+#define GL_TEXTURE3 0x84C3
+#define GL_TEXTURE4 0x84C4
+#define GL_TEXTURE5 0x84C5
+#define GL_TEXTURE6 0x84C6
+#define GL_TEXTURE7 0x84C7
+#define GL_TEXTURE8 0x84C8
+#define GL_TEXTURE9 0x84C9
+#define GL_TEXTURE10 0x84CA
+#define GL_TEXTURE11 0x84CB
+#define GL_TEXTURE12 0x84CC
+#define GL_TEXTURE13 0x84CD
+#define GL_TEXTURE14 0x84CE
+#define GL_TEXTURE15 0x84CF
+#define GL_TEXTURE16 0x84D0
+#define GL_TEXTURE17 0x84D1
+#define GL_TEXTURE18 0x84D2
+#define GL_TEXTURE19 0x84D3
+#define GL_TEXTURE20 0x84D4
+#define GL_TEXTURE21 0x84D5
+#define GL_TEXTURE22 0x84D6
+#define GL_TEXTURE23 0x84D7
+#define GL_TEXTURE24 0x84D8
+#define GL_TEXTURE25 0x84D9
+#define GL_TEXTURE26 0x84DA
+#define GL_TEXTURE27 0x84DB
+#define GL_TEXTURE28 0x84DC
+#define GL_TEXTURE29 0x84DD
+#define GL_TEXTURE30 0x84DE
+#define GL_TEXTURE31 0x84DF
+#define GL_ACTIVE_TEXTURE 0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE 0x84E1
+#define GL_MAX_TEXTURE_UNITS 0x84E2
+#define GL_TRANSPOSE_MODELVIEW_MATRIX 0x84E3
+#define GL_TRANSPOSE_PROJECTION_MATRIX 0x84E4
+#define GL_TRANSPOSE_TEXTURE_MATRIX 0x84E5
+#define GL_TRANSPOSE_COLOR_MATRIX 0x84E6
+#define GL_SUBTRACT 0x84E7
+#define GL_COMPRESSED_ALPHA 0x84E9
+#define GL_COMPRESSED_LUMINANCE 0x84EA
+#define GL_COMPRESSED_LUMINANCE_ALPHA 0x84EB
+#define GL_COMPRESSED_INTENSITY 0x84EC
+#define GL_COMPRESSED_RGB 0x84ED
+#define GL_COMPRESSED_RGBA 0x84EE
+#define GL_TEXTURE_COMPRESSION_HINT 0x84EF
+#define GL_NORMAL_MAP 0x8511
+#define GL_REFLECTION_MAP 0x8512
+#define GL_TEXTURE_CUBE_MAP 0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP 0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP 0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
+#define GL_COMBINE 0x8570
+#define GL_COMBINE_RGB 0x8571
+#define GL_COMBINE_ALPHA 0x8572
+#define GL_RGB_SCALE 0x8573
+#define GL_ADD_SIGNED 0x8574
+#define GL_INTERPOLATE 0x8575
+#define GL_CONSTANT 0x8576
+#define GL_PRIMARY_COLOR 0x8577
+#define GL_PREVIOUS 0x8578
+#define GL_SOURCE0_RGB 0x8580
+#define GL_SOURCE1_RGB 0x8581
+#define GL_SOURCE2_RGB 0x8582
+#define GL_SOURCE0_ALPHA 0x8588
+#define GL_SOURCE1_ALPHA 0x8589
+#define GL_SOURCE2_ALPHA 0x858A
+#define GL_OPERAND0_RGB 0x8590
+#define GL_OPERAND1_RGB 0x8591
+#define GL_OPERAND2_RGB 0x8592
+#define GL_OPERAND0_ALPHA 0x8598
+#define GL_OPERAND1_ALPHA 0x8599
+#define GL_OPERAND2_ALPHA 0x859A
+#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
+#define GL_TEXTURE_COMPRESSED 0x86A1
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
+#define GL_DOT3_RGB 0x86AE
+#define GL_DOT3_RGBA 0x86AF
+#define GL_MULTISAMPLE_BIT 0x20000000
+
+    typedef void (GLAPIENTRY *PFNGLACTIVETEXTUREPROC)(GLenum texture);
+    typedef void (GLAPIENTRY *PFNGLCLIENTACTIVETEXTUREPROC)(GLenum texture);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint lod, GLvoid *img);
+    typedef void (GLAPIENTRY *PFNGLLOADTRANSPOSEMATRIXDPROC)(const GLdouble m[16]);
+    typedef void (GLAPIENTRY *PFNGLLOADTRANSPOSEMATRIXFPROC)(const GLfloat m[16]);
+    typedef void (GLAPIENTRY *PFNGLMULTTRANSPOSEMATRIXDPROC)(const GLdouble m[16]);
+    typedef void (GLAPIENTRY *PFNGLMULTTRANSPOSEMATRIXFPROC)(const GLfloat m[16]);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1DPROC)(GLenum target, GLdouble s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1DVPROC)(GLenum target, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1FPROC)(GLenum target, GLfloat s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1FVPROC)(GLenum target, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1IPROC)(GLenum target, GLint s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1IVPROC)(GLenum target, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1SPROC)(GLenum target, GLshort s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1SVPROC)(GLenum target, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2DPROC)(GLenum target, GLdouble s, GLdouble t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2DVPROC)(GLenum target, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2FPROC)(GLenum target, GLfloat s, GLfloat t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2FVPROC)(GLenum target, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2IPROC)(GLenum target, GLint s, GLint t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2IVPROC)(GLenum target, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2SPROC)(GLenum target, GLshort s, GLshort t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2SVPROC)(GLenum target, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3DPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3DVPROC)(GLenum target, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3FPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3FVPROC)(GLenum target, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3IPROC)(GLenum target, GLint s, GLint t, GLint r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3IVPROC)(GLenum target, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3SPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3SVPROC)(GLenum target, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4DPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4DVPROC)(GLenum target, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4FPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4FVPROC)(GLenum target, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4IPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4IVPROC)(GLenum target, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4SPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4SVPROC)(GLenum target, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLSAMPLECOVERAGEPROC)(GLclampf value, GLboolean invert);
+
+#define glActiveTexture GLEW_GET_FUN(__glewActiveTexture)
+#define glClientActiveTexture GLEW_GET_FUN(__glewClientActiveTexture)
+#define glCompressedTexImage1D GLEW_GET_FUN(__glewCompressedTexImage1D)
+#define glCompressedTexImage2D GLEW_GET_FUN(__glewCompressedTexImage2D)
+#define glCompressedTexImage3D GLEW_GET_FUN(__glewCompressedTexImage3D)
+#define glCompressedTexSubImage1D GLEW_GET_FUN(__glewCompressedTexSubImage1D)
+#define glCompressedTexSubImage2D GLEW_GET_FUN(__glewCompressedTexSubImage2D)
+#define glCompressedTexSubImage3D GLEW_GET_FUN(__glewCompressedTexSubImage3D)
+#define glGetCompressedTexImage GLEW_GET_FUN(__glewGetCompressedTexImage)
+#define glLoadTransposeMatrixd GLEW_GET_FUN(__glewLoadTransposeMatrixd)
+#define glLoadTransposeMatrixf GLEW_GET_FUN(__glewLoadTransposeMatrixf)
+#define glMultTransposeMatrixd GLEW_GET_FUN(__glewMultTransposeMatrixd)
+#define glMultTransposeMatrixf GLEW_GET_FUN(__glewMultTransposeMatrixf)
+#define glMultiTexCoord1d GLEW_GET_FUN(__glewMultiTexCoord1d)
+#define glMultiTexCoord1dv GLEW_GET_FUN(__glewMultiTexCoord1dv)
+#define glMultiTexCoord1f GLEW_GET_FUN(__glewMultiTexCoord1f)
+#define glMultiTexCoord1fv GLEW_GET_FUN(__glewMultiTexCoord1fv)
+#define glMultiTexCoord1i GLEW_GET_FUN(__glewMultiTexCoord1i)
+#define glMultiTexCoord1iv GLEW_GET_FUN(__glewMultiTexCoord1iv)
+#define glMultiTexCoord1s GLEW_GET_FUN(__glewMultiTexCoord1s)
+#define glMultiTexCoord1sv GLEW_GET_FUN(__glewMultiTexCoord1sv)
+#define glMultiTexCoord2d GLEW_GET_FUN(__glewMultiTexCoord2d)
+#define glMultiTexCoord2dv GLEW_GET_FUN(__glewMultiTexCoord2dv)
+#define glMultiTexCoord2f GLEW_GET_FUN(__glewMultiTexCoord2f)
+#define glMultiTexCoord2fv GLEW_GET_FUN(__glewMultiTexCoord2fv)
+#define glMultiTexCoord2i GLEW_GET_FUN(__glewMultiTexCoord2i)
+#define glMultiTexCoord2iv GLEW_GET_FUN(__glewMultiTexCoord2iv)
+#define glMultiTexCoord2s GLEW_GET_FUN(__glewMultiTexCoord2s)
+#define glMultiTexCoord2sv GLEW_GET_FUN(__glewMultiTexCoord2sv)
+#define glMultiTexCoord3d GLEW_GET_FUN(__glewMultiTexCoord3d)
+#define glMultiTexCoord3dv GLEW_GET_FUN(__glewMultiTexCoord3dv)
+#define glMultiTexCoord3f GLEW_GET_FUN(__glewMultiTexCoord3f)
+#define glMultiTexCoord3fv GLEW_GET_FUN(__glewMultiTexCoord3fv)
+#define glMultiTexCoord3i GLEW_GET_FUN(__glewMultiTexCoord3i)
+#define glMultiTexCoord3iv GLEW_GET_FUN(__glewMultiTexCoord3iv)
+#define glMultiTexCoord3s GLEW_GET_FUN(__glewMultiTexCoord3s)
+#define glMultiTexCoord3sv GLEW_GET_FUN(__glewMultiTexCoord3sv)
+#define glMultiTexCoord4d GLEW_GET_FUN(__glewMultiTexCoord4d)
+#define glMultiTexCoord4dv GLEW_GET_FUN(__glewMultiTexCoord4dv)
+#define glMultiTexCoord4f GLEW_GET_FUN(__glewMultiTexCoord4f)
+#define glMultiTexCoord4fv GLEW_GET_FUN(__glewMultiTexCoord4fv)
+#define glMultiTexCoord4i GLEW_GET_FUN(__glewMultiTexCoord4i)
+#define glMultiTexCoord4iv GLEW_GET_FUN(__glewMultiTexCoord4iv)
+#define glMultiTexCoord4s GLEW_GET_FUN(__glewMultiTexCoord4s)
+#define glMultiTexCoord4sv GLEW_GET_FUN(__glewMultiTexCoord4sv)
+#define glSampleCoverage GLEW_GET_FUN(__glewSampleCoverage)
+
+#define GLEW_VERSION_1_3 GLEW_GET_VAR(__GLEW_VERSION_1_3)
+
+#endif /* GL_VERSION_1_3 */
+
+    /* ----------------------------- GL_VERSION_1_4 ---------------------------- */
+
+#ifndef GL_VERSION_1_4
+#define GL_VERSION_1_4 1
+
+#define GL_BLEND_DST_RGB 0x80C8
+#define GL_BLEND_SRC_RGB 0x80C9
+#define GL_BLEND_DST_ALPHA 0x80CA
+#define GL_BLEND_SRC_ALPHA 0x80CB
+#define GL_POINT_SIZE_MIN 0x8126
+#define GL_POINT_SIZE_MAX 0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
+#define GL_POINT_DISTANCE_ATTENUATION 0x8129
+#define GL_GENERATE_MIPMAP 0x8191
+#define GL_GENERATE_MIPMAP_HINT 0x8192
+#define GL_DEPTH_COMPONENT16 0x81A5
+#define GL_DEPTH_COMPONENT24 0x81A6
+#define GL_DEPTH_COMPONENT32 0x81A7
+#define GL_MIRRORED_REPEAT 0x8370
+#define GL_FOG_COORDINATE_SOURCE 0x8450
+#define GL_FOG_COORDINATE 0x8451
+#define GL_FRAGMENT_DEPTH 0x8452
+#define GL_CURRENT_FOG_COORDINATE 0x8453
+#define GL_FOG_COORDINATE_ARRAY_TYPE 0x8454
+#define GL_FOG_COORDINATE_ARRAY_STRIDE 0x8455
+#define GL_FOG_COORDINATE_ARRAY_POINTER 0x8456
+#define GL_FOG_COORDINATE_ARRAY 0x8457
+#define GL_COLOR_SUM 0x8458
+#define GL_CURRENT_SECONDARY_COLOR 0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE 0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE 0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE 0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER 0x845D
+#define GL_SECONDARY_COLOR_ARRAY 0x845E
+#define GL_MAX_TEXTURE_LOD_BIAS 0x84FD
+#define GL_TEXTURE_FILTER_CONTROL 0x8500
+#define GL_TEXTURE_LOD_BIAS 0x8501
+#define GL_INCR_WRAP 0x8507
+#define GL_DECR_WRAP 0x8508
+#define GL_TEXTURE_DEPTH_SIZE 0x884A
+#define GL_DEPTH_TEXTURE_MODE 0x884B
+#define GL_TEXTURE_COMPARE_MODE 0x884C
+#define GL_TEXTURE_COMPARE_FUNC 0x884D
+#define GL_COMPARE_R_TO_TEXTURE 0x884E
+
+    typedef void (GLAPIENTRY *PFNGLBLENDCOLORPROC)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONPROC)(GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDPOINTERPROC)(GLenum type, GLsizei stride, const GLvoid *pointer);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDDPROC)(GLdouble coord);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDDVPROC)(const GLdouble *coord);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDFPROC)(GLfloat coord);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDFVPROC)(const GLfloat *coord);
+    typedef void (GLAPIENTRY *PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
+    typedef void (GLAPIENTRY *PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount);
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERFVPROC)(GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERIVPROC)(GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3BPROC)(GLbyte red, GLbyte green, GLbyte blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3BVPROC)(const GLbyte *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3DPROC)(GLdouble red, GLdouble green, GLdouble blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3DVPROC)(const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3FPROC)(GLfloat red, GLfloat green, GLfloat blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3FVPROC)(const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3IPROC)(GLint red, GLint green, GLint blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3IVPROC)(const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3SPROC)(GLshort red, GLshort green, GLshort blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3SVPROC)(const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3UBPROC)(GLubyte red, GLubyte green, GLubyte blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3UBVPROC)(const GLubyte *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3UIPROC)(GLuint red, GLuint green, GLuint blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3UIVPROC)(const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3USPROC)(GLushort red, GLushort green, GLushort blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3USVPROC)(const GLushort *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLORPOINTERPROC)(GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2DPROC)(GLdouble x, GLdouble y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2DVPROC)(const GLdouble *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2FPROC)(GLfloat x, GLfloat y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2FVPROC)(const GLfloat *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2IPROC)(GLint x, GLint y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2IVPROC)(const GLint *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2SPROC)(GLshort x, GLshort y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2SVPROC)(const GLshort *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3DPROC)(GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3DVPROC)(const GLdouble *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3FPROC)(GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3FVPROC)(const GLfloat *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3IPROC)(GLint x, GLint y, GLint z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3IVPROC)(const GLint *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3SPROC)(GLshort x, GLshort y, GLshort z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3SVPROC)(const GLshort *p);
+
+#define glBlendColor GLEW_GET_FUN(__glewBlendColor)
+#define glBlendEquation GLEW_GET_FUN(__glewBlendEquation)
+#define glBlendFuncSeparate GLEW_GET_FUN(__glewBlendFuncSeparate)
+#define glFogCoordPointer GLEW_GET_FUN(__glewFogCoordPointer)
+#define glFogCoordd GLEW_GET_FUN(__glewFogCoordd)
+#define glFogCoorddv GLEW_GET_FUN(__glewFogCoorddv)
+#define glFogCoordf GLEW_GET_FUN(__glewFogCoordf)
+#define glFogCoordfv GLEW_GET_FUN(__glewFogCoordfv)
+#define glMultiDrawArrays GLEW_GET_FUN(__glewMultiDrawArrays)
+#define glMultiDrawElements GLEW_GET_FUN(__glewMultiDrawElements)
+#define glPointParameterf GLEW_GET_FUN(__glewPointParameterf)
+#define glPointParameterfv GLEW_GET_FUN(__glewPointParameterfv)
+#define glPointParameteri GLEW_GET_FUN(__glewPointParameteri)
+#define glPointParameteriv GLEW_GET_FUN(__glewPointParameteriv)
+#define glSecondaryColor3b GLEW_GET_FUN(__glewSecondaryColor3b)
+#define glSecondaryColor3bv GLEW_GET_FUN(__glewSecondaryColor3bv)
+#define glSecondaryColor3d GLEW_GET_FUN(__glewSecondaryColor3d)
+#define glSecondaryColor3dv GLEW_GET_FUN(__glewSecondaryColor3dv)
+#define glSecondaryColor3f GLEW_GET_FUN(__glewSecondaryColor3f)
+#define glSecondaryColor3fv GLEW_GET_FUN(__glewSecondaryColor3fv)
+#define glSecondaryColor3i GLEW_GET_FUN(__glewSecondaryColor3i)
+#define glSecondaryColor3iv GLEW_GET_FUN(__glewSecondaryColor3iv)
+#define glSecondaryColor3s GLEW_GET_FUN(__glewSecondaryColor3s)
+#define glSecondaryColor3sv GLEW_GET_FUN(__glewSecondaryColor3sv)
+#define glSecondaryColor3ub GLEW_GET_FUN(__glewSecondaryColor3ub)
+#define glSecondaryColor3ubv GLEW_GET_FUN(__glewSecondaryColor3ubv)
+#define glSecondaryColor3ui GLEW_GET_FUN(__glewSecondaryColor3ui)
+#define glSecondaryColor3uiv GLEW_GET_FUN(__glewSecondaryColor3uiv)
+#define glSecondaryColor3us GLEW_GET_FUN(__glewSecondaryColor3us)
+#define glSecondaryColor3usv GLEW_GET_FUN(__glewSecondaryColor3usv)
+#define glSecondaryColorPointer GLEW_GET_FUN(__glewSecondaryColorPointer)
+#define glWindowPos2d GLEW_GET_FUN(__glewWindowPos2d)
+#define glWindowPos2dv GLEW_GET_FUN(__glewWindowPos2dv)
+#define glWindowPos2f GLEW_GET_FUN(__glewWindowPos2f)
+#define glWindowPos2fv GLEW_GET_FUN(__glewWindowPos2fv)
+#define glWindowPos2i GLEW_GET_FUN(__glewWindowPos2i)
+#define glWindowPos2iv GLEW_GET_FUN(__glewWindowPos2iv)
+#define glWindowPos2s GLEW_GET_FUN(__glewWindowPos2s)
+#define glWindowPos2sv GLEW_GET_FUN(__glewWindowPos2sv)
+#define glWindowPos3d GLEW_GET_FUN(__glewWindowPos3d)
+#define glWindowPos3dv GLEW_GET_FUN(__glewWindowPos3dv)
+#define glWindowPos3f GLEW_GET_FUN(__glewWindowPos3f)
+#define glWindowPos3fv GLEW_GET_FUN(__glewWindowPos3fv)
+#define glWindowPos3i GLEW_GET_FUN(__glewWindowPos3i)
+#define glWindowPos3iv GLEW_GET_FUN(__glewWindowPos3iv)
+#define glWindowPos3s GLEW_GET_FUN(__glewWindowPos3s)
+#define glWindowPos3sv GLEW_GET_FUN(__glewWindowPos3sv)
+
+#define GLEW_VERSION_1_4 GLEW_GET_VAR(__GLEW_VERSION_1_4)
+
+#endif /* GL_VERSION_1_4 */
+
+    /* ----------------------------- GL_VERSION_1_5 ---------------------------- */
+
+#ifndef GL_VERSION_1_5
+#define GL_VERSION_1_5 1
+
+#define GL_FOG_COORD_SRC GL_FOG_COORDINATE_SOURCE
+#define GL_FOG_COORD GL_FOG_COORDINATE
+#define GL_FOG_COORD_ARRAY GL_FOG_COORDINATE_ARRAY
+#define GL_SRC0_RGB GL_SOURCE0_RGB
+#define GL_FOG_COORD_ARRAY_POINTER GL_FOG_COORDINATE_ARRAY_POINTER
+#define GL_FOG_COORD_ARRAY_TYPE GL_FOG_COORDINATE_ARRAY_TYPE
+#define GL_SRC1_ALPHA GL_SOURCE1_ALPHA
+#define GL_CURRENT_FOG_COORD GL_CURRENT_FOG_COORDINATE
+#define GL_FOG_COORD_ARRAY_STRIDE GL_FOG_COORDINATE_ARRAY_STRIDE
+#define GL_SRC0_ALPHA GL_SOURCE0_ALPHA
+#define GL_SRC1_RGB GL_SOURCE1_RGB
+#define GL_FOG_COORD_ARRAY_BUFFER_BINDING GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING
+#define GL_SRC2_ALPHA GL_SOURCE2_ALPHA
+#define GL_SRC2_RGB GL_SOURCE2_RGB
+#define GL_BUFFER_SIZE 0x8764
+#define GL_BUFFER_USAGE 0x8765
+#define GL_QUERY_COUNTER_BITS 0x8864
+#define GL_CURRENT_QUERY 0x8865
+#define GL_QUERY_RESULT 0x8866
+#define GL_QUERY_RESULT_AVAILABLE 0x8867
+#define GL_ARRAY_BUFFER 0x8892
+#define GL_ELEMENT_ARRAY_BUFFER 0x8893
+#define GL_ARRAY_BUFFER_BINDING 0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING 0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING 0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING 0x8898
+#define GL_INDEX_ARRAY_BUFFER_BINDING 0x8899
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING 0x889A
+#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING 0x889B
+#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING 0x889C
+#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING 0x889D
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING 0x889E
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
+#define GL_READ_ONLY 0x88B8
+#define GL_WRITE_ONLY 0x88B9
+#define GL_READ_WRITE 0x88BA
+#define GL_BUFFER_ACCESS 0x88BB
+#define GL_BUFFER_MAPPED 0x88BC
+#define GL_BUFFER_MAP_POINTER 0x88BD
+#define GL_STREAM_DRAW 0x88E0
+#define GL_STREAM_READ 0x88E1
+#define GL_STREAM_COPY 0x88E2
+#define GL_STATIC_DRAW 0x88E4
+#define GL_STATIC_READ 0x88E5
+#define GL_STATIC_COPY 0x88E6
+#define GL_DYNAMIC_DRAW 0x88E8
+#define GL_DYNAMIC_READ 0x88E9
+#define GL_DYNAMIC_COPY 0x88EA
+#define GL_SAMPLES_PASSED 0x8914
+
+    typedef ptrdiff_t GLsizeiptr;
+    typedef ptrdiff_t GLintptr;
+
+    typedef void (GLAPIENTRY *PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
+    typedef void (GLAPIENTRY *PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint *buffers);
+    typedef void (GLAPIENTRY *PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLENDQUERYPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLGENBUFFERSPROC)(GLsizei n, GLuint *buffers);
+    typedef void (GLAPIENTRY *PFNGLGENQUERIESPROC)(GLsizei n, GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, GLvoid **params);
+    typedef void (GLAPIENTRY *PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISBUFFERPROC)(GLuint buffer);
+    typedef GLboolean(GLAPIENTRY *PFNGLISQUERYPROC)(GLuint id);
+    typedef GLvoid *(GLAPIENTRY *PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
+    typedef GLboolean(GLAPIENTRY *PFNGLUNMAPBUFFERPROC)(GLenum target);
+
+#define glBeginQuery GLEW_GET_FUN(__glewBeginQuery)
+#define glBindBuffer GLEW_GET_FUN(__glewBindBuffer)
+#define glBufferData GLEW_GET_FUN(__glewBufferData)
+#define glBufferSubData GLEW_GET_FUN(__glewBufferSubData)
+#define glDeleteBuffers GLEW_GET_FUN(__glewDeleteBuffers)
+#define glDeleteQueries GLEW_GET_FUN(__glewDeleteQueries)
+#define glEndQuery GLEW_GET_FUN(__glewEndQuery)
+#define glGenBuffers GLEW_GET_FUN(__glewGenBuffers)
+#define glGenQueries GLEW_GET_FUN(__glewGenQueries)
+#define glGetBufferParameteriv GLEW_GET_FUN(__glewGetBufferParameteriv)
+#define glGetBufferPointerv GLEW_GET_FUN(__glewGetBufferPointerv)
+#define glGetBufferSubData GLEW_GET_FUN(__glewGetBufferSubData)
+#define glGetQueryObjectiv GLEW_GET_FUN(__glewGetQueryObjectiv)
+#define glGetQueryObjectuiv GLEW_GET_FUN(__glewGetQueryObjectuiv)
+#define glGetQueryiv GLEW_GET_FUN(__glewGetQueryiv)
+#define glIsBuffer GLEW_GET_FUN(__glewIsBuffer)
+#define glIsQuery GLEW_GET_FUN(__glewIsQuery)
+#define glMapBuffer GLEW_GET_FUN(__glewMapBuffer)
+#define glUnmapBuffer GLEW_GET_FUN(__glewUnmapBuffer)
+
+#define GLEW_VERSION_1_5 GLEW_GET_VAR(__GLEW_VERSION_1_5)
+
+#endif /* GL_VERSION_1_5 */
+
+    /* ----------------------------- GL_VERSION_2_0 ---------------------------- */
+
+#ifndef GL_VERSION_2_0
+#define GL_VERSION_2_0 1
+
+#define GL_BLEND_EQUATION_RGB GL_BLEND_EQUATION
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
+#define GL_CURRENT_VERTEX_ATTRIB 0x8626
+#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE 0x8643
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
+#define GL_STENCIL_BACK_FUNC 0x8800
+#define GL_STENCIL_BACK_FAIL 0x8801
+#define GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
+#define GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
+#define GL_MAX_DRAW_BUFFERS 0x8824
+#define GL_DRAW_BUFFER0 0x8825
+#define GL_DRAW_BUFFER1 0x8826
+#define GL_DRAW_BUFFER2 0x8827
+#define GL_DRAW_BUFFER3 0x8828
+#define GL_DRAW_BUFFER4 0x8829
+#define GL_DRAW_BUFFER5 0x882A
+#define GL_DRAW_BUFFER6 0x882B
+#define GL_DRAW_BUFFER7 0x882C
+#define GL_DRAW_BUFFER8 0x882D
+#define GL_DRAW_BUFFER9 0x882E
+#define GL_DRAW_BUFFER10 0x882F
+#define GL_DRAW_BUFFER11 0x8830
+#define GL_DRAW_BUFFER12 0x8831
+#define GL_DRAW_BUFFER13 0x8832
+#define GL_DRAW_BUFFER14 0x8833
+#define GL_DRAW_BUFFER15 0x8834
+#define GL_BLEND_EQUATION_ALPHA 0x883D
+#define GL_POINT_SPRITE 0x8861
+#define GL_COORD_REPLACE 0x8862
+#define GL_MAX_VERTEX_ATTRIBS 0x8869
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
+#define GL_MAX_TEXTURE_COORDS 0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
+#define GL_FRAGMENT_SHADER 0x8B30
+#define GL_VERTEX_SHADER 0x8B31
+#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
+#define GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
+#define GL_MAX_VARYING_FLOATS 0x8B4B
+#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
+#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
+#define GL_SHADER_TYPE 0x8B4F
+#define GL_FLOAT_VEC2 0x8B50
+#define GL_FLOAT_VEC3 0x8B51
+#define GL_FLOAT_VEC4 0x8B52
+#define GL_INT_VEC2 0x8B53
+#define GL_INT_VEC3 0x8B54
+#define GL_INT_VEC4 0x8B55
+#define GL_BOOL 0x8B56
+#define GL_BOOL_VEC2 0x8B57
+#define GL_BOOL_VEC3 0x8B58
+#define GL_BOOL_VEC4 0x8B59
+#define GL_FLOAT_MAT2 0x8B5A
+#define GL_FLOAT_MAT3 0x8B5B
+#define GL_FLOAT_MAT4 0x8B5C
+#define GL_SAMPLER_1D 0x8B5D
+#define GL_SAMPLER_2D 0x8B5E
+#define GL_SAMPLER_3D 0x8B5F
+#define GL_SAMPLER_CUBE 0x8B60
+#define GL_SAMPLER_1D_SHADOW 0x8B61
+#define GL_SAMPLER_2D_SHADOW 0x8B62
+#define GL_DELETE_STATUS 0x8B80
+#define GL_COMPILE_STATUS 0x8B81
+#define GL_LINK_STATUS 0x8B82
+#define GL_VALIDATE_STATUS 0x8B83
+#define GL_INFO_LOG_LENGTH 0x8B84
+#define GL_ATTACHED_SHADERS 0x8B85
+#define GL_ACTIVE_UNIFORMS 0x8B86
+#define GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
+#define GL_SHADER_SOURCE_LENGTH 0x8B88
+#define GL_ACTIVE_ATTRIBUTES 0x8B89
+#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
+#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
+#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
+#define GL_CURRENT_PROGRAM 0x8B8D
+#define GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
+#define GL_LOWER_LEFT 0x8CA1
+#define GL_UPPER_LEFT 0x8CA2
+#define GL_STENCIL_BACK_REF 0x8CA3
+#define GL_STENCIL_BACK_VALUE_MASK 0x8CA4
+#define GL_STENCIL_BACK_WRITEMASK 0x8CA5
+
+    typedef char GLchar;
+
+    typedef void (GLAPIENTRY *PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
+    typedef void (GLAPIENTRY *PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum, GLenum);
+    typedef void (GLAPIENTRY *PFNGLCOMPILESHADERPROC)(GLuint shader);
+    typedef GLuint(GLAPIENTRY *PFNGLCREATEPROGRAMPROC)(void);
+    typedef GLuint(GLAPIENTRY *PFNGLCREATESHADERPROC)(GLenum type);
+    typedef void (GLAPIENTRY *PFNGLDELETEPROGRAMPROC)(GLuint program);
+    typedef void (GLAPIENTRY *PFNGLDELETESHADERPROC)(GLuint shader);
+    typedef void (GLAPIENTRY *PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
+    typedef void (GLAPIENTRY *PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint);
+    typedef void (GLAPIENTRY *PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum *bufs);
+    typedef void (GLAPIENTRY *PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
+    typedef GLint(GLAPIENTRY *PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint *param);
+    typedef void (GLAPIENTRY *PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
+    typedef void (GLAPIENTRY *PFNGLGETSHADERSOURCEPROC)(GLint obj, GLsizei maxLength, GLsizei *length, GLchar *source);
+    typedef void (GLAPIENTRY *PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint *param);
+    typedef GLint(GLAPIENTRY *PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint, GLenum, GLvoid *);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBDVPROC)(GLuint, GLenum, GLdouble *);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBFVPROC)(GLuint, GLenum, GLfloat *);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBIVPROC)(GLuint, GLenum, GLint *);
+    typedef GLboolean(GLAPIENTRY *PFNGLISPROGRAMPROC)(GLuint program);
+    typedef GLboolean(GLAPIENTRY *PFNGLISSHADERPROC)(GLuint shader);
+    typedef void (GLAPIENTRY *PFNGLLINKPROGRAMPROC)(GLuint program);
+    typedef void (GLAPIENTRY *PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar **strings, const GLint *lengths);
+    typedef void (GLAPIENTRY *PFNGLSTENCILFUNCSEPARATEPROC)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
+    typedef void (GLAPIENTRY *PFNGLSTENCILMASKSEPARATEPROC)(GLenum, GLuint);
+    typedef void (GLAPIENTRY *PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUSEPROGRAMPROC)(GLuint program);
+    typedef void (GLAPIENTRY *PFNGLVALIDATEPROGRAMPROC)(GLuint program);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+
+#define glAttachShader GLEW_GET_FUN(__glewAttachShader)
+#define glBindAttribLocation GLEW_GET_FUN(__glewBindAttribLocation)
+#define glBlendEquationSeparate GLEW_GET_FUN(__glewBlendEquationSeparate)
+#define glCompileShader GLEW_GET_FUN(__glewCompileShader)
+#define glCreateProgram GLEW_GET_FUN(__glewCreateProgram)
+#define glCreateShader GLEW_GET_FUN(__glewCreateShader)
+#define glDeleteProgram GLEW_GET_FUN(__glewDeleteProgram)
+#define glDeleteShader GLEW_GET_FUN(__glewDeleteShader)
+#define glDetachShader GLEW_GET_FUN(__glewDetachShader)
+#define glDisableVertexAttribArray GLEW_GET_FUN(__glewDisableVertexAttribArray)
+#define glDrawBuffers GLEW_GET_FUN(__glewDrawBuffers)
+#define glEnableVertexAttribArray GLEW_GET_FUN(__glewEnableVertexAttribArray)
+#define glGetActiveAttrib GLEW_GET_FUN(__glewGetActiveAttrib)
+#define glGetActiveUniform GLEW_GET_FUN(__glewGetActiveUniform)
+#define glGetAttachedShaders GLEW_GET_FUN(__glewGetAttachedShaders)
+#define glGetAttribLocation GLEW_GET_FUN(__glewGetAttribLocation)
+#define glGetProgramInfoLog GLEW_GET_FUN(__glewGetProgramInfoLog)
+#define glGetProgramiv GLEW_GET_FUN(__glewGetProgramiv)
+#define glGetShaderInfoLog GLEW_GET_FUN(__glewGetShaderInfoLog)
+#define glGetShaderSource GLEW_GET_FUN(__glewGetShaderSource)
+#define glGetShaderiv GLEW_GET_FUN(__glewGetShaderiv)
+#define glGetUniformLocation GLEW_GET_FUN(__glewGetUniformLocation)
+#define glGetUniformfv GLEW_GET_FUN(__glewGetUniformfv)
+#define glGetUniformiv GLEW_GET_FUN(__glewGetUniformiv)
+#define glGetVertexAttribPointerv GLEW_GET_FUN(__glewGetVertexAttribPointerv)
+#define glGetVertexAttribdv GLEW_GET_FUN(__glewGetVertexAttribdv)
+#define glGetVertexAttribfv GLEW_GET_FUN(__glewGetVertexAttribfv)
+#define glGetVertexAttribiv GLEW_GET_FUN(__glewGetVertexAttribiv)
+#define glIsProgram GLEW_GET_FUN(__glewIsProgram)
+#define glIsShader GLEW_GET_FUN(__glewIsShader)
+#define glLinkProgram GLEW_GET_FUN(__glewLinkProgram)
+#define glShaderSource GLEW_GET_FUN(__glewShaderSource)
+#define glStencilFuncSeparate GLEW_GET_FUN(__glewStencilFuncSeparate)
+#define glStencilMaskSeparate GLEW_GET_FUN(__glewStencilMaskSeparate)
+#define glStencilOpSeparate GLEW_GET_FUN(__glewStencilOpSeparate)
+#define glUniform1f GLEW_GET_FUN(__glewUniform1f)
+#define glUniform1fv GLEW_GET_FUN(__glewUniform1fv)
+#define glUniform1i GLEW_GET_FUN(__glewUniform1i)
+#define glUniform1iv GLEW_GET_FUN(__glewUniform1iv)
+#define glUniform2f GLEW_GET_FUN(__glewUniform2f)
+#define glUniform2fv GLEW_GET_FUN(__glewUniform2fv)
+#define glUniform2i GLEW_GET_FUN(__glewUniform2i)
+#define glUniform2iv GLEW_GET_FUN(__glewUniform2iv)
+#define glUniform3f GLEW_GET_FUN(__glewUniform3f)
+#define glUniform3fv GLEW_GET_FUN(__glewUniform3fv)
+#define glUniform3i GLEW_GET_FUN(__glewUniform3i)
+#define glUniform3iv GLEW_GET_FUN(__glewUniform3iv)
+#define glUniform4f GLEW_GET_FUN(__glewUniform4f)
+#define glUniform4fv GLEW_GET_FUN(__glewUniform4fv)
+#define glUniform4i GLEW_GET_FUN(__glewUniform4i)
+#define glUniform4iv GLEW_GET_FUN(__glewUniform4iv)
+#define glUniformMatrix2fv GLEW_GET_FUN(__glewUniformMatrix2fv)
+#define glUniformMatrix3fv GLEW_GET_FUN(__glewUniformMatrix3fv)
+#define glUniformMatrix4fv GLEW_GET_FUN(__glewUniformMatrix4fv)
+#define glUseProgram GLEW_GET_FUN(__glewUseProgram)
+#define glValidateProgram GLEW_GET_FUN(__glewValidateProgram)
+#define glVertexAttrib1d GLEW_GET_FUN(__glewVertexAttrib1d)
+#define glVertexAttrib1dv GLEW_GET_FUN(__glewVertexAttrib1dv)
+#define glVertexAttrib1f GLEW_GET_FUN(__glewVertexAttrib1f)
+#define glVertexAttrib1fv GLEW_GET_FUN(__glewVertexAttrib1fv)
+#define glVertexAttrib1s GLEW_GET_FUN(__glewVertexAttrib1s)
+#define glVertexAttrib1sv GLEW_GET_FUN(__glewVertexAttrib1sv)
+#define glVertexAttrib2d GLEW_GET_FUN(__glewVertexAttrib2d)
+#define glVertexAttrib2dv GLEW_GET_FUN(__glewVertexAttrib2dv)
+#define glVertexAttrib2f GLEW_GET_FUN(__glewVertexAttrib2f)
+#define glVertexAttrib2fv GLEW_GET_FUN(__glewVertexAttrib2fv)
+#define glVertexAttrib2s GLEW_GET_FUN(__glewVertexAttrib2s)
+#define glVertexAttrib2sv GLEW_GET_FUN(__glewVertexAttrib2sv)
+#define glVertexAttrib3d GLEW_GET_FUN(__glewVertexAttrib3d)
+#define glVertexAttrib3dv GLEW_GET_FUN(__glewVertexAttrib3dv)
+#define glVertexAttrib3f GLEW_GET_FUN(__glewVertexAttrib3f)
+#define glVertexAttrib3fv GLEW_GET_FUN(__glewVertexAttrib3fv)
+#define glVertexAttrib3s GLEW_GET_FUN(__glewVertexAttrib3s)
+#define glVertexAttrib3sv GLEW_GET_FUN(__glewVertexAttrib3sv)
+#define glVertexAttrib4Nbv GLEW_GET_FUN(__glewVertexAttrib4Nbv)
+#define glVertexAttrib4Niv GLEW_GET_FUN(__glewVertexAttrib4Niv)
+#define glVertexAttrib4Nsv GLEW_GET_FUN(__glewVertexAttrib4Nsv)
+#define glVertexAttrib4Nub GLEW_GET_FUN(__glewVertexAttrib4Nub)
+#define glVertexAttrib4Nubv GLEW_GET_FUN(__glewVertexAttrib4Nubv)
+#define glVertexAttrib4Nuiv GLEW_GET_FUN(__glewVertexAttrib4Nuiv)
+#define glVertexAttrib4Nusv GLEW_GET_FUN(__glewVertexAttrib4Nusv)
+#define glVertexAttrib4bv GLEW_GET_FUN(__glewVertexAttrib4bv)
+#define glVertexAttrib4d GLEW_GET_FUN(__glewVertexAttrib4d)
+#define glVertexAttrib4dv GLEW_GET_FUN(__glewVertexAttrib4dv)
+#define glVertexAttrib4f GLEW_GET_FUN(__glewVertexAttrib4f)
+#define glVertexAttrib4fv GLEW_GET_FUN(__glewVertexAttrib4fv)
+#define glVertexAttrib4iv GLEW_GET_FUN(__glewVertexAttrib4iv)
+#define glVertexAttrib4s GLEW_GET_FUN(__glewVertexAttrib4s)
+#define glVertexAttrib4sv GLEW_GET_FUN(__glewVertexAttrib4sv)
+#define glVertexAttrib4ubv GLEW_GET_FUN(__glewVertexAttrib4ubv)
+#define glVertexAttrib4uiv GLEW_GET_FUN(__glewVertexAttrib4uiv)
+#define glVertexAttrib4usv GLEW_GET_FUN(__glewVertexAttrib4usv)
+#define glVertexAttribPointer GLEW_GET_FUN(__glewVertexAttribPointer)
+
+#define GLEW_VERSION_2_0 GLEW_GET_VAR(__GLEW_VERSION_2_0)
+
+#endif /* GL_VERSION_2_0 */
+
+    /* ----------------------------- GL_VERSION_2_1 ---------------------------- */
+
+#ifndef GL_VERSION_2_1
+#define GL_VERSION_2_1 1
+
+#define GL_CURRENT_RASTER_SECONDARY_COLOR 0x845F
+#define GL_PIXEL_PACK_BUFFER 0x88EB
+#define GL_PIXEL_UNPACK_BUFFER 0x88EC
+#define GL_PIXEL_PACK_BUFFER_BINDING 0x88ED
+#define GL_PIXEL_UNPACK_BUFFER_BINDING 0x88EF
+#define GL_FLOAT_MAT2x3 0x8B65
+#define GL_FLOAT_MAT2x4 0x8B66
+#define GL_FLOAT_MAT3x2 0x8B67
+#define GL_FLOAT_MAT3x4 0x8B68
+#define GL_FLOAT_MAT4x2 0x8B69
+#define GL_FLOAT_MAT4x3 0x8B6A
+#define GL_SRGB 0x8C40
+#define GL_SRGB8 0x8C41
+#define GL_SRGB_ALPHA 0x8C42
+#define GL_SRGB8_ALPHA8 0x8C43
+#define GL_SLUMINANCE_ALPHA 0x8C44
+#define GL_SLUMINANCE8_ALPHA8 0x8C45
+#define GL_SLUMINANCE 0x8C46
+#define GL_SLUMINANCE8 0x8C47
+#define GL_COMPRESSED_SRGB 0x8C48
+#define GL_COMPRESSED_SRGB_ALPHA 0x8C49
+#define GL_COMPRESSED_SLUMINANCE 0x8C4A
+#define GL_COMPRESSED_SLUMINANCE_ALPHA 0x8C4B
+
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+
+#define glUniformMatrix2x3fv GLEW_GET_FUN(__glewUniformMatrix2x3fv)
+#define glUniformMatrix2x4fv GLEW_GET_FUN(__glewUniformMatrix2x4fv)
+#define glUniformMatrix3x2fv GLEW_GET_FUN(__glewUniformMatrix3x2fv)
+#define glUniformMatrix3x4fv GLEW_GET_FUN(__glewUniformMatrix3x4fv)
+#define glUniformMatrix4x2fv GLEW_GET_FUN(__glewUniformMatrix4x2fv)
+#define glUniformMatrix4x3fv GLEW_GET_FUN(__glewUniformMatrix4x3fv)
+
+#define GLEW_VERSION_2_1 GLEW_GET_VAR(__GLEW_VERSION_2_1)
+
+#endif /* GL_VERSION_2_1 */
+
+    /* ----------------------------- GL_VERSION_3_0 ---------------------------- */
+
+#ifndef GL_VERSION_3_0
+#define GL_VERSION_3_0 1
+
+#define GL_MAX_CLIP_DISTANCES GL_MAX_CLIP_PLANES
+#define GL_CLIP_DISTANCE5 GL_CLIP_PLANE5
+#define GL_CLIP_DISTANCE1 GL_CLIP_PLANE1
+#define GL_CLIP_DISTANCE3 GL_CLIP_PLANE3
+#define GL_COMPARE_REF_TO_TEXTURE GL_COMPARE_R_TO_TEXTURE_ARB
+#define GL_CLIP_DISTANCE0 GL_CLIP_PLANE0
+#define GL_CLIP_DISTANCE4 GL_CLIP_PLANE4
+#define GL_CLIP_DISTANCE2 GL_CLIP_PLANE2
+#define GL_MAX_VARYING_COMPONENTS GL_MAX_VARYING_FLOATS
+#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x0001
+#define GL_MAJOR_VERSION 0x821B
+#define GL_MINOR_VERSION 0x821C
+#define GL_NUM_EXTENSIONS 0x821D
+#define GL_CONTEXT_FLAGS 0x821E
+#define GL_DEPTH_BUFFER 0x8223
+#define GL_STENCIL_BUFFER 0x8224
+#define GL_COMPRESSED_RED 0x8225
+#define GL_COMPRESSED_RG 0x8226
+#define GL_RGBA32F 0x8814
+#define GL_RGB32F 0x8815
+#define GL_RGBA16F 0x881A
+#define GL_RGB16F 0x881B
+#define GL_VERTEX_ATTRIB_ARRAY_INTEGER 0x88FD
+#define GL_MAX_ARRAY_TEXTURE_LAYERS 0x88FF
+#define GL_MIN_PROGRAM_TEXEL_OFFSET 0x8904
+#define GL_MAX_PROGRAM_TEXEL_OFFSET 0x8905
+#define GL_CLAMP_VERTEX_COLOR 0x891A
+#define GL_CLAMP_FRAGMENT_COLOR 0x891B
+#define GL_CLAMP_READ_COLOR 0x891C
+#define GL_FIXED_ONLY 0x891D
+#define GL_TEXTURE_RED_TYPE 0x8C10
+#define GL_TEXTURE_GREEN_TYPE 0x8C11
+#define GL_TEXTURE_BLUE_TYPE 0x8C12
+#define GL_TEXTURE_ALPHA_TYPE 0x8C13
+#define GL_TEXTURE_LUMINANCE_TYPE 0x8C14
+#define GL_TEXTURE_INTENSITY_TYPE 0x8C15
+#define GL_TEXTURE_DEPTH_TYPE 0x8C16
+#define GL_UNSIGNED_NORMALIZED 0x8C17
+#define GL_TEXTURE_1D_ARRAY 0x8C18
+#define GL_PROXY_TEXTURE_1D_ARRAY 0x8C19
+#define GL_TEXTURE_2D_ARRAY 0x8C1A
+#define GL_PROXY_TEXTURE_2D_ARRAY 0x8C1B
+#define GL_TEXTURE_BINDING_1D_ARRAY 0x8C1C
+#define GL_TEXTURE_BINDING_2D_ARRAY 0x8C1D
+#define GL_R11F_G11F_B10F 0x8C3A
+#define GL_UNSIGNED_INT_10F_11F_11F_REV 0x8C3B
+#define GL_RGB9_E5 0x8C3D
+#define GL_UNSIGNED_INT_5_9_9_9_REV 0x8C3E
+#define GL_TEXTURE_SHARED_SIZE 0x8C3F
+#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
+#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
+#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
+#define GL_TRANSFORM_FEEDBACK_VARYINGS 0x8C83
+#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
+#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
+#define GL_PRIMITIVES_GENERATED 0x8C87
+#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
+#define GL_RASTERIZER_DISCARD 0x8C89
+#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
+#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
+#define GL_INTERLEAVED_ATTRIBS 0x8C8C
+#define GL_SEPARATE_ATTRIBS 0x8C8D
+#define GL_TRANSFORM_FEEDBACK_BUFFER 0x8C8E
+#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
+#define GL_RGBA32UI 0x8D70
+#define GL_RGB32UI 0x8D71
+#define GL_RGBA16UI 0x8D76
+#define GL_RGB16UI 0x8D77
+#define GL_RGBA8UI 0x8D7C
+#define GL_RGB8UI 0x8D7D
+#define GL_RGBA32I 0x8D82
+#define GL_RGB32I 0x8D83
+#define GL_RGBA16I 0x8D88
+#define GL_RGB16I 0x8D89
+#define GL_RGBA8I 0x8D8E
+#define GL_RGB8I 0x8D8F
+#define GL_RED_INTEGER 0x8D94
+#define GL_GREEN_INTEGER 0x8D95
+#define GL_BLUE_INTEGER 0x8D96
+#define GL_ALPHA_INTEGER 0x8D97
+#define GL_RGB_INTEGER 0x8D98
+#define GL_RGBA_INTEGER 0x8D99
+#define GL_BGR_INTEGER 0x8D9A
+#define GL_BGRA_INTEGER 0x8D9B
+#define GL_SAMPLER_1D_ARRAY 0x8DC0
+#define GL_SAMPLER_2D_ARRAY 0x8DC1
+#define GL_SAMPLER_1D_ARRAY_SHADOW 0x8DC3
+#define GL_SAMPLER_2D_ARRAY_SHADOW 0x8DC4
+#define GL_SAMPLER_CUBE_SHADOW 0x8DC5
+#define GL_UNSIGNED_INT_VEC2 0x8DC6
+#define GL_UNSIGNED_INT_VEC3 0x8DC7
+#define GL_UNSIGNED_INT_VEC4 0x8DC8
+#define GL_INT_SAMPLER_1D 0x8DC9
+#define GL_INT_SAMPLER_2D 0x8DCA
+#define GL_INT_SAMPLER_3D 0x8DCB
+#define GL_INT_SAMPLER_CUBE 0x8DCC
+#define GL_INT_SAMPLER_1D_ARRAY 0x8DCE
+#define GL_INT_SAMPLER_2D_ARRAY 0x8DCF
+#define GL_UNSIGNED_INT_SAMPLER_1D 0x8DD1
+#define GL_UNSIGNED_INT_SAMPLER_2D 0x8DD2
+#define GL_UNSIGNED_INT_SAMPLER_3D 0x8DD3
+#define GL_UNSIGNED_INT_SAMPLER_CUBE 0x8DD4
+#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY 0x8DD6
+#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY 0x8DD7
+#define GL_QUERY_WAIT 0x8E13
+#define GL_QUERY_NO_WAIT 0x8E14
+#define GL_QUERY_BY_REGION_WAIT 0x8E15
+#define GL_QUERY_BY_REGION_NO_WAIT 0x8E16
+
+    typedef void (GLAPIENTRY *PFNGLBEGINCONDITIONALRENDERPROC)(GLuint, GLenum);
+    typedef void (GLAPIENTRY *PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum);
+    typedef void (GLAPIENTRY *PFNGLBINDFRAGDATALOCATIONPROC)(GLuint, GLuint, const GLchar *);
+    typedef void (GLAPIENTRY *PFNGLCLAMPCOLORPROC)(GLenum, GLenum);
+    typedef void (GLAPIENTRY *PFNGLCLEARBUFFERFIPROC)(GLenum, GLint, GLfloat, GLint);
+    typedef void (GLAPIENTRY *PFNGLCLEARBUFFERFVPROC)(GLenum, GLint, const GLfloat *);
+    typedef void (GLAPIENTRY *PFNGLCLEARBUFFERIVPROC)(GLenum, GLint, const GLint *);
+    typedef void (GLAPIENTRY *PFNGLCLEARBUFFERUIVPROC)(GLenum, GLint, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLCOLORMASKIPROC)(GLuint, GLboolean, GLboolean, GLboolean, GLboolean);
+    typedef void (GLAPIENTRY *PFNGLDISABLEIPROC)(GLenum, GLuint);
+    typedef void (GLAPIENTRY *PFNGLENABLEIPROC)(GLenum, GLuint);
+    typedef void (GLAPIENTRY *PFNGLENDCONDITIONALRENDERPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLENDTRANSFORMFEEDBACKPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLGETBOOLEANI_VPROC)(GLenum, GLuint, GLboolean *);
+    typedef GLint(GLAPIENTRY *PFNGLGETFRAGDATALOCATIONPROC)(GLuint, const GLchar *);
+    typedef const GLubyte *(GLAPIENTRY *PFNGLGETSTRINGIPROC)(GLenum, GLuint);
+    typedef void (GLAPIENTRY *PFNGLGETTEXPARAMETERIIVPROC)(GLenum, GLenum, GLint *);
+    typedef void (GLAPIENTRY *PFNGLGETTEXPARAMETERIUIVPROC)(GLenum, GLenum, GLuint *);
+    typedef void (GLAPIENTRY *PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint, GLuint, GLint *);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMUIVPROC)(GLuint, GLint, GLuint *);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBIIVPROC)(GLuint, GLenum, GLint *);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint, GLenum, GLuint *);
+    typedef GLboolean(GLAPIENTRY *PFNGLISENABLEDIPROC)(GLenum, GLuint);
+    typedef void (GLAPIENTRY *PFNGLTEXPARAMETERIIVPROC)(GLenum, GLenum, const GLint *);
+    typedef void (GLAPIENTRY *PFNGLTEXPARAMETERIUIVPROC)(GLenum, GLenum, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint, GLsizei, const GLchar **, GLenum);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1UIPROC)(GLint, GLuint);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1UIVPROC)(GLint, GLsizei, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2UIPROC)(GLint, GLuint, GLuint);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2UIVPROC)(GLint, GLsizei, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3UIPROC)(GLint, GLuint, GLuint, GLuint);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3UIVPROC)(GLint, GLsizei, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4UIPROC)(GLint, GLuint, GLuint, GLuint, GLuint);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4UIVPROC)(GLint, GLsizei, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI1IPROC)(GLuint, GLint);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI1IVPROC)(GLuint, const GLint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI1UIPROC)(GLuint, GLuint);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI1UIVPROC)(GLuint, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI2IPROC)(GLuint, GLint, GLint);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI2IVPROC)(GLuint, const GLint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI2UIPROC)(GLuint, GLuint, GLuint);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI2UIVPROC)(GLuint, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI3IPROC)(GLuint, GLint, GLint, GLint);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI3IVPROC)(GLuint, const GLint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI3UIPROC)(GLuint, GLuint, GLuint, GLuint);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI3UIVPROC)(GLuint, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4BVPROC)(GLuint, const GLbyte *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4IPROC)(GLuint, GLint, GLint, GLint, GLint);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4IVPROC)(GLuint, const GLint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4SVPROC)(GLuint, const GLshort *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4UBVPROC)(GLuint, const GLubyte *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4UIPROC)(GLuint, GLuint, GLuint, GLuint, GLuint);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4UIVPROC)(GLuint, const GLuint *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4USVPROC)(GLuint, const GLushort *);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint, GLint, GLenum, GLsizei, const GLvoid *);
+
+#define glBeginConditionalRender GLEW_GET_FUN(__glewBeginConditionalRender)
+#define glBeginTransformFeedback GLEW_GET_FUN(__glewBeginTransformFeedback)
+#define glBindFragDataLocation GLEW_GET_FUN(__glewBindFragDataLocation)
+#define glClampColor GLEW_GET_FUN(__glewClampColor)
+#define glClearBufferfi GLEW_GET_FUN(__glewClearBufferfi)
+#define glClearBufferfv GLEW_GET_FUN(__glewClearBufferfv)
+#define glClearBufferiv GLEW_GET_FUN(__glewClearBufferiv)
+#define glClearBufferuiv GLEW_GET_FUN(__glewClearBufferuiv)
+#define glColorMaski GLEW_GET_FUN(__glewColorMaski)
+#define glDisablei GLEW_GET_FUN(__glewDisablei)
+#define glEnablei GLEW_GET_FUN(__glewEnablei)
+#define glEndConditionalRender GLEW_GET_FUN(__glewEndConditionalRender)
+#define glEndTransformFeedback GLEW_GET_FUN(__glewEndTransformFeedback)
+#define glGetBooleani_v GLEW_GET_FUN(__glewGetBooleani_v)
+#define glGetFragDataLocation GLEW_GET_FUN(__glewGetFragDataLocation)
+#define glGetStringi GLEW_GET_FUN(__glewGetStringi)
+#define glGetTexParameterIiv GLEW_GET_FUN(__glewGetTexParameterIiv)
+#define glGetTexParameterIuiv GLEW_GET_FUN(__glewGetTexParameterIuiv)
+#define glGetTransformFeedbackVarying GLEW_GET_FUN(__glewGetTransformFeedbackVarying)
+#define glGetUniformuiv GLEW_GET_FUN(__glewGetUniformuiv)
+#define glGetVertexAttribIiv GLEW_GET_FUN(__glewGetVertexAttribIiv)
+#define glGetVertexAttribIuiv GLEW_GET_FUN(__glewGetVertexAttribIuiv)
+#define glIsEnabledi GLEW_GET_FUN(__glewIsEnabledi)
+#define glTexParameterIiv GLEW_GET_FUN(__glewTexParameterIiv)
+#define glTexParameterIuiv GLEW_GET_FUN(__glewTexParameterIuiv)
+#define glTransformFeedbackVaryings GLEW_GET_FUN(__glewTransformFeedbackVaryings)
+#define glUniform1ui GLEW_GET_FUN(__glewUniform1ui)
+#define glUniform1uiv GLEW_GET_FUN(__glewUniform1uiv)
+#define glUniform2ui GLEW_GET_FUN(__glewUniform2ui)
+#define glUniform2uiv GLEW_GET_FUN(__glewUniform2uiv)
+#define glUniform3ui GLEW_GET_FUN(__glewUniform3ui)
+#define glUniform3uiv GLEW_GET_FUN(__glewUniform3uiv)
+#define glUniform4ui GLEW_GET_FUN(__glewUniform4ui)
+#define glUniform4uiv GLEW_GET_FUN(__glewUniform4uiv)
+#define glVertexAttribI1i GLEW_GET_FUN(__glewVertexAttribI1i)
+#define glVertexAttribI1iv GLEW_GET_FUN(__glewVertexAttribI1iv)
+#define glVertexAttribI1ui GLEW_GET_FUN(__glewVertexAttribI1ui)
+#define glVertexAttribI1uiv GLEW_GET_FUN(__glewVertexAttribI1uiv)
+#define glVertexAttribI2i GLEW_GET_FUN(__glewVertexAttribI2i)
+#define glVertexAttribI2iv GLEW_GET_FUN(__glewVertexAttribI2iv)
+#define glVertexAttribI2ui GLEW_GET_FUN(__glewVertexAttribI2ui)
+#define glVertexAttribI2uiv GLEW_GET_FUN(__glewVertexAttribI2uiv)
+#define glVertexAttribI3i GLEW_GET_FUN(__glewVertexAttribI3i)
+#define glVertexAttribI3iv GLEW_GET_FUN(__glewVertexAttribI3iv)
+#define glVertexAttribI3ui GLEW_GET_FUN(__glewVertexAttribI3ui)
+#define glVertexAttribI3uiv GLEW_GET_FUN(__glewVertexAttribI3uiv)
+#define glVertexAttribI4bv GLEW_GET_FUN(__glewVertexAttribI4bv)
+#define glVertexAttribI4i GLEW_GET_FUN(__glewVertexAttribI4i)
+#define glVertexAttribI4iv GLEW_GET_FUN(__glewVertexAttribI4iv)
+#define glVertexAttribI4sv GLEW_GET_FUN(__glewVertexAttribI4sv)
+#define glVertexAttribI4ubv GLEW_GET_FUN(__glewVertexAttribI4ubv)
+#define glVertexAttribI4ui GLEW_GET_FUN(__glewVertexAttribI4ui)
+#define glVertexAttribI4uiv GLEW_GET_FUN(__glewVertexAttribI4uiv)
+#define glVertexAttribI4usv GLEW_GET_FUN(__glewVertexAttribI4usv)
+#define glVertexAttribIPointer GLEW_GET_FUN(__glewVertexAttribIPointer)
+
+#define GLEW_VERSION_3_0 GLEW_GET_VAR(__GLEW_VERSION_3_0)
+
+#endif /* GL_VERSION_3_0 */
+
+    /* ----------------------------- GL_VERSION_3_1 ---------------------------- */
+
+#ifndef GL_VERSION_3_1
+#define GL_VERSION_3_1 1
+
+#define GL_TEXTURE_RECTANGLE 0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE 0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE 0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE 0x84F8
+#define GL_SAMPLER_2D_RECT 0x8B63
+#define GL_SAMPLER_2D_RECT_SHADOW 0x8B64
+#define GL_TEXTURE_BUFFER 0x8C2A
+#define GL_MAX_TEXTURE_BUFFER_SIZE 0x8C2B
+#define GL_TEXTURE_BINDING_BUFFER 0x8C2C
+#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
+#define GL_TEXTURE_BUFFER_FORMAT 0x8C2E
+#define GL_SAMPLER_BUFFER 0x8DC2
+#define GL_INT_SAMPLER_2D_RECT 0x8DCD
+#define GL_INT_SAMPLER_BUFFER 0x8DD0
+#define GL_UNSIGNED_INT_SAMPLER_2D_RECT 0x8DD5
+#define GL_UNSIGNED_INT_SAMPLER_BUFFER 0x8DD8
+#define GL_RED_SNORM 0x8F90
+#define GL_RG_SNORM 0x8F91
+#define GL_RGB_SNORM 0x8F92
+#define GL_RGBA_SNORM 0x8F93
+#define GL_R8_SNORM 0x8F94
+#define GL_RG8_SNORM 0x8F95
+#define GL_RGB8_SNORM 0x8F96
+#define GL_RGBA8_SNORM 0x8F97
+#define GL_R16_SNORM 0x8F98
+#define GL_RG16_SNORM 0x8F99
+#define GL_RGB16_SNORM 0x8F9A
+#define GL_RGBA16_SNORM 0x8F9B
+#define GL_SIGNED_NORMALIZED 0x8F9C
+#define GL_PRIMITIVE_RESTART 0x8F9D
+#define GL_PRIMITIVE_RESTART_INDEX 0x8F9E
+#define GL_BUFFER_ACCESS_FLAGS 0x911F
+#define GL_BUFFER_MAP_LENGTH 0x9120
+#define GL_BUFFER_MAP_OFFSET 0x9121
+
+    typedef void (GLAPIENTRY *PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum, GLint, GLsizei, GLsizei);
+    typedef void (GLAPIENTRY *PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum, GLsizei, GLenum, const GLvoid *, GLsizei);
+    typedef void (GLAPIENTRY *PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint);
+    typedef void (GLAPIENTRY *PFNGLTEXBUFFERPROC)(GLenum, GLenum, GLuint);
+
+#define glDrawArraysInstanced GLEW_GET_FUN(__glewDrawArraysInstanced)
+#define glDrawElementsInstanced GLEW_GET_FUN(__glewDrawElementsInstanced)
+#define glPrimitiveRestartIndex GLEW_GET_FUN(__glewPrimitiveRestartIndex)
+#define glTexBuffer GLEW_GET_FUN(__glewTexBuffer)
+
+#define GLEW_VERSION_3_1 GLEW_GET_VAR(__GLEW_VERSION_3_1)
+
+#endif /* GL_VERSION_3_1 */
+
+    /* ----------------------------- GL_VERSION_3_2 ---------------------------- */
+
+#ifndef GL_VERSION_3_2
+#define GL_VERSION_3_2 1
+
+#define GL_CONTEXT_CORE_PROFILE_BIT 0x00000001
+#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
+#define GL_LINES_ADJACENCY 0x000A
+#define GL_LINE_STRIP_ADJACENCY 0x000B
+#define GL_TRIANGLES_ADJACENCY 0x000C
+#define GL_TRIANGLE_STRIP_ADJACENCY 0x000D
+#define GL_PROGRAM_POINT_SIZE 0x8642
+#define GL_GEOMETRY_VERTICES_OUT 0x8916
+#define GL_GEOMETRY_INPUT_TYPE 0x8917
+#define GL_GEOMETRY_OUTPUT_TYPE 0x8918
+#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
+#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
+#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
+#define GL_GEOMETRY_SHADER 0x8DD9
+#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
+#define GL_MAX_GEOMETRY_OUTPUT_VERTICES 0x8DE0
+#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
+#define GL_MAX_VERTEX_OUTPUT_COMPONENTS 0x9122
+#define GL_MAX_GEOMETRY_INPUT_COMPONENTS 0x9123
+#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
+#define GL_MAX_FRAGMENT_INPUT_COMPONENTS 0x9125
+#define GL_CONTEXT_PROFILE_MASK 0x9126
+
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum, GLenum, GLuint, GLint);
+    typedef void (GLAPIENTRY *PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum, GLenum, GLint64 *);
+    typedef void (GLAPIENTRY *PFNGLGETINTEGER64I_VPROC)(GLenum, GLuint, GLint64 *);
+
+#define glFramebufferTexture GLEW_GET_FUN(__glewFramebufferTexture)
+#define glGetBufferParameteri64v GLEW_GET_FUN(__glewGetBufferParameteri64v)
+#define glGetInteger64i_v GLEW_GET_FUN(__glewGetInteger64i_v)
+
+#define GLEW_VERSION_3_2 GLEW_GET_VAR(__GLEW_VERSION_3_2)
+
+#endif /* GL_VERSION_3_2 */
+
+    /* ----------------------------- GL_VERSION_3_3 ---------------------------- */
+
+#ifndef GL_VERSION_3_3
+#define GL_VERSION_3_3 1
+
+#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR 0x88FE
+#define GL_ANY_SAMPLES_PASSED 0x8C2F
+#define GL_TEXTURE_SWIZZLE_R 0x8E42
+#define GL_TEXTURE_SWIZZLE_G 0x8E43
+#define GL_TEXTURE_SWIZZLE_B 0x8E44
+#define GL_TEXTURE_SWIZZLE_A 0x8E45
+#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
+#define GL_RGB10_A2UI 0x906F
+
+#define GLEW_VERSION_3_3 GLEW_GET_VAR(__GLEW_VERSION_3_3)
+
+#endif /* GL_VERSION_3_3 */
+
+    /* ----------------------------- GL_VERSION_4_0 ---------------------------- */
+
+#ifndef GL_VERSION_4_0
+#define GL_VERSION_4_0 1
+
+#define GL_GEOMETRY_SHADER_INVOCATIONS 0x887F
+#define GL_SAMPLE_SHADING 0x8C36
+#define GL_MIN_SAMPLE_SHADING_VALUE 0x8C37
+#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
+#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
+#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
+#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
+#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
+#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
+#define GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS 0x8F9F
+#define GL_TEXTURE_CUBE_MAP_ARRAY 0x9009
+#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
+#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY 0x900B
+#define GL_SAMPLER_CUBE_MAP_ARRAY 0x900C
+#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW 0x900D
+#define GL_INT_SAMPLER_CUBE_MAP_ARRAY 0x900E
+#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
+
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLBLENDFUNCSEPARATEIPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
+    typedef void (GLAPIENTRY *PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
+    typedef void (GLAPIENTRY *PFNGLMINSAMPLESHADINGPROC)(GLclampf value);
+
+#define glBlendEquationSeparatei GLEW_GET_FUN(__glewBlendEquationSeparatei)
+#define glBlendEquationi GLEW_GET_FUN(__glewBlendEquationi)
+#define glBlendFuncSeparatei GLEW_GET_FUN(__glewBlendFuncSeparatei)
+#define glBlendFunci GLEW_GET_FUN(__glewBlendFunci)
+#define glMinSampleShading GLEW_GET_FUN(__glewMinSampleShading)
+
+#define GLEW_VERSION_4_0 GLEW_GET_VAR(__GLEW_VERSION_4_0)
+
+#endif /* GL_VERSION_4_0 */
+
+    /* -------------------------- GL_3DFX_multisample -------------------------- */
+
+#ifndef GL_3DFX_multisample
+#define GL_3DFX_multisample 1
+
+#define GL_MULTISAMPLE_3DFX 0x86B2
+#define GL_SAMPLE_BUFFERS_3DFX 0x86B3
+#define GL_SAMPLES_3DFX 0x86B4
+#define GL_MULTISAMPLE_BIT_3DFX 0x20000000
+
+#define GLEW_3DFX_multisample GLEW_GET_VAR(__GLEW_3DFX_multisample)
+
+#endif /* GL_3DFX_multisample */
+
+    /* ---------------------------- GL_3DFX_tbuffer ---------------------------- */
+
+#ifndef GL_3DFX_tbuffer
+#define GL_3DFX_tbuffer 1
+
+    typedef void (GLAPIENTRY *PFNGLTBUFFERMASK3DFXPROC)(GLuint mask);
+
+#define glTbufferMask3DFX GLEW_GET_FUN(__glewTbufferMask3DFX)
+
+#define GLEW_3DFX_tbuffer GLEW_GET_VAR(__GLEW_3DFX_tbuffer)
+
+#endif /* GL_3DFX_tbuffer */
+
+    /* -------------------- GL_3DFX_texture_compression_FXT1 ------------------- */
+
+#ifndef GL_3DFX_texture_compression_FXT1
+#define GL_3DFX_texture_compression_FXT1 1
+
+#define GL_COMPRESSED_RGB_FXT1_3DFX 0x86B0
+#define GL_COMPRESSED_RGBA_FXT1_3DFX 0x86B1
+
+#define GLEW_3DFX_texture_compression_FXT1 GLEW_GET_VAR(__GLEW_3DFX_texture_compression_FXT1)
+
+#endif /* GL_3DFX_texture_compression_FXT1 */
+
+    /* ----------------------- GL_AMD_draw_buffers_blend ----------------------- */
+
+#ifndef GL_AMD_draw_buffers_blend
+#define GL_AMD_draw_buffers_blend 1
+
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONINDEXEDAMDPROC)(GLuint buf, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
+    typedef void (GLAPIENTRY *PFNGLBLENDFUNCINDEXEDAMDPROC)(GLuint buf, GLenum src, GLenum dst);
+    typedef void (GLAPIENTRY *PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
+
+#define glBlendEquationIndexedAMD GLEW_GET_FUN(__glewBlendEquationIndexedAMD)
+#define glBlendEquationSeparateIndexedAMD GLEW_GET_FUN(__glewBlendEquationSeparateIndexedAMD)
+#define glBlendFuncIndexedAMD GLEW_GET_FUN(__glewBlendFuncIndexedAMD)
+#define glBlendFuncSeparateIndexedAMD GLEW_GET_FUN(__glewBlendFuncSeparateIndexedAMD)
+
+#define GLEW_AMD_draw_buffers_blend GLEW_GET_VAR(__GLEW_AMD_draw_buffers_blend)
+
+#endif /* GL_AMD_draw_buffers_blend */
+
+    /* ----------------------- GL_AMD_performance_monitor ---------------------- */
+
+#ifndef GL_AMD_performance_monitor
+#define GL_AMD_performance_monitor 1
+
+#define GL_UNSIGNED_INT 0x1405
+#define GL_FLOAT 0x1406
+#define GL_COUNTER_TYPE_AMD 0x8BC0
+#define GL_COUNTER_RANGE_AMD 0x8BC1
+#define GL_UNSIGNED_INT64_AMD 0x8BC2
+#define GL_PERCENTAGE_AMD 0x8BC3
+#define GL_PERFMON_RESULT_AVAILABLE_AMD 0x8BC4
+#define GL_PERFMON_RESULT_SIZE_AMD 0x8BC5
+#define GL_PERFMON_RESULT_AMD 0x8BC6
+
+    typedef void (GLAPIENTRY *PFNGLBEGINPERFMONITORAMDPROC)(GLuint monitor);
+    typedef void (GLAPIENTRY *PFNGLDELETEPERFMONITORSAMDPROC)(GLsizei n, GLuint *monitors);
+    typedef void (GLAPIENTRY *PFNGLENDPERFMONITORAMDPROC)(GLuint monitor);
+    typedef void (GLAPIENTRY *PFNGLGENPERFMONITORSAMDPROC)(GLsizei n, GLuint *monitors);
+    typedef void (GLAPIENTRY *PFNGLGETPERFMONITORCOUNTERDATAAMDPROC)(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten);
+    typedef void (GLAPIENTRY *PFNGLGETPERFMONITORCOUNTERINFOAMDPROC)(GLuint group, GLuint counter, GLenum pname, void *data);
+    typedef void (GLAPIENTRY *PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC)(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, char *counterString);
+    typedef void (GLAPIENTRY *PFNGLGETPERFMONITORCOUNTERSAMDPROC)(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
+    typedef void (GLAPIENTRY *PFNGLGETPERFMONITORGROUPSTRINGAMDPROC)(GLuint group, GLsizei bufSize, GLsizei *length, char *groupString);
+    typedef void (GLAPIENTRY *PFNGLGETPERFMONITORGROUPSAMDPROC)(GLint *numGroups, GLsizei groupsSize, GLuint *groups);
+    typedef void (GLAPIENTRY *PFNGLSELECTPERFMONITORCOUNTERSAMDPROC)(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList);
+
+#define glBeginPerfMonitorAMD GLEW_GET_FUN(__glewBeginPerfMonitorAMD)
+#define glDeletePerfMonitorsAMD GLEW_GET_FUN(__glewDeletePerfMonitorsAMD)
+#define glEndPerfMonitorAMD GLEW_GET_FUN(__glewEndPerfMonitorAMD)
+#define glGenPerfMonitorsAMD GLEW_GET_FUN(__glewGenPerfMonitorsAMD)
+#define glGetPerfMonitorCounterDataAMD GLEW_GET_FUN(__glewGetPerfMonitorCounterDataAMD)
+#define glGetPerfMonitorCounterInfoAMD GLEW_GET_FUN(__glewGetPerfMonitorCounterInfoAMD)
+#define glGetPerfMonitorCounterStringAMD GLEW_GET_FUN(__glewGetPerfMonitorCounterStringAMD)
+#define glGetPerfMonitorCountersAMD GLEW_GET_FUN(__glewGetPerfMonitorCountersAMD)
+#define glGetPerfMonitorGroupStringAMD GLEW_GET_FUN(__glewGetPerfMonitorGroupStringAMD)
+#define glGetPerfMonitorGroupsAMD GLEW_GET_FUN(__glewGetPerfMonitorGroupsAMD)
+#define glSelectPerfMonitorCountersAMD GLEW_GET_FUN(__glewSelectPerfMonitorCountersAMD)
+
+#define GLEW_AMD_performance_monitor GLEW_GET_VAR(__GLEW_AMD_performance_monitor)
+
+#endif /* GL_AMD_performance_monitor */
+
+    /* ------------------ GL_AMD_seamless_cubemap_per_texture ------------------ */
+
+#ifndef GL_AMD_seamless_cubemap_per_texture
+#define GL_AMD_seamless_cubemap_per_texture 1
+
+#define GL_TEXTURE_CUBE_MAP_SEAMLESS_ARB 0x884F
+
+#define GLEW_AMD_seamless_cubemap_per_texture GLEW_GET_VAR(__GLEW_AMD_seamless_cubemap_per_texture)
+
+#endif /* GL_AMD_seamless_cubemap_per_texture */
+
+    /* ---------------------- GL_AMD_shader_stencil_export --------------------- */
+
+#ifndef GL_AMD_shader_stencil_export
+#define GL_AMD_shader_stencil_export 1
+
+#define GLEW_AMD_shader_stencil_export GLEW_GET_VAR(__GLEW_AMD_shader_stencil_export)
+
+#endif /* GL_AMD_shader_stencil_export */
+
+    /* ------------------------ GL_AMD_texture_texture4 ------------------------ */
+
+#ifndef GL_AMD_texture_texture4
+#define GL_AMD_texture_texture4 1
+
+#define GLEW_AMD_texture_texture4 GLEW_GET_VAR(__GLEW_AMD_texture_texture4)
+
+#endif /* GL_AMD_texture_texture4 */
+
+    /* -------------------- GL_AMD_vertex_shader_tessellator ------------------- */
+
+#ifndef GL_AMD_vertex_shader_tessellator
+#define GL_AMD_vertex_shader_tessellator 1
+
+#define GL_SAMPLER_BUFFER_AMD 0x9001
+#define GL_INT_SAMPLER_BUFFER_AMD 0x9002
+#define GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD 0x9003
+#define GL_TESSELLATION_MODE_AMD 0x9004
+#define GL_TESSELLATION_FACTOR_AMD 0x9005
+#define GL_DISCRETE_AMD 0x9006
+#define GL_CONTINUOUS_AMD 0x9007
+
+    typedef void (GLAPIENTRY *PFNGLTESSELLATIONFACTORAMDPROC)(GLfloat factor);
+    typedef void (GLAPIENTRY *PFNGLTESSELLATIONMODEAMDPROC)(GLenum mode);
+
+#define glTessellationFactorAMD GLEW_GET_FUN(__glewTessellationFactorAMD)
+#define glTessellationModeAMD GLEW_GET_FUN(__glewTessellationModeAMD)
+
+#define GLEW_AMD_vertex_shader_tessellator GLEW_GET_VAR(__GLEW_AMD_vertex_shader_tessellator)
+
+#endif /* GL_AMD_vertex_shader_tessellator */
+
+    /* ----------------------- GL_APPLE_aux_depth_stencil ---------------------- */
+
+#ifndef GL_APPLE_aux_depth_stencil
+#define GL_APPLE_aux_depth_stencil 1
+
+#define GL_AUX_DEPTH_STENCIL_APPLE 0x8A14
+
+#define GLEW_APPLE_aux_depth_stencil GLEW_GET_VAR(__GLEW_APPLE_aux_depth_stencil)
+
+#endif /* GL_APPLE_aux_depth_stencil */
+
+    /* ------------------------ GL_APPLE_client_storage ------------------------ */
+
+#ifndef GL_APPLE_client_storage
+#define GL_APPLE_client_storage 1
+
+#define GL_UNPACK_CLIENT_STORAGE_APPLE 0x85B2
+
+#define GLEW_APPLE_client_storage GLEW_GET_VAR(__GLEW_APPLE_client_storage)
+
+#endif /* GL_APPLE_client_storage */
+
+    /* ------------------------- GL_APPLE_element_array ------------------------ */
+
+#ifndef GL_APPLE_element_array
+#define GL_APPLE_element_array 1
+
+#define GL_ELEMENT_ARRAY_APPLE 0x8768
+#define GL_ELEMENT_ARRAY_TYPE_APPLE 0x8769
+#define GL_ELEMENT_ARRAY_POINTER_APPLE 0x876A
+
+    typedef void (GLAPIENTRY *PFNGLDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, GLint first, GLsizei count);
+    typedef void (GLAPIENTRY *PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
+    typedef void (GLAPIENTRY *PFNGLELEMENTPOINTERAPPLEPROC)(GLenum type, const void *pointer);
+    typedef void (GLAPIENTRY *PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
+    typedef void (GLAPIENTRY *PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
+
+#define glDrawElementArrayAPPLE GLEW_GET_FUN(__glewDrawElementArrayAPPLE)
+#define glDrawRangeElementArrayAPPLE GLEW_GET_FUN(__glewDrawRangeElementArrayAPPLE)
+#define glElementPointerAPPLE GLEW_GET_FUN(__glewElementPointerAPPLE)
+#define glMultiDrawElementArrayAPPLE GLEW_GET_FUN(__glewMultiDrawElementArrayAPPLE)
+#define glMultiDrawRangeElementArrayAPPLE GLEW_GET_FUN(__glewMultiDrawRangeElementArrayAPPLE)
+
+#define GLEW_APPLE_element_array GLEW_GET_VAR(__GLEW_APPLE_element_array)
+
+#endif /* GL_APPLE_element_array */
+
+    /* ----------------------------- GL_APPLE_fence ---------------------------- */
+
+#ifndef GL_APPLE_fence
+#define GL_APPLE_fence 1
+
+#define GL_DRAW_PIXELS_APPLE 0x8A0A
+#define GL_FENCE_APPLE 0x8A0B
+
+    typedef void (GLAPIENTRY *PFNGLDELETEFENCESAPPLEPROC)(GLsizei n, const GLuint *fences);
+    typedef void (GLAPIENTRY *PFNGLFINISHFENCEAPPLEPROC)(GLuint fence);
+    typedef void (GLAPIENTRY *PFNGLFINISHOBJECTAPPLEPROC)(GLenum object, GLint name);
+    typedef void (GLAPIENTRY *PFNGLGENFENCESAPPLEPROC)(GLsizei n, GLuint *fences);
+    typedef GLboolean(GLAPIENTRY *PFNGLISFENCEAPPLEPROC)(GLuint fence);
+    typedef void (GLAPIENTRY *PFNGLSETFENCEAPPLEPROC)(GLuint fence);
+    typedef GLboolean(GLAPIENTRY *PFNGLTESTFENCEAPPLEPROC)(GLuint fence);
+    typedef GLboolean(GLAPIENTRY *PFNGLTESTOBJECTAPPLEPROC)(GLenum object, GLuint name);
+
+#define glDeleteFencesAPPLE GLEW_GET_FUN(__glewDeleteFencesAPPLE)
+#define glFinishFenceAPPLE GLEW_GET_FUN(__glewFinishFenceAPPLE)
+#define glFinishObjectAPPLE GLEW_GET_FUN(__glewFinishObjectAPPLE)
+#define glGenFencesAPPLE GLEW_GET_FUN(__glewGenFencesAPPLE)
+#define glIsFenceAPPLE GLEW_GET_FUN(__glewIsFenceAPPLE)
+#define glSetFenceAPPLE GLEW_GET_FUN(__glewSetFenceAPPLE)
+#define glTestFenceAPPLE GLEW_GET_FUN(__glewTestFenceAPPLE)
+#define glTestObjectAPPLE GLEW_GET_FUN(__glewTestObjectAPPLE)
+
+#define GLEW_APPLE_fence GLEW_GET_VAR(__GLEW_APPLE_fence)
+
+#endif /* GL_APPLE_fence */
+
+    /* ------------------------- GL_APPLE_float_pixels ------------------------- */
+
+#ifndef GL_APPLE_float_pixels
+#define GL_APPLE_float_pixels 1
+
+#define GL_HALF_APPLE 0x140B
+#define GL_RGBA_FLOAT32_APPLE 0x8814
+#define GL_RGB_FLOAT32_APPLE 0x8815
+#define GL_ALPHA_FLOAT32_APPLE 0x8816
+#define GL_INTENSITY_FLOAT32_APPLE 0x8817
+#define GL_LUMINANCE_FLOAT32_APPLE 0x8818
+#define GL_LUMINANCE_ALPHA_FLOAT32_APPLE 0x8819
+#define GL_RGBA_FLOAT16_APPLE 0x881A
+#define GL_RGB_FLOAT16_APPLE 0x881B
+#define GL_ALPHA_FLOAT16_APPLE 0x881C
+#define GL_INTENSITY_FLOAT16_APPLE 0x881D
+#define GL_LUMINANCE_FLOAT16_APPLE 0x881E
+#define GL_LUMINANCE_ALPHA_FLOAT16_APPLE 0x881F
+#define GL_COLOR_FLOAT_APPLE 0x8A0F
+
+#define GLEW_APPLE_float_pixels GLEW_GET_VAR(__GLEW_APPLE_float_pixels)
+
+#endif /* GL_APPLE_float_pixels */
+
+    /* ---------------------- GL_APPLE_flush_buffer_range ---------------------- */
+
+#ifndef GL_APPLE_flush_buffer_range
+#define GL_APPLE_flush_buffer_range 1
+
+#define GL_BUFFER_SERIALIZED_MODIFY_APPLE 0x8A12
+#define GL_BUFFER_FLUSHING_UNMAP_APPLE 0x8A13
+
+    typedef void (GLAPIENTRY *PFNGLBUFFERPARAMETERIAPPLEPROC)(GLenum target, GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC)(GLenum target, GLintptr offset, GLsizeiptr size);
+
+#define glBufferParameteriAPPLE GLEW_GET_FUN(__glewBufferParameteriAPPLE)
+#define glFlushMappedBufferRangeAPPLE GLEW_GET_FUN(__glewFlushMappedBufferRangeAPPLE)
+
+#define GLEW_APPLE_flush_buffer_range GLEW_GET_VAR(__GLEW_APPLE_flush_buffer_range)
+
+#endif /* GL_APPLE_flush_buffer_range */
+
+    /* ----------------------- GL_APPLE_object_purgeable ----------------------- */
+
+#ifndef GL_APPLE_object_purgeable
+#define GL_APPLE_object_purgeable 1
+
+#define GL_BUFFER_OBJECT_APPLE 0x85B3
+#define GL_RELEASED_APPLE 0x8A19
+#define GL_VOLATILE_APPLE 0x8A1A
+#define GL_RETAINED_APPLE 0x8A1B
+#define GL_UNDEFINED_APPLE 0x8A1C
+#define GL_PURGEABLE_APPLE 0x8A1D
+
+    typedef void (GLAPIENTRY *PFNGLGETOBJECTPARAMETERIVAPPLEPROC)(GLenum objectType, GLuint name, GLenum pname, GLint *params);
+    typedef GLenum(GLAPIENTRY *PFNGLOBJECTPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name, GLenum option);
+    typedef GLenum(GLAPIENTRY *PFNGLOBJECTUNPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name, GLenum option);
+
+#define glGetObjectParameterivAPPLE GLEW_GET_FUN(__glewGetObjectParameterivAPPLE)
+#define glObjectPurgeableAPPLE GLEW_GET_FUN(__glewObjectPurgeableAPPLE)
+#define glObjectUnpurgeableAPPLE GLEW_GET_FUN(__glewObjectUnpurgeableAPPLE)
+
+#define GLEW_APPLE_object_purgeable GLEW_GET_VAR(__GLEW_APPLE_object_purgeable)
+
+#endif /* GL_APPLE_object_purgeable */
+
+    /* ------------------------- GL_APPLE_pixel_buffer ------------------------- */
+
+#ifndef GL_APPLE_pixel_buffer
+#define GL_APPLE_pixel_buffer 1
+
+#define GL_MIN_PBUFFER_VIEWPORT_DIMS_APPLE 0x8A10
+
+#define GLEW_APPLE_pixel_buffer GLEW_GET_VAR(__GLEW_APPLE_pixel_buffer)
+
+#endif /* GL_APPLE_pixel_buffer */
+
+    /* ---------------------------- GL_APPLE_rgb_422 --------------------------- */
+
+#ifndef GL_APPLE_rgb_422
+#define GL_APPLE_rgb_422 1
+
+#define GL_UNSIGNED_SHORT_8_8_APPLE 0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_APPLE 0x85BB
+#define GL_RGB_422_APPLE 0x8A1F
+
+#define GLEW_APPLE_rgb_422 GLEW_GET_VAR(__GLEW_APPLE_rgb_422)
+
+#endif /* GL_APPLE_rgb_422 */
+
+    /* --------------------------- GL_APPLE_row_bytes -------------------------- */
+
+#ifndef GL_APPLE_row_bytes
+#define GL_APPLE_row_bytes 1
+
+#define GL_PACK_ROW_BYTES_APPLE 0x8A15
+#define GL_UNPACK_ROW_BYTES_APPLE 0x8A16
+
+#define GLEW_APPLE_row_bytes GLEW_GET_VAR(__GLEW_APPLE_row_bytes)
+
+#endif /* GL_APPLE_row_bytes */
+
+    /* ------------------------ GL_APPLE_specular_vector ----------------------- */
+
+#ifndef GL_APPLE_specular_vector
+#define GL_APPLE_specular_vector 1
+
+#define GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE 0x85B0
+
+#define GLEW_APPLE_specular_vector GLEW_GET_VAR(__GLEW_APPLE_specular_vector)
+
+#endif /* GL_APPLE_specular_vector */
+
+    /* ------------------------- GL_APPLE_texture_range ------------------------ */
+
+#ifndef GL_APPLE_texture_range
+#define GL_APPLE_texture_range 1
+
+#define GL_TEXTURE_RANGE_LENGTH_APPLE 0x85B7
+#define GL_TEXTURE_RANGE_POINTER_APPLE 0x85B8
+#define GL_TEXTURE_STORAGE_HINT_APPLE 0x85BC
+#define GL_STORAGE_PRIVATE_APPLE 0x85BD
+#define GL_STORAGE_CACHED_APPLE 0x85BE
+#define GL_STORAGE_SHARED_APPLE 0x85BF
+
+    typedef void (GLAPIENTRY *PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC)(GLenum target, GLenum pname, GLvoid **params);
+    typedef void (GLAPIENTRY *PFNGLTEXTURERANGEAPPLEPROC)(GLenum target, GLsizei length, GLvoid *pointer);
+
+#define glGetTexParameterPointervAPPLE GLEW_GET_FUN(__glewGetTexParameterPointervAPPLE)
+#define glTextureRangeAPPLE GLEW_GET_FUN(__glewTextureRangeAPPLE)
+
+#define GLEW_APPLE_texture_range GLEW_GET_VAR(__GLEW_APPLE_texture_range)
+
+#endif /* GL_APPLE_texture_range */
+
+    /* ------------------------ GL_APPLE_transform_hint ------------------------ */
+
+#ifndef GL_APPLE_transform_hint
+#define GL_APPLE_transform_hint 1
+
+#define GL_TRANSFORM_HINT_APPLE 0x85B1
+
+#define GLEW_APPLE_transform_hint GLEW_GET_VAR(__GLEW_APPLE_transform_hint)
+
+#endif /* GL_APPLE_transform_hint */
+
+    /* ---------------------- GL_APPLE_vertex_array_object --------------------- */
+
+#ifndef GL_APPLE_vertex_array_object
+#define GL_APPLE_vertex_array_object 1
+
+#define GL_VERTEX_ARRAY_BINDING_APPLE 0x85B5
+
+    typedef void (GLAPIENTRY *PFNGLBINDVERTEXARRAYAPPLEPROC)(GLuint array);
+    typedef void (GLAPIENTRY *PFNGLDELETEVERTEXARRAYSAPPLEPROC)(GLsizei n, const GLuint *arrays);
+    typedef void (GLAPIENTRY *PFNGLGENVERTEXARRAYSAPPLEPROC)(GLsizei n, const GLuint *arrays);
+    typedef GLboolean(GLAPIENTRY *PFNGLISVERTEXARRAYAPPLEPROC)(GLuint array);
+
+#define glBindVertexArrayAPPLE GLEW_GET_FUN(__glewBindVertexArrayAPPLE)
+#define glDeleteVertexArraysAPPLE GLEW_GET_FUN(__glewDeleteVertexArraysAPPLE)
+#define glGenVertexArraysAPPLE GLEW_GET_FUN(__glewGenVertexArraysAPPLE)
+#define glIsVertexArrayAPPLE GLEW_GET_FUN(__glewIsVertexArrayAPPLE)
+
+#define GLEW_APPLE_vertex_array_object GLEW_GET_VAR(__GLEW_APPLE_vertex_array_object)
+
+#endif /* GL_APPLE_vertex_array_object */
+
+    /* ---------------------- GL_APPLE_vertex_array_range ---------------------- */
+
+#ifndef GL_APPLE_vertex_array_range
+#define GL_APPLE_vertex_array_range 1
+
+#define GL_VERTEX_ARRAY_RANGE_APPLE 0x851D
+#define GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE 0x851E
+#define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE 0x851F
+#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_APPLE 0x8520
+#define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE 0x8521
+#define GL_STORAGE_CACHED_APPLE 0x85BE
+#define GL_STORAGE_SHARED_APPLE 0x85BF
+
+    typedef void (GLAPIENTRY *PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void *pointer);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)(GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void *pointer);
+
+#define glFlushVertexArrayRangeAPPLE GLEW_GET_FUN(__glewFlushVertexArrayRangeAPPLE)
+#define glVertexArrayParameteriAPPLE GLEW_GET_FUN(__glewVertexArrayParameteriAPPLE)
+#define glVertexArrayRangeAPPLE GLEW_GET_FUN(__glewVertexArrayRangeAPPLE)
+
+#define GLEW_APPLE_vertex_array_range GLEW_GET_VAR(__GLEW_APPLE_vertex_array_range)
+
+#endif /* GL_APPLE_vertex_array_range */
+
+    /* ------------------- GL_APPLE_vertex_program_evaluators ------------------ */
+
+#ifndef GL_APPLE_vertex_program_evaluators
+#define GL_APPLE_vertex_program_evaluators 1
+
+#define GL_VERTEX_ATTRIB_MAP1_APPLE 0x8A00
+#define GL_VERTEX_ATTRIB_MAP2_APPLE 0x8A01
+#define GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE 0x8A02
+#define GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE 0x8A03
+#define GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE 0x8A04
+#define GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE 0x8A05
+#define GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE 0x8A06
+#define GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE 0x8A07
+#define GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE 0x8A08
+#define GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE 0x8A09
+
+    typedef void (GLAPIENTRY *PFNGLDISABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
+    typedef void (GLAPIENTRY *PFNGLENABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
+    typedef GLboolean(GLAPIENTRY *PFNGLISVERTEXATTRIBENABLEDAPPLEPROC)(GLuint index, GLenum pname);
+    typedef void (GLAPIENTRY *PFNGLMAPVERTEXATTRIB1DAPPLEPROC)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
+    typedef void (GLAPIENTRY *PFNGLMAPVERTEXATTRIB1FAPPLEPROC)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
+    typedef void (GLAPIENTRY *PFNGLMAPVERTEXATTRIB2DAPPLEPROC)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
+    typedef void (GLAPIENTRY *PFNGLMAPVERTEXATTRIB2FAPPLEPROC)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
+
+#define glDisableVertexAttribAPPLE GLEW_GET_FUN(__glewDisableVertexAttribAPPLE)
+#define glEnableVertexAttribAPPLE GLEW_GET_FUN(__glewEnableVertexAttribAPPLE)
+#define glIsVertexAttribEnabledAPPLE GLEW_GET_FUN(__glewIsVertexAttribEnabledAPPLE)
+#define glMapVertexAttrib1dAPPLE GLEW_GET_FUN(__glewMapVertexAttrib1dAPPLE)
+#define glMapVertexAttrib1fAPPLE GLEW_GET_FUN(__glewMapVertexAttrib1fAPPLE)
+#define glMapVertexAttrib2dAPPLE GLEW_GET_FUN(__glewMapVertexAttrib2dAPPLE)
+#define glMapVertexAttrib2fAPPLE GLEW_GET_FUN(__glewMapVertexAttrib2fAPPLE)
+
+#define GLEW_APPLE_vertex_program_evaluators GLEW_GET_VAR(__GLEW_APPLE_vertex_program_evaluators)
+
+#endif /* GL_APPLE_vertex_program_evaluators */
+
+    /* --------------------------- GL_APPLE_ycbcr_422 -------------------------- */
+
+#ifndef GL_APPLE_ycbcr_422
+#define GL_APPLE_ycbcr_422 1
+
+#define GL_YCBCR_422_APPLE 0x85B9
+#define GL_UNSIGNED_SHORT_8_8_APPLE 0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_APPLE 0x85BB
+
+#define GLEW_APPLE_ycbcr_422 GLEW_GET_VAR(__GLEW_APPLE_ycbcr_422)
+
+#endif /* GL_APPLE_ycbcr_422 */
+
+    /* ----------------------- GL_ARB_blend_func_extended ---------------------- */
+
+#ifndef GL_ARB_blend_func_extended
+#define GL_ARB_blend_func_extended 1
+
+#define GL_SRC1_COLOR 0x88F9
+#define GL_ONE_MINUS_SRC1_COLOR 0x88FA
+#define GL_ONE_MINUS_SRC1_ALPHA 0x88FB
+#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 0x88FC
+
+    typedef void (GLAPIENTRY *PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const char *name);
+    typedef GLint(GLAPIENTRY *PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const char *name);
+
+#define glBindFragDataLocationIndexed GLEW_GET_FUN(__glewBindFragDataLocationIndexed)
+#define glGetFragDataIndex GLEW_GET_FUN(__glewGetFragDataIndex)
+
+#define GLEW_ARB_blend_func_extended GLEW_GET_VAR(__GLEW_ARB_blend_func_extended)
+
+#endif /* GL_ARB_blend_func_extended */
+
+    /* ----------------------- GL_ARB_color_buffer_float ----------------------- */
+
+#ifndef GL_ARB_color_buffer_float
+#define GL_ARB_color_buffer_float 1
+
+#define GL_RGBA_FLOAT_MODE_ARB 0x8820
+#define GL_CLAMP_VERTEX_COLOR_ARB 0x891A
+#define GL_CLAMP_FRAGMENT_COLOR_ARB 0x891B
+#define GL_CLAMP_READ_COLOR_ARB 0x891C
+#define GL_FIXED_ONLY_ARB 0x891D
+
+    typedef void (GLAPIENTRY *PFNGLCLAMPCOLORARBPROC)(GLenum target, GLenum clamp);
+
+#define glClampColorARB GLEW_GET_FUN(__glewClampColorARB)
+
+#define GLEW_ARB_color_buffer_float GLEW_GET_VAR(__GLEW_ARB_color_buffer_float)
+
+#endif /* GL_ARB_color_buffer_float */
+
+    /* -------------------------- GL_ARB_compatibility ------------------------- */
+
+#ifndef GL_ARB_compatibility
+#define GL_ARB_compatibility 1
+
+#define GLEW_ARB_compatibility GLEW_GET_VAR(__GLEW_ARB_compatibility)
+
+#endif /* GL_ARB_compatibility */
+
+    /* --------------------------- GL_ARB_copy_buffer -------------------------- */
+
+#ifndef GL_ARB_copy_buffer
+#define GL_ARB_copy_buffer 1
+
+#define GL_COPY_READ_BUFFER 0x8F36
+#define GL_COPY_WRITE_BUFFER 0x8F37
+
+    typedef void (GLAPIENTRY *PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
+
+#define glCopyBufferSubData GLEW_GET_FUN(__glewCopyBufferSubData)
+
+#define GLEW_ARB_copy_buffer GLEW_GET_VAR(__GLEW_ARB_copy_buffer)
+
+#endif /* GL_ARB_copy_buffer */
+
+    /* ----------------------- GL_ARB_depth_buffer_float ----------------------- */
+
+#ifndef GL_ARB_depth_buffer_float
+#define GL_ARB_depth_buffer_float 1
+
+#define GL_DEPTH_COMPONENT32F 0x8CAC
+#define GL_DEPTH32F_STENCIL8 0x8CAD
+#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
+
+#define GLEW_ARB_depth_buffer_float GLEW_GET_VAR(__GLEW_ARB_depth_buffer_float)
+
+#endif /* GL_ARB_depth_buffer_float */
+
+    /* --------------------------- GL_ARB_depth_clamp -------------------------- */
+
+#ifndef GL_ARB_depth_clamp
+#define GL_ARB_depth_clamp 1
+
+#define GL_DEPTH_CLAMP 0x864F
+
+#define GLEW_ARB_depth_clamp GLEW_GET_VAR(__GLEW_ARB_depth_clamp)
+
+#endif /* GL_ARB_depth_clamp */
+
+    /* -------------------------- GL_ARB_depth_texture ------------------------- */
+
+#ifndef GL_ARB_depth_texture
+#define GL_ARB_depth_texture 1
+
+#define GL_DEPTH_COMPONENT16_ARB 0x81A5
+#define GL_DEPTH_COMPONENT24_ARB 0x81A6
+#define GL_DEPTH_COMPONENT32_ARB 0x81A7
+#define GL_TEXTURE_DEPTH_SIZE_ARB 0x884A
+#define GL_DEPTH_TEXTURE_MODE_ARB 0x884B
+
+#define GLEW_ARB_depth_texture GLEW_GET_VAR(__GLEW_ARB_depth_texture)
+
+#endif /* GL_ARB_depth_texture */
+
+    /* -------------------------- GL_ARB_draw_buffers -------------------------- */
+
+#ifndef GL_ARB_draw_buffers
+#define GL_ARB_draw_buffers 1
+
+#define GL_MAX_DRAW_BUFFERS_ARB 0x8824
+#define GL_DRAW_BUFFER0_ARB 0x8825
+#define GL_DRAW_BUFFER1_ARB 0x8826
+#define GL_DRAW_BUFFER2_ARB 0x8827
+#define GL_DRAW_BUFFER3_ARB 0x8828
+#define GL_DRAW_BUFFER4_ARB 0x8829
+#define GL_DRAW_BUFFER5_ARB 0x882A
+#define GL_DRAW_BUFFER6_ARB 0x882B
+#define GL_DRAW_BUFFER7_ARB 0x882C
+#define GL_DRAW_BUFFER8_ARB 0x882D
+#define GL_DRAW_BUFFER9_ARB 0x882E
+#define GL_DRAW_BUFFER10_ARB 0x882F
+#define GL_DRAW_BUFFER11_ARB 0x8830
+#define GL_DRAW_BUFFER12_ARB 0x8831
+#define GL_DRAW_BUFFER13_ARB 0x8832
+#define GL_DRAW_BUFFER14_ARB 0x8833
+#define GL_DRAW_BUFFER15_ARB 0x8834
+
+    typedef void (GLAPIENTRY *PFNGLDRAWBUFFERSARBPROC)(GLsizei n, const GLenum *bufs);
+
+#define glDrawBuffersARB GLEW_GET_FUN(__glewDrawBuffersARB)
+
+#define GLEW_ARB_draw_buffers GLEW_GET_VAR(__GLEW_ARB_draw_buffers)
+
+#endif /* GL_ARB_draw_buffers */
+
+    /* ----------------------- GL_ARB_draw_buffers_blend ----------------------- */
+
+#ifndef GL_ARB_draw_buffers_blend
+#define GL_ARB_draw_buffers_blend 1
+
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONSEPARATEIARBPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONIARBPROC)(GLuint buf, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLBLENDFUNCSEPARATEIARBPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
+    typedef void (GLAPIENTRY *PFNGLBLENDFUNCIARBPROC)(GLuint buf, GLenum src, GLenum dst);
+
+#define glBlendEquationSeparateiARB GLEW_GET_FUN(__glewBlendEquationSeparateiARB)
+#define glBlendEquationiARB GLEW_GET_FUN(__glewBlendEquationiARB)
+#define glBlendFuncSeparateiARB GLEW_GET_FUN(__glewBlendFuncSeparateiARB)
+#define glBlendFunciARB GLEW_GET_FUN(__glewBlendFunciARB)
+
+#define GLEW_ARB_draw_buffers_blend GLEW_GET_VAR(__GLEW_ARB_draw_buffers_blend)
+
+#endif /* GL_ARB_draw_buffers_blend */
+
+    /* -------------------- GL_ARB_draw_elements_base_vertex ------------------- */
+
+#ifndef GL_ARB_draw_elements_base_vertex
+#define GL_ARB_draw_elements_base_vertex 1
+
+    typedef void (GLAPIENTRY *PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex);
+    typedef void (GLAPIENTRY *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex);
+    typedef void (GLAPIENTRY *PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex);
+    typedef void (GLAPIENTRY *PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei *count, GLenum type, GLvoid **indices, GLsizei primcount, GLint *basevertex);
+
+#define glDrawElementsBaseVertex GLEW_GET_FUN(__glewDrawElementsBaseVertex)
+#define glDrawElementsInstancedBaseVertex GLEW_GET_FUN(__glewDrawElementsInstancedBaseVertex)
+#define glDrawRangeElementsBaseVertex GLEW_GET_FUN(__glewDrawRangeElementsBaseVertex)
+#define glMultiDrawElementsBaseVertex GLEW_GET_FUN(__glewMultiDrawElementsBaseVertex)
+
+#define GLEW_ARB_draw_elements_base_vertex GLEW_GET_VAR(__GLEW_ARB_draw_elements_base_vertex)
+
+#endif /* GL_ARB_draw_elements_base_vertex */
+
+    /* -------------------------- GL_ARB_draw_indirect ------------------------- */
+
+#ifndef GL_ARB_draw_indirect
+#define GL_ARB_draw_indirect 1
+
+#define GL_DRAW_INDIRECT_BUFFER 0x8F3F
+#define GL_DRAW_INDIRECT_BUFFER_BINDING 0x8F43
+
+    typedef void (GLAPIENTRY *PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void *indirect);
+    typedef void (GLAPIENTRY *PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void *indirect);
+
+#define glDrawArraysIndirect GLEW_GET_FUN(__glewDrawArraysIndirect)
+#define glDrawElementsIndirect GLEW_GET_FUN(__glewDrawElementsIndirect)
+
+#define GLEW_ARB_draw_indirect GLEW_GET_VAR(__GLEW_ARB_draw_indirect)
+
+#endif /* GL_ARB_draw_indirect */
+
+    /* ------------------------- GL_ARB_draw_instanced ------------------------- */
+
+#ifndef GL_ARB_draw_instanced
+#define GL_ARB_draw_instanced 1
+
+    typedef void (GLAPIENTRY *PFNGLDRAWARRAYSINSTANCEDARBPROC)(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
+    typedef void (GLAPIENTRY *PFNGLDRAWELEMENTSINSTANCEDARBPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
+
+#define glDrawArraysInstancedARB GLEW_GET_FUN(__glewDrawArraysInstancedARB)
+#define glDrawElementsInstancedARB GLEW_GET_FUN(__glewDrawElementsInstancedARB)
+
+#define GLEW_ARB_draw_instanced GLEW_GET_VAR(__GLEW_ARB_draw_instanced)
+
+#endif /* GL_ARB_draw_instanced */
+
+    /* -------------------- GL_ARB_explicit_attrib_location -------------------- */
+
+#ifndef GL_ARB_explicit_attrib_location
+#define GL_ARB_explicit_attrib_location 1
+
+#define GLEW_ARB_explicit_attrib_location GLEW_GET_VAR(__GLEW_ARB_explicit_attrib_location)
+
+#endif /* GL_ARB_explicit_attrib_location */
+
+    /* ------------------- GL_ARB_fragment_coord_conventions ------------------- */
+
+#ifndef GL_ARB_fragment_coord_conventions
+#define GL_ARB_fragment_coord_conventions 1
+
+#define GLEW_ARB_fragment_coord_conventions GLEW_GET_VAR(__GLEW_ARB_fragment_coord_conventions)
+
+#endif /* GL_ARB_fragment_coord_conventions */
+
+    /* ------------------------ GL_ARB_fragment_program ------------------------ */
+
+#ifndef GL_ARB_fragment_program
+#define GL_ARB_fragment_program 1
+
+#define GL_FRAGMENT_PROGRAM_ARB 0x8804
+#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB 0x8805
+#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB 0x8806
+#define GL_PROGRAM_TEX_INDIRECTIONS_ARB 0x8807
+#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x8808
+#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x8809
+#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x880A
+#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB 0x880B
+#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB 0x880C
+#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB 0x880D
+#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x880E
+#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x880F
+#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x8810
+#define GL_MAX_TEXTURE_COORDS_ARB 0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB 0x8872
+
+#define GLEW_ARB_fragment_program GLEW_GET_VAR(__GLEW_ARB_fragment_program)
+
+#endif /* GL_ARB_fragment_program */
+
+    /* --------------------- GL_ARB_fragment_program_shadow -------------------- */
+
+#ifndef GL_ARB_fragment_program_shadow
+#define GL_ARB_fragment_program_shadow 1
+
+#define GLEW_ARB_fragment_program_shadow GLEW_GET_VAR(__GLEW_ARB_fragment_program_shadow)
+
+#endif /* GL_ARB_fragment_program_shadow */
+
+    /* ------------------------- GL_ARB_fragment_shader ------------------------ */
+
+#ifndef GL_ARB_fragment_shader
+#define GL_ARB_fragment_shader 1
+
+#define GL_FRAGMENT_SHADER_ARB 0x8B30
+#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB 0x8B49
+#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB 0x8B8B
+
+#define GLEW_ARB_fragment_shader GLEW_GET_VAR(__GLEW_ARB_fragment_shader)
+
+#endif /* GL_ARB_fragment_shader */
+
+    /* ----------------------- GL_ARB_framebuffer_object ----------------------- */
+
+#ifndef GL_ARB_framebuffer_object
+#define GL_ARB_framebuffer_object 1
+
+#define GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
+#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
+#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
+#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
+#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
+#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
+#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
+#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
+#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
+#define GL_FRAMEBUFFER_DEFAULT 0x8218
+#define GL_FRAMEBUFFER_UNDEFINED 0x8219
+#define GL_DEPTH_STENCIL_ATTACHMENT 0x821A
+#define GL_INDEX 0x8222
+#define GL_MAX_RENDERBUFFER_SIZE 0x84E8
+#define GL_DEPTH_STENCIL 0x84F9
+#define GL_UNSIGNED_INT_24_8 0x84FA
+#define GL_DEPTH24_STENCIL8 0x88F0
+#define GL_TEXTURE_STENCIL_SIZE 0x88F1
+#define GL_UNSIGNED_NORMALIZED 0x8C17
+#define GL_SRGB 0x8C40
+#define GL_DRAW_FRAMEBUFFER_BINDING 0x8CA6
+#define GL_FRAMEBUFFER_BINDING 0x8CA6
+#define GL_RENDERBUFFER_BINDING 0x8CA7
+#define GL_READ_FRAMEBUFFER 0x8CA8
+#define GL_DRAW_FRAMEBUFFER 0x8CA9
+#define GL_READ_FRAMEBUFFER_BINDING 0x8CAA
+#define GL_RENDERBUFFER_SAMPLES 0x8CAB
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
+#define GL_FRAMEBUFFER_COMPLETE 0x8CD5
+#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
+#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
+#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
+#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
+#define GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD
+#define GL_MAX_COLOR_ATTACHMENTS 0x8CDF
+#define GL_COLOR_ATTACHMENT0 0x8CE0
+#define GL_COLOR_ATTACHMENT1 0x8CE1
+#define GL_COLOR_ATTACHMENT2 0x8CE2
+#define GL_COLOR_ATTACHMENT3 0x8CE3
+#define GL_COLOR_ATTACHMENT4 0x8CE4
+#define GL_COLOR_ATTACHMENT5 0x8CE5
+#define GL_COLOR_ATTACHMENT6 0x8CE6
+#define GL_COLOR_ATTACHMENT7 0x8CE7
+#define GL_COLOR_ATTACHMENT8 0x8CE8
+#define GL_COLOR_ATTACHMENT9 0x8CE9
+#define GL_COLOR_ATTACHMENT10 0x8CEA
+#define GL_COLOR_ATTACHMENT11 0x8CEB
+#define GL_COLOR_ATTACHMENT12 0x8CEC
+#define GL_COLOR_ATTACHMENT13 0x8CED
+#define GL_COLOR_ATTACHMENT14 0x8CEE
+#define GL_COLOR_ATTACHMENT15 0x8CEF
+#define GL_DEPTH_ATTACHMENT 0x8D00
+#define GL_STENCIL_ATTACHMENT 0x8D20
+#define GL_FRAMEBUFFER 0x8D40
+#define GL_RENDERBUFFER 0x8D41
+#define GL_RENDERBUFFER_WIDTH 0x8D42
+#define GL_RENDERBUFFER_HEIGHT 0x8D43
+#define GL_RENDERBUFFER_INTERNAL_FORMAT 0x8D44
+#define GL_STENCIL_INDEX1 0x8D46
+#define GL_STENCIL_INDEX4 0x8D47
+#define GL_STENCIL_INDEX8 0x8D48
+#define GL_STENCIL_INDEX16 0x8D49
+#define GL_RENDERBUFFER_RED_SIZE 0x8D50
+#define GL_RENDERBUFFER_GREEN_SIZE 0x8D51
+#define GL_RENDERBUFFER_BLUE_SIZE 0x8D52
+#define GL_RENDERBUFFER_ALPHA_SIZE 0x8D53
+#define GL_RENDERBUFFER_DEPTH_SIZE 0x8D54
+#define GL_RENDERBUFFER_STENCIL_SIZE 0x8D55
+#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
+#define GL_MAX_SAMPLES 0x8D57
+
+    typedef void (GLAPIENTRY *PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
+    typedef void (GLAPIENTRY *PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
+    typedef void (GLAPIENTRY *PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+    typedef GLenum(GLAPIENTRY *PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint *framebuffers);
+    typedef void (GLAPIENTRY *PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint *renderbuffers);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
+    typedef void (GLAPIENTRY *PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint *framebuffers);
+    typedef void (GLAPIENTRY *PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint *renderbuffers);
+    typedef void (GLAPIENTRY *PFNGLGENERATEMIPMAPPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
+    typedef GLboolean(GLAPIENTRY *PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
+    typedef void (GLAPIENTRY *PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
+
+#define glBindFramebuffer GLEW_GET_FUN(__glewBindFramebuffer)
+#define glBindRenderbuffer GLEW_GET_FUN(__glewBindRenderbuffer)
+#define glBlitFramebuffer GLEW_GET_FUN(__glewBlitFramebuffer)
+#define glCheckFramebufferStatus GLEW_GET_FUN(__glewCheckFramebufferStatus)
+#define glDeleteFramebuffers GLEW_GET_FUN(__glewDeleteFramebuffers)
+#define glDeleteRenderbuffers GLEW_GET_FUN(__glewDeleteRenderbuffers)
+#define glFramebufferRenderbuffer GLEW_GET_FUN(__glewFramebufferRenderbuffer)
+#define glFramebufferTexture1D GLEW_GET_FUN(__glewFramebufferTexture1D)
+#define glFramebufferTexture2D GLEW_GET_FUN(__glewFramebufferTexture2D)
+#define glFramebufferTexture3D GLEW_GET_FUN(__glewFramebufferTexture3D)
+#define glFramebufferTextureLayer GLEW_GET_FUN(__glewFramebufferTextureLayer)
+#define glGenFramebuffers GLEW_GET_FUN(__glewGenFramebuffers)
+#define glGenRenderbuffers GLEW_GET_FUN(__glewGenRenderbuffers)
+#define glGenerateMipmap GLEW_GET_FUN(__glewGenerateMipmap)
+#define glGetFramebufferAttachmentParameteriv GLEW_GET_FUN(__glewGetFramebufferAttachmentParameteriv)
+#define glGetRenderbufferParameteriv GLEW_GET_FUN(__glewGetRenderbufferParameteriv)
+#define glIsFramebuffer GLEW_GET_FUN(__glewIsFramebuffer)
+#define glIsRenderbuffer GLEW_GET_FUN(__glewIsRenderbuffer)
+#define glRenderbufferStorage GLEW_GET_FUN(__glewRenderbufferStorage)
+#define glRenderbufferStorageMultisample GLEW_GET_FUN(__glewRenderbufferStorageMultisample)
+
+#define GLEW_ARB_framebuffer_object GLEW_GET_VAR(__GLEW_ARB_framebuffer_object)
+
+#endif /* GL_ARB_framebuffer_object */
+
+    /* ------------------------ GL_ARB_framebuffer_sRGB ------------------------ */
+
+#ifndef GL_ARB_framebuffer_sRGB
+#define GL_ARB_framebuffer_sRGB 1
+
+#define GL_FRAMEBUFFER_SRGB 0x8DB9
+
+#define GLEW_ARB_framebuffer_sRGB GLEW_GET_VAR(__GLEW_ARB_framebuffer_sRGB)
+
+#endif /* GL_ARB_framebuffer_sRGB */
+
+    /* ------------------------ GL_ARB_geometry_shader4 ------------------------ */
+
+#ifndef GL_ARB_geometry_shader4
+#define GL_ARB_geometry_shader4 1
+
+#define GL_LINES_ADJACENCY_ARB 0xA
+#define GL_LINE_STRIP_ADJACENCY_ARB 0xB
+#define GL_TRIANGLES_ADJACENCY_ARB 0xC
+#define GL_TRIANGLE_STRIP_ADJACENCY_ARB 0xD
+#define GL_PROGRAM_POINT_SIZE_ARB 0x8642
+#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB 0x8C29
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
+#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB 0x8DA7
+#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB 0x8DA8
+#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB 0x8DA9
+#define GL_GEOMETRY_SHADER_ARB 0x8DD9
+#define GL_GEOMETRY_VERTICES_OUT_ARB 0x8DDA
+#define GL_GEOMETRY_INPUT_TYPE_ARB 0x8DDB
+#define GL_GEOMETRY_OUTPUT_TYPE_ARB 0x8DDC
+#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB 0x8DDD
+#define GL_MAX_VERTEX_VARYING_COMPONENTS_ARB 0x8DDE
+#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB 0x8DDF
+#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB 0x8DE0
+#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB 0x8DE1
+
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTUREARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTUREFACEARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURELAYERARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMPARAMETERIARBPROC)(GLuint program, GLenum pname, GLint value);
+
+#define glFramebufferTextureARB GLEW_GET_FUN(__glewFramebufferTextureARB)
+#define glFramebufferTextureFaceARB GLEW_GET_FUN(__glewFramebufferTextureFaceARB)
+#define glFramebufferTextureLayerARB GLEW_GET_FUN(__glewFramebufferTextureLayerARB)
+#define glProgramParameteriARB GLEW_GET_FUN(__glewProgramParameteriARB)
+
+#define GLEW_ARB_geometry_shader4 GLEW_GET_VAR(__GLEW_ARB_geometry_shader4)
+
+#endif /* GL_ARB_geometry_shader4 */
+
+    /* --------------------------- GL_ARB_gpu_shader5 -------------------------- */
+
+#ifndef GL_ARB_gpu_shader5
+#define GL_ARB_gpu_shader5 1
+
+#define GL_GEOMETRY_SHADER_INVOCATIONS 0x887F
+#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
+#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
+#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
+#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
+#define GL_MAX_VERTEX_STREAMS 0x8E71
+
+#define GLEW_ARB_gpu_shader5 GLEW_GET_VAR(__GLEW_ARB_gpu_shader5)
+
+#endif /* GL_ARB_gpu_shader5 */
+
+    /* ------------------------- GL_ARB_gpu_shader_fp64 ------------------------ */
+
+#ifndef GL_ARB_gpu_shader_fp64
+#define GL_ARB_gpu_shader_fp64 1
+
+#define GLEW_ARB_gpu_shader_fp64 GLEW_GET_VAR(__GLEW_ARB_gpu_shader_fp64)
+
+#endif /* GL_ARB_gpu_shader_fp64 */
+
+    /* ------------------------ GL_ARB_half_float_pixel ------------------------ */
+
+#ifndef GL_ARB_half_float_pixel
+#define GL_ARB_half_float_pixel 1
+
+#define GL_HALF_FLOAT_ARB 0x140B
+
+#define GLEW_ARB_half_float_pixel GLEW_GET_VAR(__GLEW_ARB_half_float_pixel)
+
+#endif /* GL_ARB_half_float_pixel */
+
+    /* ------------------------ GL_ARB_half_float_vertex ----------------------- */
+
+#ifndef GL_ARB_half_float_vertex
+#define GL_ARB_half_float_vertex 1
+
+#define GL_HALF_FLOAT 0x140B
+
+#define GLEW_ARB_half_float_vertex GLEW_GET_VAR(__GLEW_ARB_half_float_vertex)
+
+#endif /* GL_ARB_half_float_vertex */
+
+    /* ----------------------------- GL_ARB_imaging ---------------------------- */
+
+#ifndef GL_ARB_imaging
+#define GL_ARB_imaging 1
+
+#define GL_CONSTANT_COLOR 0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR 0x8002
+#define GL_CONSTANT_ALPHA 0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
+#define GL_BLEND_COLOR 0x8005
+#define GL_FUNC_ADD 0x8006
+#define GL_MIN 0x8007
+#define GL_MAX 0x8008
+#define GL_BLEND_EQUATION 0x8009
+#define GL_FUNC_SUBTRACT 0x800A
+#define GL_FUNC_REVERSE_SUBTRACT 0x800B
+#define GL_CONVOLUTION_1D 0x8010
+#define GL_CONVOLUTION_2D 0x8011
+#define GL_SEPARABLE_2D 0x8012
+#define GL_CONVOLUTION_BORDER_MODE 0x8013
+#define GL_CONVOLUTION_FILTER_SCALE 0x8014
+#define GL_CONVOLUTION_FILTER_BIAS 0x8015
+#define GL_REDUCE 0x8016
+#define GL_CONVOLUTION_FORMAT 0x8017
+#define GL_CONVOLUTION_WIDTH 0x8018
+#define GL_CONVOLUTION_HEIGHT 0x8019
+#define GL_MAX_CONVOLUTION_WIDTH 0x801A
+#define GL_MAX_CONVOLUTION_HEIGHT 0x801B
+#define GL_POST_CONVOLUTION_RED_SCALE 0x801C
+#define GL_POST_CONVOLUTION_GREEN_SCALE 0x801D
+#define GL_POST_CONVOLUTION_BLUE_SCALE 0x801E
+#define GL_POST_CONVOLUTION_ALPHA_SCALE 0x801F
+#define GL_POST_CONVOLUTION_RED_BIAS 0x8020
+#define GL_POST_CONVOLUTION_GREEN_BIAS 0x8021
+#define GL_POST_CONVOLUTION_BLUE_BIAS 0x8022
+#define GL_POST_CONVOLUTION_ALPHA_BIAS 0x8023
+#define GL_HISTOGRAM 0x8024
+#define GL_PROXY_HISTOGRAM 0x8025
+#define GL_HISTOGRAM_WIDTH 0x8026
+#define GL_HISTOGRAM_FORMAT 0x8027
+#define GL_HISTOGRAM_RED_SIZE 0x8028
+#define GL_HISTOGRAM_GREEN_SIZE 0x8029
+#define GL_HISTOGRAM_BLUE_SIZE 0x802A
+#define GL_HISTOGRAM_ALPHA_SIZE 0x802B
+#define GL_HISTOGRAM_LUMINANCE_SIZE 0x802C
+#define GL_HISTOGRAM_SINK 0x802D
+#define GL_MINMAX 0x802E
+#define GL_MINMAX_FORMAT 0x802F
+#define GL_MINMAX_SINK 0x8030
+#define GL_TABLE_TOO_LARGE 0x8031
+#define GL_COLOR_MATRIX 0x80B1
+#define GL_COLOR_MATRIX_STACK_DEPTH 0x80B2
+#define GL_MAX_COLOR_MATRIX_STACK_DEPTH 0x80B3
+#define GL_POST_COLOR_MATRIX_RED_SCALE 0x80B4
+#define GL_POST_COLOR_MATRIX_GREEN_SCALE 0x80B5
+#define GL_POST_COLOR_MATRIX_BLUE_SCALE 0x80B6
+#define GL_POST_COLOR_MATRIX_ALPHA_SCALE 0x80B7
+#define GL_POST_COLOR_MATRIX_RED_BIAS 0x80B8
+#define GL_POST_COLOR_MATRIX_GREEN_BIAS 0x80B9
+#define GL_POST_COLOR_MATRIX_BLUE_BIAS 0x80BA
+#define GL_POST_COLOR_MATRIX_ALPHA_BIAS 0x80BB
+#define GL_COLOR_TABLE 0x80D0
+#define GL_POST_CONVOLUTION_COLOR_TABLE 0x80D1
+#define GL_POST_COLOR_MATRIX_COLOR_TABLE 0x80D2
+#define GL_PROXY_COLOR_TABLE 0x80D3
+#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE 0x80D4
+#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE 0x80D5
+#define GL_COLOR_TABLE_SCALE 0x80D6
+#define GL_COLOR_TABLE_BIAS 0x80D7
+#define GL_COLOR_TABLE_FORMAT 0x80D8
+#define GL_COLOR_TABLE_WIDTH 0x80D9
+#define GL_COLOR_TABLE_RED_SIZE 0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE 0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE 0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE 0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE 0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE 0x80DF
+#define GL_IGNORE_BORDER 0x8150
+#define GL_CONSTANT_BORDER 0x8151
+#define GL_WRAP_BORDER 0x8152
+#define GL_REPLICATE_BORDER 0x8153
+#define GL_CONVOLUTION_BORDER_COLOR 0x8154
+
+    typedef void (GLAPIENTRY *PFNGLCOLORSUBTABLEPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLCOLORTABLEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+    typedef void (GLAPIENTRY *PFNGLCOLORTABLEPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLCOLORTABLEPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONFILTER1DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONFILTER2DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat params);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONPARAMETERIPROC)(GLenum target, GLenum pname, GLint params);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLCOPYCOLORSUBTABLEPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
+    typedef void (GLAPIENTRY *PFNGLCOPYCOLORTABLEPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+    typedef void (GLAPIENTRY *PFNGLCOPYCONVOLUTIONFILTER1DPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+    typedef void (GLAPIENTRY *PFNGLCOPYCONVOLUTIONFILTER2DPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLEPROC)(GLenum target, GLenum format, GLenum type, GLvoid *table);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLEPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLEPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETCONVOLUTIONFILTERPROC)(GLenum target, GLenum format, GLenum type, GLvoid *image);
+    typedef void (GLAPIENTRY *PFNGLGETCONVOLUTIONPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETCONVOLUTIONPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETHISTOGRAMPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+    typedef void (GLAPIENTRY *PFNGLGETHISTOGRAMPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETHISTOGRAMPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETMINMAXPROC)(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values);
+    typedef void (GLAPIENTRY *PFNGLGETMINMAXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETMINMAXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETSEPARABLEFILTERPROC)(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
+    typedef void (GLAPIENTRY *PFNGLHISTOGRAMPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
+    typedef void (GLAPIENTRY *PFNGLMINMAXPROC)(GLenum target, GLenum internalformat, GLboolean sink);
+    typedef void (GLAPIENTRY *PFNGLRESETHISTOGRAMPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLRESETMINMAXPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLSEPARABLEFILTER2DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
+
+#define glColorSubTable GLEW_GET_FUN(__glewColorSubTable)
+#define glColorTable GLEW_GET_FUN(__glewColorTable)
+#define glColorTableParameterfv GLEW_GET_FUN(__glewColorTableParameterfv)
+#define glColorTableParameteriv GLEW_GET_FUN(__glewColorTableParameteriv)
+#define glConvolutionFilter1D GLEW_GET_FUN(__glewConvolutionFilter1D)
+#define glConvolutionFilter2D GLEW_GET_FUN(__glewConvolutionFilter2D)
+#define glConvolutionParameterf GLEW_GET_FUN(__glewConvolutionParameterf)
+#define glConvolutionParameterfv GLEW_GET_FUN(__glewConvolutionParameterfv)
+#define glConvolutionParameteri GLEW_GET_FUN(__glewConvolutionParameteri)
+#define glConvolutionParameteriv GLEW_GET_FUN(__glewConvolutionParameteriv)
+#define glCopyColorSubTable GLEW_GET_FUN(__glewCopyColorSubTable)
+#define glCopyColorTable GLEW_GET_FUN(__glewCopyColorTable)
+#define glCopyConvolutionFilter1D GLEW_GET_FUN(__glewCopyConvolutionFilter1D)
+#define glCopyConvolutionFilter2D GLEW_GET_FUN(__glewCopyConvolutionFilter2D)
+#define glGetColorTable GLEW_GET_FUN(__glewGetColorTable)
+#define glGetColorTableParameterfv GLEW_GET_FUN(__glewGetColorTableParameterfv)
+#define glGetColorTableParameteriv GLEW_GET_FUN(__glewGetColorTableParameteriv)
+#define glGetConvolutionFilter GLEW_GET_FUN(__glewGetConvolutionFilter)
+#define glGetConvolutionParameterfv GLEW_GET_FUN(__glewGetConvolutionParameterfv)
+#define glGetConvolutionParameteriv GLEW_GET_FUN(__glewGetConvolutionParameteriv)
+#define glGetHistogram GLEW_GET_FUN(__glewGetHistogram)
+#define glGetHistogramParameterfv GLEW_GET_FUN(__glewGetHistogramParameterfv)
+#define glGetHistogramParameteriv GLEW_GET_FUN(__glewGetHistogramParameteriv)
+#define glGetMinmax GLEW_GET_FUN(__glewGetMinmax)
+#define glGetMinmaxParameterfv GLEW_GET_FUN(__glewGetMinmaxParameterfv)
+#define glGetMinmaxParameteriv GLEW_GET_FUN(__glewGetMinmaxParameteriv)
+#define glGetSeparableFilter GLEW_GET_FUN(__glewGetSeparableFilter)
+#define glHistogram GLEW_GET_FUN(__glewHistogram)
+#define glMinmax GLEW_GET_FUN(__glewMinmax)
+#define glResetHistogram GLEW_GET_FUN(__glewResetHistogram)
+#define glResetMinmax GLEW_GET_FUN(__glewResetMinmax)
+#define glSeparableFilter2D GLEW_GET_FUN(__glewSeparableFilter2D)
+
+#define GLEW_ARB_imaging GLEW_GET_VAR(__GLEW_ARB_imaging)
+
+#endif /* GL_ARB_imaging */
+
+    /* ------------------------ GL_ARB_instanced_arrays ------------------------ */
+
+#ifndef GL_ARB_instanced_arrays
+#define GL_ARB_instanced_arrays 1
+
+#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB 0x88FE
+
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBDIVISORARBPROC)(GLuint index, GLuint divisor);
+
+#define glVertexAttribDivisorARB GLEW_GET_FUN(__glewVertexAttribDivisorARB)
+
+#define GLEW_ARB_instanced_arrays GLEW_GET_VAR(__GLEW_ARB_instanced_arrays)
+
+#endif /* GL_ARB_instanced_arrays */
+
+    /* ------------------------ GL_ARB_map_buffer_range ------------------------ */
+
+#ifndef GL_ARB_map_buffer_range
+#define GL_ARB_map_buffer_range 1
+
+#define GL_MAP_READ_BIT 0x0001
+#define GL_MAP_WRITE_BIT 0x0002
+#define GL_MAP_INVALIDATE_RANGE_BIT 0x0004
+#define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
+#define GL_MAP_FLUSH_EXPLICIT_BIT 0x0010
+#define GL_MAP_UNSYNCHRONIZED_BIT 0x0020
+
+    typedef void (GLAPIENTRY *PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
+    typedef GLvoid *(GLAPIENTRY *PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
+
+#define glFlushMappedBufferRange GLEW_GET_FUN(__glewFlushMappedBufferRange)
+#define glMapBufferRange GLEW_GET_FUN(__glewMapBufferRange)
+
+#define GLEW_ARB_map_buffer_range GLEW_GET_VAR(__GLEW_ARB_map_buffer_range)
+
+#endif /* GL_ARB_map_buffer_range */
+
+    /* ------------------------- GL_ARB_matrix_palette ------------------------- */
+
+#ifndef GL_ARB_matrix_palette
+#define GL_ARB_matrix_palette 1
+
+#define GL_MATRIX_PALETTE_ARB 0x8840
+#define GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB 0x8841
+#define GL_MAX_PALETTE_MATRICES_ARB 0x8842
+#define GL_CURRENT_PALETTE_MATRIX_ARB 0x8843
+#define GL_MATRIX_INDEX_ARRAY_ARB 0x8844
+#define GL_CURRENT_MATRIX_INDEX_ARB 0x8845
+#define GL_MATRIX_INDEX_ARRAY_SIZE_ARB 0x8846
+#define GL_MATRIX_INDEX_ARRAY_TYPE_ARB 0x8847
+#define GL_MATRIX_INDEX_ARRAY_STRIDE_ARB 0x8848
+#define GL_MATRIX_INDEX_ARRAY_POINTER_ARB 0x8849
+
+    typedef void (GLAPIENTRY *PFNGLCURRENTPALETTEMATRIXARBPROC)(GLint index);
+    typedef void (GLAPIENTRY *PFNGLMATRIXINDEXPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
+    typedef void (GLAPIENTRY *PFNGLMATRIXINDEXUBVARBPROC)(GLint size, GLubyte *indices);
+    typedef void (GLAPIENTRY *PFNGLMATRIXINDEXUIVARBPROC)(GLint size, GLuint *indices);
+    typedef void (GLAPIENTRY *PFNGLMATRIXINDEXUSVARBPROC)(GLint size, GLushort *indices);
+
+#define glCurrentPaletteMatrixARB GLEW_GET_FUN(__glewCurrentPaletteMatrixARB)
+#define glMatrixIndexPointerARB GLEW_GET_FUN(__glewMatrixIndexPointerARB)
+#define glMatrixIndexubvARB GLEW_GET_FUN(__glewMatrixIndexubvARB)
+#define glMatrixIndexuivARB GLEW_GET_FUN(__glewMatrixIndexuivARB)
+#define glMatrixIndexusvARB GLEW_GET_FUN(__glewMatrixIndexusvARB)
+
+#define GLEW_ARB_matrix_palette GLEW_GET_VAR(__GLEW_ARB_matrix_palette)
+
+#endif /* GL_ARB_matrix_palette */
+
+    /* --------------------------- GL_ARB_multisample -------------------------- */
+
+#ifndef GL_ARB_multisample
+#define GL_ARB_multisample 1
+
+#define GL_MULTISAMPLE_ARB 0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE_ARB 0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_ARB 0x809F
+#define GL_SAMPLE_COVERAGE_ARB 0x80A0
+#define GL_SAMPLE_BUFFERS_ARB 0x80A8
+#define GL_SAMPLES_ARB 0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE_ARB 0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT_ARB 0x80AB
+#define GL_MULTISAMPLE_BIT_ARB 0x20000000
+
+    typedef void (GLAPIENTRY *PFNGLSAMPLECOVERAGEARBPROC)(GLclampf value, GLboolean invert);
+
+#define glSampleCoverageARB GLEW_GET_FUN(__glewSampleCoverageARB)
+
+#define GLEW_ARB_multisample GLEW_GET_VAR(__GLEW_ARB_multisample)
+
+#endif /* GL_ARB_multisample */
+
+    /* -------------------------- GL_ARB_multitexture -------------------------- */
+
+#ifndef GL_ARB_multitexture
+#define GL_ARB_multitexture 1
+
+#define GL_TEXTURE0_ARB 0x84C0
+#define GL_TEXTURE1_ARB 0x84C1
+#define GL_TEXTURE2_ARB 0x84C2
+#define GL_TEXTURE3_ARB 0x84C3
+#define GL_TEXTURE4_ARB 0x84C4
+#define GL_TEXTURE5_ARB 0x84C5
+#define GL_TEXTURE6_ARB 0x84C6
+#define GL_TEXTURE7_ARB 0x84C7
+#define GL_TEXTURE8_ARB 0x84C8
+#define GL_TEXTURE9_ARB 0x84C9
+#define GL_TEXTURE10_ARB 0x84CA
+#define GL_TEXTURE11_ARB 0x84CB
+#define GL_TEXTURE12_ARB 0x84CC
+#define GL_TEXTURE13_ARB 0x84CD
+#define GL_TEXTURE14_ARB 0x84CE
+#define GL_TEXTURE15_ARB 0x84CF
+#define GL_TEXTURE16_ARB 0x84D0
+#define GL_TEXTURE17_ARB 0x84D1
+#define GL_TEXTURE18_ARB 0x84D2
+#define GL_TEXTURE19_ARB 0x84D3
+#define GL_TEXTURE20_ARB 0x84D4
+#define GL_TEXTURE21_ARB 0x84D5
+#define GL_TEXTURE22_ARB 0x84D6
+#define GL_TEXTURE23_ARB 0x84D7
+#define GL_TEXTURE24_ARB 0x84D8
+#define GL_TEXTURE25_ARB 0x84D9
+#define GL_TEXTURE26_ARB 0x84DA
+#define GL_TEXTURE27_ARB 0x84DB
+#define GL_TEXTURE28_ARB 0x84DC
+#define GL_TEXTURE29_ARB 0x84DD
+#define GL_TEXTURE30_ARB 0x84DE
+#define GL_TEXTURE31_ARB 0x84DF
+#define GL_ACTIVE_TEXTURE_ARB 0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE_ARB 0x84E1
+#define GL_MAX_TEXTURE_UNITS_ARB 0x84E2
+
+    typedef void (GLAPIENTRY *PFNGLACTIVETEXTUREARBPROC)(GLenum texture);
+    typedef void (GLAPIENTRY *PFNGLCLIENTACTIVETEXTUREARBPROC)(GLenum texture);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1DARBPROC)(GLenum target, GLdouble s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1DVARBPROC)(GLenum target, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1FARBPROC)(GLenum target, GLfloat s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1FVARBPROC)(GLenum target, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1IARBPROC)(GLenum target, GLint s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1IVARBPROC)(GLenum target, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1SARBPROC)(GLenum target, GLshort s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1SVARBPROC)(GLenum target, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2DARBPROC)(GLenum target, GLdouble s, GLdouble t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2DVARBPROC)(GLenum target, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2FARBPROC)(GLenum target, GLfloat s, GLfloat t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2FVARBPROC)(GLenum target, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2IARBPROC)(GLenum target, GLint s, GLint t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2IVARBPROC)(GLenum target, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2SARBPROC)(GLenum target, GLshort s, GLshort t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2SVARBPROC)(GLenum target, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3DVARBPROC)(GLenum target, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3FVARBPROC)(GLenum target, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3IARBPROC)(GLenum target, GLint s, GLint t, GLint r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3IVARBPROC)(GLenum target, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3SVARBPROC)(GLenum target, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4DVARBPROC)(GLenum target, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4FVARBPROC)(GLenum target, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4IARBPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4IVARBPROC)(GLenum target, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4SVARBPROC)(GLenum target, const GLshort *v);
+
+#define glActiveTextureARB GLEW_GET_FUN(__glewActiveTextureARB)
+#define glClientActiveTextureARB GLEW_GET_FUN(__glewClientActiveTextureARB)
+#define glMultiTexCoord1dARB GLEW_GET_FUN(__glewMultiTexCoord1dARB)
+#define glMultiTexCoord1dvARB GLEW_GET_FUN(__glewMultiTexCoord1dvARB)
+#define glMultiTexCoord1fARB GLEW_GET_FUN(__glewMultiTexCoord1fARB)
+#define glMultiTexCoord1fvARB GLEW_GET_FUN(__glewMultiTexCoord1fvARB)
+#define glMultiTexCoord1iARB GLEW_GET_FUN(__glewMultiTexCoord1iARB)
+#define glMultiTexCoord1ivARB GLEW_GET_FUN(__glewMultiTexCoord1ivARB)
+#define glMultiTexCoord1sARB GLEW_GET_FUN(__glewMultiTexCoord1sARB)
+#define glMultiTexCoord1svARB GLEW_GET_FUN(__glewMultiTexCoord1svARB)
+#define glMultiTexCoord2dARB GLEW_GET_FUN(__glewMultiTexCoord2dARB)
+#define glMultiTexCoord2dvARB GLEW_GET_FUN(__glewMultiTexCoord2dvARB)
+#define glMultiTexCoord2fARB GLEW_GET_FUN(__glewMultiTexCoord2fARB)
+#define glMultiTexCoord2fvARB GLEW_GET_FUN(__glewMultiTexCoord2fvARB)
+#define glMultiTexCoord2iARB GLEW_GET_FUN(__glewMultiTexCoord2iARB)
+#define glMultiTexCoord2ivARB GLEW_GET_FUN(__glewMultiTexCoord2ivARB)
+#define glMultiTexCoord2sARB GLEW_GET_FUN(__glewMultiTexCoord2sARB)
+#define glMultiTexCoord2svARB GLEW_GET_FUN(__glewMultiTexCoord2svARB)
+#define glMultiTexCoord3dARB GLEW_GET_FUN(__glewMultiTexCoord3dARB)
+#define glMultiTexCoord3dvARB GLEW_GET_FUN(__glewMultiTexCoord3dvARB)
+#define glMultiTexCoord3fARB GLEW_GET_FUN(__glewMultiTexCoord3fARB)
+#define glMultiTexCoord3fvARB GLEW_GET_FUN(__glewMultiTexCoord3fvARB)
+#define glMultiTexCoord3iARB GLEW_GET_FUN(__glewMultiTexCoord3iARB)
+#define glMultiTexCoord3ivARB GLEW_GET_FUN(__glewMultiTexCoord3ivARB)
+#define glMultiTexCoord3sARB GLEW_GET_FUN(__glewMultiTexCoord3sARB)
+#define glMultiTexCoord3svARB GLEW_GET_FUN(__glewMultiTexCoord3svARB)
+#define glMultiTexCoord4dARB GLEW_GET_FUN(__glewMultiTexCoord4dARB)
+#define glMultiTexCoord4dvARB GLEW_GET_FUN(__glewMultiTexCoord4dvARB)
+#define glMultiTexCoord4fARB GLEW_GET_FUN(__glewMultiTexCoord4fARB)
+#define glMultiTexCoord4fvARB GLEW_GET_FUN(__glewMultiTexCoord4fvARB)
+#define glMultiTexCoord4iARB GLEW_GET_FUN(__glewMultiTexCoord4iARB)
+#define glMultiTexCoord4ivARB GLEW_GET_FUN(__glewMultiTexCoord4ivARB)
+#define glMultiTexCoord4sARB GLEW_GET_FUN(__glewMultiTexCoord4sARB)
+#define glMultiTexCoord4svARB GLEW_GET_FUN(__glewMultiTexCoord4svARB)
+
+#define GLEW_ARB_multitexture GLEW_GET_VAR(__GLEW_ARB_multitexture)
+
+#endif /* GL_ARB_multitexture */
+
+    /* ------------------------- GL_ARB_occlusion_query ------------------------ */
+
+#ifndef GL_ARB_occlusion_query
+#define GL_ARB_occlusion_query 1
+
+#define GL_QUERY_COUNTER_BITS_ARB 0x8864
+#define GL_CURRENT_QUERY_ARB 0x8865
+#define GL_QUERY_RESULT_ARB 0x8866
+#define GL_QUERY_RESULT_AVAILABLE_ARB 0x8867
+#define GL_SAMPLES_PASSED_ARB 0x8914
+
+    typedef void (GLAPIENTRY *PFNGLBEGINQUERYARBPROC)(GLenum target, GLuint id);
+    typedef void (GLAPIENTRY *PFNGLDELETEQUERIESARBPROC)(GLsizei n, const GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLENDQUERYARBPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLGENQUERIESARBPROC)(GLsizei n, GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYOBJECTIVARBPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYOBJECTUIVARBPROC)(GLuint id, GLenum pname, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYIVARBPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISQUERYARBPROC)(GLuint id);
+
+#define glBeginQueryARB GLEW_GET_FUN(__glewBeginQueryARB)
+#define glDeleteQueriesARB GLEW_GET_FUN(__glewDeleteQueriesARB)
+#define glEndQueryARB GLEW_GET_FUN(__glewEndQueryARB)
+#define glGenQueriesARB GLEW_GET_FUN(__glewGenQueriesARB)
+#define glGetQueryObjectivARB GLEW_GET_FUN(__glewGetQueryObjectivARB)
+#define glGetQueryObjectuivARB GLEW_GET_FUN(__glewGetQueryObjectuivARB)
+#define glGetQueryivARB GLEW_GET_FUN(__glewGetQueryivARB)
+#define glIsQueryARB GLEW_GET_FUN(__glewIsQueryARB)
+
+#define GLEW_ARB_occlusion_query GLEW_GET_VAR(__GLEW_ARB_occlusion_query)
+
+#endif /* GL_ARB_occlusion_query */
+
+    /* ------------------------ GL_ARB_occlusion_query2 ------------------------ */
+
+#ifndef GL_ARB_occlusion_query2
+#define GL_ARB_occlusion_query2 1
+
+#define GL_ANY_SAMPLES_PASSED 0x8C2F
+
+#define GLEW_ARB_occlusion_query2 GLEW_GET_VAR(__GLEW_ARB_occlusion_query2)
+
+#endif /* GL_ARB_occlusion_query2 */
+
+    /* ----------------------- GL_ARB_pixel_buffer_object ---------------------- */
+
+#ifndef GL_ARB_pixel_buffer_object
+#define GL_ARB_pixel_buffer_object 1
+
+#define GL_PIXEL_PACK_BUFFER_ARB 0x88EB
+#define GL_PIXEL_UNPACK_BUFFER_ARB 0x88EC
+#define GL_PIXEL_PACK_BUFFER_BINDING_ARB 0x88ED
+#define GL_PIXEL_UNPACK_BUFFER_BINDING_ARB 0x88EF
+
+#define GLEW_ARB_pixel_buffer_object GLEW_GET_VAR(__GLEW_ARB_pixel_buffer_object)
+
+#endif /* GL_ARB_pixel_buffer_object */
+
+    /* ------------------------ GL_ARB_point_parameters ------------------------ */
+
+#ifndef GL_ARB_point_parameters
+#define GL_ARB_point_parameters 1
+
+#define GL_POINT_SIZE_MIN_ARB 0x8126
+#define GL_POINT_SIZE_MAX_ARB 0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_ARB 0x8128
+#define GL_POINT_DISTANCE_ATTENUATION_ARB 0x8129
+
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERFARBPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname, GLfloat *params);
+
+#define glPointParameterfARB GLEW_GET_FUN(__glewPointParameterfARB)
+#define glPointParameterfvARB GLEW_GET_FUN(__glewPointParameterfvARB)
+
+#define GLEW_ARB_point_parameters GLEW_GET_VAR(__GLEW_ARB_point_parameters)
+
+#endif /* GL_ARB_point_parameters */
+
+    /* -------------------------- GL_ARB_point_sprite -------------------------- */
+
+#ifndef GL_ARB_point_sprite
+#define GL_ARB_point_sprite 1
+
+#define GL_POINT_SPRITE_ARB 0x8861
+#define GL_COORD_REPLACE_ARB 0x8862
+
+#define GLEW_ARB_point_sprite GLEW_GET_VAR(__GLEW_ARB_point_sprite)
+
+#endif /* GL_ARB_point_sprite */
+
+    /* ------------------------ GL_ARB_provoking_vertex ------------------------ */
+
+#ifndef GL_ARB_provoking_vertex
+#define GL_ARB_provoking_vertex 1
+
+#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
+#define GL_FIRST_VERTEX_CONVENTION 0x8E4D
+#define GL_LAST_VERTEX_CONVENTION 0x8E4E
+#define GL_PROVOKING_VERTEX 0x8E4F
+
+    typedef void (GLAPIENTRY *PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
+
+#define glProvokingVertex GLEW_GET_FUN(__glewProvokingVertex)
+
+#define GLEW_ARB_provoking_vertex GLEW_GET_VAR(__GLEW_ARB_provoking_vertex)
+
+#endif /* GL_ARB_provoking_vertex */
+
+    /* ------------------------- GL_ARB_sample_shading ------------------------- */
+
+#ifndef GL_ARB_sample_shading
+#define GL_ARB_sample_shading 1
+
+#define GL_SAMPLE_SHADING_ARB 0x8C36
+#define GL_MIN_SAMPLE_SHADING_VALUE_ARB 0x8C37
+
+    typedef void (GLAPIENTRY *PFNGLMINSAMPLESHADINGARBPROC)(GLclampf value);
+
+#define glMinSampleShadingARB GLEW_GET_FUN(__glewMinSampleShadingARB)
+
+#define GLEW_ARB_sample_shading GLEW_GET_VAR(__GLEW_ARB_sample_shading)
+
+#endif /* GL_ARB_sample_shading */
+
+    /* ------------------------- GL_ARB_sampler_objects ------------------------ */
+
+#ifndef GL_ARB_sampler_objects
+#define GL_ARB_sampler_objects 1
+
+#define GL_SAMPLER_BINDING 0x8919
+
+    typedef void (GLAPIENTRY *PFNGLBINDSAMPLERPROC)(GLenum unit, GLuint sampler);
+    typedef void (GLAPIENTRY *PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint *samplers);
+    typedef void (GLAPIENTRY *PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint *samplers);
+    typedef GLboolean(GLAPIENTRY *PFNGLISSAMPLERPROC)(GLuint sampler);
+
+#define glBindSampler GLEW_GET_FUN(__glewBindSampler)
+#define glDeleteSamplers GLEW_GET_FUN(__glewDeleteSamplers)
+#define glGenSamplers GLEW_GET_FUN(__glewGenSamplers)
+#define glIsSampler GLEW_GET_FUN(__glewIsSampler)
+
+#define GLEW_ARB_sampler_objects GLEW_GET_VAR(__GLEW_ARB_sampler_objects)
+
+#endif /* GL_ARB_sampler_objects */
+
+    /* ------------------------ GL_ARB_seamless_cube_map ----------------------- */
+
+#ifndef GL_ARB_seamless_cube_map
+#define GL_ARB_seamless_cube_map 1
+
+#define GL_TEXTURE_CUBE_MAP_SEAMLESS 0x884F
+
+#define GLEW_ARB_seamless_cube_map GLEW_GET_VAR(__GLEW_ARB_seamless_cube_map)
+
+#endif /* GL_ARB_seamless_cube_map */
+
+    /* ----------------------- GL_ARB_shader_bit_encoding ---------------------- */
+
+#ifndef GL_ARB_shader_bit_encoding
+#define GL_ARB_shader_bit_encoding 1
+
+#define GLEW_ARB_shader_bit_encoding GLEW_GET_VAR(__GLEW_ARB_shader_bit_encoding)
+
+#endif /* GL_ARB_shader_bit_encoding */
+
+    /* ------------------------- GL_ARB_shader_objects ------------------------- */
+
+#ifndef GL_ARB_shader_objects
+#define GL_ARB_shader_objects 1
+
+#define GL_PROGRAM_OBJECT_ARB 0x8B40
+#define GL_SHADER_OBJECT_ARB 0x8B48
+#define GL_OBJECT_TYPE_ARB 0x8B4E
+#define GL_OBJECT_SUBTYPE_ARB 0x8B4F
+#define GL_FLOAT_VEC2_ARB 0x8B50
+#define GL_FLOAT_VEC3_ARB 0x8B51
+#define GL_FLOAT_VEC4_ARB 0x8B52
+#define GL_INT_VEC2_ARB 0x8B53
+#define GL_INT_VEC3_ARB 0x8B54
+#define GL_INT_VEC4_ARB 0x8B55
+#define GL_BOOL_ARB 0x8B56
+#define GL_BOOL_VEC2_ARB 0x8B57
+#define GL_BOOL_VEC3_ARB 0x8B58
+#define GL_BOOL_VEC4_ARB 0x8B59
+#define GL_FLOAT_MAT2_ARB 0x8B5A
+#define GL_FLOAT_MAT3_ARB 0x8B5B
+#define GL_FLOAT_MAT4_ARB 0x8B5C
+#define GL_SAMPLER_1D_ARB 0x8B5D
+#define GL_SAMPLER_2D_ARB 0x8B5E
+#define GL_SAMPLER_3D_ARB 0x8B5F
+#define GL_SAMPLER_CUBE_ARB 0x8B60
+#define GL_SAMPLER_1D_SHADOW_ARB 0x8B61
+#define GL_SAMPLER_2D_SHADOW_ARB 0x8B62
+#define GL_SAMPLER_2D_RECT_ARB 0x8B63
+#define GL_SAMPLER_2D_RECT_SHADOW_ARB 0x8B64
+#define GL_OBJECT_DELETE_STATUS_ARB 0x8B80
+#define GL_OBJECT_COMPILE_STATUS_ARB 0x8B81
+#define GL_OBJECT_LINK_STATUS_ARB 0x8B82
+#define GL_OBJECT_VALIDATE_STATUS_ARB 0x8B83
+#define GL_OBJECT_INFO_LOG_LENGTH_ARB 0x8B84
+#define GL_OBJECT_ATTACHED_OBJECTS_ARB 0x8B85
+#define GL_OBJECT_ACTIVE_UNIFORMS_ARB 0x8B86
+#define GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB 0x8B87
+#define GL_OBJECT_SHADER_SOURCE_LENGTH_ARB 0x8B88
+
+    typedef char GLcharARB;
+    typedef unsigned int GLhandleARB;
+
+    typedef void (GLAPIENTRY *PFNGLATTACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB obj);
+    typedef void (GLAPIENTRY *PFNGLCOMPILESHADERARBPROC)(GLhandleARB shaderObj);
+    typedef GLhandleARB(GLAPIENTRY *PFNGLCREATEPROGRAMOBJECTARBPROC)(void);
+    typedef GLhandleARB(GLAPIENTRY *PFNGLCREATESHADEROBJECTARBPROC)(GLenum shaderType);
+    typedef void (GLAPIENTRY *PFNGLDELETEOBJECTARBPROC)(GLhandleARB obj);
+    typedef void (GLAPIENTRY *PFNGLDETACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB attachedObj);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEUNIFORMARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+    typedef void (GLAPIENTRY *PFNGLGETATTACHEDOBJECTSARBPROC)(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
+    typedef GLhandleARB(GLAPIENTRY *PFNGLGETHANDLEARBPROC)(GLenum pname);
+    typedef void (GLAPIENTRY *PFNGLGETINFOLOGARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
+    typedef void (GLAPIENTRY *PFNGLGETOBJECTPARAMETERFVARBPROC)(GLhandleARB obj, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETOBJECTPARAMETERIVARBPROC)(GLhandleARB obj, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETSHADERSOURCEARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
+    typedef GLint(GLAPIENTRY *PFNGLGETUNIFORMLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB *name);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMFVARBPROC)(GLhandleARB programObj, GLint location, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMIVARBPROC)(GLhandleARB programObj, GLint location, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLLINKPROGRAMARBPROC)(GLhandleARB programObj);
+    typedef void (GLAPIENTRY *PFNGLSHADERSOURCEARBPROC)(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1FARBPROC)(GLint location, GLfloat v0);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1IARBPROC)(GLint location, GLint v0);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1IVARBPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2FARBPROC)(GLint location, GLfloat v0, GLfloat v1);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2IARBPROC)(GLint location, GLint v0, GLint v1);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2IVARBPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3IVARBPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4IVARBPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX2FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX3FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMMATRIX4FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLUSEPROGRAMOBJECTARBPROC)(GLhandleARB programObj);
+    typedef void (GLAPIENTRY *PFNGLVALIDATEPROGRAMARBPROC)(GLhandleARB programObj);
+
+#define glAttachObjectARB GLEW_GET_FUN(__glewAttachObjectARB)
+#define glCompileShaderARB GLEW_GET_FUN(__glewCompileShaderARB)
+#define glCreateProgramObjectARB GLEW_GET_FUN(__glewCreateProgramObjectARB)
+#define glCreateShaderObjectARB GLEW_GET_FUN(__glewCreateShaderObjectARB)
+#define glDeleteObjectARB GLEW_GET_FUN(__glewDeleteObjectARB)
+#define glDetachObjectARB GLEW_GET_FUN(__glewDetachObjectARB)
+#define glGetActiveUniformARB GLEW_GET_FUN(__glewGetActiveUniformARB)
+#define glGetAttachedObjectsARB GLEW_GET_FUN(__glewGetAttachedObjectsARB)
+#define glGetHandleARB GLEW_GET_FUN(__glewGetHandleARB)
+#define glGetInfoLogARB GLEW_GET_FUN(__glewGetInfoLogARB)
+#define glGetObjectParameterfvARB GLEW_GET_FUN(__glewGetObjectParameterfvARB)
+#define glGetObjectParameterivARB GLEW_GET_FUN(__glewGetObjectParameterivARB)
+#define glGetShaderSourceARB GLEW_GET_FUN(__glewGetShaderSourceARB)
+#define glGetUniformLocationARB GLEW_GET_FUN(__glewGetUniformLocationARB)
+#define glGetUniformfvARB GLEW_GET_FUN(__glewGetUniformfvARB)
+#define glGetUniformivARB GLEW_GET_FUN(__glewGetUniformivARB)
+#define glLinkProgramARB GLEW_GET_FUN(__glewLinkProgramARB)
+#define glShaderSourceARB GLEW_GET_FUN(__glewShaderSourceARB)
+#define glUniform1fARB GLEW_GET_FUN(__glewUniform1fARB)
+#define glUniform1fvARB GLEW_GET_FUN(__glewUniform1fvARB)
+#define glUniform1iARB GLEW_GET_FUN(__glewUniform1iARB)
+#define glUniform1ivARB GLEW_GET_FUN(__glewUniform1ivARB)
+#define glUniform2fARB GLEW_GET_FUN(__glewUniform2fARB)
+#define glUniform2fvARB GLEW_GET_FUN(__glewUniform2fvARB)
+#define glUniform2iARB GLEW_GET_FUN(__glewUniform2iARB)
+#define glUniform2ivARB GLEW_GET_FUN(__glewUniform2ivARB)
+#define glUniform3fARB GLEW_GET_FUN(__glewUniform3fARB)
+#define glUniform3fvARB GLEW_GET_FUN(__glewUniform3fvARB)
+#define glUniform3iARB GLEW_GET_FUN(__glewUniform3iARB)
+#define glUniform3ivARB GLEW_GET_FUN(__glewUniform3ivARB)
+#define glUniform4fARB GLEW_GET_FUN(__glewUniform4fARB)
+#define glUniform4fvARB GLEW_GET_FUN(__glewUniform4fvARB)
+#define glUniform4iARB GLEW_GET_FUN(__glewUniform4iARB)
+#define glUniform4ivARB GLEW_GET_FUN(__glewUniform4ivARB)
+#define glUniformMatrix2fvARB GLEW_GET_FUN(__glewUniformMatrix2fvARB)
+#define glUniformMatrix3fvARB GLEW_GET_FUN(__glewUniformMatrix3fvARB)
+#define glUniformMatrix4fvARB GLEW_GET_FUN(__glewUniformMatrix4fvARB)
+#define glUseProgramObjectARB GLEW_GET_FUN(__glewUseProgramObjectARB)
+#define glValidateProgramARB GLEW_GET_FUN(__glewValidateProgramARB)
+
+#define GLEW_ARB_shader_objects GLEW_GET_VAR(__GLEW_ARB_shader_objects)
+
+#endif /* GL_ARB_shader_objects */
+
+    /* ------------------------ GL_ARB_shader_subroutine ----------------------- */
+
+#ifndef GL_ARB_shader_subroutine
+#define GL_ARB_shader_subroutine 1
+
+#define GL_ACTIVE_SUBROUTINES 0x8DE5
+#define GL_ACTIVE_SUBROUTINE_UNIFORMS 0x8DE6
+#define GL_MAX_SUBROUTINES 0x8DE7
+#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
+#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
+#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH 0x8E48
+#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
+#define GL_NUM_COMPATIBLE_SUBROUTINES 0x8E4A
+#define GL_COMPATIBLE_SUBROUTINES 0x8E4B
+
+    typedef void (GLAPIENTRY *PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, char *name);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, char *name);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint *values);
+    typedef GLuint(GLAPIENTRY *PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const char *name);
+    typedef GLint(GLAPIENTRY *PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const char *name);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint *indices);
+
+#define glGetActiveSubroutineName GLEW_GET_FUN(__glewGetActiveSubroutineName)
+#define glGetActiveSubroutineUniformName GLEW_GET_FUN(__glewGetActiveSubroutineUniformName)
+#define glGetActiveSubroutineUniformiv GLEW_GET_FUN(__glewGetActiveSubroutineUniformiv)
+#define glGetProgramStageiv GLEW_GET_FUN(__glewGetProgramStageiv)
+#define glGetSubroutineIndex GLEW_GET_FUN(__glewGetSubroutineIndex)
+#define glGetSubroutineUniformLocation GLEW_GET_FUN(__glewGetSubroutineUniformLocation)
+#define glGetUniformSubroutineuiv GLEW_GET_FUN(__glewGetUniformSubroutineuiv)
+#define glUniformSubroutinesuiv GLEW_GET_FUN(__glewUniformSubroutinesuiv)
+
+#define GLEW_ARB_shader_subroutine GLEW_GET_VAR(__GLEW_ARB_shader_subroutine)
+
+#endif /* GL_ARB_shader_subroutine */
+
+    /* ----------------------- GL_ARB_shader_texture_lod ----------------------- */
+
+#ifndef GL_ARB_shader_texture_lod
+#define GL_ARB_shader_texture_lod 1
+
+#define GLEW_ARB_shader_texture_lod GLEW_GET_VAR(__GLEW_ARB_shader_texture_lod)
+
+#endif /* GL_ARB_shader_texture_lod */
+
+    /* ---------------------- GL_ARB_shading_language_100 ---------------------- */
+
+#ifndef GL_ARB_shading_language_100
+#define GL_ARB_shading_language_100 1
+
+#define GL_SHADING_LANGUAGE_VERSION_ARB 0x8B8C
+
+#define GLEW_ARB_shading_language_100 GLEW_GET_VAR(__GLEW_ARB_shading_language_100)
+
+#endif /* GL_ARB_shading_language_100 */
+
+    /* -------------------- GL_ARB_shading_language_include -------------------- */
+
+#ifndef GL_ARB_shading_language_include
+#define GL_ARB_shading_language_include 1
+
+#define GL_SHADER_INCLUDE_ARB 0x8DAE
+#define GL_NAMED_STRING_LENGTH_ARB 0x8DE9
+#define GL_NAMED_STRING_TYPE_ARB 0x8DEA
+
+    typedef void (GLAPIENTRY *PFNGLCOMPILESHADERINCLUDEARBPROC)(GLuint shader, GLsizei count, const char **path, const GLint *length);
+    typedef void (GLAPIENTRY *PFNGLDELETENAMEDSTRINGARBPROC)(GLint namelen, const char *name);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDSTRINGARBPROC)(GLint namelen, const char *name, GLsizei bufSize, GLint *stringlen, char *string);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDSTRINGIVARBPROC)(GLint namelen, const char *name, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISNAMEDSTRINGARBPROC)(GLint namelen, const char *name);
+    typedef void (GLAPIENTRY *PFNGLNAMEDSTRINGARBPROC)(GLenum type, GLint namelen, const char *name, GLint stringlen, const char *string);
+
+#define glCompileShaderIncludeARB GLEW_GET_FUN(__glewCompileShaderIncludeARB)
+#define glDeleteNamedStringARB GLEW_GET_FUN(__glewDeleteNamedStringARB)
+#define glGetNamedStringARB GLEW_GET_FUN(__glewGetNamedStringARB)
+#define glGetNamedStringivARB GLEW_GET_FUN(__glewGetNamedStringivARB)
+#define glIsNamedStringARB GLEW_GET_FUN(__glewIsNamedStringARB)
+#define glNamedStringARB GLEW_GET_FUN(__glewNamedStringARB)
+
+#define GLEW_ARB_shading_language_include GLEW_GET_VAR(__GLEW_ARB_shading_language_include)
+
+#endif /* GL_ARB_shading_language_include */
+
+    /* ----------------------------- GL_ARB_shadow ----------------------------- */
+
+#ifndef GL_ARB_shadow
+#define GL_ARB_shadow 1
+
+#define GL_TEXTURE_COMPARE_MODE_ARB 0x884C
+#define GL_TEXTURE_COMPARE_FUNC_ARB 0x884D
+#define GL_COMPARE_R_TO_TEXTURE_ARB 0x884E
+
+#define GLEW_ARB_shadow GLEW_GET_VAR(__GLEW_ARB_shadow)
+
+#endif /* GL_ARB_shadow */
+
+    /* ------------------------- GL_ARB_shadow_ambient ------------------------- */
+
+#ifndef GL_ARB_shadow_ambient
+#define GL_ARB_shadow_ambient 1
+
+#define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB 0x80BF
+
+#define GLEW_ARB_shadow_ambient GLEW_GET_VAR(__GLEW_ARB_shadow_ambient)
+
+#endif /* GL_ARB_shadow_ambient */
+
+    /* ------------------------------ GL_ARB_sync ------------------------------ */
+
+#ifndef GL_ARB_sync
+#define GL_ARB_sync 1
+
+#define GL_SYNC_FLUSH_COMMANDS_BIT 0x00000001
+#define GL_MAX_SERVER_WAIT_TIMEOUT 0x9111
+#define GL_OBJECT_TYPE 0x9112
+#define GL_SYNC_CONDITION 0x9113
+#define GL_SYNC_STATUS 0x9114
+#define GL_SYNC_FLAGS 0x9115
+#define GL_SYNC_FENCE 0x9116
+#define GL_SYNC_GPU_COMMANDS_COMPLETE 0x9117
+#define GL_UNSIGNALED 0x9118
+#define GL_SIGNALED 0x9119
+#define GL_ALREADY_SIGNALED 0x911A
+#define GL_TIMEOUT_EXPIRED 0x911B
+#define GL_CONDITION_SATISFIED 0x911C
+#define GL_WAIT_FAILED 0x911D
+#define GL_TIMEOUT_IGNORED 0xFFFFFFFFFFFFFFFF
+
+    typedef GLenum(GLAPIENTRY *PFNGLCLIENTWAITSYNCPROC)(GLsync GLsync,GLbitfield flags,GLuint64 timeout);
+    typedef void (GLAPIENTRY *PFNGLDELETESYNCPROC)(GLsync GLsync);
+    typedef GLsync(GLAPIENTRY *PFNGLFENCESYNCPROC)(GLenum condition,GLbitfield flags);
+    typedef void (GLAPIENTRY *PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 *params);
+    typedef void (GLAPIENTRY *PFNGLGETSYNCIVPROC)(GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei *length, GLint *values);
+    typedef GLboolean(GLAPIENTRY *PFNGLISSYNCPROC)(GLsync GLsync);
+    typedef void (GLAPIENTRY *PFNGLWAITSYNCPROC)(GLsync GLsync,GLbitfield flags,GLuint64 timeout);
+
+#define glClientWaitSync GLEW_GET_FUN(__glewClientWaitSync)
+#define glDeleteSync GLEW_GET_FUN(__glewDeleteSync)
+#define glFenceSync GLEW_GET_FUN(__glewFenceSync)
+#define glGetInteger64v GLEW_GET_FUN(__glewGetInteger64v)
+#define glGetSynciv GLEW_GET_FUN(__glewGetSynciv)
+#define glIsSync GLEW_GET_FUN(__glewIsSync)
+#define glWaitSync GLEW_GET_FUN(__glewWaitSync)
+
+#define GLEW_ARB_sync GLEW_GET_VAR(__GLEW_ARB_sync)
+
+#endif /* GL_ARB_sync */
+
+    /* ----------------------- GL_ARB_tessellation_shader ---------------------- */
+
+#ifndef GL_ARB_tessellation_shader
+#define GL_ARB_tessellation_shader 1
+
+#define GL_PATCHES 0xE
+#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
+#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
+#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
+#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
+#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
+#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
+#define GL_PATCH_VERTICES 0x8E72
+#define GL_PATCH_DEFAULT_INNER_LEVEL 0x8E73
+#define GL_PATCH_DEFAULT_OUTER_LEVEL 0x8E74
+#define GL_TESS_CONTROL_OUTPUT_VERTICES 0x8E75
+#define GL_TESS_GEN_MODE 0x8E76
+#define GL_TESS_GEN_SPACING 0x8E77
+#define GL_TESS_GEN_VERTEX_ORDER 0x8E78
+#define GL_TESS_GEN_POINT_MODE 0x8E79
+#define GL_ISOLINES 0x8E7A
+#define GL_FRACTIONAL_ODD 0x8E7B
+#define GL_FRACTIONAL_EVEN 0x8E7C
+#define GL_MAX_PATCH_VERTICES 0x8E7D
+#define GL_MAX_TESS_GEN_LEVEL 0x8E7E
+#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
+#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
+#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
+#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
+#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
+#define GL_MAX_TESS_PATCH_COMPONENTS 0x8E84
+#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
+#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
+#define GL_TESS_EVALUATION_SHADER 0x8E87
+#define GL_TESS_CONTROL_SHADER 0x8E88
+#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
+#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
+
+    typedef void (GLAPIENTRY *PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat *values);
+    typedef void (GLAPIENTRY *PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
+
+#define glPatchParameterfv GLEW_GET_FUN(__glewPatchParameterfv)
+#define glPatchParameteri GLEW_GET_FUN(__glewPatchParameteri)
+
+#define GLEW_ARB_tessellation_shader GLEW_GET_VAR(__GLEW_ARB_tessellation_shader)
+
+#endif /* GL_ARB_tessellation_shader */
+
+    /* ---------------------- GL_ARB_texture_border_clamp ---------------------- */
+
+#ifndef GL_ARB_texture_border_clamp
+#define GL_ARB_texture_border_clamp 1
+
+#define GL_CLAMP_TO_BORDER_ARB 0x812D
+
+#define GLEW_ARB_texture_border_clamp GLEW_GET_VAR(__GLEW_ARB_texture_border_clamp)
+
+#endif /* GL_ARB_texture_border_clamp */
+
+    /* ---------------------- GL_ARB_texture_buffer_object --------------------- */
+
+#ifndef GL_ARB_texture_buffer_object
+#define GL_ARB_texture_buffer_object 1
+
+#define GL_TEXTURE_BUFFER_ARB 0x8C2A
+#define GL_MAX_TEXTURE_BUFFER_SIZE_ARB 0x8C2B
+#define GL_TEXTURE_BINDING_BUFFER_ARB 0x8C2C
+#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB 0x8C2D
+#define GL_TEXTURE_BUFFER_FORMAT_ARB 0x8C2E
+
+    typedef void (GLAPIENTRY *PFNGLTEXBUFFERARBPROC)(GLenum target, GLenum internalformat, GLuint buffer);
+
+#define glTexBufferARB GLEW_GET_FUN(__glewTexBufferARB)
+
+#define GLEW_ARB_texture_buffer_object GLEW_GET_VAR(__GLEW_ARB_texture_buffer_object)
+
+#endif /* GL_ARB_texture_buffer_object */
+
+    /* ------------------- GL_ARB_texture_buffer_object_rgb32 ------------------ */
+
+#ifndef GL_ARB_texture_buffer_object_rgb32
+#define GL_ARB_texture_buffer_object_rgb32 1
+
+#define GLEW_ARB_texture_buffer_object_rgb32 GLEW_GET_VAR(__GLEW_ARB_texture_buffer_object_rgb32)
+
+#endif /* GL_ARB_texture_buffer_object_rgb32 */
+
+    /* ----------------------- GL_ARB_texture_compression ---------------------- */
+
+#ifndef GL_ARB_texture_compression
+#define GL_ARB_texture_compression 1
+
+#define GL_COMPRESSED_ALPHA_ARB 0x84E9
+#define GL_COMPRESSED_LUMINANCE_ARB 0x84EA
+#define GL_COMPRESSED_LUMINANCE_ALPHA_ARB 0x84EB
+#define GL_COMPRESSED_INTENSITY_ARB 0x84EC
+#define GL_COMPRESSED_RGB_ARB 0x84ED
+#define GL_COMPRESSED_RGBA_ARB 0x84EE
+#define GL_TEXTURE_COMPRESSION_HINT_ARB 0x84EF
+#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB 0x86A0
+#define GL_TEXTURE_COMPRESSED_ARB 0x86A1
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3
+
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint lod, void *img);
+
+#define glCompressedTexImage1DARB GLEW_GET_FUN(__glewCompressedTexImage1DARB)
+#define glCompressedTexImage2DARB GLEW_GET_FUN(__glewCompressedTexImage2DARB)
+#define glCompressedTexImage3DARB GLEW_GET_FUN(__glewCompressedTexImage3DARB)
+#define glCompressedTexSubImage1DARB GLEW_GET_FUN(__glewCompressedTexSubImage1DARB)
+#define glCompressedTexSubImage2DARB GLEW_GET_FUN(__glewCompressedTexSubImage2DARB)
+#define glCompressedTexSubImage3DARB GLEW_GET_FUN(__glewCompressedTexSubImage3DARB)
+#define glGetCompressedTexImageARB GLEW_GET_FUN(__glewGetCompressedTexImageARB)
+
+#define GLEW_ARB_texture_compression GLEW_GET_VAR(__GLEW_ARB_texture_compression)
+
+#endif /* GL_ARB_texture_compression */
+
+    /* -------------------- GL_ARB_texture_compression_bptc -------------------- */
+
+#ifndef GL_ARB_texture_compression_bptc
+#define GL_ARB_texture_compression_bptc 1
+
+#define GL_COMPRESSED_RGBA_BPTC_UNORM_ARB 0x8E8C
+#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB 0x8E8D
+#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB 0x8E8E
+#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB 0x8E8F
+
+#define GLEW_ARB_texture_compression_bptc GLEW_GET_VAR(__GLEW_ARB_texture_compression_bptc)
+
+#endif /* GL_ARB_texture_compression_bptc */
+
+    /* -------------------- GL_ARB_texture_compression_rgtc -------------------- */
+
+#ifndef GL_ARB_texture_compression_rgtc
+#define GL_ARB_texture_compression_rgtc 1
+
+#define GL_COMPRESSED_RED_RGTC1 0x8DBB
+#define GL_COMPRESSED_SIGNED_RED_RGTC1 0x8DBC
+#define GL_COMPRESSED_RG_RGTC2 0x8DBD
+#define GL_COMPRESSED_SIGNED_RG_RGTC2 0x8DBE
+
+#define GLEW_ARB_texture_compression_rgtc GLEW_GET_VAR(__GLEW_ARB_texture_compression_rgtc)
+
+#endif /* GL_ARB_texture_compression_rgtc */
+
+    /* ------------------------ GL_ARB_texture_cube_map ------------------------ */
+
+#ifndef GL_ARB_texture_cube_map
+#define GL_ARB_texture_cube_map 1
+
+#define GL_NORMAL_MAP_ARB 0x8511
+#define GL_REFLECTION_MAP_ARB 0x8512
+#define GL_TEXTURE_CUBE_MAP_ARB 0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_ARB 0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP_ARB 0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB 0x851C
+
+#define GLEW_ARB_texture_cube_map GLEW_GET_VAR(__GLEW_ARB_texture_cube_map)
+
+#endif /* GL_ARB_texture_cube_map */
+
+    /* --------------------- GL_ARB_texture_cube_map_array --------------------- */
+
+#ifndef GL_ARB_texture_cube_map_array
+#define GL_ARB_texture_cube_map_array 1
+
+#define GL_TEXTURE_CUBE_MAP_ARRAY_ARB 0x9009
+#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB 0x900A
+#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB 0x900B
+#define GL_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900C
+#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB 0x900D
+#define GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900E
+#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900F
+
+#define GLEW_ARB_texture_cube_map_array GLEW_GET_VAR(__GLEW_ARB_texture_cube_map_array)
+
+#endif /* GL_ARB_texture_cube_map_array */
+
+    /* ------------------------- GL_ARB_texture_env_add ------------------------ */
+
+#ifndef GL_ARB_texture_env_add
+#define GL_ARB_texture_env_add 1
+
+#define GLEW_ARB_texture_env_add GLEW_GET_VAR(__GLEW_ARB_texture_env_add)
+
+#endif /* GL_ARB_texture_env_add */
+
+    /* ----------------------- GL_ARB_texture_env_combine ---------------------- */
+
+#ifndef GL_ARB_texture_env_combine
+#define GL_ARB_texture_env_combine 1
+
+#define GL_SUBTRACT_ARB 0x84E7
+#define GL_COMBINE_ARB 0x8570
+#define GL_COMBINE_RGB_ARB 0x8571
+#define GL_COMBINE_ALPHA_ARB 0x8572
+#define GL_RGB_SCALE_ARB 0x8573
+#define GL_ADD_SIGNED_ARB 0x8574
+#define GL_INTERPOLATE_ARB 0x8575
+#define GL_CONSTANT_ARB 0x8576
+#define GL_PRIMARY_COLOR_ARB 0x8577
+#define GL_PREVIOUS_ARB 0x8578
+#define GL_SOURCE0_RGB_ARB 0x8580
+#define GL_SOURCE1_RGB_ARB 0x8581
+#define GL_SOURCE2_RGB_ARB 0x8582
+#define GL_SOURCE0_ALPHA_ARB 0x8588
+#define GL_SOURCE1_ALPHA_ARB 0x8589
+#define GL_SOURCE2_ALPHA_ARB 0x858A
+#define GL_OPERAND0_RGB_ARB 0x8590
+#define GL_OPERAND1_RGB_ARB 0x8591
+#define GL_OPERAND2_RGB_ARB 0x8592
+#define GL_OPERAND0_ALPHA_ARB 0x8598
+#define GL_OPERAND1_ALPHA_ARB 0x8599
+#define GL_OPERAND2_ALPHA_ARB 0x859A
+
+#define GLEW_ARB_texture_env_combine GLEW_GET_VAR(__GLEW_ARB_texture_env_combine)
+
+#endif /* GL_ARB_texture_env_combine */
+
+    /* ---------------------- GL_ARB_texture_env_crossbar ---------------------- */
+
+#ifndef GL_ARB_texture_env_crossbar
+#define GL_ARB_texture_env_crossbar 1
+
+#define GLEW_ARB_texture_env_crossbar GLEW_GET_VAR(__GLEW_ARB_texture_env_crossbar)
+
+#endif /* GL_ARB_texture_env_crossbar */
+
+    /* ------------------------ GL_ARB_texture_env_dot3 ------------------------ */
+
+#ifndef GL_ARB_texture_env_dot3
+#define GL_ARB_texture_env_dot3 1
+
+#define GL_DOT3_RGB_ARB 0x86AE
+#define GL_DOT3_RGBA_ARB 0x86AF
+
+#define GLEW_ARB_texture_env_dot3 GLEW_GET_VAR(__GLEW_ARB_texture_env_dot3)
+
+#endif /* GL_ARB_texture_env_dot3 */
+
+    /* -------------------------- GL_ARB_texture_float ------------------------- */
+
+#ifndef GL_ARB_texture_float
+#define GL_ARB_texture_float 1
+
+#define GL_RGBA32F_ARB 0x8814
+#define GL_RGB32F_ARB 0x8815
+#define GL_ALPHA32F_ARB 0x8816
+#define GL_INTENSITY32F_ARB 0x8817
+#define GL_LUMINANCE32F_ARB 0x8818
+#define GL_LUMINANCE_ALPHA32F_ARB 0x8819
+#define GL_RGBA16F_ARB 0x881A
+#define GL_RGB16F_ARB 0x881B
+#define GL_ALPHA16F_ARB 0x881C
+#define GL_INTENSITY16F_ARB 0x881D
+#define GL_LUMINANCE16F_ARB 0x881E
+#define GL_LUMINANCE_ALPHA16F_ARB 0x881F
+#define GL_TEXTURE_RED_TYPE_ARB 0x8C10
+#define GL_TEXTURE_GREEN_TYPE_ARB 0x8C11
+#define GL_TEXTURE_BLUE_TYPE_ARB 0x8C12
+#define GL_TEXTURE_ALPHA_TYPE_ARB 0x8C13
+#define GL_TEXTURE_LUMINANCE_TYPE_ARB 0x8C14
+#define GL_TEXTURE_INTENSITY_TYPE_ARB 0x8C15
+#define GL_TEXTURE_DEPTH_TYPE_ARB 0x8C16
+#define GL_UNSIGNED_NORMALIZED_ARB 0x8C17
+
+#define GLEW_ARB_texture_float GLEW_GET_VAR(__GLEW_ARB_texture_float)
+
+#endif /* GL_ARB_texture_float */
+
+    /* ------------------------- GL_ARB_texture_gather ------------------------- */
+
+#ifndef GL_ARB_texture_gather
+#define GL_ARB_texture_gather 1
+
+#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5E
+#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5F
+#define GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB 0x8F9F
+
+#define GLEW_ARB_texture_gather GLEW_GET_VAR(__GLEW_ARB_texture_gather)
+
+#endif /* GL_ARB_texture_gather */
+
+    /* --------------------- GL_ARB_texture_mirrored_repeat -------------------- */
+
+#ifndef GL_ARB_texture_mirrored_repeat
+#define GL_ARB_texture_mirrored_repeat 1
+
+#define GL_MIRRORED_REPEAT_ARB 0x8370
+
+#define GLEW_ARB_texture_mirrored_repeat GLEW_GET_VAR(__GLEW_ARB_texture_mirrored_repeat)
+
+#endif /* GL_ARB_texture_mirrored_repeat */
+
+    /* ----------------------- GL_ARB_texture_multisample ---------------------- */
+
+#ifndef GL_ARB_texture_multisample
+#define GL_ARB_texture_multisample 1
+
+#define GL_SAMPLE_POSITION 0x8E50
+#define GL_SAMPLE_MASK 0x8E51
+#define GL_SAMPLE_MASK_VALUE 0x8E52
+#define GL_MAX_SAMPLE_MASK_WORDS 0x8E59
+#define GL_TEXTURE_2D_MULTISAMPLE 0x9100
+#define GL_PROXY_TEXTURE_2D_MULTISAMPLE 0x9101
+#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9102
+#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
+#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
+#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
+#define GL_TEXTURE_SAMPLES 0x9106
+#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
+#define GL_SAMPLER_2D_MULTISAMPLE 0x9108
+#define GL_INT_SAMPLER_2D_MULTISAMPLE 0x9109
+#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
+#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910B
+#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
+#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
+#define GL_MAX_COLOR_TEXTURE_SAMPLES 0x910E
+#define GL_MAX_DEPTH_TEXTURE_SAMPLES 0x910F
+#define GL_MAX_INTEGER_SAMPLES 0x9110
+
+    typedef void (GLAPIENTRY *PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat *val);
+    typedef void (GLAPIENTRY *PFNGLSAMPLEMASKIPROC)(GLuint index, GLbitfield mask);
+    typedef void (GLAPIENTRY *PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
+    typedef void (GLAPIENTRY *PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
+
+#define glGetMultisamplefv GLEW_GET_FUN(__glewGetMultisamplefv)
+#define glSampleMaski GLEW_GET_FUN(__glewSampleMaski)
+#define glTexImage2DMultisample GLEW_GET_FUN(__glewTexImage2DMultisample)
+#define glTexImage3DMultisample GLEW_GET_FUN(__glewTexImage3DMultisample)
+
+#define GLEW_ARB_texture_multisample GLEW_GET_VAR(__GLEW_ARB_texture_multisample)
+
+#endif /* GL_ARB_texture_multisample */
+
+    /* -------------------- GL_ARB_texture_non_power_of_two -------------------- */
+
+#ifndef GL_ARB_texture_non_power_of_two
+#define GL_ARB_texture_non_power_of_two 1
+
+#define GLEW_ARB_texture_non_power_of_two GLEW_GET_VAR(__GLEW_ARB_texture_non_power_of_two)
+
+#endif /* GL_ARB_texture_non_power_of_two */
+
+    /* ------------------------ GL_ARB_texture_query_lod ----------------------- */
+
+#ifndef GL_ARB_texture_query_lod
+#define GL_ARB_texture_query_lod 1
+
+#define GLEW_ARB_texture_query_lod GLEW_GET_VAR(__GLEW_ARB_texture_query_lod)
+
+#endif /* GL_ARB_texture_query_lod */
+
+    /* ------------------------ GL_ARB_texture_rectangle ----------------------- */
+
+#ifndef GL_ARB_texture_rectangle
+#define GL_ARB_texture_rectangle 1
+
+#define GL_TEXTURE_RECTANGLE_ARB 0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE_ARB 0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE_ARB 0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB 0x84F8
+#define GL_SAMPLER_2D_RECT_ARB 0x8B63
+#define GL_SAMPLER_2D_RECT_SHADOW_ARB 0x8B64
+
+#define GLEW_ARB_texture_rectangle GLEW_GET_VAR(__GLEW_ARB_texture_rectangle)
+
+#endif /* GL_ARB_texture_rectangle */
+
+    /* --------------------------- GL_ARB_texture_rg --------------------------- */
+
+#ifndef GL_ARB_texture_rg
+#define GL_ARB_texture_rg 1
+
+#define GL_RED 0x1903
+#define GL_COMPRESSED_RED 0x8225
+#define GL_COMPRESSED_RG 0x8226
+#define GL_RG 0x8227
+#define GL_RG_INTEGER 0x8228
+#define GL_R8 0x8229
+#define GL_R16 0x822A
+#define GL_RG8 0x822B
+#define GL_RG16 0x822C
+#define GL_R16F 0x822D
+#define GL_R32F 0x822E
+#define GL_RG16F 0x822F
+#define GL_RG32F 0x8230
+#define GL_R8I 0x8231
+#define GL_R8UI 0x8232
+#define GL_R16I 0x8233
+#define GL_R16UI 0x8234
+#define GL_R32I 0x8235
+#define GL_R32UI 0x8236
+#define GL_RG8I 0x8237
+#define GL_RG8UI 0x8238
+#define GL_RG16I 0x8239
+#define GL_RG16UI 0x823A
+#define GL_RG32I 0x823B
+#define GL_RG32UI 0x823C
+
+#define GLEW_ARB_texture_rg GLEW_GET_VAR(__GLEW_ARB_texture_rg)
+
+#endif /* GL_ARB_texture_rg */
+
+    /* ----------------------- GL_ARB_texture_rgb10_a2ui ----------------------- */
+
+#ifndef GL_ARB_texture_rgb10_a2ui
+#define GL_ARB_texture_rgb10_a2ui 1
+
+#define GL_RGB10_A2UI 0x906F
+
+#define GLEW_ARB_texture_rgb10_a2ui GLEW_GET_VAR(__GLEW_ARB_texture_rgb10_a2ui)
+
+#endif /* GL_ARB_texture_rgb10_a2ui */
+
+    /* ------------------------- GL_ARB_texture_swizzle ------------------------ */
+
+#ifndef GL_ARB_texture_swizzle
+#define GL_ARB_texture_swizzle 1
+
+#define GL_TEXTURE_SWIZZLE_R 0x8E42
+#define GL_TEXTURE_SWIZZLE_G 0x8E43
+#define GL_TEXTURE_SWIZZLE_B 0x8E44
+#define GL_TEXTURE_SWIZZLE_A 0x8E45
+#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
+
+#define GLEW_ARB_texture_swizzle GLEW_GET_VAR(__GLEW_ARB_texture_swizzle)
+
+#endif /* GL_ARB_texture_swizzle */
+
+    /* --------------------------- GL_ARB_timer_query -------------------------- */
+
+#ifndef GL_ARB_timer_query
+#define GL_ARB_timer_query 1
+
+#define GL_TIME_ELAPSED 0x88BF
+#define GL_TIMESTAMP 0x8E28
+
+    typedef void (GLAPIENTRY *PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 *params);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 *params);
+    typedef void (GLAPIENTRY *PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
+
+#define glGetQueryObjecti64v GLEW_GET_FUN(__glewGetQueryObjecti64v)
+#define glGetQueryObjectui64v GLEW_GET_FUN(__glewGetQueryObjectui64v)
+#define glQueryCounter GLEW_GET_FUN(__glewQueryCounter)
+
+#define GLEW_ARB_timer_query GLEW_GET_VAR(__GLEW_ARB_timer_query)
+
+#endif /* GL_ARB_timer_query */
+
+    /* ----------------------- GL_ARB_transform_feedback2 ---------------------- */
+
+#ifndef GL_ARB_transform_feedback2
+#define GL_ARB_transform_feedback2 1
+
+#define GL_TRANSFORM_FEEDBACK 0x8E22
+#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED 0x8E23
+#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE 0x8E24
+#define GL_TRANSFORM_FEEDBACK_BINDING 0x8E25
+
+    typedef void (GLAPIENTRY *PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
+    typedef void (GLAPIENTRY *PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
+    typedef void (GLAPIENTRY *PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint *ids);
+    typedef GLboolean(GLAPIENTRY *PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
+
+#define glBindTransformFeedback GLEW_GET_FUN(__glewBindTransformFeedback)
+#define glDeleteTransformFeedbacks GLEW_GET_FUN(__glewDeleteTransformFeedbacks)
+#define glDrawTransformFeedback GLEW_GET_FUN(__glewDrawTransformFeedback)
+#define glGenTransformFeedbacks GLEW_GET_FUN(__glewGenTransformFeedbacks)
+#define glIsTransformFeedback GLEW_GET_FUN(__glewIsTransformFeedback)
+#define glPauseTransformFeedback GLEW_GET_FUN(__glewPauseTransformFeedback)
+#define glResumeTransformFeedback GLEW_GET_FUN(__glewResumeTransformFeedback)
+
+#define GLEW_ARB_transform_feedback2 GLEW_GET_VAR(__GLEW_ARB_transform_feedback2)
+
+#endif /* GL_ARB_transform_feedback2 */
+
+    /* ----------------------- GL_ARB_transform_feedback3 ---------------------- */
+
+#ifndef GL_ARB_transform_feedback3
+#define GL_ARB_transform_feedback3 1
+
+#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
+#define GL_MAX_VERTEX_STREAMS 0x8E71
+
+    typedef void (GLAPIENTRY *PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
+    typedef void (GLAPIENTRY *PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
+    typedef void (GLAPIENTRY *PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint *params);
+
+#define glBeginQueryIndexed GLEW_GET_FUN(__glewBeginQueryIndexed)
+#define glDrawTransformFeedbackStream GLEW_GET_FUN(__glewDrawTransformFeedbackStream)
+#define glEndQueryIndexed GLEW_GET_FUN(__glewEndQueryIndexed)
+#define glGetQueryIndexediv GLEW_GET_FUN(__glewGetQueryIndexediv)
+
+#define GLEW_ARB_transform_feedback3 GLEW_GET_VAR(__GLEW_ARB_transform_feedback3)
+
+#endif /* GL_ARB_transform_feedback3 */
+
+    /* ------------------------ GL_ARB_transpose_matrix ------------------------ */
+
+#ifndef GL_ARB_transpose_matrix
+#define GL_ARB_transpose_matrix 1
+
+#define GL_TRANSPOSE_MODELVIEW_MATRIX_ARB 0x84E3
+#define GL_TRANSPOSE_PROJECTION_MATRIX_ARB 0x84E4
+#define GL_TRANSPOSE_TEXTURE_MATRIX_ARB 0x84E5
+#define GL_TRANSPOSE_COLOR_MATRIX_ARB 0x84E6
+
+    typedef void (GLAPIENTRY *PFNGLLOADTRANSPOSEMATRIXDARBPROC)(GLdouble m[16]);
+    typedef void (GLAPIENTRY *PFNGLLOADTRANSPOSEMATRIXFARBPROC)(GLfloat m[16]);
+    typedef void (GLAPIENTRY *PFNGLMULTTRANSPOSEMATRIXDARBPROC)(GLdouble m[16]);
+    typedef void (GLAPIENTRY *PFNGLMULTTRANSPOSEMATRIXFARBPROC)(GLfloat m[16]);
+
+#define glLoadTransposeMatrixdARB GLEW_GET_FUN(__glewLoadTransposeMatrixdARB)
+#define glLoadTransposeMatrixfARB GLEW_GET_FUN(__glewLoadTransposeMatrixfARB)
+#define glMultTransposeMatrixdARB GLEW_GET_FUN(__glewMultTransposeMatrixdARB)
+#define glMultTransposeMatrixfARB GLEW_GET_FUN(__glewMultTransposeMatrixfARB)
+
+#define GLEW_ARB_transpose_matrix GLEW_GET_VAR(__GLEW_ARB_transpose_matrix)
+
+#endif /* GL_ARB_transpose_matrix */
+
+    /* ---------------------- GL_ARB_uniform_buffer_object --------------------- */
+
+#ifndef GL_ARB_uniform_buffer_object
+#define GL_ARB_uniform_buffer_object 1
+
+#define GL_UNIFORM_BUFFER 0x8A11
+#define GL_UNIFORM_BUFFER_BINDING 0x8A28
+#define GL_UNIFORM_BUFFER_START 0x8A29
+#define GL_UNIFORM_BUFFER_SIZE 0x8A2A
+#define GL_MAX_VERTEX_UNIFORM_BLOCKS 0x8A2B
+#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS 0x8A2C
+#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS 0x8A2D
+#define GL_MAX_COMBINED_UNIFORM_BLOCKS 0x8A2E
+#define GL_MAX_UNIFORM_BUFFER_BINDINGS 0x8A2F
+#define GL_MAX_UNIFORM_BLOCK_SIZE 0x8A30
+#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
+#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
+#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
+#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
+#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
+#define GL_ACTIVE_UNIFORM_BLOCKS 0x8A36
+#define GL_UNIFORM_TYPE 0x8A37
+#define GL_UNIFORM_SIZE 0x8A38
+#define GL_UNIFORM_NAME_LENGTH 0x8A39
+#define GL_UNIFORM_BLOCK_INDEX 0x8A3A
+#define GL_UNIFORM_OFFSET 0x8A3B
+#define GL_UNIFORM_ARRAY_STRIDE 0x8A3C
+#define GL_UNIFORM_MATRIX_STRIDE 0x8A3D
+#define GL_UNIFORM_IS_ROW_MAJOR 0x8A3E
+#define GL_UNIFORM_BLOCK_BINDING 0x8A3F
+#define GL_UNIFORM_BLOCK_DATA_SIZE 0x8A40
+#define GL_UNIFORM_BLOCK_NAME_LENGTH 0x8A41
+#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS 0x8A42
+#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
+#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
+#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
+#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
+#define GL_INVALID_INDEX 0xFFFFFFFF
+
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, char *uniformBlockName);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, char *uniformName);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint *data);
+    typedef GLuint(GLAPIENTRY *PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const char *uniformBlockName);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const char **uniformNames, GLuint *uniformIndices);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
+
+#define glBindBufferBase GLEW_GET_FUN(__glewBindBufferBase)
+#define glBindBufferRange GLEW_GET_FUN(__glewBindBufferRange)
+#define glGetActiveUniformBlockName GLEW_GET_FUN(__glewGetActiveUniformBlockName)
+#define glGetActiveUniformBlockiv GLEW_GET_FUN(__glewGetActiveUniformBlockiv)
+#define glGetActiveUniformName GLEW_GET_FUN(__glewGetActiveUniformName)
+#define glGetActiveUniformsiv GLEW_GET_FUN(__glewGetActiveUniformsiv)
+#define glGetIntegeri_v GLEW_GET_FUN(__glewGetIntegeri_v)
+#define glGetUniformBlockIndex GLEW_GET_FUN(__glewGetUniformBlockIndex)
+#define glGetUniformIndices GLEW_GET_FUN(__glewGetUniformIndices)
+#define glUniformBlockBinding GLEW_GET_FUN(__glewUniformBlockBinding)
+
+#define GLEW_ARB_uniform_buffer_object GLEW_GET_VAR(__GLEW_ARB_uniform_buffer_object)
+
+#endif /* GL_ARB_uniform_buffer_object */
+
+    /* ------------------------ GL_ARB_vertex_array_bgra ----------------------- */
+
+#ifndef GL_ARB_vertex_array_bgra
+#define GL_ARB_vertex_array_bgra 1
+
+#define GL_BGRA 0x80E1
+
+#define GLEW_ARB_vertex_array_bgra GLEW_GET_VAR(__GLEW_ARB_vertex_array_bgra)
+
+#endif /* GL_ARB_vertex_array_bgra */
+
+    /* ----------------------- GL_ARB_vertex_array_object ---------------------- */
+
+#ifndef GL_ARB_vertex_array_object
+#define GL_ARB_vertex_array_object 1
+
+#define GL_VERTEX_ARRAY_BINDING 0x85B5
+
+    typedef void (GLAPIENTRY *PFNGLBINDVERTEXARRAYPROC)(GLuint array);
+    typedef void (GLAPIENTRY *PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint *arrays);
+    typedef void (GLAPIENTRY *PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint *arrays);
+    typedef GLboolean(GLAPIENTRY *PFNGLISVERTEXARRAYPROC)(GLuint array);
+
+#define glBindVertexArray GLEW_GET_FUN(__glewBindVertexArray)
+#define glDeleteVertexArrays GLEW_GET_FUN(__glewDeleteVertexArrays)
+#define glGenVertexArrays GLEW_GET_FUN(__glewGenVertexArrays)
+#define glIsVertexArray GLEW_GET_FUN(__glewIsVertexArray)
+
+#define GLEW_ARB_vertex_array_object GLEW_GET_VAR(__GLEW_ARB_vertex_array_object)
+
+#endif /* GL_ARB_vertex_array_object */
+
+    /* -------------------------- GL_ARB_vertex_blend -------------------------- */
+
+#ifndef GL_ARB_vertex_blend
+#define GL_ARB_vertex_blend 1
+
+#define GL_MODELVIEW0_ARB 0x1700
+#define GL_MODELVIEW1_ARB 0x850A
+#define GL_MAX_VERTEX_UNITS_ARB 0x86A4
+#define GL_ACTIVE_VERTEX_UNITS_ARB 0x86A5
+#define GL_WEIGHT_SUM_UNITY_ARB 0x86A6
+#define GL_VERTEX_BLEND_ARB 0x86A7
+#define GL_CURRENT_WEIGHT_ARB 0x86A8
+#define GL_WEIGHT_ARRAY_TYPE_ARB 0x86A9
+#define GL_WEIGHT_ARRAY_STRIDE_ARB 0x86AA
+#define GL_WEIGHT_ARRAY_SIZE_ARB 0x86AB
+#define GL_WEIGHT_ARRAY_POINTER_ARB 0x86AC
+#define GL_WEIGHT_ARRAY_ARB 0x86AD
+#define GL_MODELVIEW2_ARB 0x8722
+#define GL_MODELVIEW3_ARB 0x8723
+#define GL_MODELVIEW4_ARB 0x8724
+#define GL_MODELVIEW5_ARB 0x8725
+#define GL_MODELVIEW6_ARB 0x8726
+#define GL_MODELVIEW7_ARB 0x8727
+#define GL_MODELVIEW8_ARB 0x8728
+#define GL_MODELVIEW9_ARB 0x8729
+#define GL_MODELVIEW10_ARB 0x872A
+#define GL_MODELVIEW11_ARB 0x872B
+#define GL_MODELVIEW12_ARB 0x872C
+#define GL_MODELVIEW13_ARB 0x872D
+#define GL_MODELVIEW14_ARB 0x872E
+#define GL_MODELVIEW15_ARB 0x872F
+#define GL_MODELVIEW16_ARB 0x8730
+#define GL_MODELVIEW17_ARB 0x8731
+#define GL_MODELVIEW18_ARB 0x8732
+#define GL_MODELVIEW19_ARB 0x8733
+#define GL_MODELVIEW20_ARB 0x8734
+#define GL_MODELVIEW21_ARB 0x8735
+#define GL_MODELVIEW22_ARB 0x8736
+#define GL_MODELVIEW23_ARB 0x8737
+#define GL_MODELVIEW24_ARB 0x8738
+#define GL_MODELVIEW25_ARB 0x8739
+#define GL_MODELVIEW26_ARB 0x873A
+#define GL_MODELVIEW27_ARB 0x873B
+#define GL_MODELVIEW28_ARB 0x873C
+#define GL_MODELVIEW29_ARB 0x873D
+#define GL_MODELVIEW30_ARB 0x873E
+#define GL_MODELVIEW31_ARB 0x873F
+
+    typedef void (GLAPIENTRY *PFNGLVERTEXBLENDARBPROC)(GLint count);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTBVARBPROC)(GLint size, GLbyte *weights);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTDVARBPROC)(GLint size, GLdouble *weights);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTFVARBPROC)(GLint size, GLfloat *weights);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTIVARBPROC)(GLint size, GLint *weights);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTSVARBPROC)(GLint size, GLshort *weights);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTUBVARBPROC)(GLint size, GLubyte *weights);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTUIVARBPROC)(GLint size, GLuint *weights);
+    typedef void (GLAPIENTRY *PFNGLWEIGHTUSVARBPROC)(GLint size, GLushort *weights);
+
+#define glVertexBlendARB GLEW_GET_FUN(__glewVertexBlendARB)
+#define glWeightPointerARB GLEW_GET_FUN(__glewWeightPointerARB)
+#define glWeightbvARB GLEW_GET_FUN(__glewWeightbvARB)
+#define glWeightdvARB GLEW_GET_FUN(__glewWeightdvARB)
+#define glWeightfvARB GLEW_GET_FUN(__glewWeightfvARB)
+#define glWeightivARB GLEW_GET_FUN(__glewWeightivARB)
+#define glWeightsvARB GLEW_GET_FUN(__glewWeightsvARB)
+#define glWeightubvARB GLEW_GET_FUN(__glewWeightubvARB)
+#define glWeightuivARB GLEW_GET_FUN(__glewWeightuivARB)
+#define glWeightusvARB GLEW_GET_FUN(__glewWeightusvARB)
+
+#define GLEW_ARB_vertex_blend GLEW_GET_VAR(__GLEW_ARB_vertex_blend)
+
+#endif /* GL_ARB_vertex_blend */
+
+    /* ---------------------- GL_ARB_vertex_buffer_object ---------------------- */
+
+#ifndef GL_ARB_vertex_buffer_object
+#define GL_ARB_vertex_buffer_object 1
+
+#define GL_BUFFER_SIZE_ARB 0x8764
+#define GL_BUFFER_USAGE_ARB 0x8765
+#define GL_ARRAY_BUFFER_ARB 0x8892
+#define GL_ELEMENT_ARRAY_BUFFER_ARB 0x8893
+#define GL_ARRAY_BUFFER_BINDING_ARB 0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB 0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB 0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB 0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB 0x8898
+#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB 0x8899
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB 0x889A
+#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB 0x889B
+#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB 0x889C
+#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB 0x889D
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB 0x889E
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB 0x889F
+#define GL_READ_ONLY_ARB 0x88B8
+#define GL_WRITE_ONLY_ARB 0x88B9
+#define GL_READ_WRITE_ARB 0x88BA
+#define GL_BUFFER_ACCESS_ARB 0x88BB
+#define GL_BUFFER_MAPPED_ARB 0x88BC
+#define GL_BUFFER_MAP_POINTER_ARB 0x88BD
+#define GL_STREAM_DRAW_ARB 0x88E0
+#define GL_STREAM_READ_ARB 0x88E1
+#define GL_STREAM_COPY_ARB 0x88E2
+#define GL_STATIC_DRAW_ARB 0x88E4
+#define GL_STATIC_READ_ARB 0x88E5
+#define GL_STATIC_COPY_ARB 0x88E6
+#define GL_DYNAMIC_DRAW_ARB 0x88E8
+#define GL_DYNAMIC_READ_ARB 0x88E9
+#define GL_DYNAMIC_COPY_ARB 0x88EA
+
+    typedef ptrdiff_t GLsizeiptrARB;
+    typedef ptrdiff_t GLintptrARB;
+
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFERARBPROC)(GLenum target, GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLBUFFERDATAARBPROC)(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+    typedef void (GLAPIENTRY *PFNGLBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+    typedef void (GLAPIENTRY *PFNGLDELETEBUFFERSARBPROC)(GLsizei n, const GLuint *buffers);
+    typedef void (GLAPIENTRY *PFNGLGENBUFFERSARBPROC)(GLsizei n, GLuint *buffers);
+    typedef void (GLAPIENTRY *PFNGLGETBUFFERPARAMETERIVARBPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETBUFFERPOINTERVARBPROC)(GLenum target, GLenum pname, GLvoid **params);
+    typedef void (GLAPIENTRY *PFNGLGETBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+    typedef GLboolean(GLAPIENTRY *PFNGLISBUFFERARBPROC)(GLuint buffer);
+    typedef GLvoid *(GLAPIENTRY *PFNGLMAPBUFFERARBPROC)(GLenum target, GLenum access);
+    typedef GLboolean(GLAPIENTRY *PFNGLUNMAPBUFFERARBPROC)(GLenum target);
+
+#define glBindBufferARB GLEW_GET_FUN(__glewBindBufferARB)
+#define glBufferDataARB GLEW_GET_FUN(__glewBufferDataARB)
+#define glBufferSubDataARB GLEW_GET_FUN(__glewBufferSubDataARB)
+#define glDeleteBuffersARB GLEW_GET_FUN(__glewDeleteBuffersARB)
+#define glGenBuffersARB GLEW_GET_FUN(__glewGenBuffersARB)
+#define glGetBufferParameterivARB GLEW_GET_FUN(__glewGetBufferParameterivARB)
+#define glGetBufferPointervARB GLEW_GET_FUN(__glewGetBufferPointervARB)
+#define glGetBufferSubDataARB GLEW_GET_FUN(__glewGetBufferSubDataARB)
+#define glIsBufferARB GLEW_GET_FUN(__glewIsBufferARB)
+#define glMapBufferARB GLEW_GET_FUN(__glewMapBufferARB)
+#define glUnmapBufferARB GLEW_GET_FUN(__glewUnmapBufferARB)
+
+#define GLEW_ARB_vertex_buffer_object GLEW_GET_VAR(__GLEW_ARB_vertex_buffer_object)
+
+#endif /* GL_ARB_vertex_buffer_object */
+
+    /* ------------------------- GL_ARB_vertex_program ------------------------- */
+
+#ifndef GL_ARB_vertex_program
+#define GL_ARB_vertex_program 1
+
+#define GL_COLOR_SUM_ARB 0x8458
+#define GL_VERTEX_PROGRAM_ARB 0x8620
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB 0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB 0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB 0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB 0x8625
+#define GL_CURRENT_VERTEX_ATTRIB_ARB 0x8626
+#define GL_PROGRAM_LENGTH_ARB 0x8627
+#define GL_PROGRAM_STRING_ARB 0x8628
+#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB 0x862E
+#define GL_MAX_PROGRAM_MATRICES_ARB 0x862F
+#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB 0x8640
+#define GL_CURRENT_MATRIX_ARB 0x8641
+#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB 0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB 0x8643
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB 0x8645
+#define GL_PROGRAM_ERROR_POSITION_ARB 0x864B
+#define GL_PROGRAM_BINDING_ARB 0x8677
+#define GL_MAX_VERTEX_ATTRIBS_ARB 0x8869
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB 0x886A
+#define GL_PROGRAM_ERROR_STRING_ARB 0x8874
+#define GL_PROGRAM_FORMAT_ASCII_ARB 0x8875
+#define GL_PROGRAM_FORMAT_ARB 0x8876
+#define GL_PROGRAM_INSTRUCTIONS_ARB 0x88A0
+#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB 0x88A1
+#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A2
+#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A3
+#define GL_PROGRAM_TEMPORARIES_ARB 0x88A4
+#define GL_MAX_PROGRAM_TEMPORARIES_ARB 0x88A5
+#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A6
+#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A7
+#define GL_PROGRAM_PARAMETERS_ARB 0x88A8
+#define GL_MAX_PROGRAM_PARAMETERS_ARB 0x88A9
+#define GL_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AA
+#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AB
+#define GL_PROGRAM_ATTRIBS_ARB 0x88AC
+#define GL_MAX_PROGRAM_ATTRIBS_ARB 0x88AD
+#define GL_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AE
+#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AF
+#define GL_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B0
+#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B1
+#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B2
+#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B3
+#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB 0x88B4
+#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB 0x88B5
+#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB 0x88B6
+#define GL_TRANSPOSE_CURRENT_MATRIX_ARB 0x88B7
+#define GL_MATRIX0_ARB 0x88C0
+#define GL_MATRIX1_ARB 0x88C1
+#define GL_MATRIX2_ARB 0x88C2
+#define GL_MATRIX3_ARB 0x88C3
+#define GL_MATRIX4_ARB 0x88C4
+#define GL_MATRIX5_ARB 0x88C5
+#define GL_MATRIX6_ARB 0x88C6
+#define GL_MATRIX7_ARB 0x88C7
+#define GL_MATRIX8_ARB 0x88C8
+#define GL_MATRIX9_ARB 0x88C9
+#define GL_MATRIX10_ARB 0x88CA
+#define GL_MATRIX11_ARB 0x88CB
+#define GL_MATRIX12_ARB 0x88CC
+#define GL_MATRIX13_ARB 0x88CD
+#define GL_MATRIX14_ARB 0x88CE
+#define GL_MATRIX15_ARB 0x88CF
+#define GL_MATRIX16_ARB 0x88D0
+#define GL_MATRIX17_ARB 0x88D1
+#define GL_MATRIX18_ARB 0x88D2
+#define GL_MATRIX19_ARB 0x88D3
+#define GL_MATRIX20_ARB 0x88D4
+#define GL_MATRIX21_ARB 0x88D5
+#define GL_MATRIX22_ARB 0x88D6
+#define GL_MATRIX23_ARB 0x88D7
+#define GL_MATRIX24_ARB 0x88D8
+#define GL_MATRIX25_ARB 0x88D9
+#define GL_MATRIX26_ARB 0x88DA
+#define GL_MATRIX27_ARB 0x88DB
+#define GL_MATRIX28_ARB 0x88DC
+#define GL_MATRIX29_ARB 0x88DD
+#define GL_MATRIX30_ARB 0x88DE
+#define GL_MATRIX31_ARB 0x88DF
+
+    typedef void (GLAPIENTRY *PFNGLBINDPROGRAMARBPROC)(GLenum target, GLuint program);
+    typedef void (GLAPIENTRY *PFNGLDELETEPROGRAMSARBPROC)(GLsizei n, const GLuint *programs);
+    typedef void (GLAPIENTRY *PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
+    typedef void (GLAPIENTRY *PFNGLENABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
+    typedef void (GLAPIENTRY *PFNGLGENPROGRAMSARBPROC)(GLsizei n, GLuint *programs);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMENVPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMENVPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMSTRINGARBPROC)(GLenum target, GLenum pname, void *string);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMIVARBPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBPOINTERVARBPROC)(GLuint index, GLenum pname, GLvoid **pointer);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBDVARBPROC)(GLuint index, GLenum pname, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBFVARBPROC)(GLuint index, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBIVARBPROC)(GLuint index, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISPROGRAMARBPROC)(GLuint program);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMSTRINGARBPROC)(GLenum target, GLenum format, GLsizei len, const void *string);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1DARBPROC)(GLuint index, GLdouble x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1DVARBPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1FARBPROC)(GLuint index, GLfloat x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1FVARBPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1SARBPROC)(GLuint index, GLshort x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1SVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2DARBPROC)(GLuint index, GLdouble x, GLdouble y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2DVARBPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2FARBPROC)(GLuint index, GLfloat x, GLfloat y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2FVARBPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2SARBPROC)(GLuint index, GLshort x, GLshort y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2SVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3DVARBPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3FVARBPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3SVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NBVARBPROC)(GLuint index, const GLbyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NIVARBPROC)(GLuint index, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NSVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NUBARBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NUBVARBPROC)(GLuint index, const GLubyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NUIVARBPROC)(GLuint index, const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4NUSVARBPROC)(GLuint index, const GLushort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4BVARBPROC)(GLuint index, const GLbyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4DVARBPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4FVARBPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4IVARBPROC)(GLuint index, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4SVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4UBVARBPROC)(GLuint index, const GLubyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4UIVARBPROC)(GLuint index, const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4USVARBPROC)(GLuint index, const GLushort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBPOINTERARBPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
+
+#define glBindProgramARB GLEW_GET_FUN(__glewBindProgramARB)
+#define glDeleteProgramsARB GLEW_GET_FUN(__glewDeleteProgramsARB)
+#define glDisableVertexAttribArrayARB GLEW_GET_FUN(__glewDisableVertexAttribArrayARB)
+#define glEnableVertexAttribArrayARB GLEW_GET_FUN(__glewEnableVertexAttribArrayARB)
+#define glGenProgramsARB GLEW_GET_FUN(__glewGenProgramsARB)
+#define glGetProgramEnvParameterdvARB GLEW_GET_FUN(__glewGetProgramEnvParameterdvARB)
+#define glGetProgramEnvParameterfvARB GLEW_GET_FUN(__glewGetProgramEnvParameterfvARB)
+#define glGetProgramLocalParameterdvARB GLEW_GET_FUN(__glewGetProgramLocalParameterdvARB)
+#define glGetProgramLocalParameterfvARB GLEW_GET_FUN(__glewGetProgramLocalParameterfvARB)
+#define glGetProgramStringARB GLEW_GET_FUN(__glewGetProgramStringARB)
+#define glGetProgramivARB GLEW_GET_FUN(__glewGetProgramivARB)
+#define glGetVertexAttribPointervARB GLEW_GET_FUN(__glewGetVertexAttribPointervARB)
+#define glGetVertexAttribdvARB GLEW_GET_FUN(__glewGetVertexAttribdvARB)
+#define glGetVertexAttribfvARB GLEW_GET_FUN(__glewGetVertexAttribfvARB)
+#define glGetVertexAttribivARB GLEW_GET_FUN(__glewGetVertexAttribivARB)
+#define glIsProgramARB GLEW_GET_FUN(__glewIsProgramARB)
+#define glProgramEnvParameter4dARB GLEW_GET_FUN(__glewProgramEnvParameter4dARB)
+#define glProgramEnvParameter4dvARB GLEW_GET_FUN(__glewProgramEnvParameter4dvARB)
+#define glProgramEnvParameter4fARB GLEW_GET_FUN(__glewProgramEnvParameter4fARB)
+#define glProgramEnvParameter4fvARB GLEW_GET_FUN(__glewProgramEnvParameter4fvARB)
+#define glProgramLocalParameter4dARB GLEW_GET_FUN(__glewProgramLocalParameter4dARB)
+#define glProgramLocalParameter4dvARB GLEW_GET_FUN(__glewProgramLocalParameter4dvARB)
+#define glProgramLocalParameter4fARB GLEW_GET_FUN(__glewProgramLocalParameter4fARB)
+#define glProgramLocalParameter4fvARB GLEW_GET_FUN(__glewProgramLocalParameter4fvARB)
+#define glProgramStringARB GLEW_GET_FUN(__glewProgramStringARB)
+#define glVertexAttrib1dARB GLEW_GET_FUN(__glewVertexAttrib1dARB)
+#define glVertexAttrib1dvARB GLEW_GET_FUN(__glewVertexAttrib1dvARB)
+#define glVertexAttrib1fARB GLEW_GET_FUN(__glewVertexAttrib1fARB)
+#define glVertexAttrib1fvARB GLEW_GET_FUN(__glewVertexAttrib1fvARB)
+#define glVertexAttrib1sARB GLEW_GET_FUN(__glewVertexAttrib1sARB)
+#define glVertexAttrib1svARB GLEW_GET_FUN(__glewVertexAttrib1svARB)
+#define glVertexAttrib2dARB GLEW_GET_FUN(__glewVertexAttrib2dARB)
+#define glVertexAttrib2dvARB GLEW_GET_FUN(__glewVertexAttrib2dvARB)
+#define glVertexAttrib2fARB GLEW_GET_FUN(__glewVertexAttrib2fARB)
+#define glVertexAttrib2fvARB GLEW_GET_FUN(__glewVertexAttrib2fvARB)
+#define glVertexAttrib2sARB GLEW_GET_FUN(__glewVertexAttrib2sARB)
+#define glVertexAttrib2svARB GLEW_GET_FUN(__glewVertexAttrib2svARB)
+#define glVertexAttrib3dARB GLEW_GET_FUN(__glewVertexAttrib3dARB)
+#define glVertexAttrib3dvARB GLEW_GET_FUN(__glewVertexAttrib3dvARB)
+#define glVertexAttrib3fARB GLEW_GET_FUN(__glewVertexAttrib3fARB)
+#define glVertexAttrib3fvARB GLEW_GET_FUN(__glewVertexAttrib3fvARB)
+#define glVertexAttrib3sARB GLEW_GET_FUN(__glewVertexAttrib3sARB)
+#define glVertexAttrib3svARB GLEW_GET_FUN(__glewVertexAttrib3svARB)
+#define glVertexAttrib4NbvARB GLEW_GET_FUN(__glewVertexAttrib4NbvARB)
+#define glVertexAttrib4NivARB GLEW_GET_FUN(__glewVertexAttrib4NivARB)
+#define glVertexAttrib4NsvARB GLEW_GET_FUN(__glewVertexAttrib4NsvARB)
+#define glVertexAttrib4NubARB GLEW_GET_FUN(__glewVertexAttrib4NubARB)
+#define glVertexAttrib4NubvARB GLEW_GET_FUN(__glewVertexAttrib4NubvARB)
+#define glVertexAttrib4NuivARB GLEW_GET_FUN(__glewVertexAttrib4NuivARB)
+#define glVertexAttrib4NusvARB GLEW_GET_FUN(__glewVertexAttrib4NusvARB)
+#define glVertexAttrib4bvARB GLEW_GET_FUN(__glewVertexAttrib4bvARB)
+#define glVertexAttrib4dARB GLEW_GET_FUN(__glewVertexAttrib4dARB)
+#define glVertexAttrib4dvARB GLEW_GET_FUN(__glewVertexAttrib4dvARB)
+#define glVertexAttrib4fARB GLEW_GET_FUN(__glewVertexAttrib4fARB)
+#define glVertexAttrib4fvARB GLEW_GET_FUN(__glewVertexAttrib4fvARB)
+#define glVertexAttrib4ivARB GLEW_GET_FUN(__glewVertexAttrib4ivARB)
+#define glVertexAttrib4sARB GLEW_GET_FUN(__glewVertexAttrib4sARB)
+#define glVertexAttrib4svARB GLEW_GET_FUN(__glewVertexAttrib4svARB)
+#define glVertexAttrib4ubvARB GLEW_GET_FUN(__glewVertexAttrib4ubvARB)
+#define glVertexAttrib4uivARB GLEW_GET_FUN(__glewVertexAttrib4uivARB)
+#define glVertexAttrib4usvARB GLEW_GET_FUN(__glewVertexAttrib4usvARB)
+#define glVertexAttribPointerARB GLEW_GET_FUN(__glewVertexAttribPointerARB)
+
+#define GLEW_ARB_vertex_program GLEW_GET_VAR(__GLEW_ARB_vertex_program)
+
+#endif /* GL_ARB_vertex_program */
+
+    /* -------------------------- GL_ARB_vertex_shader ------------------------- */
+
+#ifndef GL_ARB_vertex_shader
+#define GL_ARB_vertex_shader 1
+
+#define GL_VERTEX_SHADER_ARB 0x8B31
+#define GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB 0x8B4A
+#define GL_MAX_VARYING_FLOATS_ARB 0x8B4B
+#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB 0x8B4C
+#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB 0x8B4D
+#define GL_OBJECT_ACTIVE_ATTRIBUTES_ARB 0x8B89
+#define GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB 0x8B8A
+
+    typedef void (GLAPIENTRY *PFNGLBINDATTRIBLOCATIONARBPROC)(GLhandleARB programObj, GLuint index, const GLcharARB *name);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEATTRIBARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+    typedef GLint(GLAPIENTRY *PFNGLGETATTRIBLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB *name);
+
+#define glBindAttribLocationARB GLEW_GET_FUN(__glewBindAttribLocationARB)
+#define glGetActiveAttribARB GLEW_GET_FUN(__glewGetActiveAttribARB)
+#define glGetAttribLocationARB GLEW_GET_FUN(__glewGetAttribLocationARB)
+
+#define GLEW_ARB_vertex_shader GLEW_GET_VAR(__GLEW_ARB_vertex_shader)
+
+#endif /* GL_ARB_vertex_shader */
+
+    /* ------------------- GL_ARB_vertex_type_2_10_10_10_rev ------------------- */
+
+#ifndef GL_ARB_vertex_type_2_10_10_10_rev
+#define GL_ARB_vertex_type_2_10_10_10_rev 1
+
+#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
+#define GL_INT_2_10_10_10_REV 0x8D9F
+
+    typedef void (GLAPIENTRY *PFNGLCOLORP3UIPROC)(GLenum type, GLuint color);
+    typedef void (GLAPIENTRY *PFNGLCOLORP3UIVPROC)(GLenum type, const GLuint *color);
+    typedef void (GLAPIENTRY *PFNGLCOLORP4UIPROC)(GLenum type, GLuint color);
+    typedef void (GLAPIENTRY *PFNGLCOLORP4UIVPROC)(GLenum type, const GLuint *color);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDP1UIPROC)(GLenum texture, GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDP1UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDP2UIPROC)(GLenum texture, GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDP2UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDP3UIPROC)(GLenum texture, GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDP3UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDP4UIPROC)(GLenum texture, GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDP4UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLNORMALP3UIPROC)(GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLNORMALP3UIVPROC)(GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLORP3UIPROC)(GLenum type, GLuint color);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLORP3UIVPROC)(GLenum type, const GLuint *color);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDP1UIPROC)(GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDP1UIVPROC)(GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDP2UIPROC)(GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDP2UIVPROC)(GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDP3UIPROC)(GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDP3UIVPROC)(GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDP4UIPROC)(GLenum type, GLuint coords);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDP4UIVPROC)(GLenum type, const GLuint *coords);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXP2UIPROC)(GLenum type, GLuint value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXP2UIVPROC)(GLenum type, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXP3UIPROC)(GLenum type, GLuint value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXP3UIVPROC)(GLenum type, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXP4UIPROC)(GLenum type, GLuint value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXP4UIVPROC)(GLenum type, const GLuint *value);
+
+#define glColorP3ui GLEW_GET_FUN(__glewColorP3ui)
+#define glColorP3uiv GLEW_GET_FUN(__glewColorP3uiv)
+#define glColorP4ui GLEW_GET_FUN(__glewColorP4ui)
+#define glColorP4uiv GLEW_GET_FUN(__glewColorP4uiv)
+#define glMultiTexCoordP1ui GLEW_GET_FUN(__glewMultiTexCoordP1ui)
+#define glMultiTexCoordP1uiv GLEW_GET_FUN(__glewMultiTexCoordP1uiv)
+#define glMultiTexCoordP2ui GLEW_GET_FUN(__glewMultiTexCoordP2ui)
+#define glMultiTexCoordP2uiv GLEW_GET_FUN(__glewMultiTexCoordP2uiv)
+#define glMultiTexCoordP3ui GLEW_GET_FUN(__glewMultiTexCoordP3ui)
+#define glMultiTexCoordP3uiv GLEW_GET_FUN(__glewMultiTexCoordP3uiv)
+#define glMultiTexCoordP4ui GLEW_GET_FUN(__glewMultiTexCoordP4ui)
+#define glMultiTexCoordP4uiv GLEW_GET_FUN(__glewMultiTexCoordP4uiv)
+#define glNormalP3ui GLEW_GET_FUN(__glewNormalP3ui)
+#define glNormalP3uiv GLEW_GET_FUN(__glewNormalP3uiv)
+#define glSecondaryColorP3ui GLEW_GET_FUN(__glewSecondaryColorP3ui)
+#define glSecondaryColorP3uiv GLEW_GET_FUN(__glewSecondaryColorP3uiv)
+#define glTexCoordP1ui GLEW_GET_FUN(__glewTexCoordP1ui)
+#define glTexCoordP1uiv GLEW_GET_FUN(__glewTexCoordP1uiv)
+#define glTexCoordP2ui GLEW_GET_FUN(__glewTexCoordP2ui)
+#define glTexCoordP2uiv GLEW_GET_FUN(__glewTexCoordP2uiv)
+#define glTexCoordP3ui GLEW_GET_FUN(__glewTexCoordP3ui)
+#define glTexCoordP3uiv GLEW_GET_FUN(__glewTexCoordP3uiv)
+#define glTexCoordP4ui GLEW_GET_FUN(__glewTexCoordP4ui)
+#define glTexCoordP4uiv GLEW_GET_FUN(__glewTexCoordP4uiv)
+#define glVertexAttribP1ui GLEW_GET_FUN(__glewVertexAttribP1ui)
+#define glVertexAttribP1uiv GLEW_GET_FUN(__glewVertexAttribP1uiv)
+#define glVertexAttribP2ui GLEW_GET_FUN(__glewVertexAttribP2ui)
+#define glVertexAttribP2uiv GLEW_GET_FUN(__glewVertexAttribP2uiv)
+#define glVertexAttribP3ui GLEW_GET_FUN(__glewVertexAttribP3ui)
+#define glVertexAttribP3uiv GLEW_GET_FUN(__glewVertexAttribP3uiv)
+#define glVertexAttribP4ui GLEW_GET_FUN(__glewVertexAttribP4ui)
+#define glVertexAttribP4uiv GLEW_GET_FUN(__glewVertexAttribP4uiv)
+#define glVertexP2ui GLEW_GET_FUN(__glewVertexP2ui)
+#define glVertexP2uiv GLEW_GET_FUN(__glewVertexP2uiv)
+#define glVertexP3ui GLEW_GET_FUN(__glewVertexP3ui)
+#define glVertexP3uiv GLEW_GET_FUN(__glewVertexP3uiv)
+#define glVertexP4ui GLEW_GET_FUN(__glewVertexP4ui)
+#define glVertexP4uiv GLEW_GET_FUN(__glewVertexP4uiv)
+
+#define GLEW_ARB_vertex_type_2_10_10_10_rev GLEW_GET_VAR(__GLEW_ARB_vertex_type_2_10_10_10_rev)
+
+#endif /* GL_ARB_vertex_type_2_10_10_10_rev */
+
+    /* --------------------------- GL_ARB_window_pos --------------------------- */
+
+#ifndef GL_ARB_window_pos
+#define GL_ARB_window_pos 1
+
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2DARBPROC)(GLdouble x, GLdouble y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2DVARBPROC)(const GLdouble *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2FARBPROC)(GLfloat x, GLfloat y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2FVARBPROC)(const GLfloat *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2IARBPROC)(GLint x, GLint y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2IVARBPROC)(const GLint *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2SARBPROC)(GLshort x, GLshort y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2SVARBPROC)(const GLshort *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3DARBPROC)(GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3DVARBPROC)(const GLdouble *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3FARBPROC)(GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3FVARBPROC)(const GLfloat *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3IARBPROC)(GLint x, GLint y, GLint z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3IVARBPROC)(const GLint *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3SARBPROC)(GLshort x, GLshort y, GLshort z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3SVARBPROC)(const GLshort *p);
+
+#define glWindowPos2dARB GLEW_GET_FUN(__glewWindowPos2dARB)
+#define glWindowPos2dvARB GLEW_GET_FUN(__glewWindowPos2dvARB)
+#define glWindowPos2fARB GLEW_GET_FUN(__glewWindowPos2fARB)
+#define glWindowPos2fvARB GLEW_GET_FUN(__glewWindowPos2fvARB)
+#define glWindowPos2iARB GLEW_GET_FUN(__glewWindowPos2iARB)
+#define glWindowPos2ivARB GLEW_GET_FUN(__glewWindowPos2ivARB)
+#define glWindowPos2sARB GLEW_GET_FUN(__glewWindowPos2sARB)
+#define glWindowPos2svARB GLEW_GET_FUN(__glewWindowPos2svARB)
+#define glWindowPos3dARB GLEW_GET_FUN(__glewWindowPos3dARB)
+#define glWindowPos3dvARB GLEW_GET_FUN(__glewWindowPos3dvARB)
+#define glWindowPos3fARB GLEW_GET_FUN(__glewWindowPos3fARB)
+#define glWindowPos3fvARB GLEW_GET_FUN(__glewWindowPos3fvARB)
+#define glWindowPos3iARB GLEW_GET_FUN(__glewWindowPos3iARB)
+#define glWindowPos3ivARB GLEW_GET_FUN(__glewWindowPos3ivARB)
+#define glWindowPos3sARB GLEW_GET_FUN(__glewWindowPos3sARB)
+#define glWindowPos3svARB GLEW_GET_FUN(__glewWindowPos3svARB)
+
+#define GLEW_ARB_window_pos GLEW_GET_VAR(__GLEW_ARB_window_pos)
+
+#endif /* GL_ARB_window_pos */
+
+    /* ------------------------- GL_ATIX_point_sprites ------------------------- */
+
+#ifndef GL_ATIX_point_sprites
+#define GL_ATIX_point_sprites 1
+
+#define GL_TEXTURE_POINT_MODE_ATIX 0x60B0
+#define GL_TEXTURE_POINT_ONE_COORD_ATIX 0x60B1
+#define GL_TEXTURE_POINT_SPRITE_ATIX 0x60B2
+#define GL_POINT_SPRITE_CULL_MODE_ATIX 0x60B3
+#define GL_POINT_SPRITE_CULL_CENTER_ATIX 0x60B4
+#define GL_POINT_SPRITE_CULL_CLIP_ATIX 0x60B5
+
+#define GLEW_ATIX_point_sprites GLEW_GET_VAR(__GLEW_ATIX_point_sprites)
+
+#endif /* GL_ATIX_point_sprites */
+
+    /* ---------------------- GL_ATIX_texture_env_combine3 --------------------- */
+
+#ifndef GL_ATIX_texture_env_combine3
+#define GL_ATIX_texture_env_combine3 1
+
+#define GL_MODULATE_ADD_ATIX 0x8744
+#define GL_MODULATE_SIGNED_ADD_ATIX 0x8745
+#define GL_MODULATE_SUBTRACT_ATIX 0x8746
+
+#define GLEW_ATIX_texture_env_combine3 GLEW_GET_VAR(__GLEW_ATIX_texture_env_combine3)
+
+#endif /* GL_ATIX_texture_env_combine3 */
+
+    /* ----------------------- GL_ATIX_texture_env_route ----------------------- */
+
+#ifndef GL_ATIX_texture_env_route
+#define GL_ATIX_texture_env_route 1
+
+#define GL_SECONDARY_COLOR_ATIX 0x8747
+#define GL_TEXTURE_OUTPUT_RGB_ATIX 0x8748
+#define GL_TEXTURE_OUTPUT_ALPHA_ATIX 0x8749
+
+#define GLEW_ATIX_texture_env_route GLEW_GET_VAR(__GLEW_ATIX_texture_env_route)
+
+#endif /* GL_ATIX_texture_env_route */
+
+    /* ---------------- GL_ATIX_vertex_shader_output_point_size ---------------- */
+
+#ifndef GL_ATIX_vertex_shader_output_point_size
+#define GL_ATIX_vertex_shader_output_point_size 1
+
+#define GL_OUTPUT_POINT_SIZE_ATIX 0x610E
+
+#define GLEW_ATIX_vertex_shader_output_point_size GLEW_GET_VAR(__GLEW_ATIX_vertex_shader_output_point_size)
+
+#endif /* GL_ATIX_vertex_shader_output_point_size */
+
+    /* -------------------------- GL_ATI_draw_buffers -------------------------- */
+
+#ifndef GL_ATI_draw_buffers
+#define GL_ATI_draw_buffers 1
+
+#define GL_MAX_DRAW_BUFFERS_ATI 0x8824
+#define GL_DRAW_BUFFER0_ATI 0x8825
+#define GL_DRAW_BUFFER1_ATI 0x8826
+#define GL_DRAW_BUFFER2_ATI 0x8827
+#define GL_DRAW_BUFFER3_ATI 0x8828
+#define GL_DRAW_BUFFER4_ATI 0x8829
+#define GL_DRAW_BUFFER5_ATI 0x882A
+#define GL_DRAW_BUFFER6_ATI 0x882B
+#define GL_DRAW_BUFFER7_ATI 0x882C
+#define GL_DRAW_BUFFER8_ATI 0x882D
+#define GL_DRAW_BUFFER9_ATI 0x882E
+#define GL_DRAW_BUFFER10_ATI 0x882F
+#define GL_DRAW_BUFFER11_ATI 0x8830
+#define GL_DRAW_BUFFER12_ATI 0x8831
+#define GL_DRAW_BUFFER13_ATI 0x8832
+#define GL_DRAW_BUFFER14_ATI 0x8833
+#define GL_DRAW_BUFFER15_ATI 0x8834
+
+    typedef void (GLAPIENTRY *PFNGLDRAWBUFFERSATIPROC)(GLsizei n, const GLenum *bufs);
+
+#define glDrawBuffersATI GLEW_GET_FUN(__glewDrawBuffersATI)
+
+#define GLEW_ATI_draw_buffers GLEW_GET_VAR(__GLEW_ATI_draw_buffers)
+
+#endif /* GL_ATI_draw_buffers */
+
+    /* -------------------------- GL_ATI_element_array ------------------------- */
+
+#ifndef GL_ATI_element_array
+#define GL_ATI_element_array 1
+
+#define GL_ELEMENT_ARRAY_ATI 0x8768
+#define GL_ELEMENT_ARRAY_TYPE_ATI 0x8769
+#define GL_ELEMENT_ARRAY_POINTER_ATI 0x876A
+
+    typedef void (GLAPIENTRY *PFNGLDRAWELEMENTARRAYATIPROC)(GLenum mode, GLsizei count);
+    typedef void (GLAPIENTRY *PFNGLDRAWRANGEELEMENTARRAYATIPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count);
+    typedef void (GLAPIENTRY *PFNGLELEMENTPOINTERATIPROC)(GLenum type, const void *pointer);
+
+#define glDrawElementArrayATI GLEW_GET_FUN(__glewDrawElementArrayATI)
+#define glDrawRangeElementArrayATI GLEW_GET_FUN(__glewDrawRangeElementArrayATI)
+#define glElementPointerATI GLEW_GET_FUN(__glewElementPointerATI)
+
+#define GLEW_ATI_element_array GLEW_GET_VAR(__GLEW_ATI_element_array)
+
+#endif /* GL_ATI_element_array */
+
+    /* ------------------------- GL_ATI_envmap_bumpmap ------------------------- */
+
+#ifndef GL_ATI_envmap_bumpmap
+#define GL_ATI_envmap_bumpmap 1
+
+#define GL_BUMP_ROT_MATRIX_ATI 0x8775
+#define GL_BUMP_ROT_MATRIX_SIZE_ATI 0x8776
+#define GL_BUMP_NUM_TEX_UNITS_ATI 0x8777
+#define GL_BUMP_TEX_UNITS_ATI 0x8778
+#define GL_DUDV_ATI 0x8779
+#define GL_DU8DV8_ATI 0x877A
+#define GL_BUMP_ENVMAP_ATI 0x877B
+#define GL_BUMP_TARGET_ATI 0x877C
+
+    typedef void (GLAPIENTRY *PFNGLGETTEXBUMPPARAMETERFVATIPROC)(GLenum pname, GLfloat *param);
+    typedef void (GLAPIENTRY *PFNGLGETTEXBUMPPARAMETERIVATIPROC)(GLenum pname, GLint *param);
+    typedef void (GLAPIENTRY *PFNGLTEXBUMPPARAMETERFVATIPROC)(GLenum pname, GLfloat *param);
+    typedef void (GLAPIENTRY *PFNGLTEXBUMPPARAMETERIVATIPROC)(GLenum pname, GLint *param);
+
+#define glGetTexBumpParameterfvATI GLEW_GET_FUN(__glewGetTexBumpParameterfvATI)
+#define glGetTexBumpParameterivATI GLEW_GET_FUN(__glewGetTexBumpParameterivATI)
+#define glTexBumpParameterfvATI GLEW_GET_FUN(__glewTexBumpParameterfvATI)
+#define glTexBumpParameterivATI GLEW_GET_FUN(__glewTexBumpParameterivATI)
+
+#define GLEW_ATI_envmap_bumpmap GLEW_GET_VAR(__GLEW_ATI_envmap_bumpmap)
+
+#endif /* GL_ATI_envmap_bumpmap */
+
+    /* ------------------------- GL_ATI_fragment_shader ------------------------ */
+
+#ifndef GL_ATI_fragment_shader
+#define GL_ATI_fragment_shader 1
+
+#define GL_RED_BIT_ATI 0x00000001
+#define GL_2X_BIT_ATI 0x00000001
+#define GL_4X_BIT_ATI 0x00000002
+#define GL_GREEN_BIT_ATI 0x00000002
+#define GL_COMP_BIT_ATI 0x00000002
+#define GL_BLUE_BIT_ATI 0x00000004
+#define GL_8X_BIT_ATI 0x00000004
+#define GL_NEGATE_BIT_ATI 0x00000004
+#define GL_BIAS_BIT_ATI 0x00000008
+#define GL_HALF_BIT_ATI 0x00000008
+#define GL_QUARTER_BIT_ATI 0x00000010
+#define GL_EIGHTH_BIT_ATI 0x00000020
+#define GL_SATURATE_BIT_ATI 0x00000040
+#define GL_FRAGMENT_SHADER_ATI 0x8920
+#define GL_REG_0_ATI 0x8921
+#define GL_REG_1_ATI 0x8922
+#define GL_REG_2_ATI 0x8923
+#define GL_REG_3_ATI 0x8924
+#define GL_REG_4_ATI 0x8925
+#define GL_REG_5_ATI 0x8926
+#define GL_CON_0_ATI 0x8941
+#define GL_CON_1_ATI 0x8942
+#define GL_CON_2_ATI 0x8943
+#define GL_CON_3_ATI 0x8944
+#define GL_CON_4_ATI 0x8945
+#define GL_CON_5_ATI 0x8946
+#define GL_CON_6_ATI 0x8947
+#define GL_CON_7_ATI 0x8948
+#define GL_MOV_ATI 0x8961
+#define GL_ADD_ATI 0x8963
+#define GL_MUL_ATI 0x8964
+#define GL_SUB_ATI 0x8965
+#define GL_DOT3_ATI 0x8966
+#define GL_DOT4_ATI 0x8967
+#define GL_MAD_ATI 0x8968
+#define GL_LERP_ATI 0x8969
+#define GL_CND_ATI 0x896A
+#define GL_CND0_ATI 0x896B
+#define GL_DOT2_ADD_ATI 0x896C
+#define GL_SECONDARY_INTERPOLATOR_ATI 0x896D
+#define GL_NUM_FRAGMENT_REGISTERS_ATI 0x896E
+#define GL_NUM_FRAGMENT_CONSTANTS_ATI 0x896F
+#define GL_NUM_PASSES_ATI 0x8970
+#define GL_NUM_INSTRUCTIONS_PER_PASS_ATI 0x8971
+#define GL_NUM_INSTRUCTIONS_TOTAL_ATI 0x8972
+#define GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI 0x8973
+#define GL_NUM_LOOPBACK_COMPONENTS_ATI 0x8974
+#define GL_COLOR_ALPHA_PAIRING_ATI 0x8975
+#define GL_SWIZZLE_STR_ATI 0x8976
+#define GL_SWIZZLE_STQ_ATI 0x8977
+#define GL_SWIZZLE_STR_DR_ATI 0x8978
+#define GL_SWIZZLE_STQ_DQ_ATI 0x8979
+#define GL_SWIZZLE_STRQ_ATI 0x897A
+#define GL_SWIZZLE_STRQ_DQ_ATI 0x897B
+
+    typedef void (GLAPIENTRY *PFNGLALPHAFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
+    typedef void (GLAPIENTRY *PFNGLALPHAFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
+    typedef void (GLAPIENTRY *PFNGLALPHAFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
+    typedef void (GLAPIENTRY *PFNGLBEGINFRAGMENTSHADERATIPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLBINDFRAGMENTSHADERATIPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLCOLORFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
+    typedef void (GLAPIENTRY *PFNGLCOLORFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
+    typedef void (GLAPIENTRY *PFNGLCOLORFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
+    typedef void (GLAPIENTRY *PFNGLDELETEFRAGMENTSHADERATIPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLENDFRAGMENTSHADERATIPROC)(void);
+    typedef GLuint(GLAPIENTRY *PFNGLGENFRAGMENTSHADERSATIPROC)(GLuint range);
+    typedef void (GLAPIENTRY *PFNGLPASSTEXCOORDATIPROC)(GLuint dst, GLuint coord, GLenum swizzle);
+    typedef void (GLAPIENTRY *PFNGLSAMPLEMAPATIPROC)(GLuint dst, GLuint interp, GLenum swizzle);
+    typedef void (GLAPIENTRY *PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)(GLuint dst, const GLfloat *value);
+
+#define glAlphaFragmentOp1ATI GLEW_GET_FUN(__glewAlphaFragmentOp1ATI)
+#define glAlphaFragmentOp2ATI GLEW_GET_FUN(__glewAlphaFragmentOp2ATI)
+#define glAlphaFragmentOp3ATI GLEW_GET_FUN(__glewAlphaFragmentOp3ATI)
+#define glBeginFragmentShaderATI GLEW_GET_FUN(__glewBeginFragmentShaderATI)
+#define glBindFragmentShaderATI GLEW_GET_FUN(__glewBindFragmentShaderATI)
+#define glColorFragmentOp1ATI GLEW_GET_FUN(__glewColorFragmentOp1ATI)
+#define glColorFragmentOp2ATI GLEW_GET_FUN(__glewColorFragmentOp2ATI)
+#define glColorFragmentOp3ATI GLEW_GET_FUN(__glewColorFragmentOp3ATI)
+#define glDeleteFragmentShaderATI GLEW_GET_FUN(__glewDeleteFragmentShaderATI)
+#define glEndFragmentShaderATI GLEW_GET_FUN(__glewEndFragmentShaderATI)
+#define glGenFragmentShadersATI GLEW_GET_FUN(__glewGenFragmentShadersATI)
+#define glPassTexCoordATI GLEW_GET_FUN(__glewPassTexCoordATI)
+#define glSampleMapATI GLEW_GET_FUN(__glewSampleMapATI)
+#define glSetFragmentShaderConstantATI GLEW_GET_FUN(__glewSetFragmentShaderConstantATI)
+
+#define GLEW_ATI_fragment_shader GLEW_GET_VAR(__GLEW_ATI_fragment_shader)
+
+#endif /* GL_ATI_fragment_shader */
+
+    /* ------------------------ GL_ATI_map_object_buffer ----------------------- */
+
+#ifndef GL_ATI_map_object_buffer
+#define GL_ATI_map_object_buffer 1
+
+    typedef void *(GLAPIENTRY *PFNGLMAPOBJECTBUFFERATIPROC)(GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLUNMAPOBJECTBUFFERATIPROC)(GLuint buffer);
+
+#define glMapObjectBufferATI GLEW_GET_FUN(__glewMapObjectBufferATI)
+#define glUnmapObjectBufferATI GLEW_GET_FUN(__glewUnmapObjectBufferATI)
+
+#define GLEW_ATI_map_object_buffer GLEW_GET_VAR(__GLEW_ATI_map_object_buffer)
+
+#endif /* GL_ATI_map_object_buffer */
+
+    /* ----------------------------- GL_ATI_meminfo ---------------------------- */
+
+#ifndef GL_ATI_meminfo
+#define GL_ATI_meminfo 1
+
+#define GL_VBO_FREE_MEMORY_ATI 0x87FB
+#define GL_TEXTURE_FREE_MEMORY_ATI 0x87FC
+#define GL_RENDERBUFFER_FREE_MEMORY_ATI 0x87FD
+
+#define GLEW_ATI_meminfo GLEW_GET_VAR(__GLEW_ATI_meminfo)
+
+#endif /* GL_ATI_meminfo */
+
+    /* -------------------------- GL_ATI_pn_triangles -------------------------- */
+
+#ifndef GL_ATI_pn_triangles
+#define GL_ATI_pn_triangles 1
+
+#define GL_PN_TRIANGLES_ATI 0x87F0
+#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F1
+#define GL_PN_TRIANGLES_POINT_MODE_ATI 0x87F2
+#define GL_PN_TRIANGLES_NORMAL_MODE_ATI 0x87F3
+#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F4
+#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI 0x87F5
+#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI 0x87F6
+#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI 0x87F7
+#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI 0x87F8
+
+    typedef void (GLAPIENTRY *PFNGLPNTRIANGLESFATIPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLPNTRIANGLESIATIPROC)(GLenum pname, GLint param);
+
+#define glPNTrianglesfATI GLEW_GET_FUN(__glPNTrianglewesfATI)
+#define glPNTrianglesiATI GLEW_GET_FUN(__glPNTrianglewesiATI)
+
+#define GLEW_ATI_pn_triangles GLEW_GET_VAR(__GLEW_ATI_pn_triangles)
+
+#endif /* GL_ATI_pn_triangles */
+
+    /* ------------------------ GL_ATI_separate_stencil ------------------------ */
+
+#ifndef GL_ATI_separate_stencil
+#define GL_ATI_separate_stencil 1
+
+#define GL_STENCIL_BACK_FUNC_ATI 0x8800
+#define GL_STENCIL_BACK_FAIL_ATI 0x8801
+#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI 0x8802
+#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI 0x8803
+
+    typedef void (GLAPIENTRY *PFNGLSTENCILFUNCSEPARATEATIPROC)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
+    typedef void (GLAPIENTRY *PFNGLSTENCILOPSEPARATEATIPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+
+#define glStencilFuncSeparateATI GLEW_GET_FUN(__glewStencilFuncSeparateATI)
+#define glStencilOpSeparateATI GLEW_GET_FUN(__glewStencilOpSeparateATI)
+
+#define GLEW_ATI_separate_stencil GLEW_GET_VAR(__GLEW_ATI_separate_stencil)
+
+#endif /* GL_ATI_separate_stencil */
+
+    /* ----------------------- GL_ATI_shader_texture_lod ----------------------- */
+
+#ifndef GL_ATI_shader_texture_lod
+#define GL_ATI_shader_texture_lod 1
+
+#define GLEW_ATI_shader_texture_lod GLEW_GET_VAR(__GLEW_ATI_shader_texture_lod)
+
+#endif /* GL_ATI_shader_texture_lod */
+
+    /* ---------------------- GL_ATI_text_fragment_shader ---------------------- */
+
+#ifndef GL_ATI_text_fragment_shader
+#define GL_ATI_text_fragment_shader 1
+
+#define GL_TEXT_FRAGMENT_SHADER_ATI 0x8200
+
+#define GLEW_ATI_text_fragment_shader GLEW_GET_VAR(__GLEW_ATI_text_fragment_shader)
+
+#endif /* GL_ATI_text_fragment_shader */
+
+    /* --------------------- GL_ATI_texture_compression_3dc -------------------- */
+
+#ifndef GL_ATI_texture_compression_3dc
+#define GL_ATI_texture_compression_3dc 1
+
+#define GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI 0x8837
+
+#define GLEW_ATI_texture_compression_3dc GLEW_GET_VAR(__GLEW_ATI_texture_compression_3dc)
+
+#endif /* GL_ATI_texture_compression_3dc */
+
+    /* ---------------------- GL_ATI_texture_env_combine3 ---------------------- */
+
+#ifndef GL_ATI_texture_env_combine3
+#define GL_ATI_texture_env_combine3 1
+
+#define GL_MODULATE_ADD_ATI 0x8744
+#define GL_MODULATE_SIGNED_ADD_ATI 0x8745
+#define GL_MODULATE_SUBTRACT_ATI 0x8746
+
+#define GLEW_ATI_texture_env_combine3 GLEW_GET_VAR(__GLEW_ATI_texture_env_combine3)
+
+#endif /* GL_ATI_texture_env_combine3 */
+
+    /* -------------------------- GL_ATI_texture_float ------------------------- */
+
+#ifndef GL_ATI_texture_float
+#define GL_ATI_texture_float 1
+
+#define GL_RGBA_FLOAT32_ATI 0x8814
+#define GL_RGB_FLOAT32_ATI 0x8815
+#define GL_ALPHA_FLOAT32_ATI 0x8816
+#define GL_INTENSITY_FLOAT32_ATI 0x8817
+#define GL_LUMINANCE_FLOAT32_ATI 0x8818
+#define GL_LUMINANCE_ALPHA_FLOAT32_ATI 0x8819
+#define GL_RGBA_FLOAT16_ATI 0x881A
+#define GL_RGB_FLOAT16_ATI 0x881B
+#define GL_ALPHA_FLOAT16_ATI 0x881C
+#define GL_INTENSITY_FLOAT16_ATI 0x881D
+#define GL_LUMINANCE_FLOAT16_ATI 0x881E
+#define GL_LUMINANCE_ALPHA_FLOAT16_ATI 0x881F
+
+#define GLEW_ATI_texture_float GLEW_GET_VAR(__GLEW_ATI_texture_float)
+
+#endif /* GL_ATI_texture_float */
+
+    /* ----------------------- GL_ATI_texture_mirror_once ---------------------- */
+
+#ifndef GL_ATI_texture_mirror_once
+#define GL_ATI_texture_mirror_once 1
+
+#define GL_MIRROR_CLAMP_ATI 0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_ATI 0x8743
+
+#define GLEW_ATI_texture_mirror_once GLEW_GET_VAR(__GLEW_ATI_texture_mirror_once)
+
+#endif /* GL_ATI_texture_mirror_once */
+
+    /* ----------------------- GL_ATI_vertex_array_object ---------------------- */
+
+#ifndef GL_ATI_vertex_array_object
+#define GL_ATI_vertex_array_object 1
+
+#define GL_STATIC_ATI 0x8760
+#define GL_DYNAMIC_ATI 0x8761
+#define GL_PRESERVE_ATI 0x8762
+#define GL_DISCARD_ATI 0x8763
+#define GL_OBJECT_BUFFER_SIZE_ATI 0x8764
+#define GL_OBJECT_BUFFER_USAGE_ATI 0x8765
+#define GL_ARRAY_OBJECT_BUFFER_ATI 0x8766
+#define GL_ARRAY_OBJECT_OFFSET_ATI 0x8767
+
+    typedef void (GLAPIENTRY *PFNGLARRAYOBJECTATIPROC)(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
+    typedef void (GLAPIENTRY *PFNGLFREEOBJECTBUFFERATIPROC)(GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLGETARRAYOBJECTFVATIPROC)(GLenum array, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETARRAYOBJECTIVATIPROC)(GLenum array, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETOBJECTBUFFERFVATIPROC)(GLuint buffer, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETOBJECTBUFFERIVATIPROC)(GLuint buffer, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETVARIANTARRAYOBJECTFVATIPROC)(GLuint id, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETVARIANTARRAYOBJECTIVATIPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISOBJECTBUFFERATIPROC)(GLuint buffer);
+    typedef GLuint(GLAPIENTRY *PFNGLNEWOBJECTBUFFERATIPROC)(GLsizei size, const void *pointer, GLenum usage);
+    typedef void (GLAPIENTRY *PFNGLUPDATEOBJECTBUFFERATIPROC)(GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
+    typedef void (GLAPIENTRY *PFNGLVARIANTARRAYOBJECTATIPROC)(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
+
+#define glArrayObjectATI GLEW_GET_FUN(__glewArrayObjectATI)
+#define glFreeObjectBufferATI GLEW_GET_FUN(__glewFreeObjectBufferATI)
+#define glGetArrayObjectfvATI GLEW_GET_FUN(__glewGetArrayObjectfvATI)
+#define glGetArrayObjectivATI GLEW_GET_FUN(__glewGetArrayObjectivATI)
+#define glGetObjectBufferfvATI GLEW_GET_FUN(__glewGetObjectBufferfvATI)
+#define glGetObjectBufferivATI GLEW_GET_FUN(__glewGetObjectBufferivATI)
+#define glGetVariantArrayObjectfvATI GLEW_GET_FUN(__glewGetVariantArrayObjectfvATI)
+#define glGetVariantArrayObjectivATI GLEW_GET_FUN(__glewGetVariantArrayObjectivATI)
+#define glIsObjectBufferATI GLEW_GET_FUN(__glewIsObjectBufferATI)
+#define glNewObjectBufferATI GLEW_GET_FUN(__glewNewObjectBufferATI)
+#define glUpdateObjectBufferATI GLEW_GET_FUN(__glewUpdateObjectBufferATI)
+#define glVariantArrayObjectATI GLEW_GET_FUN(__glewVariantArrayObjectATI)
+
+#define GLEW_ATI_vertex_array_object GLEW_GET_VAR(__GLEW_ATI_vertex_array_object)
+
+#endif /* GL_ATI_vertex_array_object */
+
+    /* ------------------- GL_ATI_vertex_attrib_array_object ------------------- */
+
+#ifndef GL_ATI_vertex_attrib_array_object
+#define GL_ATI_vertex_attrib_array_object 1
+
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)(GLuint index, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)(GLuint index, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
+
+#define glGetVertexAttribArrayObjectfvATI GLEW_GET_FUN(__glewGetVertexAttribArrayObjectfvATI)
+#define glGetVertexAttribArrayObjectivATI GLEW_GET_FUN(__glewGetVertexAttribArrayObjectivATI)
+#define glVertexAttribArrayObjectATI GLEW_GET_FUN(__glewVertexAttribArrayObjectATI)
+
+#define GLEW_ATI_vertex_attrib_array_object GLEW_GET_VAR(__GLEW_ATI_vertex_attrib_array_object)
+
+#endif /* GL_ATI_vertex_attrib_array_object */
+
+    /* ------------------------- GL_ATI_vertex_streams ------------------------- */
+
+#ifndef GL_ATI_vertex_streams
+#define GL_ATI_vertex_streams 1
+
+#define GL_MAX_VERTEX_STREAMS_ATI 0x876B
+#define GL_VERTEX_SOURCE_ATI 0x876C
+#define GL_VERTEX_STREAM0_ATI 0x876D
+#define GL_VERTEX_STREAM1_ATI 0x876E
+#define GL_VERTEX_STREAM2_ATI 0x876F
+#define GL_VERTEX_STREAM3_ATI 0x8770
+#define GL_VERTEX_STREAM4_ATI 0x8771
+#define GL_VERTEX_STREAM5_ATI 0x8772
+#define GL_VERTEX_STREAM6_ATI 0x8773
+#define GL_VERTEX_STREAM7_ATI 0x8774
+
+    typedef void (GLAPIENTRY *PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)(GLenum stream);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3BATIPROC)(GLenum stream, GLbyte x, GLbyte y, GLbyte z);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3BVATIPROC)(GLenum stream, const GLbyte *v);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3DVATIPROC)(GLenum stream, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3FVATIPROC)(GLenum stream, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3IATIPROC)(GLenum stream, GLint x, GLint y, GLint z);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3IVATIPROC)(GLenum stream, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z);
+    typedef void (GLAPIENTRY *PFNGLNORMALSTREAM3SVATIPROC)(GLenum stream, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXBLENDENVFATIPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLVERTEXBLENDENVIATIPROC)(GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM2DATIPROC)(GLenum stream, GLdouble x, GLdouble y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM2DVATIPROC)(GLenum stream, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM2FATIPROC)(GLenum stream, GLfloat x, GLfloat y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM2FVATIPROC)(GLenum stream, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM2IATIPROC)(GLenum stream, GLint x, GLint y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM2IVATIPROC)(GLenum stream, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM2SATIPROC)(GLenum stream, GLshort x, GLshort y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM2SVATIPROC)(GLenum stream, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM3DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM3DVATIPROC)(GLenum stream, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM3FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM3FVATIPROC)(GLenum stream, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM3IATIPROC)(GLenum stream, GLint x, GLint y, GLint z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM3IVATIPROC)(GLenum stream, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM3SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM3SVATIPROC)(GLenum stream, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM4DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM4DVATIPROC)(GLenum stream, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM4FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM4FVATIPROC)(GLenum stream, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM4IATIPROC)(GLenum stream, GLint x, GLint y, GLint z, GLint w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM4IVATIPROC)(GLenum stream, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM4SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXSTREAM4SVATIPROC)(GLenum stream, const GLshort *v);
+
+#define glClientActiveVertexStreamATI GLEW_GET_FUN(__glewClientActiveVertexStreamATI)
+#define glNormalStream3bATI GLEW_GET_FUN(__glewNormalStream3bATI)
+#define glNormalStream3bvATI GLEW_GET_FUN(__glewNormalStream3bvATI)
+#define glNormalStream3dATI GLEW_GET_FUN(__glewNormalStream3dATI)
+#define glNormalStream3dvATI GLEW_GET_FUN(__glewNormalStream3dvATI)
+#define glNormalStream3fATI GLEW_GET_FUN(__glewNormalStream3fATI)
+#define glNormalStream3fvATI GLEW_GET_FUN(__glewNormalStream3fvATI)
+#define glNormalStream3iATI GLEW_GET_FUN(__glewNormalStream3iATI)
+#define glNormalStream3ivATI GLEW_GET_FUN(__glewNormalStream3ivATI)
+#define glNormalStream3sATI GLEW_GET_FUN(__glewNormalStream3sATI)
+#define glNormalStream3svATI GLEW_GET_FUN(__glewNormalStream3svATI)
+#define glVertexBlendEnvfATI GLEW_GET_FUN(__glewVertexBlendEnvfATI)
+#define glVertexBlendEnviATI GLEW_GET_FUN(__glewVertexBlendEnviATI)
+#define glVertexStream2dATI GLEW_GET_FUN(__glewVertexStream2dATI)
+#define glVertexStream2dvATI GLEW_GET_FUN(__glewVertexStream2dvATI)
+#define glVertexStream2fATI GLEW_GET_FUN(__glewVertexStream2fATI)
+#define glVertexStream2fvATI GLEW_GET_FUN(__glewVertexStream2fvATI)
+#define glVertexStream2iATI GLEW_GET_FUN(__glewVertexStream2iATI)
+#define glVertexStream2ivATI GLEW_GET_FUN(__glewVertexStream2ivATI)
+#define glVertexStream2sATI GLEW_GET_FUN(__glewVertexStream2sATI)
+#define glVertexStream2svATI GLEW_GET_FUN(__glewVertexStream2svATI)
+#define glVertexStream3dATI GLEW_GET_FUN(__glewVertexStream3dATI)
+#define glVertexStream3dvATI GLEW_GET_FUN(__glewVertexStream3dvATI)
+#define glVertexStream3fATI GLEW_GET_FUN(__glewVertexStream3fATI)
+#define glVertexStream3fvATI GLEW_GET_FUN(__glewVertexStream3fvATI)
+#define glVertexStream3iATI GLEW_GET_FUN(__glewVertexStream3iATI)
+#define glVertexStream3ivATI GLEW_GET_FUN(__glewVertexStream3ivATI)
+#define glVertexStream3sATI GLEW_GET_FUN(__glewVertexStream3sATI)
+#define glVertexStream3svATI GLEW_GET_FUN(__glewVertexStream3svATI)
+#define glVertexStream4dATI GLEW_GET_FUN(__glewVertexStream4dATI)
+#define glVertexStream4dvATI GLEW_GET_FUN(__glewVertexStream4dvATI)
+#define glVertexStream4fATI GLEW_GET_FUN(__glewVertexStream4fATI)
+#define glVertexStream4fvATI GLEW_GET_FUN(__glewVertexStream4fvATI)
+#define glVertexStream4iATI GLEW_GET_FUN(__glewVertexStream4iATI)
+#define glVertexStream4ivATI GLEW_GET_FUN(__glewVertexStream4ivATI)
+#define glVertexStream4sATI GLEW_GET_FUN(__glewVertexStream4sATI)
+#define glVertexStream4svATI GLEW_GET_FUN(__glewVertexStream4svATI)
+
+#define GLEW_ATI_vertex_streams GLEW_GET_VAR(__GLEW_ATI_vertex_streams)
+
+#endif /* GL_ATI_vertex_streams */
+
+    /* --------------------------- GL_EXT_422_pixels --------------------------- */
+
+#ifndef GL_EXT_422_pixels
+#define GL_EXT_422_pixels 1
+
+#define GL_422_EXT 0x80CC
+#define GL_422_REV_EXT 0x80CD
+#define GL_422_AVERAGE_EXT 0x80CE
+#define GL_422_REV_AVERAGE_EXT 0x80CF
+
+#define GLEW_EXT_422_pixels GLEW_GET_VAR(__GLEW_EXT_422_pixels)
+
+#endif /* GL_EXT_422_pixels */
+
+    /* ---------------------------- GL_EXT_Cg_shader --------------------------- */
+
+#ifndef GL_EXT_Cg_shader
+#define GL_EXT_Cg_shader 1
+
+#define GL_CG_VERTEX_SHADER_EXT 0x890E
+#define GL_CG_FRAGMENT_SHADER_EXT 0x890F
+
+#define GLEW_EXT_Cg_shader GLEW_GET_VAR(__GLEW_EXT_Cg_shader)
+
+#endif /* GL_EXT_Cg_shader */
+
+    /* ------------------------------ GL_EXT_abgr ------------------------------ */
+
+#ifndef GL_EXT_abgr
+#define GL_EXT_abgr 1
+
+#define GL_ABGR_EXT 0x8000
+
+#define GLEW_EXT_abgr GLEW_GET_VAR(__GLEW_EXT_abgr)
+
+#endif /* GL_EXT_abgr */
+
+    /* ------------------------------ GL_EXT_bgra ------------------------------ */
+
+#ifndef GL_EXT_bgra
+#define GL_EXT_bgra 1
+
+#define GL_BGR_EXT 0x80E0
+#define GL_BGRA_EXT 0x80E1
+
+#define GLEW_EXT_bgra GLEW_GET_VAR(__GLEW_EXT_bgra)
+
+#endif /* GL_EXT_bgra */
+
+    /* ------------------------ GL_EXT_bindable_uniform ------------------------ */
+
+#ifndef GL_EXT_bindable_uniform
+#define GL_EXT_bindable_uniform 1
+
+#define GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT 0x8DE2
+#define GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT 0x8DE3
+#define GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT 0x8DE4
+#define GL_MAX_BINDABLE_UNIFORM_SIZE_EXT 0x8DED
+#define GL_UNIFORM_BUFFER_EXT 0x8DEE
+#define GL_UNIFORM_BUFFER_BINDING_EXT 0x8DEF
+
+    typedef GLint(GLAPIENTRY *PFNGLGETUNIFORMBUFFERSIZEEXTPROC)(GLuint program, GLint location);
+    typedef GLintptr(GLAPIENTRY *PFNGLGETUNIFORMOFFSETEXTPROC)(GLuint program, GLint location);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMBUFFEREXTPROC)(GLuint program, GLint location, GLuint buffer);
+
+#define glGetUniformBufferSizeEXT GLEW_GET_FUN(__glewGetUniformBufferSizeEXT)
+#define glGetUniformOffsetEXT GLEW_GET_FUN(__glewGetUniformOffsetEXT)
+#define glUniformBufferEXT GLEW_GET_FUN(__glewUniformBufferEXT)
+
+#define GLEW_EXT_bindable_uniform GLEW_GET_VAR(__GLEW_EXT_bindable_uniform)
+
+#endif /* GL_EXT_bindable_uniform */
+
+    /* --------------------------- GL_EXT_blend_color -------------------------- */
+
+#ifndef GL_EXT_blend_color
+#define GL_EXT_blend_color 1
+
+#define GL_CONSTANT_COLOR_EXT 0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR_EXT 0x8002
+#define GL_CONSTANT_ALPHA_EXT 0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT 0x8004
+#define GL_BLEND_COLOR_EXT 0x8005
+
+    typedef void (GLAPIENTRY *PFNGLBLENDCOLOREXTPROC)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+
+#define glBlendColorEXT GLEW_GET_FUN(__glewBlendColorEXT)
+
+#define GLEW_EXT_blend_color GLEW_GET_VAR(__GLEW_EXT_blend_color)
+
+#endif /* GL_EXT_blend_color */
+
+    /* --------------------- GL_EXT_blend_equation_separate -------------------- */
+
+#ifndef GL_EXT_blend_equation_separate
+#define GL_EXT_blend_equation_separate 1
+
+#define GL_BLEND_EQUATION_RGB_EXT 0x8009
+#define GL_BLEND_EQUATION_ALPHA_EXT 0x883D
+
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONSEPARATEEXTPROC)(GLenum modeRGB, GLenum modeAlpha);
+
+#define glBlendEquationSeparateEXT GLEW_GET_FUN(__glewBlendEquationSeparateEXT)
+
+#define GLEW_EXT_blend_equation_separate GLEW_GET_VAR(__GLEW_EXT_blend_equation_separate)
+
+#endif /* GL_EXT_blend_equation_separate */
+
+    /* ----------------------- GL_EXT_blend_func_separate ---------------------- */
+
+#ifndef GL_EXT_blend_func_separate
+#define GL_EXT_blend_func_separate 1
+
+#define GL_BLEND_DST_RGB_EXT 0x80C8
+#define GL_BLEND_SRC_RGB_EXT 0x80C9
+#define GL_BLEND_DST_ALPHA_EXT 0x80CA
+#define GL_BLEND_SRC_ALPHA_EXT 0x80CB
+
+    typedef void (GLAPIENTRY *PFNGLBLENDFUNCSEPARATEEXTPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+
+#define glBlendFuncSeparateEXT GLEW_GET_FUN(__glewBlendFuncSeparateEXT)
+
+#define GLEW_EXT_blend_func_separate GLEW_GET_VAR(__GLEW_EXT_blend_func_separate)
+
+#endif /* GL_EXT_blend_func_separate */
+
+    /* ------------------------- GL_EXT_blend_logic_op ------------------------- */
+
+#ifndef GL_EXT_blend_logic_op
+#define GL_EXT_blend_logic_op 1
+
+#define GLEW_EXT_blend_logic_op GLEW_GET_VAR(__GLEW_EXT_blend_logic_op)
+
+#endif /* GL_EXT_blend_logic_op */
+
+    /* -------------------------- GL_EXT_blend_minmax -------------------------- */
+
+#ifndef GL_EXT_blend_minmax
+#define GL_EXT_blend_minmax 1
+
+#define GL_FUNC_ADD_EXT 0x8006
+#define GL_MIN_EXT 0x8007
+#define GL_MAX_EXT 0x8008
+#define GL_BLEND_EQUATION_EXT 0x8009
+
+    typedef void (GLAPIENTRY *PFNGLBLENDEQUATIONEXTPROC)(GLenum mode);
+
+#define glBlendEquationEXT GLEW_GET_FUN(__glewBlendEquationEXT)
+
+#define GLEW_EXT_blend_minmax GLEW_GET_VAR(__GLEW_EXT_blend_minmax)
+
+#endif /* GL_EXT_blend_minmax */
+
+    /* ------------------------- GL_EXT_blend_subtract ------------------------- */
+
+#ifndef GL_EXT_blend_subtract
+#define GL_EXT_blend_subtract 1
+
+#define GL_FUNC_SUBTRACT_EXT 0x800A
+#define GL_FUNC_REVERSE_SUBTRACT_EXT 0x800B
+
+#define GLEW_EXT_blend_subtract GLEW_GET_VAR(__GLEW_EXT_blend_subtract)
+
+#endif /* GL_EXT_blend_subtract */
+
+    /* ------------------------ GL_EXT_clip_volume_hint ------------------------ */
+
+#ifndef GL_EXT_clip_volume_hint
+#define GL_EXT_clip_volume_hint 1
+
+#define GL_CLIP_VOLUME_CLIPPING_HINT_EXT 0x80F0
+
+#define GLEW_EXT_clip_volume_hint GLEW_GET_VAR(__GLEW_EXT_clip_volume_hint)
+
+#endif /* GL_EXT_clip_volume_hint */
+
+    /* ------------------------------ GL_EXT_cmyka ----------------------------- */
+
+#ifndef GL_EXT_cmyka
+#define GL_EXT_cmyka 1
+
+#define GL_CMYK_EXT 0x800C
+#define GL_CMYKA_EXT 0x800D
+#define GL_PACK_CMYK_HINT_EXT 0x800E
+#define GL_UNPACK_CMYK_HINT_EXT 0x800F
+
+#define GLEW_EXT_cmyka GLEW_GET_VAR(__GLEW_EXT_cmyka)
+
+#endif /* GL_EXT_cmyka */
+
+    /* ------------------------- GL_EXT_color_subtable ------------------------- */
+
+#ifndef GL_EXT_color_subtable
+#define GL_EXT_color_subtable 1
+
+    typedef void (GLAPIENTRY *PFNGLCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOPYCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
+
+#define glColorSubTableEXT GLEW_GET_FUN(__glewColorSubTableEXT)
+#define glCopyColorSubTableEXT GLEW_GET_FUN(__glewCopyColorSubTableEXT)
+
+#define GLEW_EXT_color_subtable GLEW_GET_VAR(__GLEW_EXT_color_subtable)
+
+#endif /* GL_EXT_color_subtable */
+
+    /* ---------------------- GL_EXT_compiled_vertex_array --------------------- */
+
+#ifndef GL_EXT_compiled_vertex_array
+#define GL_EXT_compiled_vertex_array 1
+
+#define GL_ARRAY_ELEMENT_LOCK_FIRST_EXT 0x81A8
+#define GL_ARRAY_ELEMENT_LOCK_COUNT_EXT 0x81A9
+
+    typedef void (GLAPIENTRY *PFNGLLOCKARRAYSEXTPROC)(GLint first, GLsizei count);
+    typedef void (GLAPIENTRY *PFNGLUNLOCKARRAYSEXTPROC)(void);
+
+#define glLockArraysEXT GLEW_GET_FUN(__glewLockArraysEXT)
+#define glUnlockArraysEXT GLEW_GET_FUN(__glewUnlockArraysEXT)
+
+#define GLEW_EXT_compiled_vertex_array GLEW_GET_VAR(__GLEW_EXT_compiled_vertex_array)
+
+#endif /* GL_EXT_compiled_vertex_array */
+
+    /* --------------------------- GL_EXT_convolution -------------------------- */
+
+#ifndef GL_EXT_convolution
+#define GL_EXT_convolution 1
+
+#define GL_CONVOLUTION_1D_EXT 0x8010
+#define GL_CONVOLUTION_2D_EXT 0x8011
+#define GL_SEPARABLE_2D_EXT 0x8012
+#define GL_CONVOLUTION_BORDER_MODE_EXT 0x8013
+#define GL_CONVOLUTION_FILTER_SCALE_EXT 0x8014
+#define GL_CONVOLUTION_FILTER_BIAS_EXT 0x8015
+#define GL_REDUCE_EXT 0x8016
+#define GL_CONVOLUTION_FORMAT_EXT 0x8017
+#define GL_CONVOLUTION_WIDTH_EXT 0x8018
+#define GL_CONVOLUTION_HEIGHT_EXT 0x8019
+#define GL_MAX_CONVOLUTION_WIDTH_EXT 0x801A
+#define GL_MAX_CONVOLUTION_HEIGHT_EXT 0x801B
+#define GL_POST_CONVOLUTION_RED_SCALE_EXT 0x801C
+#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT 0x801D
+#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT 0x801E
+#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT 0x801F
+#define GL_POST_CONVOLUTION_RED_BIAS_EXT 0x8020
+#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT 0x8021
+#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT 0x8022
+#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT 0x8023
+
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+    typedef void (GLAPIENTRY *PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLGETCONVOLUTIONFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, void *image);
+    typedef void (GLAPIENTRY *PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETSEPARABLEFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
+    typedef void (GLAPIENTRY *PFNGLSEPARABLEFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
+
+#define glConvolutionFilter1DEXT GLEW_GET_FUN(__glewConvolutionFilter1DEXT)
+#define glConvolutionFilter2DEXT GLEW_GET_FUN(__glewConvolutionFilter2DEXT)
+#define glConvolutionParameterfEXT GLEW_GET_FUN(__glewConvolutionParameterfEXT)
+#define glConvolutionParameterfvEXT GLEW_GET_FUN(__glewConvolutionParameterfvEXT)
+#define glConvolutionParameteriEXT GLEW_GET_FUN(__glewConvolutionParameteriEXT)
+#define glConvolutionParameterivEXT GLEW_GET_FUN(__glewConvolutionParameterivEXT)
+#define glCopyConvolutionFilter1DEXT GLEW_GET_FUN(__glewCopyConvolutionFilter1DEXT)
+#define glCopyConvolutionFilter2DEXT GLEW_GET_FUN(__glewCopyConvolutionFilter2DEXT)
+#define glGetConvolutionFilterEXT GLEW_GET_FUN(__glewGetConvolutionFilterEXT)
+#define glGetConvolutionParameterfvEXT GLEW_GET_FUN(__glewGetConvolutionParameterfvEXT)
+#define glGetConvolutionParameterivEXT GLEW_GET_FUN(__glewGetConvolutionParameterivEXT)
+#define glGetSeparableFilterEXT GLEW_GET_FUN(__glewGetSeparableFilterEXT)
+#define glSeparableFilter2DEXT GLEW_GET_FUN(__glewSeparableFilter2DEXT)
+
+#define GLEW_EXT_convolution GLEW_GET_VAR(__GLEW_EXT_convolution)
+
+#endif /* GL_EXT_convolution */
+
+    /* ------------------------ GL_EXT_coordinate_frame ------------------------ */
+
+#ifndef GL_EXT_coordinate_frame
+#define GL_EXT_coordinate_frame 1
+
+#define GL_TANGENT_ARRAY_EXT 0x8439
+#define GL_BINORMAL_ARRAY_EXT 0x843A
+#define GL_CURRENT_TANGENT_EXT 0x843B
+#define GL_CURRENT_BINORMAL_EXT 0x843C
+#define GL_TANGENT_ARRAY_TYPE_EXT 0x843E
+#define GL_TANGENT_ARRAY_STRIDE_EXT 0x843F
+#define GL_BINORMAL_ARRAY_TYPE_EXT 0x8440
+#define GL_BINORMAL_ARRAY_STRIDE_EXT 0x8441
+#define GL_TANGENT_ARRAY_POINTER_EXT 0x8442
+#define GL_BINORMAL_ARRAY_POINTER_EXT 0x8443
+#define GL_MAP1_TANGENT_EXT 0x8444
+#define GL_MAP2_TANGENT_EXT 0x8445
+#define GL_MAP1_BINORMAL_EXT 0x8446
+#define GL_MAP2_BINORMAL_EXT 0x8447
+
+    typedef void (GLAPIENTRY *PFNGLBINORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, void *pointer);
+    typedef void (GLAPIENTRY *PFNGLTANGENTPOINTEREXTPROC)(GLenum type, GLsizei stride, void *pointer);
+
+#define glBinormalPointerEXT GLEW_GET_FUN(__glewBinormalPointerEXT)
+#define glTangentPointerEXT GLEW_GET_FUN(__glewTangentPointerEXT)
+
+#define GLEW_EXT_coordinate_frame GLEW_GET_VAR(__GLEW_EXT_coordinate_frame)
+
+#endif /* GL_EXT_coordinate_frame */
+
+    /* -------------------------- GL_EXT_copy_texture -------------------------- */
+
+#ifndef GL_EXT_copy_texture
+#define GL_EXT_copy_texture 1
+
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXIMAGE1DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXIMAGE2DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+
+#define glCopyTexImage1DEXT GLEW_GET_FUN(__glewCopyTexImage1DEXT)
+#define glCopyTexImage2DEXT GLEW_GET_FUN(__glewCopyTexImage2DEXT)
+#define glCopyTexSubImage1DEXT GLEW_GET_FUN(__glewCopyTexSubImage1DEXT)
+#define glCopyTexSubImage2DEXT GLEW_GET_FUN(__glewCopyTexSubImage2DEXT)
+#define glCopyTexSubImage3DEXT GLEW_GET_FUN(__glewCopyTexSubImage3DEXT)
+
+#define GLEW_EXT_copy_texture GLEW_GET_VAR(__GLEW_EXT_copy_texture)
+
+#endif /* GL_EXT_copy_texture */
+
+    /* --------------------------- GL_EXT_cull_vertex -------------------------- */
+
+#ifndef GL_EXT_cull_vertex
+#define GL_EXT_cull_vertex 1
+
+    typedef void (GLAPIENTRY *PFNGLCULLPARAMETERDVEXTPROC)(GLenum pname, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLCULLPARAMETERFVEXTPROC)(GLenum pname, GLfloat *params);
+
+#define glCullParameterdvEXT GLEW_GET_FUN(__glewCullParameterdvEXT)
+#define glCullParameterfvEXT GLEW_GET_FUN(__glewCullParameterfvEXT)
+
+#define GLEW_EXT_cull_vertex GLEW_GET_VAR(__GLEW_EXT_cull_vertex)
+
+#endif /* GL_EXT_cull_vertex */
+
+    /* ------------------------ GL_EXT_depth_bounds_test ----------------------- */
+
+#ifndef GL_EXT_depth_bounds_test
+#define GL_EXT_depth_bounds_test 1
+
+#define GL_DEPTH_BOUNDS_TEST_EXT 0x8890
+#define GL_DEPTH_BOUNDS_EXT 0x8891
+
+    typedef void (GLAPIENTRY *PFNGLDEPTHBOUNDSEXTPROC)(GLclampd zmin, GLclampd zmax);
+
+#define glDepthBoundsEXT GLEW_GET_FUN(__glewDepthBoundsEXT)
+
+#define GLEW_EXT_depth_bounds_test GLEW_GET_VAR(__GLEW_EXT_depth_bounds_test)
+
+#endif /* GL_EXT_depth_bounds_test */
+
+    /* ----------------------- GL_EXT_direct_state_access ---------------------- */
+
+#ifndef GL_EXT_direct_state_access
+#define GL_EXT_direct_state_access 1
+
+#define GL_PROGRAM_MATRIX_EXT 0x8E2D
+#define GL_TRANSPOSE_PROGRAM_MATRIX_EXT 0x8E2E
+#define GL_PROGRAM_MATRIX_STACK_DEPTH_EXT 0x8E2F
+
+    typedef void (GLAPIENTRY *PFNGLBINDMULTITEXTUREEXTPROC)(GLenum texunit, GLenum target, GLuint texture);
+    typedef GLenum(GLAPIENTRY *PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC)(GLuint framebuffer, GLenum target);
+    typedef void (GLAPIENTRY *PFNGLCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
+    typedef void (GLAPIENTRY *PFNGLCOPYMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
+    typedef void (GLAPIENTRY *PFNGLCOPYMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+    typedef void (GLAPIENTRY *PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
+    typedef void (GLAPIENTRY *PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLDISABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLDISABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
+    typedef void (GLAPIENTRY *PFNGLENABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLENABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLENABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLENABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
+    typedef void (GLAPIENTRY *PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC)(GLuint framebuffer, GLsizei n, const GLenum *bufs);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERREADBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLGENERATEMULTITEXMIPMAPEXTPROC)(GLenum texunit, GLenum target);
+    typedef void (GLAPIENTRY *PFNGLGENERATETEXTUREMIPMAPEXTPROC)(GLuint texture, GLenum target);
+    typedef void (GLAPIENTRY *PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC)(GLenum texunit, GLenum target, GLint level, void *img);
+    typedef void (GLAPIENTRY *PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target, GLint level, void *img);
+    typedef void (GLAPIENTRY *PFNGLGETDOUBLEINDEXEDVEXTPROC)(GLenum target, GLuint index, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETDOUBLEI_VEXTPROC)(GLenum pname, GLuint index, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETFLOATINDEXEDVEXTPROC)(GLenum target, GLuint index, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETFLOATI_VEXTPROC)(GLenum pname, GLuint index, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum pname, GLint *param);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXIMAGEEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC)(GLuint buffer, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDBUFFERPOINTERVEXTPROC)(GLuint buffer, GLenum pname, void **params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC)(GLuint program, GLenum target, GLuint index, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC)(GLuint program, GLenum target, GLuint index, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target, GLenum pname, void *string);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDPROGRAMIVEXTPROC)(GLuint program, GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC)(GLuint renderbuffer, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETPOINTERINDEXEDVEXTPROC)(GLenum target, GLuint index, GLvoid **params);
+    typedef void (GLAPIENTRY *PFNGLGETPOINTERI_VEXTPROC)(GLenum pname, GLuint index, GLvoid **params);
+    typedef void (GLAPIENTRY *PFNGLGETTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
+    typedef void (GLAPIENTRY *PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLGETTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint *param);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXARRAYINTEGERVEXTPROC)(GLuint vaobj, GLenum pname, GLint *param);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC)(GLuint vaobj, GLuint index, GLenum pname, GLvoid **param);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXARRAYPOINTERVEXTPROC)(GLuint vaobj, GLenum pname, GLvoid **param);
+    typedef GLvoid *(GLAPIENTRY *PFNGLMAPNAMEDBUFFEREXTPROC)(GLuint buffer, GLenum access);
+    typedef GLvoid *(GLAPIENTRY *PFNGLMAPNAMEDBUFFERRANGEEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
+    typedef void (GLAPIENTRY *PFNGLMATRIXFRUSTUMEXTPROC)(GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
+    typedef void (GLAPIENTRY *PFNGLMATRIXLOADIDENTITYEXTPROC)(GLenum matrixMode);
+    typedef void (GLAPIENTRY *PFNGLMATRIXLOADTRANSPOSEDEXTPROC)(GLenum matrixMode, const GLdouble *m);
+    typedef void (GLAPIENTRY *PFNGLMATRIXLOADTRANSPOSEFEXTPROC)(GLenum matrixMode, const GLfloat *m);
+    typedef void (GLAPIENTRY *PFNGLMATRIXLOADDEXTPROC)(GLenum matrixMode, const GLdouble *m);
+    typedef void (GLAPIENTRY *PFNGLMATRIXLOADFEXTPROC)(GLenum matrixMode, const GLfloat *m);
+    typedef void (GLAPIENTRY *PFNGLMATRIXMULTTRANSPOSEDEXTPROC)(GLenum matrixMode, const GLdouble *m);
+    typedef void (GLAPIENTRY *PFNGLMATRIXMULTTRANSPOSEFEXTPROC)(GLenum matrixMode, const GLfloat *m);
+    typedef void (GLAPIENTRY *PFNGLMATRIXMULTDEXTPROC)(GLenum matrixMode, const GLdouble *m);
+    typedef void (GLAPIENTRY *PFNGLMATRIXMULTFEXTPROC)(GLenum matrixMode, const GLfloat *m);
+    typedef void (GLAPIENTRY *PFNGLMATRIXORTHOEXTPROC)(GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
+    typedef void (GLAPIENTRY *PFNGLMATRIXPOPEXTPROC)(GLenum matrixMode);
+    typedef void (GLAPIENTRY *PFNGLMATRIXPUSHEXTPROC)(GLenum matrixMode);
+    typedef void (GLAPIENTRY *PFNGLMATRIXROTATEDEXTPROC)(GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLMATRIXROTATEFEXTPROC)(GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLMATRIXSCALEDEXTPROC)(GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLMATRIXSCALEFEXTPROC)(GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLMATRIXTRANSLATEDEXTPROC)(GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLMATRIXTRANSLATEFEXTPROC)(GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXBUFFEREXTPROC)(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORDPOINTEREXTPROC)(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXENVFEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXENVIEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXGENDEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXGENFEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXGENIEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXPARAMETERFEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXPARAMETERIEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint *param);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXRENDERBUFFEREXTPROC)(GLenum texunit, GLenum target, GLuint renderbuffer);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLNAMEDBUFFERDATAEXTPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
+    typedef void (GLAPIENTRY *PFNGLNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
+    typedef void (GLAPIENTRY *PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
+    typedef void (GLAPIENTRY *PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+    typedef void (GLAPIENTRY *PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
+    typedef void (GLAPIENTRY *PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
+    typedef void (GLAPIENTRY *PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC)(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC)(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC)(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC)(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
+    typedef void (GLAPIENTRY *PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC)(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1FEXTPROC)(GLuint program, GLint location, GLfloat v0);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1IEXTPROC)(GLuint program, GLint location, GLint v0);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1UIEXTPROC)(GLuint program, GLint location, GLuint v0);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (GLAPIENTRY *PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREBUFFEREXTPROC)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREPARAMETERFEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLfloat *param);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREPARAMETERIEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLint *param);
+    typedef void (GLAPIENTRY *PFNGLTEXTURERENDERBUFFEREXTPROC)(GLuint texture, GLenum target, GLuint renderbuffer);
+    typedef void (GLAPIENTRY *PFNGLTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
+    typedef GLboolean(GLAPIENTRY *PFNGLUNMAPNAMEDBUFFEREXTPROC)(GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYCOLOROFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYINDEXOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYNORMALOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+
+#define glBindMultiTextureEXT GLEW_GET_FUN(__glewBindMultiTextureEXT)
+#define glCheckNamedFramebufferStatusEXT GLEW_GET_FUN(__glewCheckNamedFramebufferStatusEXT)
+#define glClientAttribDefaultEXT GLEW_GET_FUN(__glewClientAttribDefaultEXT)
+#define glCompressedMultiTexImage1DEXT GLEW_GET_FUN(__glewCompressedMultiTexImage1DEXT)
+#define glCompressedMultiTexImage2DEXT GLEW_GET_FUN(__glewCompressedMultiTexImage2DEXT)
+#define glCompressedMultiTexImage3DEXT GLEW_GET_FUN(__glewCompressedMultiTexImage3DEXT)
+#define glCompressedMultiTexSubImage1DEXT GLEW_GET_FUN(__glewCompressedMultiTexSubImage1DEXT)
+#define glCompressedMultiTexSubImage2DEXT GLEW_GET_FUN(__glewCompressedMultiTexSubImage2DEXT)
+#define glCompressedMultiTexSubImage3DEXT GLEW_GET_FUN(__glewCompressedMultiTexSubImage3DEXT)
+#define glCompressedTextureImage1DEXT GLEW_GET_FUN(__glewCompressedTextureImage1DEXT)
+#define glCompressedTextureImage2DEXT GLEW_GET_FUN(__glewCompressedTextureImage2DEXT)
+#define glCompressedTextureImage3DEXT GLEW_GET_FUN(__glewCompressedTextureImage3DEXT)
+#define glCompressedTextureSubImage1DEXT GLEW_GET_FUN(__glewCompressedTextureSubImage1DEXT)
+#define glCompressedTextureSubImage2DEXT GLEW_GET_FUN(__glewCompressedTextureSubImage2DEXT)
+#define glCompressedTextureSubImage3DEXT GLEW_GET_FUN(__glewCompressedTextureSubImage3DEXT)
+#define glCopyMultiTexImage1DEXT GLEW_GET_FUN(__glewCopyMultiTexImage1DEXT)
+#define glCopyMultiTexImage2DEXT GLEW_GET_FUN(__glewCopyMultiTexImage2DEXT)
+#define glCopyMultiTexSubImage1DEXT GLEW_GET_FUN(__glewCopyMultiTexSubImage1DEXT)
+#define glCopyMultiTexSubImage2DEXT GLEW_GET_FUN(__glewCopyMultiTexSubImage2DEXT)
+#define glCopyMultiTexSubImage3DEXT GLEW_GET_FUN(__glewCopyMultiTexSubImage3DEXT)
+#define glCopyTextureImage1DEXT GLEW_GET_FUN(__glewCopyTextureImage1DEXT)
+#define glCopyTextureImage2DEXT GLEW_GET_FUN(__glewCopyTextureImage2DEXT)
+#define glCopyTextureSubImage1DEXT GLEW_GET_FUN(__glewCopyTextureSubImage1DEXT)
+#define glCopyTextureSubImage2DEXT GLEW_GET_FUN(__glewCopyTextureSubImage2DEXT)
+#define glCopyTextureSubImage3DEXT GLEW_GET_FUN(__glewCopyTextureSubImage3DEXT)
+#define glDisableClientStateIndexedEXT GLEW_GET_FUN(__glewDisableClientStateIndexedEXT)
+#define glDisableClientStateiEXT GLEW_GET_FUN(__glewDisableClientStateiEXT)
+#define glDisableVertexArrayAttribEXT GLEW_GET_FUN(__glewDisableVertexArrayAttribEXT)
+#define glDisableVertexArrayEXT GLEW_GET_FUN(__glewDisableVertexArrayEXT)
+#define glEnableClientStateIndexedEXT GLEW_GET_FUN(__glewEnableClientStateIndexedEXT)
+#define glEnableClientStateiEXT GLEW_GET_FUN(__glewEnableClientStateiEXT)
+#define glEnableVertexArrayAttribEXT GLEW_GET_FUN(__glewEnableVertexArrayAttribEXT)
+#define glEnableVertexArrayEXT GLEW_GET_FUN(__glewEnableVertexArrayEXT)
+#define glFlushMappedNamedBufferRangeEXT GLEW_GET_FUN(__glewFlushMappedNamedBufferRangeEXT)
+#define glFramebufferDrawBufferEXT GLEW_GET_FUN(__glewFramebufferDrawBufferEXT)
+#define glFramebufferDrawBuffersEXT GLEW_GET_FUN(__glewFramebufferDrawBuffersEXT)
+#define glFramebufferReadBufferEXT GLEW_GET_FUN(__glewFramebufferReadBufferEXT)
+#define glGenerateMultiTexMipmapEXT GLEW_GET_FUN(__glewGenerateMultiTexMipmapEXT)
+#define glGenerateTextureMipmapEXT GLEW_GET_FUN(__glewGenerateTextureMipmapEXT)
+#define glGetCompressedMultiTexImageEXT GLEW_GET_FUN(__glewGetCompressedMultiTexImageEXT)
+#define glGetCompressedTextureImageEXT GLEW_GET_FUN(__glewGetCompressedTextureImageEXT)
+#define glGetDoubleIndexedvEXT GLEW_GET_FUN(__glewGetDoubleIndexedvEXT)
+#define glGetDoublei_vEXT GLEW_GET_FUN(__glewGetDoublei_vEXT)
+#define glGetFloatIndexedvEXT GLEW_GET_FUN(__glewGetFloatIndexedvEXT)
+#define glGetFloati_vEXT GLEW_GET_FUN(__glewGetFloati_vEXT)
+#define glGetFramebufferParameterivEXT GLEW_GET_FUN(__glewGetFramebufferParameterivEXT)
+#define glGetMultiTexEnvfvEXT GLEW_GET_FUN(__glewGetMultiTexEnvfvEXT)
+#define glGetMultiTexEnvivEXT GLEW_GET_FUN(__glewGetMultiTexEnvivEXT)
+#define glGetMultiTexGendvEXT GLEW_GET_FUN(__glewGetMultiTexGendvEXT)
+#define glGetMultiTexGenfvEXT GLEW_GET_FUN(__glewGetMultiTexGenfvEXT)
+#define glGetMultiTexGenivEXT GLEW_GET_FUN(__glewGetMultiTexGenivEXT)
+#define glGetMultiTexImageEXT GLEW_GET_FUN(__glewGetMultiTexImageEXT)
+#define glGetMultiTexLevelParameterfvEXT GLEW_GET_FUN(__glewGetMultiTexLevelParameterfvEXT)
+#define glGetMultiTexLevelParameterivEXT GLEW_GET_FUN(__glewGetMultiTexLevelParameterivEXT)
+#define glGetMultiTexParameterIivEXT GLEW_GET_FUN(__glewGetMultiTexParameterIivEXT)
+#define glGetMultiTexParameterIuivEXT GLEW_GET_FUN(__glewGetMultiTexParameterIuivEXT)
+#define glGetMultiTexParameterfvEXT GLEW_GET_FUN(__glewGetMultiTexParameterfvEXT)
+#define glGetMultiTexParameterivEXT GLEW_GET_FUN(__glewGetMultiTexParameterivEXT)
+#define glGetNamedBufferParameterivEXT GLEW_GET_FUN(__glewGetNamedBufferParameterivEXT)
+#define glGetNamedBufferPointervEXT GLEW_GET_FUN(__glewGetNamedBufferPointervEXT)
+#define glGetNamedBufferSubDataEXT GLEW_GET_FUN(__glewGetNamedBufferSubDataEXT)
+#define glGetNamedFramebufferAttachmentParameterivEXT GLEW_GET_FUN(__glewGetNamedFramebufferAttachmentParameterivEXT)
+#define glGetNamedProgramLocalParameterIivEXT GLEW_GET_FUN(__glewGetNamedProgramLocalParameterIivEXT)
+#define glGetNamedProgramLocalParameterIuivEXT GLEW_GET_FUN(__glewGetNamedProgramLocalParameterIuivEXT)
+#define glGetNamedProgramLocalParameterdvEXT GLEW_GET_FUN(__glewGetNamedProgramLocalParameterdvEXT)
+#define glGetNamedProgramLocalParameterfvEXT GLEW_GET_FUN(__glewGetNamedProgramLocalParameterfvEXT)
+#define glGetNamedProgramStringEXT GLEW_GET_FUN(__glewGetNamedProgramStringEXT)
+#define glGetNamedProgramivEXT GLEW_GET_FUN(__glewGetNamedProgramivEXT)
+#define glGetNamedRenderbufferParameterivEXT GLEW_GET_FUN(__glewGetNamedRenderbufferParameterivEXT)
+#define glGetPointerIndexedvEXT GLEW_GET_FUN(__glewGetPointerIndexedvEXT)
+#define glGetPointeri_vEXT GLEW_GET_FUN(__glewGetPointeri_vEXT)
+#define glGetTextureImageEXT GLEW_GET_FUN(__glewGetTextureImageEXT)
+#define glGetTextureLevelParameterfvEXT GLEW_GET_FUN(__glewGetTextureLevelParameterfvEXT)
+#define glGetTextureLevelParameterivEXT GLEW_GET_FUN(__glewGetTextureLevelParameterivEXT)
+#define glGetTextureParameterIivEXT GLEW_GET_FUN(__glewGetTextureParameterIivEXT)
+#define glGetTextureParameterIuivEXT GLEW_GET_FUN(__glewGetTextureParameterIuivEXT)
+#define glGetTextureParameterfvEXT GLEW_GET_FUN(__glewGetTextureParameterfvEXT)
+#define glGetTextureParameterivEXT GLEW_GET_FUN(__glewGetTextureParameterivEXT)
+#define glGetVertexArrayIntegeri_vEXT GLEW_GET_FUN(__glewGetVertexArrayIntegeri_vEXT)
+#define glGetVertexArrayIntegervEXT GLEW_GET_FUN(__glewGetVertexArrayIntegervEXT)
+#define glGetVertexArrayPointeri_vEXT GLEW_GET_FUN(__glewGetVertexArrayPointeri_vEXT)
+#define glGetVertexArrayPointervEXT GLEW_GET_FUN(__glewGetVertexArrayPointervEXT)
+#define glMapNamedBufferEXT GLEW_GET_FUN(__glewMapNamedBufferEXT)
+#define glMapNamedBufferRangeEXT GLEW_GET_FUN(__glewMapNamedBufferRangeEXT)
+#define glMatrixFrustumEXT GLEW_GET_FUN(__glewMatrixFrustumEXT)
+#define glMatrixLoadIdentityEXT GLEW_GET_FUN(__glewMatrixLoadIdentityEXT)
+#define glMatrixLoadTransposedEXT GLEW_GET_FUN(__glewMatrixLoadTransposedEXT)
+#define glMatrixLoadTransposefEXT GLEW_GET_FUN(__glewMatrixLoadTransposefEXT)
+#define glMatrixLoaddEXT GLEW_GET_FUN(__glewMatrixLoaddEXT)
+#define glMatrixLoadfEXT GLEW_GET_FUN(__glewMatrixLoadfEXT)
+#define glMatrixMultTransposedEXT GLEW_GET_FUN(__glewMatrixMultTransposedEXT)
+#define glMatrixMultTransposefEXT GLEW_GET_FUN(__glewMatrixMultTransposefEXT)
+#define glMatrixMultdEXT GLEW_GET_FUN(__glewMatrixMultdEXT)
+#define glMatrixMultfEXT GLEW_GET_FUN(__glewMatrixMultfEXT)
+#define glMatrixOrthoEXT GLEW_GET_FUN(__glewMatrixOrthoEXT)
+#define glMatrixPopEXT GLEW_GET_FUN(__glewMatrixPopEXT)
+#define glMatrixPushEXT GLEW_GET_FUN(__glewMatrixPushEXT)
+#define glMatrixRotatedEXT GLEW_GET_FUN(__glewMatrixRotatedEXT)
+#define glMatrixRotatefEXT GLEW_GET_FUN(__glewMatrixRotatefEXT)
+#define glMatrixScaledEXT GLEW_GET_FUN(__glewMatrixScaledEXT)
+#define glMatrixScalefEXT GLEW_GET_FUN(__glewMatrixScalefEXT)
+#define glMatrixTranslatedEXT GLEW_GET_FUN(__glewMatrixTranslatedEXT)
+#define glMatrixTranslatefEXT GLEW_GET_FUN(__glewMatrixTranslatefEXT)
+#define glMultiTexBufferEXT GLEW_GET_FUN(__glewMultiTexBufferEXT)
+#define glMultiTexCoordPointerEXT GLEW_GET_FUN(__glewMultiTexCoordPointerEXT)
+#define glMultiTexEnvfEXT GLEW_GET_FUN(__glewMultiTexEnvfEXT)
+#define glMultiTexEnvfvEXT GLEW_GET_FUN(__glewMultiTexEnvfvEXT)
+#define glMultiTexEnviEXT GLEW_GET_FUN(__glewMultiTexEnviEXT)
+#define glMultiTexEnvivEXT GLEW_GET_FUN(__glewMultiTexEnvivEXT)
+#define glMultiTexGendEXT GLEW_GET_FUN(__glewMultiTexGendEXT)
+#define glMultiTexGendvEXT GLEW_GET_FUN(__glewMultiTexGendvEXT)
+#define glMultiTexGenfEXT GLEW_GET_FUN(__glewMultiTexGenfEXT)
+#define glMultiTexGenfvEXT GLEW_GET_FUN(__glewMultiTexGenfvEXT)
+#define glMultiTexGeniEXT GLEW_GET_FUN(__glewMultiTexGeniEXT)
+#define glMultiTexGenivEXT GLEW_GET_FUN(__glewMultiTexGenivEXT)
+#define glMultiTexImage1DEXT GLEW_GET_FUN(__glewMultiTexImage1DEXT)
+#define glMultiTexImage2DEXT GLEW_GET_FUN(__glewMultiTexImage2DEXT)
+#define glMultiTexImage3DEXT GLEW_GET_FUN(__glewMultiTexImage3DEXT)
+#define glMultiTexParameterIivEXT GLEW_GET_FUN(__glewMultiTexParameterIivEXT)
+#define glMultiTexParameterIuivEXT GLEW_GET_FUN(__glewMultiTexParameterIuivEXT)
+#define glMultiTexParameterfEXT GLEW_GET_FUN(__glewMultiTexParameterfEXT)
+#define glMultiTexParameterfvEXT GLEW_GET_FUN(__glewMultiTexParameterfvEXT)
+#define glMultiTexParameteriEXT GLEW_GET_FUN(__glewMultiTexParameteriEXT)
+#define glMultiTexParameterivEXT GLEW_GET_FUN(__glewMultiTexParameterivEXT)
+#define glMultiTexRenderbufferEXT GLEW_GET_FUN(__glewMultiTexRenderbufferEXT)
+#define glMultiTexSubImage1DEXT GLEW_GET_FUN(__glewMultiTexSubImage1DEXT)
+#define glMultiTexSubImage2DEXT GLEW_GET_FUN(__glewMultiTexSubImage2DEXT)
+#define glMultiTexSubImage3DEXT GLEW_GET_FUN(__glewMultiTexSubImage3DEXT)
+#define glNamedBufferDataEXT GLEW_GET_FUN(__glewNamedBufferDataEXT)
+#define glNamedBufferSubDataEXT GLEW_GET_FUN(__glewNamedBufferSubDataEXT)
+#define glNamedCopyBufferSubDataEXT GLEW_GET_FUN(__glewNamedCopyBufferSubDataEXT)
+#define glNamedFramebufferRenderbufferEXT GLEW_GET_FUN(__glewNamedFramebufferRenderbufferEXT)
+#define glNamedFramebufferTexture1DEXT GLEW_GET_FUN(__glewNamedFramebufferTexture1DEXT)
+#define glNamedFramebufferTexture2DEXT GLEW_GET_FUN(__glewNamedFramebufferTexture2DEXT)
+#define glNamedFramebufferTexture3DEXT GLEW_GET_FUN(__glewNamedFramebufferTexture3DEXT)
+#define glNamedFramebufferTextureEXT GLEW_GET_FUN(__glewNamedFramebufferTextureEXT)
+#define glNamedFramebufferTextureFaceEXT GLEW_GET_FUN(__glewNamedFramebufferTextureFaceEXT)
+#define glNamedFramebufferTextureLayerEXT GLEW_GET_FUN(__glewNamedFramebufferTextureLayerEXT)
+#define glNamedProgramLocalParameter4dEXT GLEW_GET_FUN(__glewNamedProgramLocalParameter4dEXT)
+#define glNamedProgramLocalParameter4dvEXT GLEW_GET_FUN(__glewNamedProgramLocalParameter4dvEXT)
+#define glNamedProgramLocalParameter4fEXT GLEW_GET_FUN(__glewNamedProgramLocalParameter4fEXT)
+#define glNamedProgramLocalParameter4fvEXT GLEW_GET_FUN(__glewNamedProgramLocalParameter4fvEXT)
+#define glNamedProgramLocalParameterI4iEXT GLEW_GET_FUN(__glewNamedProgramLocalParameterI4iEXT)
+#define glNamedProgramLocalParameterI4ivEXT GLEW_GET_FUN(__glewNamedProgramLocalParameterI4ivEXT)
+#define glNamedProgramLocalParameterI4uiEXT GLEW_GET_FUN(__glewNamedProgramLocalParameterI4uiEXT)
+#define glNamedProgramLocalParameterI4uivEXT GLEW_GET_FUN(__glewNamedProgramLocalParameterI4uivEXT)
+#define glNamedProgramLocalParameters4fvEXT GLEW_GET_FUN(__glewNamedProgramLocalParameters4fvEXT)
+#define glNamedProgramLocalParametersI4ivEXT GLEW_GET_FUN(__glewNamedProgramLocalParametersI4ivEXT)
+#define glNamedProgramLocalParametersI4uivEXT GLEW_GET_FUN(__glewNamedProgramLocalParametersI4uivEXT)
+#define glNamedProgramStringEXT GLEW_GET_FUN(__glewNamedProgramStringEXT)
+#define glNamedRenderbufferStorageEXT GLEW_GET_FUN(__glewNamedRenderbufferStorageEXT)
+#define glNamedRenderbufferStorageMultisampleCoverageEXT GLEW_GET_FUN(__glewNamedRenderbufferStorageMultisampleCoverageEXT)
+#define glNamedRenderbufferStorageMultisampleEXT GLEW_GET_FUN(__glewNamedRenderbufferStorageMultisampleEXT)
+#define glProgramUniform1fEXT GLEW_GET_FUN(__glewProgramUniform1fEXT)
+#define glProgramUniform1fvEXT GLEW_GET_FUN(__glewProgramUniform1fvEXT)
+#define glProgramUniform1iEXT GLEW_GET_FUN(__glewProgramUniform1iEXT)
+#define glProgramUniform1ivEXT GLEW_GET_FUN(__glewProgramUniform1ivEXT)
+#define glProgramUniform1uiEXT GLEW_GET_FUN(__glewProgramUniform1uiEXT)
+#define glProgramUniform1uivEXT GLEW_GET_FUN(__glewProgramUniform1uivEXT)
+#define glProgramUniform2fEXT GLEW_GET_FUN(__glewProgramUniform2fEXT)
+#define glProgramUniform2fvEXT GLEW_GET_FUN(__glewProgramUniform2fvEXT)
+#define glProgramUniform2iEXT GLEW_GET_FUN(__glewProgramUniform2iEXT)
+#define glProgramUniform2ivEXT GLEW_GET_FUN(__glewProgramUniform2ivEXT)
+#define glProgramUniform2uiEXT GLEW_GET_FUN(__glewProgramUniform2uiEXT)
+#define glProgramUniform2uivEXT GLEW_GET_FUN(__glewProgramUniform2uivEXT)
+#define glProgramUniform3fEXT GLEW_GET_FUN(__glewProgramUniform3fEXT)
+#define glProgramUniform3fvEXT GLEW_GET_FUN(__glewProgramUniform3fvEXT)
+#define glProgramUniform3iEXT GLEW_GET_FUN(__glewProgramUniform3iEXT)
+#define glProgramUniform3ivEXT GLEW_GET_FUN(__glewProgramUniform3ivEXT)
+#define glProgramUniform3uiEXT GLEW_GET_FUN(__glewProgramUniform3uiEXT)
+#define glProgramUniform3uivEXT GLEW_GET_FUN(__glewProgramUniform3uivEXT)
+#define glProgramUniform4fEXT GLEW_GET_FUN(__glewProgramUniform4fEXT)
+#define glProgramUniform4fvEXT GLEW_GET_FUN(__glewProgramUniform4fvEXT)
+#define glProgramUniform4iEXT GLEW_GET_FUN(__glewProgramUniform4iEXT)
+#define glProgramUniform4ivEXT GLEW_GET_FUN(__glewProgramUniform4ivEXT)
+#define glProgramUniform4uiEXT GLEW_GET_FUN(__glewProgramUniform4uiEXT)
+#define glProgramUniform4uivEXT GLEW_GET_FUN(__glewProgramUniform4uivEXT)
+#define glProgramUniformMatrix2fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix2fvEXT)
+#define glProgramUniformMatrix2x3fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix2x3fvEXT)
+#define glProgramUniformMatrix2x4fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix2x4fvEXT)
+#define glProgramUniformMatrix3fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix3fvEXT)
+#define glProgramUniformMatrix3x2fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix3x2fvEXT)
+#define glProgramUniformMatrix3x4fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix3x4fvEXT)
+#define glProgramUniformMatrix4fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix4fvEXT)
+#define glProgramUniformMatrix4x2fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix4x2fvEXT)
+#define glProgramUniformMatrix4x3fvEXT GLEW_GET_FUN(__glewProgramUniformMatrix4x3fvEXT)
+#define glPushClientAttribDefaultEXT GLEW_GET_FUN(__glewPushClientAttribDefaultEXT)
+#define glTextureBufferEXT GLEW_GET_FUN(__glewTextureBufferEXT)
+#define glTextureImage1DEXT GLEW_GET_FUN(__glewTextureImage1DEXT)
+#define glTextureImage2DEXT GLEW_GET_FUN(__glewTextureImage2DEXT)
+#define glTextureImage3DEXT GLEW_GET_FUN(__glewTextureImage3DEXT)
+#define glTextureParameterIivEXT GLEW_GET_FUN(__glewTextureParameterIivEXT)
+#define glTextureParameterIuivEXT GLEW_GET_FUN(__glewTextureParameterIuivEXT)
+#define glTextureParameterfEXT GLEW_GET_FUN(__glewTextureParameterfEXT)
+#define glTextureParameterfvEXT GLEW_GET_FUN(__glewTextureParameterfvEXT)
+#define glTextureParameteriEXT GLEW_GET_FUN(__glewTextureParameteriEXT)
+#define glTextureParameterivEXT GLEW_GET_FUN(__glewTextureParameterivEXT)
+#define glTextureRenderbufferEXT GLEW_GET_FUN(__glewTextureRenderbufferEXT)
+#define glTextureSubImage1DEXT GLEW_GET_FUN(__glewTextureSubImage1DEXT)
+#define glTextureSubImage2DEXT GLEW_GET_FUN(__glewTextureSubImage2DEXT)
+#define glTextureSubImage3DEXT GLEW_GET_FUN(__glewTextureSubImage3DEXT)
+#define glUnmapNamedBufferEXT GLEW_GET_FUN(__glewUnmapNamedBufferEXT)
+#define glVertexArrayColorOffsetEXT GLEW_GET_FUN(__glewVertexArrayColorOffsetEXT)
+#define glVertexArrayEdgeFlagOffsetEXT GLEW_GET_FUN(__glewVertexArrayEdgeFlagOffsetEXT)
+#define glVertexArrayFogCoordOffsetEXT GLEW_GET_FUN(__glewVertexArrayFogCoordOffsetEXT)
+#define glVertexArrayIndexOffsetEXT GLEW_GET_FUN(__glewVertexArrayIndexOffsetEXT)
+#define glVertexArrayMultiTexCoordOffsetEXT GLEW_GET_FUN(__glewVertexArrayMultiTexCoordOffsetEXT)
+#define glVertexArrayNormalOffsetEXT GLEW_GET_FUN(__glewVertexArrayNormalOffsetEXT)
+#define glVertexArraySecondaryColorOffsetEXT GLEW_GET_FUN(__glewVertexArraySecondaryColorOffsetEXT)
+#define glVertexArrayTexCoordOffsetEXT GLEW_GET_FUN(__glewVertexArrayTexCoordOffsetEXT)
+#define glVertexArrayVertexAttribIOffsetEXT GLEW_GET_FUN(__glewVertexArrayVertexAttribIOffsetEXT)
+#define glVertexArrayVertexAttribOffsetEXT GLEW_GET_FUN(__glewVertexArrayVertexAttribOffsetEXT)
+#define glVertexArrayVertexOffsetEXT GLEW_GET_FUN(__glewVertexArrayVertexOffsetEXT)
+
+#define GLEW_EXT_direct_state_access GLEW_GET_VAR(__GLEW_EXT_direct_state_access)
+
+#endif /* GL_EXT_direct_state_access */
+
+    /* -------------------------- GL_EXT_draw_buffers2 ------------------------- */
+
+#ifndef GL_EXT_draw_buffers2
+#define GL_EXT_draw_buffers2 1
+
+    typedef void (GLAPIENTRY *PFNGLCOLORMASKINDEXEDEXTPROC)(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
+    typedef void (GLAPIENTRY *PFNGLDISABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLENABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
+    typedef void (GLAPIENTRY *PFNGLGETBOOLEANINDEXEDVEXTPROC)(GLenum value, GLuint index, GLboolean *data);
+    typedef void (GLAPIENTRY *PFNGLGETINTEGERINDEXEDVEXTPROC)(GLenum value, GLuint index, GLint *data);
+    typedef GLboolean(GLAPIENTRY *PFNGLISENABLEDINDEXEDEXTPROC)(GLenum target, GLuint index);
+
+#define glColorMaskIndexedEXT GLEW_GET_FUN(__glewColorMaskIndexedEXT)
+#define glDisableIndexedEXT GLEW_GET_FUN(__glewDisableIndexedEXT)
+#define glEnableIndexedEXT GLEW_GET_FUN(__glewEnableIndexedEXT)
+#define glGetBooleanIndexedvEXT GLEW_GET_FUN(__glewGetBooleanIndexedvEXT)
+#define glGetIntegerIndexedvEXT GLEW_GET_FUN(__glewGetIntegerIndexedvEXT)
+#define glIsEnabledIndexedEXT GLEW_GET_FUN(__glewIsEnabledIndexedEXT)
+
+#define GLEW_EXT_draw_buffers2 GLEW_GET_VAR(__GLEW_EXT_draw_buffers2)
+
+#endif /* GL_EXT_draw_buffers2 */
+
+    /* ------------------------- GL_EXT_draw_instanced ------------------------- */
+
+#ifndef GL_EXT_draw_instanced
+#define GL_EXT_draw_instanced 1
+
+    typedef void (GLAPIENTRY *PFNGLDRAWARRAYSINSTANCEDEXTPROC)(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
+    typedef void (GLAPIENTRY *PFNGLDRAWELEMENTSINSTANCEDEXTPROC)(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
+
+#define glDrawArraysInstancedEXT GLEW_GET_FUN(__glewDrawArraysInstancedEXT)
+#define glDrawElementsInstancedEXT GLEW_GET_FUN(__glewDrawElementsInstancedEXT)
+
+#define GLEW_EXT_draw_instanced GLEW_GET_VAR(__GLEW_EXT_draw_instanced)
+
+#endif /* GL_EXT_draw_instanced */
+
+    /* ----------------------- GL_EXT_draw_range_elements ---------------------- */
+
+#ifndef GL_EXT_draw_range_elements
+#define GL_EXT_draw_range_elements 1
+
+#define GL_MAX_ELEMENTS_VERTICES 0x80E8
+#define GL_MAX_ELEMENTS_INDICES 0x80E9
+
+    typedef void (GLAPIENTRY *PFNGLDRAWRANGEELEMENTSEXTPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
+
+#define glDrawRangeElementsEXT GLEW_GET_FUN(__glewDrawRangeElementsEXT)
+
+#define GLEW_EXT_draw_range_elements GLEW_GET_VAR(__GLEW_EXT_draw_range_elements)
+
+#endif /* GL_EXT_draw_range_elements */
+
+    /* ---------------------------- GL_EXT_fog_coord --------------------------- */
+
+#ifndef GL_EXT_fog_coord
+#define GL_EXT_fog_coord 1
+
+#define GL_FOG_COORDINATE_SOURCE_EXT 0x8450
+#define GL_FOG_COORDINATE_EXT 0x8451
+#define GL_FRAGMENT_DEPTH_EXT 0x8452
+#define GL_CURRENT_FOG_COORDINATE_EXT 0x8453
+#define GL_FOG_COORDINATE_ARRAY_TYPE_EXT 0x8454
+#define GL_FOG_COORDINATE_ARRAY_STRIDE_EXT 0x8455
+#define GL_FOG_COORDINATE_ARRAY_POINTER_EXT 0x8456
+#define GL_FOG_COORDINATE_ARRAY_EXT 0x8457
+
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDPOINTEREXTPROC)(GLenum type, GLsizei stride, const GLvoid *pointer);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDDEXTPROC)(GLdouble coord);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDDVEXTPROC)(const GLdouble *coord);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDFEXTPROC)(GLfloat coord);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDFVEXTPROC)(const GLfloat *coord);
+
+#define glFogCoordPointerEXT GLEW_GET_FUN(__glewFogCoordPointerEXT)
+#define glFogCoorddEXT GLEW_GET_FUN(__glewFogCoorddEXT)
+#define glFogCoorddvEXT GLEW_GET_FUN(__glewFogCoorddvEXT)
+#define glFogCoordfEXT GLEW_GET_FUN(__glewFogCoordfEXT)
+#define glFogCoordfvEXT GLEW_GET_FUN(__glewFogCoordfvEXT)
+
+#define GLEW_EXT_fog_coord GLEW_GET_VAR(__GLEW_EXT_fog_coord)
+
+#endif /* GL_EXT_fog_coord */
+
+    /* ------------------------ GL_EXT_fragment_lighting ----------------------- */
+
+#ifndef GL_EXT_fragment_lighting
+#define GL_EXT_fragment_lighting 1
+
+#define GL_FRAGMENT_LIGHTING_EXT 0x8400
+#define GL_FRAGMENT_COLOR_MATERIAL_EXT 0x8401
+#define GL_FRAGMENT_COLOR_MATERIAL_FACE_EXT 0x8402
+#define GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_EXT 0x8403
+#define GL_MAX_FRAGMENT_LIGHTS_EXT 0x8404
+#define GL_MAX_ACTIVE_LIGHTS_EXT 0x8405
+#define GL_CURRENT_RASTER_NORMAL_EXT 0x8406
+#define GL_LIGHT_ENV_MODE_EXT 0x8407
+#define GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_EXT 0x8408
+#define GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_EXT 0x8409
+#define GL_FRAGMENT_LIGHT_MODEL_AMBIENT_EXT 0x840A
+#define GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_EXT 0x840B
+#define GL_FRAGMENT_LIGHT0_EXT 0x840C
+#define GL_FRAGMENT_LIGHT7_EXT 0x8413
+
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTCOLORMATERIALEXTPROC)(GLenum face, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTMODELFEXTPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTMODELFVEXTPROC)(GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTMODELIEXTPROC)(GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTMODELIVEXTPROC)(GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTFEXTPROC)(GLenum light, GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTFVEXTPROC)(GLenum light, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTIEXTPROC)(GLenum light, GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTIVEXTPROC)(GLenum light, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTMATERIALFEXTPROC)(GLenum face, GLenum pname, const GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTMATERIALFVEXTPROC)(GLenum face, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTMATERIALIEXTPROC)(GLenum face, GLenum pname, const GLint param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTMATERIALIVEXTPROC)(GLenum face, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETFRAGMENTLIGHTFVEXTPROC)(GLenum light, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETFRAGMENTLIGHTIVEXTPROC)(GLenum light, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETFRAGMENTMATERIALFVEXTPROC)(GLenum face, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETFRAGMENTMATERIALIVEXTPROC)(GLenum face, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLLIGHTENVIEXTPROC)(GLenum pname, GLint param);
+
+#define glFragmentColorMaterialEXT GLEW_GET_FUN(__glewFragmentColorMaterialEXT)
+#define glFragmentLightModelfEXT GLEW_GET_FUN(__glewFragmentLightModelfEXT)
+#define glFragmentLightModelfvEXT GLEW_GET_FUN(__glewFragmentLightModelfvEXT)
+#define glFragmentLightModeliEXT GLEW_GET_FUN(__glewFragmentLightModeliEXT)
+#define glFragmentLightModelivEXT GLEW_GET_FUN(__glewFragmentLightModelivEXT)
+#define glFragmentLightfEXT GLEW_GET_FUN(__glewFragmentLightfEXT)
+#define glFragmentLightfvEXT GLEW_GET_FUN(__glewFragmentLightfvEXT)
+#define glFragmentLightiEXT GLEW_GET_FUN(__glewFragmentLightiEXT)
+#define glFragmentLightivEXT GLEW_GET_FUN(__glewFragmentLightivEXT)
+#define glFragmentMaterialfEXT GLEW_GET_FUN(__glewFragmentMaterialfEXT)
+#define glFragmentMaterialfvEXT GLEW_GET_FUN(__glewFragmentMaterialfvEXT)
+#define glFragmentMaterialiEXT GLEW_GET_FUN(__glewFragmentMaterialiEXT)
+#define glFragmentMaterialivEXT GLEW_GET_FUN(__glewFragmentMaterialivEXT)
+#define glGetFragmentLightfvEXT GLEW_GET_FUN(__glewGetFragmentLightfvEXT)
+#define glGetFragmentLightivEXT GLEW_GET_FUN(__glewGetFragmentLightivEXT)
+#define glGetFragmentMaterialfvEXT GLEW_GET_FUN(__glewGetFragmentMaterialfvEXT)
+#define glGetFragmentMaterialivEXT GLEW_GET_FUN(__glewGetFragmentMaterialivEXT)
+#define glLightEnviEXT GLEW_GET_FUN(__glewLightEnviEXT)
+
+#define GLEW_EXT_fragment_lighting GLEW_GET_VAR(__GLEW_EXT_fragment_lighting)
+
+#endif /* GL_EXT_fragment_lighting */
+
+    /* ------------------------ GL_EXT_framebuffer_blit ------------------------ */
+
+#ifndef GL_EXT_framebuffer_blit
+#define GL_EXT_framebuffer_blit 1
+
+#define GL_DRAW_FRAMEBUFFER_BINDING_EXT 0x8CA6
+#define GL_READ_FRAMEBUFFER_EXT 0x8CA8
+#define GL_DRAW_FRAMEBUFFER_EXT 0x8CA9
+#define GL_READ_FRAMEBUFFER_BINDING_EXT 0x8CAA
+
+    typedef void (GLAPIENTRY *PFNGLBLITFRAMEBUFFEREXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+
+#define glBlitFramebufferEXT GLEW_GET_FUN(__glewBlitFramebufferEXT)
+
+#define GLEW_EXT_framebuffer_blit GLEW_GET_VAR(__GLEW_EXT_framebuffer_blit)
+
+#endif /* GL_EXT_framebuffer_blit */
+
+    /* --------------------- GL_EXT_framebuffer_multisample -------------------- */
+
+#ifndef GL_EXT_framebuffer_multisample
+#define GL_EXT_framebuffer_multisample 1
+
+#define GL_RENDERBUFFER_SAMPLES_EXT 0x8CAB
+#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT 0x8D56
+#define GL_MAX_SAMPLES_EXT 0x8D57
+
+    typedef void (GLAPIENTRY *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
+
+#define glRenderbufferStorageMultisampleEXT GLEW_GET_FUN(__glewRenderbufferStorageMultisampleEXT)
+
+#define GLEW_EXT_framebuffer_multisample GLEW_GET_VAR(__GLEW_EXT_framebuffer_multisample)
+
+#endif /* GL_EXT_framebuffer_multisample */
+
+    /* ----------------------- GL_EXT_framebuffer_object ----------------------- */
+
+#ifndef GL_EXT_framebuffer_object
+#define GL_EXT_framebuffer_object 1
+
+#define GL_INVALID_FRAMEBUFFER_OPERATION_EXT 0x0506
+#define GL_MAX_RENDERBUFFER_SIZE_EXT 0x84E8
+#define GL_FRAMEBUFFER_BINDING_EXT 0x8CA6
+#define GL_RENDERBUFFER_BINDING_EXT 0x8CA7
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT 0x8CD0
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT 0x8CD1
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT 0x8CD2
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT 0x8CD3
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT 0x8CD4
+#define GL_FRAMEBUFFER_COMPLETE_EXT 0x8CD5
+#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT 0x8CD6
+#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT 0x8CD7
+#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT 0x8CD9
+#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT 0x8CDA
+#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT 0x8CDB
+#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT 0x8CDC
+#define GL_FRAMEBUFFER_UNSUPPORTED_EXT 0x8CDD
+#define GL_MAX_COLOR_ATTACHMENTS_EXT 0x8CDF
+#define GL_COLOR_ATTACHMENT0_EXT 0x8CE0
+#define GL_COLOR_ATTACHMENT1_EXT 0x8CE1
+#define GL_COLOR_ATTACHMENT2_EXT 0x8CE2
+#define GL_COLOR_ATTACHMENT3_EXT 0x8CE3
+#define GL_COLOR_ATTACHMENT4_EXT 0x8CE4
+#define GL_COLOR_ATTACHMENT5_EXT 0x8CE5
+#define GL_COLOR_ATTACHMENT6_EXT 0x8CE6
+#define GL_COLOR_ATTACHMENT7_EXT 0x8CE7
+#define GL_COLOR_ATTACHMENT8_EXT 0x8CE8
+#define GL_COLOR_ATTACHMENT9_EXT 0x8CE9
+#define GL_COLOR_ATTACHMENT10_EXT 0x8CEA
+#define GL_COLOR_ATTACHMENT11_EXT 0x8CEB
+#define GL_COLOR_ATTACHMENT12_EXT 0x8CEC
+#define GL_COLOR_ATTACHMENT13_EXT 0x8CED
+#define GL_COLOR_ATTACHMENT14_EXT 0x8CEE
+#define GL_COLOR_ATTACHMENT15_EXT 0x8CEF
+#define GL_DEPTH_ATTACHMENT_EXT 0x8D00
+#define GL_STENCIL_ATTACHMENT_EXT 0x8D20
+#define GL_FRAMEBUFFER_EXT 0x8D40
+#define GL_RENDERBUFFER_EXT 0x8D41
+#define GL_RENDERBUFFER_WIDTH_EXT 0x8D42
+#define GL_RENDERBUFFER_HEIGHT_EXT 0x8D43
+#define GL_RENDERBUFFER_INTERNAL_FORMAT_EXT 0x8D44
+#define GL_STENCIL_INDEX1_EXT 0x8D46
+#define GL_STENCIL_INDEX4_EXT 0x8D47
+#define GL_STENCIL_INDEX8_EXT 0x8D48
+#define GL_STENCIL_INDEX16_EXT 0x8D49
+#define GL_RENDERBUFFER_RED_SIZE_EXT 0x8D50
+#define GL_RENDERBUFFER_GREEN_SIZE_EXT 0x8D51
+#define GL_RENDERBUFFER_BLUE_SIZE_EXT 0x8D52
+#define GL_RENDERBUFFER_ALPHA_SIZE_EXT 0x8D53
+#define GL_RENDERBUFFER_DEPTH_SIZE_EXT 0x8D54
+#define GL_RENDERBUFFER_STENCIL_SIZE_EXT 0x8D55
+
+    typedef void (GLAPIENTRY *PFNGLBINDFRAMEBUFFEREXTPROC)(GLenum target, GLuint framebuffer);
+    typedef void (GLAPIENTRY *PFNGLBINDRENDERBUFFEREXTPROC)(GLenum target, GLuint renderbuffer);
+    typedef GLenum(GLAPIENTRY *PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLDELETEFRAMEBUFFERSEXTPROC)(GLsizei n, const GLuint *framebuffers);
+    typedef void (GLAPIENTRY *PFNGLDELETERENDERBUFFERSEXTPROC)(GLsizei n, const GLuint *renderbuffers);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
+    typedef void (GLAPIENTRY *PFNGLGENFRAMEBUFFERSEXTPROC)(GLsizei n, GLuint *framebuffers);
+    typedef void (GLAPIENTRY *PFNGLGENRENDERBUFFERSEXTPROC)(GLsizei n, GLuint *renderbuffers);
+    typedef void (GLAPIENTRY *PFNGLGENERATEMIPMAPEXTPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISFRAMEBUFFEREXTPROC)(GLuint framebuffer);
+    typedef GLboolean(GLAPIENTRY *PFNGLISRENDERBUFFEREXTPROC)(GLuint renderbuffer);
+    typedef void (GLAPIENTRY *PFNGLRENDERBUFFERSTORAGEEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
+
+#define glBindFramebufferEXT GLEW_GET_FUN(__glewBindFramebufferEXT)
+#define glBindRenderbufferEXT GLEW_GET_FUN(__glewBindRenderbufferEXT)
+#define glCheckFramebufferStatusEXT GLEW_GET_FUN(__glewCheckFramebufferStatusEXT)
+#define glDeleteFramebuffersEXT GLEW_GET_FUN(__glewDeleteFramebuffersEXT)
+#define glDeleteRenderbuffersEXT GLEW_GET_FUN(__glewDeleteRenderbuffersEXT)
+#define glFramebufferRenderbufferEXT GLEW_GET_FUN(__glewFramebufferRenderbufferEXT)
+#define glFramebufferTexture1DEXT GLEW_GET_FUN(__glewFramebufferTexture1DEXT)
+#define glFramebufferTexture2DEXT GLEW_GET_FUN(__glewFramebufferTexture2DEXT)
+#define glFramebufferTexture3DEXT GLEW_GET_FUN(__glewFramebufferTexture3DEXT)
+#define glGenFramebuffersEXT GLEW_GET_FUN(__glewGenFramebuffersEXT)
+#define glGenRenderbuffersEXT GLEW_GET_FUN(__glewGenRenderbuffersEXT)
+#define glGenerateMipmapEXT GLEW_GET_FUN(__glewGenerateMipmapEXT)
+#define glGetFramebufferAttachmentParameterivEXT GLEW_GET_FUN(__glewGetFramebufferAttachmentParameterivEXT)
+#define glGetRenderbufferParameterivEXT GLEW_GET_FUN(__glewGetRenderbufferParameterivEXT)
+#define glIsFramebufferEXT GLEW_GET_FUN(__glewIsFramebufferEXT)
+#define glIsRenderbufferEXT GLEW_GET_FUN(__glewIsRenderbufferEXT)
+#define glRenderbufferStorageEXT GLEW_GET_FUN(__glewRenderbufferStorageEXT)
+
+#define GLEW_EXT_framebuffer_object GLEW_GET_VAR(__GLEW_EXT_framebuffer_object)
+
+#endif /* GL_EXT_framebuffer_object */
+
+    /* ------------------------ GL_EXT_framebuffer_sRGB ------------------------ */
+
+#ifndef GL_EXT_framebuffer_sRGB
+#define GL_EXT_framebuffer_sRGB 1
+
+#define GL_FRAMEBUFFER_SRGB_EXT 0x8DB9
+#define GL_FRAMEBUFFER_SRGB_CAPABLE_EXT 0x8DBA
+
+#define GLEW_EXT_framebuffer_sRGB GLEW_GET_VAR(__GLEW_EXT_framebuffer_sRGB)
+
+#endif /* GL_EXT_framebuffer_sRGB */
+
+    /* ------------------------ GL_EXT_geometry_shader4 ------------------------ */
+
+#ifndef GL_EXT_geometry_shader4
+#define GL_EXT_geometry_shader4 1
+
+#define GL_LINES_ADJACENCY_EXT 0xA
+#define GL_LINE_STRIP_ADJACENCY_EXT 0xB
+#define GL_TRIANGLES_ADJACENCY_EXT 0xC
+#define GL_TRIANGLE_STRIP_ADJACENCY_EXT 0xD
+#define GL_PROGRAM_POINT_SIZE_EXT 0x8642
+#define GL_MAX_VARYING_COMPONENTS_EXT 0x8B4B
+#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT 0x8C29
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT 0x8CD4
+#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT 0x8DA7
+#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT 0x8DA8
+#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT 0x8DA9
+#define GL_GEOMETRY_SHADER_EXT 0x8DD9
+#define GL_GEOMETRY_VERTICES_OUT_EXT 0x8DDA
+#define GL_GEOMETRY_INPUT_TYPE_EXT 0x8DDB
+#define GL_GEOMETRY_OUTPUT_TYPE_EXT 0x8DDC
+#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT 0x8DDD
+#define GL_MAX_VERTEX_VARYING_COMPONENTS_EXT 0x8DDE
+#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT 0x8DDF
+#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT 0x8DE0
+#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT 0x8DE1
+
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTUREEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
+    typedef void (GLAPIENTRY *PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMPARAMETERIEXTPROC)(GLuint program, GLenum pname, GLint value);
+
+#define glFramebufferTextureEXT GLEW_GET_FUN(__glewFramebufferTextureEXT)
+#define glFramebufferTextureFaceEXT GLEW_GET_FUN(__glewFramebufferTextureFaceEXT)
+#define glFramebufferTextureLayerEXT GLEW_GET_FUN(__glewFramebufferTextureLayerEXT)
+#define glProgramParameteriEXT GLEW_GET_FUN(__glewProgramParameteriEXT)
+
+#define GLEW_EXT_geometry_shader4 GLEW_GET_VAR(__GLEW_EXT_geometry_shader4)
+
+#endif /* GL_EXT_geometry_shader4 */
+
+    /* --------------------- GL_EXT_gpu_program_parameters --------------------- */
+
+#ifndef GL_EXT_gpu_program_parameters
+#define GL_EXT_gpu_program_parameters 1
+
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETERS4FVEXTPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
+
+#define glProgramEnvParameters4fvEXT GLEW_GET_FUN(__glewProgramEnvParameters4fvEXT)
+#define glProgramLocalParameters4fvEXT GLEW_GET_FUN(__glewProgramLocalParameters4fvEXT)
+
+#define GLEW_EXT_gpu_program_parameters GLEW_GET_VAR(__GLEW_EXT_gpu_program_parameters)
+
+#endif /* GL_EXT_gpu_program_parameters */
+
+    /* --------------------------- GL_EXT_gpu_shader4 -------------------------- */
+
+#ifndef GL_EXT_gpu_shader4
+#define GL_EXT_gpu_shader4 1
+
+#define GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT 0x88FD
+#define GL_SAMPLER_1D_ARRAY_EXT 0x8DC0
+#define GL_SAMPLER_2D_ARRAY_EXT 0x8DC1
+#define GL_SAMPLER_BUFFER_EXT 0x8DC2
+#define GL_SAMPLER_1D_ARRAY_SHADOW_EXT 0x8DC3
+#define GL_SAMPLER_2D_ARRAY_SHADOW_EXT 0x8DC4
+#define GL_SAMPLER_CUBE_SHADOW_EXT 0x8DC5
+#define GL_UNSIGNED_INT_VEC2_EXT 0x8DC6
+#define GL_UNSIGNED_INT_VEC3_EXT 0x8DC7
+#define GL_UNSIGNED_INT_VEC4_EXT 0x8DC8
+#define GL_INT_SAMPLER_1D_EXT 0x8DC9
+#define GL_INT_SAMPLER_2D_EXT 0x8DCA
+#define GL_INT_SAMPLER_3D_EXT 0x8DCB
+#define GL_INT_SAMPLER_CUBE_EXT 0x8DCC
+#define GL_INT_SAMPLER_2D_RECT_EXT 0x8DCD
+#define GL_INT_SAMPLER_1D_ARRAY_EXT 0x8DCE
+#define GL_INT_SAMPLER_2D_ARRAY_EXT 0x8DCF
+#define GL_INT_SAMPLER_BUFFER_EXT 0x8DD0
+#define GL_UNSIGNED_INT_SAMPLER_1D_EXT 0x8DD1
+#define GL_UNSIGNED_INT_SAMPLER_2D_EXT 0x8DD2
+#define GL_UNSIGNED_INT_SAMPLER_3D_EXT 0x8DD3
+#define GL_UNSIGNED_INT_SAMPLER_CUBE_EXT 0x8DD4
+#define GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT 0x8DD5
+#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT 0x8DD6
+#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT 0x8DD7
+#define GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT 0x8DD8
+
+    typedef void (GLAPIENTRY *PFNGLBINDFRAGDATALOCATIONEXTPROC)(GLuint program, GLuint color, const GLchar *name);
+    typedef GLint(GLAPIENTRY *PFNGLGETFRAGDATALOCATIONEXTPROC)(GLuint program, const GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMUIVEXTPROC)(GLuint program, GLint location, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBIIVEXTPROC)(GLuint index, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBIUIVEXTPROC)(GLuint index, GLenum pname, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1UIEXTPROC)(GLint location, GLuint v0);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2UIEXTPROC)(GLint location, GLuint v0, GLuint v1);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI1IEXTPROC)(GLuint index, GLint x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI1IVEXTPROC)(GLuint index, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI1UIEXTPROC)(GLuint index, GLuint x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI1UIVEXTPROC)(GLuint index, const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI2IEXTPROC)(GLuint index, GLint x, GLint y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI2IVEXTPROC)(GLuint index, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI2UIEXTPROC)(GLuint index, GLuint x, GLuint y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI2UIVEXTPROC)(GLuint index, const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI3IEXTPROC)(GLuint index, GLint x, GLint y, GLint z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI3IVEXTPROC)(GLuint index, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI3UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI3UIVEXTPROC)(GLuint index, const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4BVEXTPROC)(GLuint index, const GLbyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4IEXTPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4IVEXTPROC)(GLuint index, const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4SVEXTPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4UBVEXTPROC)(GLuint index, const GLubyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4UIVEXTPROC)(GLuint index, const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBI4USVEXTPROC)(GLuint index, const GLushort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBIPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+
+#define glBindFragDataLocationEXT GLEW_GET_FUN(__glewBindFragDataLocationEXT)
+#define glGetFragDataLocationEXT GLEW_GET_FUN(__glewGetFragDataLocationEXT)
+#define glGetUniformuivEXT GLEW_GET_FUN(__glewGetUniformuivEXT)
+#define glGetVertexAttribIivEXT GLEW_GET_FUN(__glewGetVertexAttribIivEXT)
+#define glGetVertexAttribIuivEXT GLEW_GET_FUN(__glewGetVertexAttribIuivEXT)
+#define glUniform1uiEXT GLEW_GET_FUN(__glewUniform1uiEXT)
+#define glUniform1uivEXT GLEW_GET_FUN(__glewUniform1uivEXT)
+#define glUniform2uiEXT GLEW_GET_FUN(__glewUniform2uiEXT)
+#define glUniform2uivEXT GLEW_GET_FUN(__glewUniform2uivEXT)
+#define glUniform3uiEXT GLEW_GET_FUN(__glewUniform3uiEXT)
+#define glUniform3uivEXT GLEW_GET_FUN(__glewUniform3uivEXT)
+#define glUniform4uiEXT GLEW_GET_FUN(__glewUniform4uiEXT)
+#define glUniform4uivEXT GLEW_GET_FUN(__glewUniform4uivEXT)
+#define glVertexAttribI1iEXT GLEW_GET_FUN(__glewVertexAttribI1iEXT)
+#define glVertexAttribI1ivEXT GLEW_GET_FUN(__glewVertexAttribI1ivEXT)
+#define glVertexAttribI1uiEXT GLEW_GET_FUN(__glewVertexAttribI1uiEXT)
+#define glVertexAttribI1uivEXT GLEW_GET_FUN(__glewVertexAttribI1uivEXT)
+#define glVertexAttribI2iEXT GLEW_GET_FUN(__glewVertexAttribI2iEXT)
+#define glVertexAttribI2ivEXT GLEW_GET_FUN(__glewVertexAttribI2ivEXT)
+#define glVertexAttribI2uiEXT GLEW_GET_FUN(__glewVertexAttribI2uiEXT)
+#define glVertexAttribI2uivEXT GLEW_GET_FUN(__glewVertexAttribI2uivEXT)
+#define glVertexAttribI3iEXT GLEW_GET_FUN(__glewVertexAttribI3iEXT)
+#define glVertexAttribI3ivEXT GLEW_GET_FUN(__glewVertexAttribI3ivEXT)
+#define glVertexAttribI3uiEXT GLEW_GET_FUN(__glewVertexAttribI3uiEXT)
+#define glVertexAttribI3uivEXT GLEW_GET_FUN(__glewVertexAttribI3uivEXT)
+#define glVertexAttribI4bvEXT GLEW_GET_FUN(__glewVertexAttribI4bvEXT)
+#define glVertexAttribI4iEXT GLEW_GET_FUN(__glewVertexAttribI4iEXT)
+#define glVertexAttribI4ivEXT GLEW_GET_FUN(__glewVertexAttribI4ivEXT)
+#define glVertexAttribI4svEXT GLEW_GET_FUN(__glewVertexAttribI4svEXT)
+#define glVertexAttribI4ubvEXT GLEW_GET_FUN(__glewVertexAttribI4ubvEXT)
+#define glVertexAttribI4uiEXT GLEW_GET_FUN(__glewVertexAttribI4uiEXT)
+#define glVertexAttribI4uivEXT GLEW_GET_FUN(__glewVertexAttribI4uivEXT)
+#define glVertexAttribI4usvEXT GLEW_GET_FUN(__glewVertexAttribI4usvEXT)
+#define glVertexAttribIPointerEXT GLEW_GET_FUN(__glewVertexAttribIPointerEXT)
+
+#define GLEW_EXT_gpu_shader4 GLEW_GET_VAR(__GLEW_EXT_gpu_shader4)
+
+#endif /* GL_EXT_gpu_shader4 */
+
+    /* ---------------------------- GL_EXT_histogram --------------------------- */
+
+#ifndef GL_EXT_histogram
+#define GL_EXT_histogram 1
+
+#define GL_HISTOGRAM_EXT 0x8024
+#define GL_PROXY_HISTOGRAM_EXT 0x8025
+#define GL_HISTOGRAM_WIDTH_EXT 0x8026
+#define GL_HISTOGRAM_FORMAT_EXT 0x8027
+#define GL_HISTOGRAM_RED_SIZE_EXT 0x8028
+#define GL_HISTOGRAM_GREEN_SIZE_EXT 0x8029
+#define GL_HISTOGRAM_BLUE_SIZE_EXT 0x802A
+#define GL_HISTOGRAM_ALPHA_SIZE_EXT 0x802B
+#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT 0x802C
+#define GL_HISTOGRAM_SINK_EXT 0x802D
+#define GL_MINMAX_EXT 0x802E
+#define GL_MINMAX_FORMAT_EXT 0x802F
+#define GL_MINMAX_SINK_EXT 0x8030
+
+    typedef void (GLAPIENTRY *PFNGLGETHISTOGRAMEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
+    typedef void (GLAPIENTRY *PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETMINMAXEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
+    typedef void (GLAPIENTRY *PFNGLGETMINMAXPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETMINMAXPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLHISTOGRAMEXTPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
+    typedef void (GLAPIENTRY *PFNGLMINMAXEXTPROC)(GLenum target, GLenum internalformat, GLboolean sink);
+    typedef void (GLAPIENTRY *PFNGLRESETHISTOGRAMEXTPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLRESETMINMAXEXTPROC)(GLenum target);
+
+#define glGetHistogramEXT GLEW_GET_FUN(__glewGetHistogramEXT)
+#define glGetHistogramParameterfvEXT GLEW_GET_FUN(__glewGetHistogramParameterfvEXT)
+#define glGetHistogramParameterivEXT GLEW_GET_FUN(__glewGetHistogramParameterivEXT)
+#define glGetMinmaxEXT GLEW_GET_FUN(__glewGetMinmaxEXT)
+#define glGetMinmaxParameterfvEXT GLEW_GET_FUN(__glewGetMinmaxParameterfvEXT)
+#define glGetMinmaxParameterivEXT GLEW_GET_FUN(__glewGetMinmaxParameterivEXT)
+#define glHistogramEXT GLEW_GET_FUN(__glewHistogramEXT)
+#define glMinmaxEXT GLEW_GET_FUN(__glewMinmaxEXT)
+#define glResetHistogramEXT GLEW_GET_FUN(__glewResetHistogramEXT)
+#define glResetMinmaxEXT GLEW_GET_FUN(__glewResetMinmaxEXT)
+
+#define GLEW_EXT_histogram GLEW_GET_VAR(__GLEW_EXT_histogram)
+
+#endif /* GL_EXT_histogram */
+
+    /* ----------------------- GL_EXT_index_array_formats ---------------------- */
+
+#ifndef GL_EXT_index_array_formats
+#define GL_EXT_index_array_formats 1
+
+#define GLEW_EXT_index_array_formats GLEW_GET_VAR(__GLEW_EXT_index_array_formats)
+
+#endif /* GL_EXT_index_array_formats */
+
+    /* --------------------------- GL_EXT_index_func --------------------------- */
+
+#ifndef GL_EXT_index_func
+#define GL_EXT_index_func 1
+
+    typedef void (GLAPIENTRY *PFNGLINDEXFUNCEXTPROC)(GLenum func, GLfloat ref);
+
+#define glIndexFuncEXT GLEW_GET_FUN(__glewIndexFuncEXT)
+
+#define GLEW_EXT_index_func GLEW_GET_VAR(__GLEW_EXT_index_func)
+
+#endif /* GL_EXT_index_func */
+
+    /* ------------------------- GL_EXT_index_material ------------------------- */
+
+#ifndef GL_EXT_index_material
+#define GL_EXT_index_material 1
+
+    typedef void (GLAPIENTRY *PFNGLINDEXMATERIALEXTPROC)(GLenum face, GLenum mode);
+
+#define glIndexMaterialEXT GLEW_GET_FUN(__glewIndexMaterialEXT)
+
+#define GLEW_EXT_index_material GLEW_GET_VAR(__GLEW_EXT_index_material)
+
+#endif /* GL_EXT_index_material */
+
+    /* -------------------------- GL_EXT_index_texture ------------------------- */
+
+#ifndef GL_EXT_index_texture
+#define GL_EXT_index_texture 1
+
+#define GLEW_EXT_index_texture GLEW_GET_VAR(__GLEW_EXT_index_texture)
+
+#endif /* GL_EXT_index_texture */
+
+    /* -------------------------- GL_EXT_light_texture ------------------------- */
+
+#ifndef GL_EXT_light_texture
+#define GL_EXT_light_texture 1
+
+#define GL_FRAGMENT_MATERIAL_EXT 0x8349
+#define GL_FRAGMENT_NORMAL_EXT 0x834A
+#define GL_FRAGMENT_COLOR_EXT 0x834C
+#define GL_ATTENUATION_EXT 0x834D
+#define GL_SHADOW_ATTENUATION_EXT 0x834E
+#define GL_TEXTURE_APPLICATION_MODE_EXT 0x834F
+#define GL_TEXTURE_LIGHT_EXT 0x8350
+#define GL_TEXTURE_MATERIAL_FACE_EXT 0x8351
+#define GL_TEXTURE_MATERIAL_PARAMETER_EXT 0x8352
+#define GL_FRAGMENT_DEPTH_EXT 0x8452
+
+    typedef void (GLAPIENTRY *PFNGLAPPLYTEXTUREEXTPROC)(GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLTEXTURELIGHTEXTPROC)(GLenum pname);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREMATERIALEXTPROC)(GLenum face, GLenum mode);
+
+#define glApplyTextureEXT GLEW_GET_FUN(__glewApplyTextureEXT)
+#define glTextureLightEXT GLEW_GET_FUN(__glewTextureLightEXT)
+#define glTextureMaterialEXT GLEW_GET_FUN(__glewTextureMaterialEXT)
+
+#define GLEW_EXT_light_texture GLEW_GET_VAR(__GLEW_EXT_light_texture)
+
+#endif /* GL_EXT_light_texture */
+
+    /* ------------------------- GL_EXT_misc_attribute ------------------------- */
+
+#ifndef GL_EXT_misc_attribute
+#define GL_EXT_misc_attribute 1
+
+#define GLEW_EXT_misc_attribute GLEW_GET_VAR(__GLEW_EXT_misc_attribute)
+
+#endif /* GL_EXT_misc_attribute */
+
+    /* ------------------------ GL_EXT_multi_draw_arrays ----------------------- */
+
+#ifndef GL_EXT_multi_draw_arrays
+#define GL_EXT_multi_draw_arrays 1
+
+    typedef void (GLAPIENTRY *PFNGLMULTIDRAWARRAYSEXTPROC)(GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
+    typedef void (GLAPIENTRY *PFNGLMULTIDRAWELEMENTSEXTPROC)(GLenum mode, GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount);
+
+#define glMultiDrawArraysEXT GLEW_GET_FUN(__glewMultiDrawArraysEXT)
+#define glMultiDrawElementsEXT GLEW_GET_FUN(__glewMultiDrawElementsEXT)
+
+#define GLEW_EXT_multi_draw_arrays GLEW_GET_VAR(__GLEW_EXT_multi_draw_arrays)
+
+#endif /* GL_EXT_multi_draw_arrays */
+
+    /* --------------------------- GL_EXT_multisample -------------------------- */
+
+#ifndef GL_EXT_multisample
+#define GL_EXT_multisample 1
+
+#define GL_MULTISAMPLE_EXT 0x809D
+#define GL_SAMPLE_ALPHA_TO_MASK_EXT 0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_EXT 0x809F
+#define GL_SAMPLE_MASK_EXT 0x80A0
+#define GL_1PASS_EXT 0x80A1
+#define GL_2PASS_0_EXT 0x80A2
+#define GL_2PASS_1_EXT 0x80A3
+#define GL_4PASS_0_EXT 0x80A4
+#define GL_4PASS_1_EXT 0x80A5
+#define GL_4PASS_2_EXT 0x80A6
+#define GL_4PASS_3_EXT 0x80A7
+#define GL_SAMPLE_BUFFERS_EXT 0x80A8
+#define GL_SAMPLES_EXT 0x80A9
+#define GL_SAMPLE_MASK_VALUE_EXT 0x80AA
+#define GL_SAMPLE_MASK_INVERT_EXT 0x80AB
+#define GL_SAMPLE_PATTERN_EXT 0x80AC
+#define GL_MULTISAMPLE_BIT_EXT 0x20000000
+
+    typedef void (GLAPIENTRY *PFNGLSAMPLEMASKEXTPROC)(GLclampf value, GLboolean invert);
+    typedef void (GLAPIENTRY *PFNGLSAMPLEPATTERNEXTPROC)(GLenum pattern);
+
+#define glSampleMaskEXT GLEW_GET_FUN(__glewSampleMaskEXT)
+#define glSamplePatternEXT GLEW_GET_FUN(__glewSamplePatternEXT)
+
+#define GLEW_EXT_multisample GLEW_GET_VAR(__GLEW_EXT_multisample)
+
+#endif /* GL_EXT_multisample */
+
+    /* ---------------------- GL_EXT_packed_depth_stencil ---------------------- */
+
+#ifndef GL_EXT_packed_depth_stencil
+#define GL_EXT_packed_depth_stencil 1
+
+#define GL_DEPTH_STENCIL_EXT 0x84F9
+#define GL_UNSIGNED_INT_24_8_EXT 0x84FA
+#define GL_DEPTH24_STENCIL8_EXT 0x88F0
+#define GL_TEXTURE_STENCIL_SIZE_EXT 0x88F1
+
+#define GLEW_EXT_packed_depth_stencil GLEW_GET_VAR(__GLEW_EXT_packed_depth_stencil)
+
+#endif /* GL_EXT_packed_depth_stencil */
+
+    /* -------------------------- GL_EXT_packed_float -------------------------- */
+
+#ifndef GL_EXT_packed_float
+#define GL_EXT_packed_float 1
+
+#define GL_R11F_G11F_B10F_EXT 0x8C3A
+#define GL_UNSIGNED_INT_10F_11F_11F_REV_EXT 0x8C3B
+#define GL_RGBA_SIGNED_COMPONENTS_EXT 0x8C3C
+
+#define GLEW_EXT_packed_float GLEW_GET_VAR(__GLEW_EXT_packed_float)
+
+#endif /* GL_EXT_packed_float */
+
+    /* -------------------------- GL_EXT_packed_pixels ------------------------- */
+
+#ifndef GL_EXT_packed_pixels
+#define GL_EXT_packed_pixels 1
+
+#define GL_UNSIGNED_BYTE_3_3_2_EXT 0x8032
+#define GL_UNSIGNED_SHORT_4_4_4_4_EXT 0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1_EXT 0x8034
+#define GL_UNSIGNED_INT_8_8_8_8_EXT 0x8035
+#define GL_UNSIGNED_INT_10_10_10_2_EXT 0x8036
+
+#define GLEW_EXT_packed_pixels GLEW_GET_VAR(__GLEW_EXT_packed_pixels)
+
+#endif /* GL_EXT_packed_pixels */
+
+    /* ------------------------ GL_EXT_paletted_texture ------------------------ */
+
+#ifndef GL_EXT_paletted_texture
+#define GL_EXT_paletted_texture 1
+
+#define GL_TEXTURE_1D 0x0DE0
+#define GL_TEXTURE_2D 0x0DE1
+#define GL_PROXY_TEXTURE_1D 0x8063
+#define GL_PROXY_TEXTURE_2D 0x8064
+#define GL_TEXTURE_3D_EXT 0x806F
+#define GL_PROXY_TEXTURE_3D_EXT 0x8070
+#define GL_COLOR_TABLE_FORMAT_EXT 0x80D8
+#define GL_COLOR_TABLE_WIDTH_EXT 0x80D9
+#define GL_COLOR_TABLE_RED_SIZE_EXT 0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE_EXT 0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE_EXT 0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE_EXT 0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE_EXT 0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE_EXT 0x80DF
+#define GL_COLOR_INDEX1_EXT 0x80E2
+#define GL_COLOR_INDEX2_EXT 0x80E3
+#define GL_COLOR_INDEX4_EXT 0x80E4
+#define GL_COLOR_INDEX8_EXT 0x80E5
+#define GL_COLOR_INDEX12_EXT 0x80E6
+#define GL_COLOR_INDEX16_EXT 0x80E7
+#define GL_TEXTURE_INDEX_SIZE_EXT 0x80ED
+#define GL_TEXTURE_CUBE_MAP_ARB 0x8513
+#define GL_PROXY_TEXTURE_CUBE_MAP_ARB 0x851B
+
+    typedef void (GLAPIENTRY *PFNGLCOLORTABLEEXTPROC)(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLEEXTPROC)(GLenum target, GLenum format, GLenum type, void *data);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+
+#define glColorTableEXT GLEW_GET_FUN(__glewColorTableEXT)
+#define glGetColorTableEXT GLEW_GET_FUN(__glewGetColorTableEXT)
+#define glGetColorTableParameterfvEXT GLEW_GET_FUN(__glewGetColorTableParameterfvEXT)
+#define glGetColorTableParameterivEXT GLEW_GET_FUN(__glewGetColorTableParameterivEXT)
+
+#define GLEW_EXT_paletted_texture GLEW_GET_VAR(__GLEW_EXT_paletted_texture)
+
+#endif /* GL_EXT_paletted_texture */
+
+    /* ----------------------- GL_EXT_pixel_buffer_object ---------------------- */
+
+#ifndef GL_EXT_pixel_buffer_object
+#define GL_EXT_pixel_buffer_object 1
+
+#define GL_PIXEL_PACK_BUFFER_EXT 0x88EB
+#define GL_PIXEL_UNPACK_BUFFER_EXT 0x88EC
+#define GL_PIXEL_PACK_BUFFER_BINDING_EXT 0x88ED
+#define GL_PIXEL_UNPACK_BUFFER_BINDING_EXT 0x88EF
+
+#define GLEW_EXT_pixel_buffer_object GLEW_GET_VAR(__GLEW_EXT_pixel_buffer_object)
+
+#endif /* GL_EXT_pixel_buffer_object */
+
+    /* ------------------------- GL_EXT_pixel_transform ------------------------ */
+
+#ifndef GL_EXT_pixel_transform
+#define GL_EXT_pixel_transform 1
+
+#define GL_PIXEL_TRANSFORM_2D_EXT 0x8330
+#define GL_PIXEL_MAG_FILTER_EXT 0x8331
+#define GL_PIXEL_MIN_FILTER_EXT 0x8332
+#define GL_PIXEL_CUBIC_WEIGHT_EXT 0x8333
+#define GL_CUBIC_EXT 0x8334
+#define GL_AVERAGE_EXT 0x8335
+#define GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8336
+#define GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8337
+#define GL_PIXEL_TRANSFORM_2D_MATRIX_EXT 0x8338
+
+    typedef void (GLAPIENTRY *PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)(GLenum target, GLenum pname, const GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)(GLenum target, GLenum pname, const GLint param);
+    typedef void (GLAPIENTRY *PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
+
+#define glGetPixelTransformParameterfvEXT GLEW_GET_FUN(__glewGetPixelTransformParameterfvEXT)
+#define glGetPixelTransformParameterivEXT GLEW_GET_FUN(__glewGetPixelTransformParameterivEXT)
+#define glPixelTransformParameterfEXT GLEW_GET_FUN(__glewPixelTransformParameterfEXT)
+#define glPixelTransformParameterfvEXT GLEW_GET_FUN(__glewPixelTransformParameterfvEXT)
+#define glPixelTransformParameteriEXT GLEW_GET_FUN(__glewPixelTransformParameteriEXT)
+#define glPixelTransformParameterivEXT GLEW_GET_FUN(__glewPixelTransformParameterivEXT)
+
+#define GLEW_EXT_pixel_transform GLEW_GET_VAR(__GLEW_EXT_pixel_transform)
+
+#endif /* GL_EXT_pixel_transform */
+
+    /* ------------------- GL_EXT_pixel_transform_color_table ------------------ */
+
+#ifndef GL_EXT_pixel_transform_color_table
+#define GL_EXT_pixel_transform_color_table 1
+
+#define GLEW_EXT_pixel_transform_color_table GLEW_GET_VAR(__GLEW_EXT_pixel_transform_color_table)
+
+#endif /* GL_EXT_pixel_transform_color_table */
+
+    /* ------------------------ GL_EXT_point_parameters ------------------------ */
+
+#ifndef GL_EXT_point_parameters
+#define GL_EXT_point_parameters 1
+
+#define GL_POINT_SIZE_MIN_EXT 0x8126
+#define GL_POINT_SIZE_MAX_EXT 0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_EXT 0x8128
+#define GL_DISTANCE_ATTENUATION_EXT 0x8129
+
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERFEXTPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERFVEXTPROC)(GLenum pname, GLfloat *params);
+
+#define glPointParameterfEXT GLEW_GET_FUN(__glewPointParameterfEXT)
+#define glPointParameterfvEXT GLEW_GET_FUN(__glewPointParameterfvEXT)
+
+#define GLEW_EXT_point_parameters GLEW_GET_VAR(__GLEW_EXT_point_parameters)
+
+#endif /* GL_EXT_point_parameters */
+
+    /* ------------------------- GL_EXT_polygon_offset ------------------------- */
+
+#ifndef GL_EXT_polygon_offset
+#define GL_EXT_polygon_offset 1
+
+#define GL_POLYGON_OFFSET_EXT 0x8037
+#define GL_POLYGON_OFFSET_FACTOR_EXT 0x8038
+#define GL_POLYGON_OFFSET_BIAS_EXT 0x8039
+
+    typedef void (GLAPIENTRY *PFNGLPOLYGONOFFSETEXTPROC)(GLfloat factor, GLfloat bias);
+
+#define glPolygonOffsetEXT GLEW_GET_FUN(__glewPolygonOffsetEXT)
+
+#define GLEW_EXT_polygon_offset GLEW_GET_VAR(__GLEW_EXT_polygon_offset)
+
+#endif /* GL_EXT_polygon_offset */
+
+    /* ------------------------ GL_EXT_provoking_vertex ------------------------ */
+
+#ifndef GL_EXT_provoking_vertex
+#define GL_EXT_provoking_vertex 1
+
+#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT 0x8E4C
+#define GL_FIRST_VERTEX_CONVENTION_EXT 0x8E4D
+#define GL_LAST_VERTEX_CONVENTION_EXT 0x8E4E
+#define GL_PROVOKING_VERTEX_EXT 0x8E4F
+
+    typedef void (GLAPIENTRY *PFNGLPROVOKINGVERTEXEXTPROC)(GLenum mode);
+
+#define glProvokingVertexEXT GLEW_GET_FUN(__glewProvokingVertexEXT)
+
+#define GLEW_EXT_provoking_vertex GLEW_GET_VAR(__GLEW_EXT_provoking_vertex)
+
+#endif /* GL_EXT_provoking_vertex */
+
+    /* ------------------------- GL_EXT_rescale_normal ------------------------- */
+
+#ifndef GL_EXT_rescale_normal
+#define GL_EXT_rescale_normal 1
+
+#define GL_RESCALE_NORMAL_EXT 0x803A
+
+#define GLEW_EXT_rescale_normal GLEW_GET_VAR(__GLEW_EXT_rescale_normal)
+
+#endif /* GL_EXT_rescale_normal */
+
+    /* -------------------------- GL_EXT_scene_marker -------------------------- */
+
+#ifndef GL_EXT_scene_marker
+#define GL_EXT_scene_marker 1
+
+    typedef void (GLAPIENTRY *PFNGLBEGINSCENEEXTPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLENDSCENEEXTPROC)(void);
+
+#define glBeginSceneEXT GLEW_GET_FUN(__glewBeginSceneEXT)
+#define glEndSceneEXT GLEW_GET_FUN(__glewEndSceneEXT)
+
+#define GLEW_EXT_scene_marker GLEW_GET_VAR(__GLEW_EXT_scene_marker)
+
+#endif /* GL_EXT_scene_marker */
+
+    /* ------------------------- GL_EXT_secondary_color ------------------------ */
+
+#ifndef GL_EXT_secondary_color
+#define GL_EXT_secondary_color 1
+
+#define GL_COLOR_SUM_EXT 0x8458
+#define GL_CURRENT_SECONDARY_COLOR_EXT 0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT 0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT 0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT 0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT 0x845D
+#define GL_SECONDARY_COLOR_ARRAY_EXT 0x845E
+
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3BEXTPROC)(GLbyte red, GLbyte green, GLbyte blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3BVEXTPROC)(const GLbyte *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3DEXTPROC)(GLdouble red, GLdouble green, GLdouble blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3DVEXTPROC)(const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3FEXTPROC)(GLfloat red, GLfloat green, GLfloat blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3FVEXTPROC)(const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3IEXTPROC)(GLint red, GLint green, GLint blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3IVEXTPROC)(const GLint *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3SEXTPROC)(GLshort red, GLshort green, GLshort blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3SVEXTPROC)(const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3UBEXTPROC)(GLubyte red, GLubyte green, GLubyte blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3UBVEXTPROC)(const GLubyte *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3UIEXTPROC)(GLuint red, GLuint green, GLuint blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3UIVEXTPROC)(const GLuint *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3USEXTPROC)(GLushort red, GLushort green, GLushort blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3USVEXTPROC)(const GLushort *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
+
+#define glSecondaryColor3bEXT GLEW_GET_FUN(__glewSecondaryColor3bEXT)
+#define glSecondaryColor3bvEXT GLEW_GET_FUN(__glewSecondaryColor3bvEXT)
+#define glSecondaryColor3dEXT GLEW_GET_FUN(__glewSecondaryColor3dEXT)
+#define glSecondaryColor3dvEXT GLEW_GET_FUN(__glewSecondaryColor3dvEXT)
+#define glSecondaryColor3fEXT GLEW_GET_FUN(__glewSecondaryColor3fEXT)
+#define glSecondaryColor3fvEXT GLEW_GET_FUN(__glewSecondaryColor3fvEXT)
+#define glSecondaryColor3iEXT GLEW_GET_FUN(__glewSecondaryColor3iEXT)
+#define glSecondaryColor3ivEXT GLEW_GET_FUN(__glewSecondaryColor3ivEXT)
+#define glSecondaryColor3sEXT GLEW_GET_FUN(__glewSecondaryColor3sEXT)
+#define glSecondaryColor3svEXT GLEW_GET_FUN(__glewSecondaryColor3svEXT)
+#define glSecondaryColor3ubEXT GLEW_GET_FUN(__glewSecondaryColor3ubEXT)
+#define glSecondaryColor3ubvEXT GLEW_GET_FUN(__glewSecondaryColor3ubvEXT)
+#define glSecondaryColor3uiEXT GLEW_GET_FUN(__glewSecondaryColor3uiEXT)
+#define glSecondaryColor3uivEXT GLEW_GET_FUN(__glewSecondaryColor3uivEXT)
+#define glSecondaryColor3usEXT GLEW_GET_FUN(__glewSecondaryColor3usEXT)
+#define glSecondaryColor3usvEXT GLEW_GET_FUN(__glewSecondaryColor3usvEXT)
+#define glSecondaryColorPointerEXT GLEW_GET_FUN(__glewSecondaryColorPointerEXT)
+
+#define GLEW_EXT_secondary_color GLEW_GET_VAR(__GLEW_EXT_secondary_color)
+
+#endif /* GL_EXT_secondary_color */
+
+    /* --------------------- GL_EXT_separate_shader_objects -------------------- */
+
+#ifndef GL_EXT_separate_shader_objects
+#define GL_EXT_separate_shader_objects 1
+
+#define GL_ACTIVE_PROGRAM_EXT 0x8B8D
+
+    typedef void (GLAPIENTRY *PFNGLACTIVEPROGRAMEXTPROC)(GLuint program);
+    typedef GLuint(GLAPIENTRY *PFNGLCREATESHADERPROGRAMEXTPROC)(GLenum type, const char *string);
+    typedef void (GLAPIENTRY *PFNGLUSESHADERPROGRAMEXTPROC)(GLenum type, GLuint program);
+
+#define glActiveProgramEXT GLEW_GET_FUN(__glewActiveProgramEXT)
+#define glCreateShaderProgramEXT GLEW_GET_FUN(__glewCreateShaderProgramEXT)
+#define glUseShaderProgramEXT GLEW_GET_FUN(__glewUseShaderProgramEXT)
+
+#define GLEW_EXT_separate_shader_objects GLEW_GET_VAR(__GLEW_EXT_separate_shader_objects)
+
+#endif /* GL_EXT_separate_shader_objects */
+
+    /* --------------------- GL_EXT_separate_specular_color -------------------- */
+
+#ifndef GL_EXT_separate_specular_color
+#define GL_EXT_separate_specular_color 1
+
+#define GL_LIGHT_MODEL_COLOR_CONTROL_EXT 0x81F8
+#define GL_SINGLE_COLOR_EXT 0x81F9
+#define GL_SEPARATE_SPECULAR_COLOR_EXT 0x81FA
+
+#define GLEW_EXT_separate_specular_color GLEW_GET_VAR(__GLEW_EXT_separate_specular_color)
+
+#endif /* GL_EXT_separate_specular_color */
+
+    /* --------------------- GL_EXT_shader_image_load_store -------------------- */
+
+#ifndef GL_EXT_shader_image_load_store
+#define GL_EXT_shader_image_load_store 1
+
+#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT 0x00000001
+#define GL_ELEMENT_ARRAY_BARRIER_BIT_EXT 0x00000002
+#define GL_UNIFORM_BARRIER_BIT_EXT 0x00000004
+#define GL_TEXTURE_FETCH_BARRIER_BIT_EXT 0x00000008
+#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT 0x00000020
+#define GL_COMMAND_BARRIER_BIT_EXT 0x00000040
+#define GL_PIXEL_BUFFER_BARRIER_BIT_EXT 0x00000080
+#define GL_TEXTURE_UPDATE_BARRIER_BIT_EXT 0x00000100
+#define GL_BUFFER_UPDATE_BARRIER_BIT_EXT 0x00000200
+#define GL_FRAMEBUFFER_BARRIER_BIT_EXT 0x00000400
+#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT 0x00000800
+#define GL_ATOMIC_COUNTER_BARRIER_BIT_EXT 0x00001000
+#define GL_MAX_IMAGE_UNITS_EXT 0x8F38
+#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT 0x8F39
+#define GL_IMAGE_BINDING_NAME_EXT 0x8F3A
+#define GL_IMAGE_BINDING_LEVEL_EXT 0x8F3B
+#define GL_IMAGE_BINDING_LAYERED_EXT 0x8F3C
+#define GL_IMAGE_BINDING_LAYER_EXT 0x8F3D
+#define GL_IMAGE_BINDING_ACCESS_EXT 0x8F3E
+#define GL_IMAGE_1D_EXT 0x904C
+#define GL_IMAGE_2D_EXT 0x904D
+#define GL_IMAGE_3D_EXT 0x904E
+#define GL_IMAGE_2D_RECT_EXT 0x904F
+#define GL_IMAGE_CUBE_EXT 0x9050
+#define GL_IMAGE_BUFFER_EXT 0x9051
+#define GL_IMAGE_1D_ARRAY_EXT 0x9052
+#define GL_IMAGE_2D_ARRAY_EXT 0x9053
+#define GL_IMAGE_CUBE_MAP_ARRAY_EXT 0x9054
+#define GL_IMAGE_2D_MULTISAMPLE_EXT 0x9055
+#define GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT 0x9056
+#define GL_INT_IMAGE_1D_EXT 0x9057
+#define GL_INT_IMAGE_2D_EXT 0x9058
+#define GL_INT_IMAGE_3D_EXT 0x9059
+#define GL_INT_IMAGE_2D_RECT_EXT 0x905A
+#define GL_INT_IMAGE_CUBE_EXT 0x905B
+#define GL_INT_IMAGE_BUFFER_EXT 0x905C
+#define GL_INT_IMAGE_1D_ARRAY_EXT 0x905D
+#define GL_INT_IMAGE_2D_ARRAY_EXT 0x905E
+#define GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT 0x905F
+#define GL_INT_IMAGE_2D_MULTISAMPLE_EXT 0x9060
+#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT 0x9061
+#define GL_UNSIGNED_INT_IMAGE_1D_EXT 0x9062
+#define GL_UNSIGNED_INT_IMAGE_2D_EXT 0x9063
+#define GL_UNSIGNED_INT_IMAGE_3D_EXT 0x9064
+#define GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT 0x9065
+#define GL_UNSIGNED_INT_IMAGE_CUBE_EXT 0x9066
+#define GL_UNSIGNED_INT_IMAGE_BUFFER_EXT 0x9067
+#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT 0x9068
+#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT 0x9069
+#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT 0x906A
+#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT 0x906B
+#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT 0x906C
+#define GL_MAX_IMAGE_SAMPLES_EXT 0x906D
+#define GL_IMAGE_BINDING_FORMAT_EXT 0x906E
+#define GL_ALL_BARRIER_BITS_EXT 0xFFFFFFFF
+
+    typedef void (GLAPIENTRY *PFNGLBINDIMAGETEXTUREEXTPROC)(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
+    typedef void (GLAPIENTRY *PFNGLMEMORYBARRIEREXTPROC)(GLbitfield barriers);
+
+#define glBindImageTextureEXT GLEW_GET_FUN(__glewBindImageTextureEXT)
+#define glMemoryBarrierEXT GLEW_GET_FUN(__glewMemoryBarrierEXT)
+
+#define GLEW_EXT_shader_image_load_store GLEW_GET_VAR(__GLEW_EXT_shader_image_load_store)
+
+#endif /* GL_EXT_shader_image_load_store */
+
+    /* -------------------------- GL_EXT_shadow_funcs -------------------------- */
+
+#ifndef GL_EXT_shadow_funcs
+#define GL_EXT_shadow_funcs 1
+
+#define GLEW_EXT_shadow_funcs GLEW_GET_VAR(__GLEW_EXT_shadow_funcs)
+
+#endif /* GL_EXT_shadow_funcs */
+
+    /* --------------------- GL_EXT_shared_texture_palette --------------------- */
+
+#ifndef GL_EXT_shared_texture_palette
+#define GL_EXT_shared_texture_palette 1
+
+#define GL_SHARED_TEXTURE_PALETTE_EXT 0x81FB
+
+#define GLEW_EXT_shared_texture_palette GLEW_GET_VAR(__GLEW_EXT_shared_texture_palette)
+
+#endif /* GL_EXT_shared_texture_palette */
+
+    /* ------------------------ GL_EXT_stencil_clear_tag ----------------------- */
+
+#ifndef GL_EXT_stencil_clear_tag
+#define GL_EXT_stencil_clear_tag 1
+
+#define GL_STENCIL_TAG_BITS_EXT 0x88F2
+#define GL_STENCIL_CLEAR_TAG_VALUE_EXT 0x88F3
+
+#define GLEW_EXT_stencil_clear_tag GLEW_GET_VAR(__GLEW_EXT_stencil_clear_tag)
+
+#endif /* GL_EXT_stencil_clear_tag */
+
+    /* ------------------------ GL_EXT_stencil_two_side ------------------------ */
+
+#ifndef GL_EXT_stencil_two_side
+#define GL_EXT_stencil_two_side 1
+
+#define GL_STENCIL_TEST_TWO_SIDE_EXT 0x8910
+#define GL_ACTIVE_STENCIL_FACE_EXT 0x8911
+
+    typedef void (GLAPIENTRY *PFNGLACTIVESTENCILFACEEXTPROC)(GLenum face);
+
+#define glActiveStencilFaceEXT GLEW_GET_FUN(__glewActiveStencilFaceEXT)
+
+#define GLEW_EXT_stencil_two_side GLEW_GET_VAR(__GLEW_EXT_stencil_two_side)
+
+#endif /* GL_EXT_stencil_two_side */
+
+    /* -------------------------- GL_EXT_stencil_wrap -------------------------- */
+
+#ifndef GL_EXT_stencil_wrap
+#define GL_EXT_stencil_wrap 1
+
+#define GL_INCR_WRAP_EXT 0x8507
+#define GL_DECR_WRAP_EXT 0x8508
+
+#define GLEW_EXT_stencil_wrap GLEW_GET_VAR(__GLEW_EXT_stencil_wrap)
+
+#endif /* GL_EXT_stencil_wrap */
+
+    /* --------------------------- GL_EXT_subtexture --------------------------- */
+
+#ifndef GL_EXT_subtexture
+#define GL_EXT_subtexture 1
+
+    typedef void (GLAPIENTRY *PFNGLTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
+
+#define glTexSubImage1DEXT GLEW_GET_FUN(__glewTexSubImage1DEXT)
+#define glTexSubImage2DEXT GLEW_GET_FUN(__glewTexSubImage2DEXT)
+#define glTexSubImage3DEXT GLEW_GET_FUN(__glewTexSubImage3DEXT)
+
+#define GLEW_EXT_subtexture GLEW_GET_VAR(__GLEW_EXT_subtexture)
+
+#endif /* GL_EXT_subtexture */
+
+    /* ----------------------------- GL_EXT_texture ---------------------------- */
+
+#ifndef GL_EXT_texture
+#define GL_EXT_texture 1
+
+#define GL_ALPHA4_EXT 0x803B
+#define GL_ALPHA8_EXT 0x803C
+#define GL_ALPHA12_EXT 0x803D
+#define GL_ALPHA16_EXT 0x803E
+#define GL_LUMINANCE4_EXT 0x803F
+#define GL_LUMINANCE8_EXT 0x8040
+#define GL_LUMINANCE12_EXT 0x8041
+#define GL_LUMINANCE16_EXT 0x8042
+#define GL_LUMINANCE4_ALPHA4_EXT 0x8043
+#define GL_LUMINANCE6_ALPHA2_EXT 0x8044
+#define GL_LUMINANCE8_ALPHA8_EXT 0x8045
+#define GL_LUMINANCE12_ALPHA4_EXT 0x8046
+#define GL_LUMINANCE12_ALPHA12_EXT 0x8047
+#define GL_LUMINANCE16_ALPHA16_EXT 0x8048
+#define GL_INTENSITY_EXT 0x8049
+#define GL_INTENSITY4_EXT 0x804A
+#define GL_INTENSITY8_EXT 0x804B
+#define GL_INTENSITY12_EXT 0x804C
+#define GL_INTENSITY16_EXT 0x804D
+#define GL_RGB2_EXT 0x804E
+#define GL_RGB4_EXT 0x804F
+#define GL_RGB5_EXT 0x8050
+#define GL_RGB8_EXT 0x8051
+#define GL_RGB10_EXT 0x8052
+#define GL_RGB12_EXT 0x8053
+#define GL_RGB16_EXT 0x8054
+#define GL_RGBA2_EXT 0x8055
+#define GL_RGBA4_EXT 0x8056
+#define GL_RGB5_A1_EXT 0x8057
+#define GL_RGBA8_EXT 0x8058
+#define GL_RGB10_A2_EXT 0x8059
+#define GL_RGBA12_EXT 0x805A
+#define GL_RGBA16_EXT 0x805B
+#define GL_TEXTURE_RED_SIZE_EXT 0x805C
+#define GL_TEXTURE_GREEN_SIZE_EXT 0x805D
+#define GL_TEXTURE_BLUE_SIZE_EXT 0x805E
+#define GL_TEXTURE_ALPHA_SIZE_EXT 0x805F
+#define GL_TEXTURE_LUMINANCE_SIZE_EXT 0x8060
+#define GL_TEXTURE_INTENSITY_SIZE_EXT 0x8061
+#define GL_REPLACE_EXT 0x8062
+#define GL_PROXY_TEXTURE_1D_EXT 0x8063
+#define GL_PROXY_TEXTURE_2D_EXT 0x8064
+
+#define GLEW_EXT_texture GLEW_GET_VAR(__GLEW_EXT_texture)
+
+#endif /* GL_EXT_texture */
+
+    /* ---------------------------- GL_EXT_texture3D --------------------------- */
+
+#ifndef GL_EXT_texture3D
+#define GL_EXT_texture3D 1
+
+#define GL_PACK_SKIP_IMAGES_EXT 0x806B
+#define GL_PACK_IMAGE_HEIGHT_EXT 0x806C
+#define GL_UNPACK_SKIP_IMAGES_EXT 0x806D
+#define GL_UNPACK_IMAGE_HEIGHT_EXT 0x806E
+#define GL_TEXTURE_3D_EXT 0x806F
+#define GL_PROXY_TEXTURE_3D_EXT 0x8070
+#define GL_TEXTURE_DEPTH_EXT 0x8071
+#define GL_TEXTURE_WRAP_R_EXT 0x8072
+#define GL_MAX_3D_TEXTURE_SIZE_EXT 0x8073
+
+    typedef void (GLAPIENTRY *PFNGLTEXIMAGE3DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+
+#define glTexImage3DEXT GLEW_GET_FUN(__glewTexImage3DEXT)
+
+#define GLEW_EXT_texture3D GLEW_GET_VAR(__GLEW_EXT_texture3D)
+
+#endif /* GL_EXT_texture3D */
+
+    /* -------------------------- GL_EXT_texture_array ------------------------- */
+
+#ifndef GL_EXT_texture_array
+#define GL_EXT_texture_array 1
+
+#define GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT 0x884E
+#define GL_MAX_ARRAY_TEXTURE_LAYERS_EXT 0x88FF
+#define GL_TEXTURE_1D_ARRAY_EXT 0x8C18
+#define GL_PROXY_TEXTURE_1D_ARRAY_EXT 0x8C19
+#define GL_TEXTURE_2D_ARRAY_EXT 0x8C1A
+#define GL_PROXY_TEXTURE_2D_ARRAY_EXT 0x8C1B
+#define GL_TEXTURE_BINDING_1D_ARRAY_EXT 0x8C1C
+#define GL_TEXTURE_BINDING_2D_ARRAY_EXT 0x8C1D
+
+#define GLEW_EXT_texture_array GLEW_GET_VAR(__GLEW_EXT_texture_array)
+
+#endif /* GL_EXT_texture_array */
+
+    /* ---------------------- GL_EXT_texture_buffer_object --------------------- */
+
+#ifndef GL_EXT_texture_buffer_object
+#define GL_EXT_texture_buffer_object 1
+
+#define GL_TEXTURE_BUFFER_EXT 0x8C2A
+#define GL_MAX_TEXTURE_BUFFER_SIZE_EXT 0x8C2B
+#define GL_TEXTURE_BINDING_BUFFER_EXT 0x8C2C
+#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT 0x8C2D
+#define GL_TEXTURE_BUFFER_FORMAT_EXT 0x8C2E
+
+    typedef void (GLAPIENTRY *PFNGLTEXBUFFEREXTPROC)(GLenum target, GLenum internalformat, GLuint buffer);
+
+#define glTexBufferEXT GLEW_GET_FUN(__glewTexBufferEXT)
+
+#define GLEW_EXT_texture_buffer_object GLEW_GET_VAR(__GLEW_EXT_texture_buffer_object)
+
+#endif /* GL_EXT_texture_buffer_object */
+
+    /* -------------------- GL_EXT_texture_compression_dxt1 -------------------- */
+
+#ifndef GL_EXT_texture_compression_dxt1
+#define GL_EXT_texture_compression_dxt1 1
+
+#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
+#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT 0x83F1
+
+#define GLEW_EXT_texture_compression_dxt1 GLEW_GET_VAR(__GLEW_EXT_texture_compression_dxt1)
+
+#endif /* GL_EXT_texture_compression_dxt1 */
+
+    /* -------------------- GL_EXT_texture_compression_latc -------------------- */
+
+#ifndef GL_EXT_texture_compression_latc
+#define GL_EXT_texture_compression_latc 1
+
+#define GL_COMPRESSED_LUMINANCE_LATC1_EXT 0x8C70
+#define GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT 0x8C71
+#define GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT 0x8C72
+#define GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT 0x8C73
+
+#define GLEW_EXT_texture_compression_latc GLEW_GET_VAR(__GLEW_EXT_texture_compression_latc)
+
+#endif /* GL_EXT_texture_compression_latc */
+
+    /* -------------------- GL_EXT_texture_compression_rgtc -------------------- */
+
+#ifndef GL_EXT_texture_compression_rgtc
+#define GL_EXT_texture_compression_rgtc 1
+
+#define GL_COMPRESSED_RED_RGTC1_EXT 0x8DBB
+#define GL_COMPRESSED_SIGNED_RED_RGTC1_EXT 0x8DBC
+#define GL_COMPRESSED_RED_GREEN_RGTC2_EXT 0x8DBD
+#define GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT 0x8DBE
+
+#define GLEW_EXT_texture_compression_rgtc GLEW_GET_VAR(__GLEW_EXT_texture_compression_rgtc)
+
+#endif /* GL_EXT_texture_compression_rgtc */
+
+    /* -------------------- GL_EXT_texture_compression_s3tc -------------------- */
+
+#ifndef GL_EXT_texture_compression_s3tc
+#define GL_EXT_texture_compression_s3tc 1
+
+#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
+#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT 0x83F1
+#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT 0x83F2
+#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT 0x83F3
+
+#define GLEW_EXT_texture_compression_s3tc GLEW_GET_VAR(__GLEW_EXT_texture_compression_s3tc)
+
+#endif /* GL_EXT_texture_compression_s3tc */
+
+    /* ------------------------ GL_EXT_texture_cube_map ------------------------ */
+
+#ifndef GL_EXT_texture_cube_map
+#define GL_EXT_texture_cube_map 1
+
+#define GL_NORMAL_MAP_EXT 0x8511
+#define GL_REFLECTION_MAP_EXT 0x8512
+#define GL_TEXTURE_CUBE_MAP_EXT 0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_EXT 0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP_EXT 0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT 0x851C
+
+#define GLEW_EXT_texture_cube_map GLEW_GET_VAR(__GLEW_EXT_texture_cube_map)
+
+#endif /* GL_EXT_texture_cube_map */
+
+    /* ----------------------- GL_EXT_texture_edge_clamp ----------------------- */
+
+#ifndef GL_EXT_texture_edge_clamp
+#define GL_EXT_texture_edge_clamp 1
+
+#define GL_CLAMP_TO_EDGE_EXT 0x812F
+
+#define GLEW_EXT_texture_edge_clamp GLEW_GET_VAR(__GLEW_EXT_texture_edge_clamp)
+
+#endif /* GL_EXT_texture_edge_clamp */
+
+    /* --------------------------- GL_EXT_texture_env -------------------------- */
+
+#ifndef GL_EXT_texture_env
+#define GL_EXT_texture_env 1
+
+#define GL_TEXTURE_ENV0_EXT 0
+#define GL_ENV_BLEND_EXT 0
+#define GL_TEXTURE_ENV_SHIFT_EXT 0
+#define GL_ENV_REPLACE_EXT 0
+#define GL_ENV_ADD_EXT 0
+#define GL_ENV_SUBTRACT_EXT 0
+#define GL_TEXTURE_ENV_MODE_ALPHA_EXT 0
+#define GL_ENV_REVERSE_SUBTRACT_EXT 0
+#define GL_ENV_REVERSE_BLEND_EXT 0
+#define GL_ENV_COPY_EXT 0
+#define GL_ENV_MODULATE_EXT 0
+
+#define GLEW_EXT_texture_env GLEW_GET_VAR(__GLEW_EXT_texture_env)
+
+#endif /* GL_EXT_texture_env */
+
+    /* ------------------------- GL_EXT_texture_env_add ------------------------ */
+
+#ifndef GL_EXT_texture_env_add
+#define GL_EXT_texture_env_add 1
+
+#define GLEW_EXT_texture_env_add GLEW_GET_VAR(__GLEW_EXT_texture_env_add)
+
+#endif /* GL_EXT_texture_env_add */
+
+    /* ----------------------- GL_EXT_texture_env_combine ---------------------- */
+
+#ifndef GL_EXT_texture_env_combine
+#define GL_EXT_texture_env_combine 1
+
+#define GL_COMBINE_EXT 0x8570
+#define GL_COMBINE_RGB_EXT 0x8571
+#define GL_COMBINE_ALPHA_EXT 0x8572
+#define GL_RGB_SCALE_EXT 0x8573
+#define GL_ADD_SIGNED_EXT 0x8574
+#define GL_INTERPOLATE_EXT 0x8575
+#define GL_CONSTANT_EXT 0x8576
+#define GL_PRIMARY_COLOR_EXT 0x8577
+#define GL_PREVIOUS_EXT 0x8578
+#define GL_SOURCE0_RGB_EXT 0x8580
+#define GL_SOURCE1_RGB_EXT 0x8581
+#define GL_SOURCE2_RGB_EXT 0x8582
+#define GL_SOURCE0_ALPHA_EXT 0x8588
+#define GL_SOURCE1_ALPHA_EXT 0x8589
+#define GL_SOURCE2_ALPHA_EXT 0x858A
+#define GL_OPERAND0_RGB_EXT 0x8590
+#define GL_OPERAND1_RGB_EXT 0x8591
+#define GL_OPERAND2_RGB_EXT 0x8592
+#define GL_OPERAND0_ALPHA_EXT 0x8598
+#define GL_OPERAND1_ALPHA_EXT 0x8599
+#define GL_OPERAND2_ALPHA_EXT 0x859A
+
+#define GLEW_EXT_texture_env_combine GLEW_GET_VAR(__GLEW_EXT_texture_env_combine)
+
+#endif /* GL_EXT_texture_env_combine */
+
+    /* ------------------------ GL_EXT_texture_env_dot3 ------------------------ */
+
+#ifndef GL_EXT_texture_env_dot3
+#define GL_EXT_texture_env_dot3 1
+
+#define GL_DOT3_RGB_EXT 0x8740
+#define GL_DOT3_RGBA_EXT 0x8741
+
+#define GLEW_EXT_texture_env_dot3 GLEW_GET_VAR(__GLEW_EXT_texture_env_dot3)
+
+#endif /* GL_EXT_texture_env_dot3 */
+
+    /* ------------------- GL_EXT_texture_filter_anisotropic ------------------- */
+
+#ifndef GL_EXT_texture_filter_anisotropic
+#define GL_EXT_texture_filter_anisotropic 1
+
+#define GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE
+#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
+
+#define GLEW_EXT_texture_filter_anisotropic GLEW_GET_VAR(__GLEW_EXT_texture_filter_anisotropic)
+
+#endif /* GL_EXT_texture_filter_anisotropic */
+
+    /* ------------------------- GL_EXT_texture_integer ------------------------ */
+
+#ifndef GL_EXT_texture_integer
+#define GL_EXT_texture_integer 1
+
+#define GL_RGBA32UI_EXT 0x8D70
+#define GL_RGB32UI_EXT 0x8D71
+#define GL_ALPHA32UI_EXT 0x8D72
+#define GL_INTENSITY32UI_EXT 0x8D73
+#define GL_LUMINANCE32UI_EXT 0x8D74
+#define GL_LUMINANCE_ALPHA32UI_EXT 0x8D75
+#define GL_RGBA16UI_EXT 0x8D76
+#define GL_RGB16UI_EXT 0x8D77
+#define GL_ALPHA16UI_EXT 0x8D78
+#define GL_INTENSITY16UI_EXT 0x8D79
+#define GL_LUMINANCE16UI_EXT 0x8D7A
+#define GL_LUMINANCE_ALPHA16UI_EXT 0x8D7B
+#define GL_RGBA8UI_EXT 0x8D7C
+#define GL_RGB8UI_EXT 0x8D7D
+#define GL_ALPHA8UI_EXT 0x8D7E
+#define GL_INTENSITY8UI_EXT 0x8D7F
+#define GL_LUMINANCE8UI_EXT 0x8D80
+#define GL_LUMINANCE_ALPHA8UI_EXT 0x8D81
+#define GL_RGBA32I_EXT 0x8D82
+#define GL_RGB32I_EXT 0x8D83
+#define GL_ALPHA32I_EXT 0x8D84
+#define GL_INTENSITY32I_EXT 0x8D85
+#define GL_LUMINANCE32I_EXT 0x8D86
+#define GL_LUMINANCE_ALPHA32I_EXT 0x8D87
+#define GL_RGBA16I_EXT 0x8D88
+#define GL_RGB16I_EXT 0x8D89
+#define GL_ALPHA16I_EXT 0x8D8A
+#define GL_INTENSITY16I_EXT 0x8D8B
+#define GL_LUMINANCE16I_EXT 0x8D8C
+#define GL_LUMINANCE_ALPHA16I_EXT 0x8D8D
+#define GL_RGBA8I_EXT 0x8D8E
+#define GL_RGB8I_EXT 0x8D8F
+#define GL_ALPHA8I_EXT 0x8D90
+#define GL_INTENSITY8I_EXT 0x8D91
+#define GL_LUMINANCE8I_EXT 0x8D92
+#define GL_LUMINANCE_ALPHA8I_EXT 0x8D93
+#define GL_RED_INTEGER_EXT 0x8D94
+#define GL_GREEN_INTEGER_EXT 0x8D95
+#define GL_BLUE_INTEGER_EXT 0x8D96
+#define GL_ALPHA_INTEGER_EXT 0x8D97
+#define GL_RGB_INTEGER_EXT 0x8D98
+#define GL_RGBA_INTEGER_EXT 0x8D99
+#define GL_BGR_INTEGER_EXT 0x8D9A
+#define GL_BGRA_INTEGER_EXT 0x8D9B
+#define GL_LUMINANCE_INTEGER_EXT 0x8D9C
+#define GL_LUMINANCE_ALPHA_INTEGER_EXT 0x8D9D
+#define GL_RGBA_INTEGER_MODE_EXT 0x8D9E
+
+    typedef void (GLAPIENTRY *PFNGLCLEARCOLORIIEXTPROC)(GLint red, GLint green, GLint blue, GLint alpha);
+    typedef void (GLAPIENTRY *PFNGLCLEARCOLORIUIEXTPROC)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
+    typedef void (GLAPIENTRY *PFNGLGETTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, const GLuint *params);
+
+#define glClearColorIiEXT GLEW_GET_FUN(__glewClearColorIiEXT)
+#define glClearColorIuiEXT GLEW_GET_FUN(__glewClearColorIuiEXT)
+#define glGetTexParameterIivEXT GLEW_GET_FUN(__glewGetTexParameterIivEXT)
+#define glGetTexParameterIuivEXT GLEW_GET_FUN(__glewGetTexParameterIuivEXT)
+#define glTexParameterIivEXT GLEW_GET_FUN(__glewTexParameterIivEXT)
+#define glTexParameterIuivEXT GLEW_GET_FUN(__glewTexParameterIuivEXT)
+
+#define GLEW_EXT_texture_integer GLEW_GET_VAR(__GLEW_EXT_texture_integer)
+
+#endif /* GL_EXT_texture_integer */
+
+    /* ------------------------ GL_EXT_texture_lod_bias ------------------------ */
+
+#ifndef GL_EXT_texture_lod_bias
+#define GL_EXT_texture_lod_bias 1
+
+#define GL_MAX_TEXTURE_LOD_BIAS_EXT 0x84FD
+#define GL_TEXTURE_FILTER_CONTROL_EXT 0x8500
+#define GL_TEXTURE_LOD_BIAS_EXT 0x8501
+
+#define GLEW_EXT_texture_lod_bias GLEW_GET_VAR(__GLEW_EXT_texture_lod_bias)
+
+#endif /* GL_EXT_texture_lod_bias */
+
+    /* ---------------------- GL_EXT_texture_mirror_clamp ---------------------- */
+
+#ifndef GL_EXT_texture_mirror_clamp
+#define GL_EXT_texture_mirror_clamp 1
+
+#define GL_MIRROR_CLAMP_EXT 0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_EXT 0x8743
+#define GL_MIRROR_CLAMP_TO_BORDER_EXT 0x8912
+
+#define GLEW_EXT_texture_mirror_clamp GLEW_GET_VAR(__GLEW_EXT_texture_mirror_clamp)
+
+#endif /* GL_EXT_texture_mirror_clamp */
+
+    /* ------------------------- GL_EXT_texture_object ------------------------- */
+
+#ifndef GL_EXT_texture_object
+#define GL_EXT_texture_object 1
+
+#define GL_TEXTURE_PRIORITY_EXT 0x8066
+#define GL_TEXTURE_RESIDENT_EXT 0x8067
+#define GL_TEXTURE_1D_BINDING_EXT 0x8068
+#define GL_TEXTURE_2D_BINDING_EXT 0x8069
+#define GL_TEXTURE_3D_BINDING_EXT 0x806A
+
+    typedef GLboolean(GLAPIENTRY *PFNGLARETEXTURESRESIDENTEXTPROC)(GLsizei n, const GLuint *textures, GLboolean *residences);
+    typedef void (GLAPIENTRY *PFNGLBINDTEXTUREEXTPROC)(GLenum target, GLuint texture);
+    typedef void (GLAPIENTRY *PFNGLDELETETEXTURESEXTPROC)(GLsizei n, const GLuint *textures);
+    typedef void (GLAPIENTRY *PFNGLGENTEXTURESEXTPROC)(GLsizei n, GLuint *textures);
+    typedef GLboolean(GLAPIENTRY *PFNGLISTEXTUREEXTPROC)(GLuint texture);
+    typedef void (GLAPIENTRY *PFNGLPRIORITIZETEXTURESEXTPROC)(GLsizei n, const GLuint *textures, const GLclampf *priorities);
+
+#define glAreTexturesResidentEXT GLEW_GET_FUN(__glewAreTexturesResidentEXT)
+#define glBindTextureEXT GLEW_GET_FUN(__glewBindTextureEXT)
+#define glDeleteTexturesEXT GLEW_GET_FUN(__glewDeleteTexturesEXT)
+#define glGenTexturesEXT GLEW_GET_FUN(__glewGenTexturesEXT)
+#define glIsTextureEXT GLEW_GET_FUN(__glewIsTextureEXT)
+#define glPrioritizeTexturesEXT GLEW_GET_FUN(__glewPrioritizeTexturesEXT)
+
+#define GLEW_EXT_texture_object GLEW_GET_VAR(__GLEW_EXT_texture_object)
+
+#endif /* GL_EXT_texture_object */
+
+    /* --------------------- GL_EXT_texture_perturb_normal --------------------- */
+
+#ifndef GL_EXT_texture_perturb_normal
+#define GL_EXT_texture_perturb_normal 1
+
+#define GL_PERTURB_EXT 0x85AE
+#define GL_TEXTURE_NORMAL_EXT 0x85AF
+
+    typedef void (GLAPIENTRY *PFNGLTEXTURENORMALEXTPROC)(GLenum mode);
+
+#define glTextureNormalEXT GLEW_GET_FUN(__glewTextureNormalEXT)
+
+#define GLEW_EXT_texture_perturb_normal GLEW_GET_VAR(__GLEW_EXT_texture_perturb_normal)
+
+#endif /* GL_EXT_texture_perturb_normal */
+
+    /* ------------------------ GL_EXT_texture_rectangle ----------------------- */
+
+#ifndef GL_EXT_texture_rectangle
+#define GL_EXT_texture_rectangle 1
+
+#define GL_TEXTURE_RECTANGLE_EXT 0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE_EXT 0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE_EXT 0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT 0x84F8
+
+#define GLEW_EXT_texture_rectangle GLEW_GET_VAR(__GLEW_EXT_texture_rectangle)
+
+#endif /* GL_EXT_texture_rectangle */
+
+    /* -------------------------- GL_EXT_texture_sRGB -------------------------- */
+
+#ifndef GL_EXT_texture_sRGB
+#define GL_EXT_texture_sRGB 1
+
+#define GL_SRGB_EXT 0x8C40
+#define GL_SRGB8_EXT 0x8C41
+#define GL_SRGB_ALPHA_EXT 0x8C42
+#define GL_SRGB8_ALPHA8_EXT 0x8C43
+#define GL_SLUMINANCE_ALPHA_EXT 0x8C44
+#define GL_SLUMINANCE8_ALPHA8_EXT 0x8C45
+#define GL_SLUMINANCE_EXT 0x8C46
+#define GL_SLUMINANCE8_EXT 0x8C47
+#define GL_COMPRESSED_SRGB_EXT 0x8C48
+#define GL_COMPRESSED_SRGB_ALPHA_EXT 0x8C49
+#define GL_COMPRESSED_SLUMINANCE_EXT 0x8C4A
+#define GL_COMPRESSED_SLUMINANCE_ALPHA_EXT 0x8C4B
+#define GL_COMPRESSED_SRGB_S3TC_DXT1_EXT 0x8C4C
+#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT 0x8C4D
+#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT 0x8C4E
+#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT 0x8C4F
+
+#define GLEW_EXT_texture_sRGB GLEW_GET_VAR(__GLEW_EXT_texture_sRGB)
+
+#endif /* GL_EXT_texture_sRGB */
+
+    /* --------------------- GL_EXT_texture_shared_exponent -------------------- */
+
+#ifndef GL_EXT_texture_shared_exponent
+#define GL_EXT_texture_shared_exponent 1
+
+#define GL_RGB9_E5_EXT 0x8C3D
+#define GL_UNSIGNED_INT_5_9_9_9_REV_EXT 0x8C3E
+#define GL_TEXTURE_SHARED_SIZE_EXT 0x8C3F
+
+#define GLEW_EXT_texture_shared_exponent GLEW_GET_VAR(__GLEW_EXT_texture_shared_exponent)
+
+#endif /* GL_EXT_texture_shared_exponent */
+
+    /* -------------------------- GL_EXT_texture_snorm ------------------------- */
+
+#ifndef GL_EXT_texture_snorm
+#define GL_EXT_texture_snorm 1
+
+#define GL_RED_SNORM 0x8F90
+#define GL_RG_SNORM 0x8F91
+#define GL_RGB_SNORM 0x8F92
+#define GL_RGBA_SNORM 0x8F93
+#define GL_R8_SNORM 0x8F94
+#define GL_RG8_SNORM 0x8F95
+#define GL_RGB8_SNORM 0x8F96
+#define GL_RGBA8_SNORM 0x8F97
+#define GL_R16_SNORM 0x8F98
+#define GL_RG16_SNORM 0x8F99
+#define GL_RGB16_SNORM 0x8F9A
+#define GL_RGBA16_SNORM 0x8F9B
+#define GL_SIGNED_NORMALIZED 0x8F9C
+#define GL_ALPHA_SNORM 0x9010
+#define GL_LUMINANCE_SNORM 0x9011
+#define GL_LUMINANCE_ALPHA_SNORM 0x9012
+#define GL_INTENSITY_SNORM 0x9013
+#define GL_ALPHA8_SNORM 0x9014
+#define GL_LUMINANCE8_SNORM 0x9015
+#define GL_LUMINANCE8_ALPHA8_SNORM 0x9016
+#define GL_INTENSITY8_SNORM 0x9017
+#define GL_ALPHA16_SNORM 0x9018
+#define GL_LUMINANCE16_SNORM 0x9019
+#define GL_LUMINANCE16_ALPHA16_SNORM 0x901A
+#define GL_INTENSITY16_SNORM 0x901B
+
+#define GLEW_EXT_texture_snorm GLEW_GET_VAR(__GLEW_EXT_texture_snorm)
+
+#endif /* GL_EXT_texture_snorm */
+
+    /* ------------------------- GL_EXT_texture_swizzle ------------------------ */
+
+#ifndef GL_EXT_texture_swizzle
+#define GL_EXT_texture_swizzle 1
+
+#define GL_TEXTURE_SWIZZLE_R_EXT 0x8E42
+#define GL_TEXTURE_SWIZZLE_G_EXT 0x8E43
+#define GL_TEXTURE_SWIZZLE_B_EXT 0x8E44
+#define GL_TEXTURE_SWIZZLE_A_EXT 0x8E45
+#define GL_TEXTURE_SWIZZLE_RGBA_EXT 0x8E46
+
+#define GLEW_EXT_texture_swizzle GLEW_GET_VAR(__GLEW_EXT_texture_swizzle)
+
+#endif /* GL_EXT_texture_swizzle */
+
+    /* --------------------------- GL_EXT_timer_query -------------------------- */
+
+#ifndef GL_EXT_timer_query
+#define GL_EXT_timer_query 1
+
+#define GL_TIME_ELAPSED_EXT 0x88BF
+
+    typedef void (GLAPIENTRY *PFNGLGETQUERYOBJECTI64VEXTPROC)(GLuint id, GLenum pname, GLint64EXT *params);
+    typedef void (GLAPIENTRY *PFNGLGETQUERYOBJECTUI64VEXTPROC)(GLuint id, GLenum pname, GLuint64EXT *params);
+
+#define glGetQueryObjecti64vEXT GLEW_GET_FUN(__glewGetQueryObjecti64vEXT)
+#define glGetQueryObjectui64vEXT GLEW_GET_FUN(__glewGetQueryObjectui64vEXT)
+
+#define GLEW_EXT_timer_query GLEW_GET_VAR(__GLEW_EXT_timer_query)
+
+#endif /* GL_EXT_timer_query */
+
+    /* ----------------------- GL_EXT_transform_feedback ----------------------- */
+
+#ifndef GL_EXT_transform_feedback
+#define GL_EXT_transform_feedback 1
+
+#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT 0x8C76
+#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT 0x8C7F
+#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT 0x8C80
+#define GL_TRANSFORM_FEEDBACK_VARYINGS_EXT 0x8C83
+#define GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT 0x8C84
+#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT 0x8C85
+#define GL_PRIMITIVES_GENERATED_EXT 0x8C87
+#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT 0x8C88
+#define GL_RASTERIZER_DISCARD_EXT 0x8C89
+#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT 0x8C8A
+#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT 0x8C8B
+#define GL_INTERLEAVED_ATTRIBS_EXT 0x8C8C
+#define GL_SEPARATE_ATTRIBS_EXT 0x8C8D
+#define GL_TRANSFORM_FEEDBACK_BUFFER_EXT 0x8C8E
+#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT 0x8C8F
+
+    typedef void (GLAPIENTRY *PFNGLBEGINTRANSFORMFEEDBACKEXTPROC)(GLenum primitiveMode);
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFERBASEEXTPROC)(GLenum target, GLuint index, GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFEROFFSETEXTPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFERRANGEEXTPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
+    typedef void (GLAPIENTRY *PFNGLENDTRANSFORMFEEDBACKEXTPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, char *name);
+    typedef void (GLAPIENTRY *PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC)(GLuint program, GLsizei count, const char **varyings, GLenum bufferMode);
+
+#define glBeginTransformFeedbackEXT GLEW_GET_FUN(__glewBeginTransformFeedbackEXT)
+#define glBindBufferBaseEXT GLEW_GET_FUN(__glewBindBufferBaseEXT)
+#define glBindBufferOffsetEXT GLEW_GET_FUN(__glewBindBufferOffsetEXT)
+#define glBindBufferRangeEXT GLEW_GET_FUN(__glewBindBufferRangeEXT)
+#define glEndTransformFeedbackEXT GLEW_GET_FUN(__glewEndTransformFeedbackEXT)
+#define glGetTransformFeedbackVaryingEXT GLEW_GET_FUN(__glewGetTransformFeedbackVaryingEXT)
+#define glTransformFeedbackVaryingsEXT GLEW_GET_FUN(__glewTransformFeedbackVaryingsEXT)
+
+#define GLEW_EXT_transform_feedback GLEW_GET_VAR(__GLEW_EXT_transform_feedback)
+
+#endif /* GL_EXT_transform_feedback */
+
+    /* -------------------------- GL_EXT_vertex_array -------------------------- */
+
+#ifndef GL_EXT_vertex_array
+#define GL_EXT_vertex_array 1
+
+#define GL_DOUBLE_EXT 0x140A
+#define GL_VERTEX_ARRAY_EXT 0x8074
+#define GL_NORMAL_ARRAY_EXT 0x8075
+#define GL_COLOR_ARRAY_EXT 0x8076
+#define GL_INDEX_ARRAY_EXT 0x8077
+#define GL_TEXTURE_COORD_ARRAY_EXT 0x8078
+#define GL_EDGE_FLAG_ARRAY_EXT 0x8079
+#define GL_VERTEX_ARRAY_SIZE_EXT 0x807A
+#define GL_VERTEX_ARRAY_TYPE_EXT 0x807B
+#define GL_VERTEX_ARRAY_STRIDE_EXT 0x807C
+#define GL_VERTEX_ARRAY_COUNT_EXT 0x807D
+#define GL_NORMAL_ARRAY_TYPE_EXT 0x807E
+#define GL_NORMAL_ARRAY_STRIDE_EXT 0x807F
+#define GL_NORMAL_ARRAY_COUNT_EXT 0x8080
+#define GL_COLOR_ARRAY_SIZE_EXT 0x8081
+#define GL_COLOR_ARRAY_TYPE_EXT 0x8082
+#define GL_COLOR_ARRAY_STRIDE_EXT 0x8083
+#define GL_COLOR_ARRAY_COUNT_EXT 0x8084
+#define GL_INDEX_ARRAY_TYPE_EXT 0x8085
+#define GL_INDEX_ARRAY_STRIDE_EXT 0x8086
+#define GL_INDEX_ARRAY_COUNT_EXT 0x8087
+#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT 0x8088
+#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT 0x8089
+#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
+#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT 0x808B
+#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT 0x808C
+#define GL_EDGE_FLAG_ARRAY_COUNT_EXT 0x808D
+#define GL_VERTEX_ARRAY_POINTER_EXT 0x808E
+#define GL_NORMAL_ARRAY_POINTER_EXT 0x808F
+#define GL_COLOR_ARRAY_POINTER_EXT 0x8090
+#define GL_INDEX_ARRAY_POINTER_EXT 0x8091
+#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
+#define GL_EDGE_FLAG_ARRAY_POINTER_EXT 0x8093
+
+    typedef void (GLAPIENTRY *PFNGLARRAYELEMENTEXTPROC)(GLint i);
+    typedef void (GLAPIENTRY *PFNGLCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+    typedef void (GLAPIENTRY *PFNGLDRAWARRAYSEXTPROC)(GLenum mode, GLint first, GLsizei count);
+    typedef void (GLAPIENTRY *PFNGLEDGEFLAGPOINTEREXTPROC)(GLsizei stride, GLsizei count, const GLboolean *pointer);
+    typedef void (GLAPIENTRY *PFNGLGETPOINTERVEXTPROC)(GLenum pname, void **params);
+    typedef void (GLAPIENTRY *PFNGLINDEXPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+    typedef void (GLAPIENTRY *PFNGLNORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+    typedef void (GLAPIENTRY *PFNGLVERTEXPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+
+#define glArrayElementEXT GLEW_GET_FUN(__glewArrayElementEXT)
+#define glColorPointerEXT GLEW_GET_FUN(__glewColorPointerEXT)
+#define glDrawArraysEXT GLEW_GET_FUN(__glewDrawArraysEXT)
+#define glEdgeFlagPointerEXT GLEW_GET_FUN(__glewEdgeFlagPointerEXT)
+#define glGetPointervEXT GLEW_GET_FUN(__glewGetPointervEXT)
+#define glIndexPointerEXT GLEW_GET_FUN(__glewIndexPointerEXT)
+#define glNormalPointerEXT GLEW_GET_FUN(__glewNormalPointerEXT)
+#define glTexCoordPointerEXT GLEW_GET_FUN(__glewTexCoordPointerEXT)
+#define glVertexPointerEXT GLEW_GET_FUN(__glewVertexPointerEXT)
+
+#define GLEW_EXT_vertex_array GLEW_GET_VAR(__GLEW_EXT_vertex_array)
+
+#endif /* GL_EXT_vertex_array */
+
+    /* ------------------------ GL_EXT_vertex_array_bgra ----------------------- */
+
+#ifndef GL_EXT_vertex_array_bgra
+#define GL_EXT_vertex_array_bgra 1
+
+#define GL_BGRA 0x80E1
+
+#define GLEW_EXT_vertex_array_bgra GLEW_GET_VAR(__GLEW_EXT_vertex_array_bgra)
+
+#endif /* GL_EXT_vertex_array_bgra */
+
+    /* ----------------------- GL_EXT_vertex_attrib_64bit ---------------------- */
+
+#ifndef GL_EXT_vertex_attrib_64bit
+#define GL_EXT_vertex_attrib_64bit 1
+
+#define GL_DOUBLE_MAT2_EXT 0x8F46
+#define GL_DOUBLE_MAT3_EXT 0x8F47
+#define GL_DOUBLE_MAT4_EXT 0x8F48
+#define GL_DOUBLE_VEC2_EXT 0x8FFC
+#define GL_DOUBLE_VEC3_EXT 0x8FFD
+#define GL_DOUBLE_VEC4_EXT 0x8FFE
+
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBLDVEXTPROC)(GLuint index, GLenum pname, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL1DEXTPROC)(GLuint index, GLdouble x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL1DVEXTPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL2DEXTPROC)(GLuint index, GLdouble x, GLdouble y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL2DVEXTPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL3DEXTPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL3DVEXTPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL4DEXTPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL4DVEXTPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBLPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
+
+#define glGetVertexAttribLdvEXT GLEW_GET_FUN(__glewGetVertexAttribLdvEXT)
+#define glVertexArrayVertexAttribLOffsetEXT GLEW_GET_FUN(__glewVertexArrayVertexAttribLOffsetEXT)
+#define glVertexAttribL1dEXT GLEW_GET_FUN(__glewVertexAttribL1dEXT)
+#define glVertexAttribL1dvEXT GLEW_GET_FUN(__glewVertexAttribL1dvEXT)
+#define glVertexAttribL2dEXT GLEW_GET_FUN(__glewVertexAttribL2dEXT)
+#define glVertexAttribL2dvEXT GLEW_GET_FUN(__glewVertexAttribL2dvEXT)
+#define glVertexAttribL3dEXT GLEW_GET_FUN(__glewVertexAttribL3dEXT)
+#define glVertexAttribL3dvEXT GLEW_GET_FUN(__glewVertexAttribL3dvEXT)
+#define glVertexAttribL4dEXT GLEW_GET_FUN(__glewVertexAttribL4dEXT)
+#define glVertexAttribL4dvEXT GLEW_GET_FUN(__glewVertexAttribL4dvEXT)
+#define glVertexAttribLPointerEXT GLEW_GET_FUN(__glewVertexAttribLPointerEXT)
+
+#define GLEW_EXT_vertex_attrib_64bit GLEW_GET_VAR(__GLEW_EXT_vertex_attrib_64bit)
+
+#endif /* GL_EXT_vertex_attrib_64bit */
+
+    /* -------------------------- GL_EXT_vertex_shader ------------------------- */
+
+#ifndef GL_EXT_vertex_shader
+#define GL_EXT_vertex_shader 1
+
+#define GL_VERTEX_SHADER_EXT 0x8780
+#define GL_VERTEX_SHADER_BINDING_EXT 0x8781
+#define GL_OP_INDEX_EXT 0x8782
+#define GL_OP_NEGATE_EXT 0x8783
+#define GL_OP_DOT3_EXT 0x8784
+#define GL_OP_DOT4_EXT 0x8785
+#define GL_OP_MUL_EXT 0x8786
+#define GL_OP_ADD_EXT 0x8787
+#define GL_OP_MADD_EXT 0x8788
+#define GL_OP_FRAC_EXT 0x8789
+#define GL_OP_MAX_EXT 0x878A
+#define GL_OP_MIN_EXT 0x878B
+#define GL_OP_SET_GE_EXT 0x878C
+#define GL_OP_SET_LT_EXT 0x878D
+#define GL_OP_CLAMP_EXT 0x878E
+#define GL_OP_FLOOR_EXT 0x878F
+#define GL_OP_ROUND_EXT 0x8790
+#define GL_OP_EXP_BASE_2_EXT 0x8791
+#define GL_OP_LOG_BASE_2_EXT 0x8792
+#define GL_OP_POWER_EXT 0x8793
+#define GL_OP_RECIP_EXT 0x8794
+#define GL_OP_RECIP_SQRT_EXT 0x8795
+#define GL_OP_SUB_EXT 0x8796
+#define GL_OP_CROSS_PRODUCT_EXT 0x8797
+#define GL_OP_MULTIPLY_MATRIX_EXT 0x8798
+#define GL_OP_MOV_EXT 0x8799
+#define GL_OUTPUT_VERTEX_EXT 0x879A
+#define GL_OUTPUT_COLOR0_EXT 0x879B
+#define GL_OUTPUT_COLOR1_EXT 0x879C
+#define GL_OUTPUT_TEXTURE_COORD0_EXT 0x879D
+#define GL_OUTPUT_TEXTURE_COORD1_EXT 0x879E
+#define GL_OUTPUT_TEXTURE_COORD2_EXT 0x879F
+#define GL_OUTPUT_TEXTURE_COORD3_EXT 0x87A0
+#define GL_OUTPUT_TEXTURE_COORD4_EXT 0x87A1
+#define GL_OUTPUT_TEXTURE_COORD5_EXT 0x87A2
+#define GL_OUTPUT_TEXTURE_COORD6_EXT 0x87A3
+#define GL_OUTPUT_TEXTURE_COORD7_EXT 0x87A4
+#define GL_OUTPUT_TEXTURE_COORD8_EXT 0x87A5
+#define GL_OUTPUT_TEXTURE_COORD9_EXT 0x87A6
+#define GL_OUTPUT_TEXTURE_COORD10_EXT 0x87A7
+#define GL_OUTPUT_TEXTURE_COORD11_EXT 0x87A8
+#define GL_OUTPUT_TEXTURE_COORD12_EXT 0x87A9
+#define GL_OUTPUT_TEXTURE_COORD13_EXT 0x87AA
+#define GL_OUTPUT_TEXTURE_COORD14_EXT 0x87AB
+#define GL_OUTPUT_TEXTURE_COORD15_EXT 0x87AC
+#define GL_OUTPUT_TEXTURE_COORD16_EXT 0x87AD
+#define GL_OUTPUT_TEXTURE_COORD17_EXT 0x87AE
+#define GL_OUTPUT_TEXTURE_COORD18_EXT 0x87AF
+#define GL_OUTPUT_TEXTURE_COORD19_EXT 0x87B0
+#define GL_OUTPUT_TEXTURE_COORD20_EXT 0x87B1
+#define GL_OUTPUT_TEXTURE_COORD21_EXT 0x87B2
+#define GL_OUTPUT_TEXTURE_COORD22_EXT 0x87B3
+#define GL_OUTPUT_TEXTURE_COORD23_EXT 0x87B4
+#define GL_OUTPUT_TEXTURE_COORD24_EXT 0x87B5
+#define GL_OUTPUT_TEXTURE_COORD25_EXT 0x87B6
+#define GL_OUTPUT_TEXTURE_COORD26_EXT 0x87B7
+#define GL_OUTPUT_TEXTURE_COORD27_EXT 0x87B8
+#define GL_OUTPUT_TEXTURE_COORD28_EXT 0x87B9
+#define GL_OUTPUT_TEXTURE_COORD29_EXT 0x87BA
+#define GL_OUTPUT_TEXTURE_COORD30_EXT 0x87BB
+#define GL_OUTPUT_TEXTURE_COORD31_EXT 0x87BC
+#define GL_OUTPUT_FOG_EXT 0x87BD
+#define GL_SCALAR_EXT 0x87BE
+#define GL_VECTOR_EXT 0x87BF
+#define GL_MATRIX_EXT 0x87C0
+#define GL_VARIANT_EXT 0x87C1
+#define GL_INVARIANT_EXT 0x87C2
+#define GL_LOCAL_CONSTANT_EXT 0x87C3
+#define GL_LOCAL_EXT 0x87C4
+#define GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87C5
+#define GL_MAX_VERTEX_SHADER_VARIANTS_EXT 0x87C6
+#define GL_MAX_VERTEX_SHADER_INVARIANTS_EXT 0x87C7
+#define GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87C8
+#define GL_MAX_VERTEX_SHADER_LOCALS_EXT 0x87C9
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CA
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT 0x87CB
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT 0x87CC
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87CD
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT 0x87CE
+#define GL_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CF
+#define GL_VERTEX_SHADER_VARIANTS_EXT 0x87D0
+#define GL_VERTEX_SHADER_INVARIANTS_EXT 0x87D1
+#define GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87D2
+#define GL_VERTEX_SHADER_LOCALS_EXT 0x87D3
+#define GL_VERTEX_SHADER_OPTIMIZED_EXT 0x87D4
+#define GL_X_EXT 0x87D5
+#define GL_Y_EXT 0x87D6
+#define GL_Z_EXT 0x87D7
+#define GL_W_EXT 0x87D8
+#define GL_NEGATIVE_X_EXT 0x87D9
+#define GL_NEGATIVE_Y_EXT 0x87DA
+#define GL_NEGATIVE_Z_EXT 0x87DB
+#define GL_NEGATIVE_W_EXT 0x87DC
+#define GL_ZERO_EXT 0x87DD
+#define GL_ONE_EXT 0x87DE
+#define GL_NEGATIVE_ONE_EXT 0x87DF
+#define GL_NORMALIZED_RANGE_EXT 0x87E0
+#define GL_FULL_RANGE_EXT 0x87E1
+#define GL_CURRENT_VERTEX_EXT 0x87E2
+#define GL_MVP_MATRIX_EXT 0x87E3
+#define GL_VARIANT_VALUE_EXT 0x87E4
+#define GL_VARIANT_DATATYPE_EXT 0x87E5
+#define GL_VARIANT_ARRAY_STRIDE_EXT 0x87E6
+#define GL_VARIANT_ARRAY_TYPE_EXT 0x87E7
+#define GL_VARIANT_ARRAY_EXT 0x87E8
+#define GL_VARIANT_ARRAY_POINTER_EXT 0x87E9
+#define GL_INVARIANT_VALUE_EXT 0x87EA
+#define GL_INVARIANT_DATATYPE_EXT 0x87EB
+#define GL_LOCAL_CONSTANT_VALUE_EXT 0x87EC
+#define GL_LOCAL_CONSTANT_DATATYPE_EXT 0x87ED
+
+    typedef void (GLAPIENTRY *PFNGLBEGINVERTEXSHADEREXTPROC)(void);
+    typedef GLuint(GLAPIENTRY *PFNGLBINDLIGHTPARAMETEREXTPROC)(GLenum light, GLenum value);
+    typedef GLuint(GLAPIENTRY *PFNGLBINDMATERIALPARAMETEREXTPROC)(GLenum face, GLenum value);
+    typedef GLuint(GLAPIENTRY *PFNGLBINDPARAMETEREXTPROC)(GLenum value);
+    typedef GLuint(GLAPIENTRY *PFNGLBINDTEXGENPARAMETEREXTPROC)(GLenum unit, GLenum coord, GLenum value);
+    typedef GLuint(GLAPIENTRY *PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)(GLenum unit, GLenum value);
+    typedef void (GLAPIENTRY *PFNGLBINDVERTEXSHADEREXTPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLDELETEVERTEXSHADEREXTPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLENDVERTEXSHADEREXTPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLEXTRACTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
+    typedef GLuint(GLAPIENTRY *PFNGLGENSYMBOLSEXTPROC)(GLenum dataType, GLenum storageType, GLenum range, GLuint components);
+    typedef GLuint(GLAPIENTRY *PFNGLGENVERTEXSHADERSEXTPROC)(GLuint range);
+    typedef void (GLAPIENTRY *PFNGLGETINVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
+    typedef void (GLAPIENTRY *PFNGLGETINVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
+    typedef void (GLAPIENTRY *PFNGLGETINVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
+    typedef void (GLAPIENTRY *PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
+    typedef void (GLAPIENTRY *PFNGLGETLOCALCONSTANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
+    typedef void (GLAPIENTRY *PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
+    typedef void (GLAPIENTRY *PFNGLGETVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
+    typedef void (GLAPIENTRY *PFNGLGETVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
+    typedef void (GLAPIENTRY *PFNGLGETVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
+    typedef void (GLAPIENTRY *PFNGLGETVARIANTPOINTERVEXTPROC)(GLuint id, GLenum value, GLvoid **data);
+    typedef void (GLAPIENTRY *PFNGLINSERTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
+    typedef GLboolean(GLAPIENTRY *PFNGLISVARIANTENABLEDEXTPROC)(GLuint id, GLenum cap);
+    typedef void (GLAPIENTRY *PFNGLSETINVARIANTEXTPROC)(GLuint id, GLenum type, GLvoid *addr);
+    typedef void (GLAPIENTRY *PFNGLSETLOCALCONSTANTEXTPROC)(GLuint id, GLenum type, GLvoid *addr);
+    typedef void (GLAPIENTRY *PFNGLSHADEROP1EXTPROC)(GLenum op, GLuint res, GLuint arg1);
+    typedef void (GLAPIENTRY *PFNGLSHADEROP2EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2);
+    typedef void (GLAPIENTRY *PFNGLSHADEROP3EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
+    typedef void (GLAPIENTRY *PFNGLSWIZZLEEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
+    typedef void (GLAPIENTRY *PFNGLVARIANTPOINTEREXTPROC)(GLuint id, GLenum type, GLuint stride, GLvoid *addr);
+    typedef void (GLAPIENTRY *PFNGLVARIANTBVEXTPROC)(GLuint id, GLbyte *addr);
+    typedef void (GLAPIENTRY *PFNGLVARIANTDVEXTPROC)(GLuint id, GLdouble *addr);
+    typedef void (GLAPIENTRY *PFNGLVARIANTFVEXTPROC)(GLuint id, GLfloat *addr);
+    typedef void (GLAPIENTRY *PFNGLVARIANTIVEXTPROC)(GLuint id, GLint *addr);
+    typedef void (GLAPIENTRY *PFNGLVARIANTSVEXTPROC)(GLuint id, GLshort *addr);
+    typedef void (GLAPIENTRY *PFNGLVARIANTUBVEXTPROC)(GLuint id, GLubyte *addr);
+    typedef void (GLAPIENTRY *PFNGLVARIANTUIVEXTPROC)(GLuint id, GLuint *addr);
+    typedef void (GLAPIENTRY *PFNGLVARIANTUSVEXTPROC)(GLuint id, GLushort *addr);
+    typedef void (GLAPIENTRY *PFNGLWRITEMASKEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
+
+#define glBeginVertexShaderEXT GLEW_GET_FUN(__glewBeginVertexShaderEXT)
+#define glBindLightParameterEXT GLEW_GET_FUN(__glewBindLightParameterEXT)
+#define glBindMaterialParameterEXT GLEW_GET_FUN(__glewBindMaterialParameterEXT)
+#define glBindParameterEXT GLEW_GET_FUN(__glewBindParameterEXT)
+#define glBindTexGenParameterEXT GLEW_GET_FUN(__glewBindTexGenParameterEXT)
+#define glBindTextureUnitParameterEXT GLEW_GET_FUN(__glewBindTextureUnitParameterEXT)
+#define glBindVertexShaderEXT GLEW_GET_FUN(__glewBindVertexShaderEXT)
+#define glDeleteVertexShaderEXT GLEW_GET_FUN(__glewDeleteVertexShaderEXT)
+#define glDisableVariantClientStateEXT GLEW_GET_FUN(__glewDisableVariantClientStateEXT)
+#define glEnableVariantClientStateEXT GLEW_GET_FUN(__glewEnableVariantClientStateEXT)
+#define glEndVertexShaderEXT GLEW_GET_FUN(__glewEndVertexShaderEXT)
+#define glExtractComponentEXT GLEW_GET_FUN(__glewExtractComponentEXT)
+#define glGenSymbolsEXT GLEW_GET_FUN(__glewGenSymbolsEXT)
+#define glGenVertexShadersEXT GLEW_GET_FUN(__glewGenVertexShadersEXT)
+#define glGetInvariantBooleanvEXT GLEW_GET_FUN(__glewGetInvariantBooleanvEXT)
+#define glGetInvariantFloatvEXT GLEW_GET_FUN(__glewGetInvariantFloatvEXT)
+#define glGetInvariantIntegervEXT GLEW_GET_FUN(__glewGetInvariantIntegervEXT)
+#define glGetLocalConstantBooleanvEXT GLEW_GET_FUN(__glewGetLocalConstantBooleanvEXT)
+#define glGetLocalConstantFloatvEXT GLEW_GET_FUN(__glewGetLocalConstantFloatvEXT)
+#define glGetLocalConstantIntegervEXT GLEW_GET_FUN(__glewGetLocalConstantIntegervEXT)
+#define glGetVariantBooleanvEXT GLEW_GET_FUN(__glewGetVariantBooleanvEXT)
+#define glGetVariantFloatvEXT GLEW_GET_FUN(__glewGetVariantFloatvEXT)
+#define glGetVariantIntegervEXT GLEW_GET_FUN(__glewGetVariantIntegervEXT)
+#define glGetVariantPointervEXT GLEW_GET_FUN(__glewGetVariantPointervEXT)
+#define glInsertComponentEXT GLEW_GET_FUN(__glewInsertComponentEXT)
+#define glIsVariantEnabledEXT GLEW_GET_FUN(__glewIsVariantEnabledEXT)
+#define glSetInvariantEXT GLEW_GET_FUN(__glewSetInvariantEXT)
+#define glSetLocalConstantEXT GLEW_GET_FUN(__glewSetLocalConstantEXT)
+#define glShaderOp1EXT GLEW_GET_FUN(__glewShaderOp1EXT)
+#define glShaderOp2EXT GLEW_GET_FUN(__glewShaderOp2EXT)
+#define glShaderOp3EXT GLEW_GET_FUN(__glewShaderOp3EXT)
+#define glSwizzleEXT GLEW_GET_FUN(__glewSwizzleEXT)
+#define glVariantPointerEXT GLEW_GET_FUN(__glewVariantPointerEXT)
+#define glVariantbvEXT GLEW_GET_FUN(__glewVariantbvEXT)
+#define glVariantdvEXT GLEW_GET_FUN(__glewVariantdvEXT)
+#define glVariantfvEXT GLEW_GET_FUN(__glewVariantfvEXT)
+#define glVariantivEXT GLEW_GET_FUN(__glewVariantivEXT)
+#define glVariantsvEXT GLEW_GET_FUN(__glewVariantsvEXT)
+#define glVariantubvEXT GLEW_GET_FUN(__glewVariantubvEXT)
+#define glVariantuivEXT GLEW_GET_FUN(__glewVariantuivEXT)
+#define glVariantusvEXT GLEW_GET_FUN(__glewVariantusvEXT)
+#define glWriteMaskEXT GLEW_GET_FUN(__glewWriteMaskEXT)
+
+#define GLEW_EXT_vertex_shader GLEW_GET_VAR(__GLEW_EXT_vertex_shader)
+
+#endif /* GL_EXT_vertex_shader */
+
+    /* ------------------------ GL_EXT_vertex_weighting ------------------------ */
+
+#ifndef GL_EXT_vertex_weighting
+#define GL_EXT_vertex_weighting 1
+
+#define GL_MODELVIEW0_STACK_DEPTH_EXT 0x0BA3
+#define GL_MODELVIEW0_MATRIX_EXT 0x0BA6
+#define GL_MODELVIEW0_EXT 0x1700
+#define GL_MODELVIEW1_STACK_DEPTH_EXT 0x8502
+#define GL_MODELVIEW1_MATRIX_EXT 0x8506
+#define GL_VERTEX_WEIGHTING_EXT 0x8509
+#define GL_MODELVIEW1_EXT 0x850A
+#define GL_CURRENT_VERTEX_WEIGHT_EXT 0x850B
+#define GL_VERTEX_WEIGHT_ARRAY_EXT 0x850C
+#define GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT 0x850D
+#define GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT 0x850E
+#define GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT 0x850F
+#define GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT 0x8510
+
+    typedef void (GLAPIENTRY *PFNGLVERTEXWEIGHTPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, void *pointer);
+    typedef void (GLAPIENTRY *PFNGLVERTEXWEIGHTFEXTPROC)(GLfloat weight);
+    typedef void (GLAPIENTRY *PFNGLVERTEXWEIGHTFVEXTPROC)(GLfloat *weight);
+
+#define glVertexWeightPointerEXT GLEW_GET_FUN(__glewVertexWeightPointerEXT)
+#define glVertexWeightfEXT GLEW_GET_FUN(__glewVertexWeightfEXT)
+#define glVertexWeightfvEXT GLEW_GET_FUN(__glewVertexWeightfvEXT)
+
+#define GLEW_EXT_vertex_weighting GLEW_GET_VAR(__GLEW_EXT_vertex_weighting)
+
+#endif /* GL_EXT_vertex_weighting */
+
+    /* ---------------------- GL_GREMEDY_frame_terminator ---------------------- */
+
+#ifndef GL_GREMEDY_frame_terminator
+#define GL_GREMEDY_frame_terminator 1
+
+    typedef void (GLAPIENTRY *PFNGLFRAMETERMINATORGREMEDYPROC)(void);
+
+#define glFrameTerminatorGREMEDY GLEW_GET_FUN(__glewFrameTerminatorGREMEDY)
+
+#define GLEW_GREMEDY_frame_terminator GLEW_GET_VAR(__GLEW_GREMEDY_frame_terminator)
+
+#endif /* GL_GREMEDY_frame_terminator */
+
+    /* ------------------------ GL_GREMEDY_string_marker ----------------------- */
+
+#ifndef GL_GREMEDY_string_marker
+#define GL_GREMEDY_string_marker 1
+
+    typedef void (GLAPIENTRY *PFNGLSTRINGMARKERGREMEDYPROC)(GLsizei len, const void *string);
+
+#define glStringMarkerGREMEDY GLEW_GET_FUN(__glewStringMarkerGREMEDY)
+
+#define GLEW_GREMEDY_string_marker GLEW_GET_VAR(__GLEW_GREMEDY_string_marker)
+
+#endif /* GL_GREMEDY_string_marker */
+
+    /* --------------------- GL_HP_convolution_border_modes -------------------- */
+
+#ifndef GL_HP_convolution_border_modes
+#define GL_HP_convolution_border_modes 1
+
+#define GLEW_HP_convolution_border_modes GLEW_GET_VAR(__GLEW_HP_convolution_border_modes)
+
+#endif /* GL_HP_convolution_border_modes */
+
+    /* ------------------------- GL_HP_image_transform ------------------------- */
+
+#ifndef GL_HP_image_transform
+#define GL_HP_image_transform 1
+
+    typedef void (GLAPIENTRY *PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLIMAGETRANSFORMPARAMETERFHPPROC)(GLenum target, GLenum pname, const GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLIMAGETRANSFORMPARAMETERIHPPROC)(GLenum target, GLenum pname, const GLint param);
+    typedef void (GLAPIENTRY *PFNGLIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname, const GLint *params);
+
+#define glGetImageTransformParameterfvHP GLEW_GET_FUN(__glewGetImageTransformParameterfvHP)
+#define glGetImageTransformParameterivHP GLEW_GET_FUN(__glewGetImageTransformParameterivHP)
+#define glImageTransformParameterfHP GLEW_GET_FUN(__glewImageTransformParameterfHP)
+#define glImageTransformParameterfvHP GLEW_GET_FUN(__glewImageTransformParameterfvHP)
+#define glImageTransformParameteriHP GLEW_GET_FUN(__glewImageTransformParameteriHP)
+#define glImageTransformParameterivHP GLEW_GET_FUN(__glewImageTransformParameterivHP)
+
+#define GLEW_HP_image_transform GLEW_GET_VAR(__GLEW_HP_image_transform)
+
+#endif /* GL_HP_image_transform */
+
+    /* -------------------------- GL_HP_occlusion_test ------------------------- */
+
+#ifndef GL_HP_occlusion_test
+#define GL_HP_occlusion_test 1
+
+#define GL_OCCLUSION_TEST_HP 0x8165
+#define GL_OCCLUSION_TEST_RESULT_HP 0x8166
+
+#define GLEW_HP_occlusion_test GLEW_GET_VAR(__GLEW_HP_occlusion_test)
+
+#endif /* GL_HP_occlusion_test */
+
+    /* ------------------------- GL_HP_texture_lighting ------------------------ */
+
+#ifndef GL_HP_texture_lighting
+#define GL_HP_texture_lighting 1
+
+#define GLEW_HP_texture_lighting GLEW_GET_VAR(__GLEW_HP_texture_lighting)
+
+#endif /* GL_HP_texture_lighting */
+
+    /* --------------------------- GL_IBM_cull_vertex -------------------------- */
+
+#ifndef GL_IBM_cull_vertex
+#define GL_IBM_cull_vertex 1
+
+#define GL_CULL_VERTEX_IBM 103050
+
+#define GLEW_IBM_cull_vertex GLEW_GET_VAR(__GLEW_IBM_cull_vertex)
+
+#endif /* GL_IBM_cull_vertex */
+
+    /* ---------------------- GL_IBM_multimode_draw_arrays --------------------- */
+
+#ifndef GL_IBM_multimode_draw_arrays
+#define GL_IBM_multimode_draw_arrays 1
+
+    typedef void (GLAPIENTRY *PFNGLMULTIMODEDRAWARRAYSIBMPROC)(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
+    typedef void (GLAPIENTRY *PFNGLMULTIMODEDRAWELEMENTSIBMPROC)(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount, GLint modestride);
+
+#define glMultiModeDrawArraysIBM GLEW_GET_FUN(__glewMultiModeDrawArraysIBM)
+#define glMultiModeDrawElementsIBM GLEW_GET_FUN(__glewMultiModeDrawElementsIBM)
+
+#define GLEW_IBM_multimode_draw_arrays GLEW_GET_VAR(__GLEW_IBM_multimode_draw_arrays)
+
+#endif /* GL_IBM_multimode_draw_arrays */
+
+    /* ------------------------- GL_IBM_rasterpos_clip ------------------------- */
+
+#ifndef GL_IBM_rasterpos_clip
+#define GL_IBM_rasterpos_clip 1
+
+#define GL_RASTER_POSITION_UNCLIPPED_IBM 103010
+
+#define GLEW_IBM_rasterpos_clip GLEW_GET_VAR(__GLEW_IBM_rasterpos_clip)
+
+#endif /* GL_IBM_rasterpos_clip */
+
+    /* --------------------------- GL_IBM_static_data -------------------------- */
+
+#ifndef GL_IBM_static_data
+#define GL_IBM_static_data 1
+
+#define GL_ALL_STATIC_DATA_IBM 103060
+#define GL_STATIC_VERTEX_ARRAY_IBM 103061
+
+#define GLEW_IBM_static_data GLEW_GET_VAR(__GLEW_IBM_static_data)
+
+#endif /* GL_IBM_static_data */
+
+    /* --------------------- GL_IBM_texture_mirrored_repeat -------------------- */
+
+#ifndef GL_IBM_texture_mirrored_repeat
+#define GL_IBM_texture_mirrored_repeat 1
+
+#define GL_MIRRORED_REPEAT_IBM 0x8370
+
+#define GLEW_IBM_texture_mirrored_repeat GLEW_GET_VAR(__GLEW_IBM_texture_mirrored_repeat)
+
+#endif /* GL_IBM_texture_mirrored_repeat */
+
+    /* ----------------------- GL_IBM_vertex_array_lists ----------------------- */
+
+#ifndef GL_IBM_vertex_array_lists
+#define GL_IBM_vertex_array_lists 1
+
+#define GL_VERTEX_ARRAY_LIST_IBM 103070
+#define GL_NORMAL_ARRAY_LIST_IBM 103071
+#define GL_COLOR_ARRAY_LIST_IBM 103072
+#define GL_INDEX_ARRAY_LIST_IBM 103073
+#define GL_TEXTURE_COORD_ARRAY_LIST_IBM 103074
+#define GL_EDGE_FLAG_ARRAY_LIST_IBM 103075
+#define GL_FOG_COORDINATE_ARRAY_LIST_IBM 103076
+#define GL_SECONDARY_COLOR_ARRAY_LIST_IBM 103077
+#define GL_VERTEX_ARRAY_LIST_STRIDE_IBM 103080
+#define GL_NORMAL_ARRAY_LIST_STRIDE_IBM 103081
+#define GL_COLOR_ARRAY_LIST_STRIDE_IBM 103082
+#define GL_INDEX_ARRAY_LIST_STRIDE_IBM 103083
+#define GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM 103084
+#define GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM 103085
+#define GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM 103086
+#define GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM 103087
+
+    typedef void (GLAPIENTRY *PFNGLCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+    typedef void (GLAPIENTRY *PFNGLEDGEFLAGPOINTERLISTIBMPROC)(GLint stride, const GLboolean **pointer, GLint ptrstride);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDPOINTERLISTIBMPROC)(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+    typedef void (GLAPIENTRY *PFNGLINDEXPOINTERLISTIBMPROC)(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+    typedef void (GLAPIENTRY *PFNGLNORMALPOINTERLISTIBMPROC)(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+    typedef void (GLAPIENTRY *PFNGLVERTEXPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+
+#define glColorPointerListIBM GLEW_GET_FUN(__glewColorPointerListIBM)
+#define glEdgeFlagPointerListIBM GLEW_GET_FUN(__glewEdgeFlagPointerListIBM)
+#define glFogCoordPointerListIBM GLEW_GET_FUN(__glewFogCoordPointerListIBM)
+#define glIndexPointerListIBM GLEW_GET_FUN(__glewIndexPointerListIBM)
+#define glNormalPointerListIBM GLEW_GET_FUN(__glewNormalPointerListIBM)
+#define glSecondaryColorPointerListIBM GLEW_GET_FUN(__glewSecondaryColorPointerListIBM)
+#define glTexCoordPointerListIBM GLEW_GET_FUN(__glewTexCoordPointerListIBM)
+#define glVertexPointerListIBM GLEW_GET_FUN(__glewVertexPointerListIBM)
+
+#define GLEW_IBM_vertex_array_lists GLEW_GET_VAR(__GLEW_IBM_vertex_array_lists)
+
+#endif /* GL_IBM_vertex_array_lists */
+
+    /* -------------------------- GL_INGR_color_clamp -------------------------- */
+
+#ifndef GL_INGR_color_clamp
+#define GL_INGR_color_clamp 1
+
+#define GL_RED_MIN_CLAMP_INGR 0x8560
+#define GL_GREEN_MIN_CLAMP_INGR 0x8561
+#define GL_BLUE_MIN_CLAMP_INGR 0x8562
+#define GL_ALPHA_MIN_CLAMP_INGR 0x8563
+#define GL_RED_MAX_CLAMP_INGR 0x8564
+#define GL_GREEN_MAX_CLAMP_INGR 0x8565
+#define GL_BLUE_MAX_CLAMP_INGR 0x8566
+#define GL_ALPHA_MAX_CLAMP_INGR 0x8567
+
+#define GLEW_INGR_color_clamp GLEW_GET_VAR(__GLEW_INGR_color_clamp)
+
+#endif /* GL_INGR_color_clamp */
+
+    /* ------------------------- GL_INGR_interlace_read ------------------------ */
+
+#ifndef GL_INGR_interlace_read
+#define GL_INGR_interlace_read 1
+
+#define GL_INTERLACE_READ_INGR 0x8568
+
+#define GLEW_INGR_interlace_read GLEW_GET_VAR(__GLEW_INGR_interlace_read)
+
+#endif /* GL_INGR_interlace_read */
+
+    /* ------------------------ GL_INTEL_parallel_arrays ----------------------- */
+
+#ifndef GL_INTEL_parallel_arrays
+#define GL_INTEL_parallel_arrays 1
+
+#define GL_PARALLEL_ARRAYS_INTEL 0x83F4
+#define GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL 0x83F5
+#define GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL 0x83F6
+#define GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL 0x83F7
+#define GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL 0x83F8
+
+    typedef void (GLAPIENTRY *PFNGLCOLORPOINTERVINTELPROC)(GLint size, GLenum type, const void **pointer);
+    typedef void (GLAPIENTRY *PFNGLNORMALPOINTERVINTELPROC)(GLenum type, const void **pointer);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDPOINTERVINTELPROC)(GLint size, GLenum type, const void **pointer);
+    typedef void (GLAPIENTRY *PFNGLVERTEXPOINTERVINTELPROC)(GLint size, GLenum type, const void **pointer);
+
+#define glColorPointervINTEL GLEW_GET_FUN(__glewColorPointervINTEL)
+#define glNormalPointervINTEL GLEW_GET_FUN(__glewNormalPointervINTEL)
+#define glTexCoordPointervINTEL GLEW_GET_FUN(__glewTexCoordPointervINTEL)
+#define glVertexPointervINTEL GLEW_GET_FUN(__glewVertexPointervINTEL)
+
+#define GLEW_INTEL_parallel_arrays GLEW_GET_VAR(__GLEW_INTEL_parallel_arrays)
+
+#endif /* GL_INTEL_parallel_arrays */
+
+    /* ------------------------ GL_INTEL_texture_scissor ----------------------- */
+
+#ifndef GL_INTEL_texture_scissor
+#define GL_INTEL_texture_scissor 1
+
+    typedef void (GLAPIENTRY *PFNGLTEXSCISSORFUNCINTELPROC)(GLenum target, GLenum lfunc, GLenum hfunc);
+    typedef void (GLAPIENTRY *PFNGLTEXSCISSORINTELPROC)(GLenum target, GLclampf tlow, GLclampf thigh);
+
+#define glTexScissorFuncINTEL GLEW_GET_FUN(__glewTexScissorFuncINTEL)
+#define glTexScissorINTEL GLEW_GET_FUN(__glewTexScissorINTEL)
+
+#define GLEW_INTEL_texture_scissor GLEW_GET_VAR(__GLEW_INTEL_texture_scissor)
+
+#endif /* GL_INTEL_texture_scissor */
+
+    /* -------------------------- GL_KTX_buffer_region ------------------------- */
+
+#ifndef GL_KTX_buffer_region
+#define GL_KTX_buffer_region 1
+
+#define GL_KTX_FRONT_REGION 0x0
+#define GL_KTX_BACK_REGION 0x1
+#define GL_KTX_Z_REGION 0x2
+#define GL_KTX_STENCIL_REGION 0x3
+
+    typedef GLuint(GLAPIENTRY *PFNGLBUFFERREGIONENABLEDEXTPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLDELETEBUFFERREGIONEXTPROC)(GLenum region);
+    typedef void (GLAPIENTRY *PFNGLDRAWBUFFERREGIONEXTPROC)(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
+    typedef GLuint(GLAPIENTRY *PFNGLNEWBUFFERREGIONEXTPROC)(GLenum region);
+    typedef void (GLAPIENTRY *PFNGLREADBUFFERREGIONEXTPROC)(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);
+
+#define glBufferRegionEnabledEXT GLEW_GET_FUN(__glewBufferRegionEnabledEXT)
+#define glDeleteBufferRegionEXT GLEW_GET_FUN(__glewDeleteBufferRegionEXT)
+#define glDrawBufferRegionEXT GLEW_GET_FUN(__glewDrawBufferRegionEXT)
+#define glNewBufferRegionEXT GLEW_GET_FUN(__glewNewBufferRegionEXT)
+#define glReadBufferRegionEXT GLEW_GET_FUN(__glewReadBufferRegionEXT)
+
+#define GLEW_KTX_buffer_region GLEW_GET_VAR(__GLEW_KTX_buffer_region)
+
+#endif /* GL_KTX_buffer_region */
+
+    /* ------------------------- GL_MESAX_texture_stack ------------------------ */
+
+#ifndef GL_MESAX_texture_stack
+#define GL_MESAX_texture_stack 1
+
+#define GL_TEXTURE_1D_STACK_MESAX 0x8759
+#define GL_TEXTURE_2D_STACK_MESAX 0x875A
+#define GL_PROXY_TEXTURE_1D_STACK_MESAX 0x875B
+#define GL_PROXY_TEXTURE_2D_STACK_MESAX 0x875C
+#define GL_TEXTURE_1D_STACK_BINDING_MESAX 0x875D
+#define GL_TEXTURE_2D_STACK_BINDING_MESAX 0x875E
+
+#define GLEW_MESAX_texture_stack GLEW_GET_VAR(__GLEW_MESAX_texture_stack)
+
+#endif /* GL_MESAX_texture_stack */
+
+    /* -------------------------- GL_MESA_pack_invert -------------------------- */
+
+#ifndef GL_MESA_pack_invert
+#define GL_MESA_pack_invert 1
+
+#define GL_PACK_INVERT_MESA 0x8758
+
+#define GLEW_MESA_pack_invert GLEW_GET_VAR(__GLEW_MESA_pack_invert)
+
+#endif /* GL_MESA_pack_invert */
+
+    /* ------------------------- GL_MESA_resize_buffers ------------------------ */
+
+#ifndef GL_MESA_resize_buffers
+#define GL_MESA_resize_buffers 1
+
+    typedef void (GLAPIENTRY *PFNGLRESIZEBUFFERSMESAPROC)(void);
+
+#define glResizeBuffersMESA GLEW_GET_FUN(__glewResizeBuffersMESA)
+
+#define GLEW_MESA_resize_buffers GLEW_GET_VAR(__GLEW_MESA_resize_buffers)
+
+#endif /* GL_MESA_resize_buffers */
+
+    /* --------------------------- GL_MESA_window_pos -------------------------- */
+
+#ifndef GL_MESA_window_pos
+#define GL_MESA_window_pos 1
+
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2DMESAPROC)(GLdouble x, GLdouble y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2DVMESAPROC)(const GLdouble *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2FMESAPROC)(GLfloat x, GLfloat y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2FVMESAPROC)(const GLfloat *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2IMESAPROC)(GLint x, GLint y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2IVMESAPROC)(const GLint *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2SMESAPROC)(GLshort x, GLshort y);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS2SVMESAPROC)(const GLshort *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3DMESAPROC)(GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3DVMESAPROC)(const GLdouble *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3FMESAPROC)(GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3FVMESAPROC)(const GLfloat *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3IMESAPROC)(GLint x, GLint y, GLint z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3IVMESAPROC)(const GLint *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3SMESAPROC)(GLshort x, GLshort y, GLshort z);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS3SVMESAPROC)(const GLshort *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS4DMESAPROC)(GLdouble x, GLdouble y, GLdouble z, GLdouble);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS4DVMESAPROC)(const GLdouble *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS4FMESAPROC)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS4FVMESAPROC)(const GLfloat *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS4IMESAPROC)(GLint x, GLint y, GLint z, GLint w);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS4IVMESAPROC)(const GLint *p);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS4SMESAPROC)(GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (GLAPIENTRY *PFNGLWINDOWPOS4SVMESAPROC)(const GLshort *p);
+
+#define glWindowPos2dMESA GLEW_GET_FUN(__glewWindowPos2dMESA)
+#define glWindowPos2dvMESA GLEW_GET_FUN(__glewWindowPos2dvMESA)
+#define glWindowPos2fMESA GLEW_GET_FUN(__glewWindowPos2fMESA)
+#define glWindowPos2fvMESA GLEW_GET_FUN(__glewWindowPos2fvMESA)
+#define glWindowPos2iMESA GLEW_GET_FUN(__glewWindowPos2iMESA)
+#define glWindowPos2ivMESA GLEW_GET_FUN(__glewWindowPos2ivMESA)
+#define glWindowPos2sMESA GLEW_GET_FUN(__glewWindowPos2sMESA)
+#define glWindowPos2svMESA GLEW_GET_FUN(__glewWindowPos2svMESA)
+#define glWindowPos3dMESA GLEW_GET_FUN(__glewWindowPos3dMESA)
+#define glWindowPos3dvMESA GLEW_GET_FUN(__glewWindowPos3dvMESA)
+#define glWindowPos3fMESA GLEW_GET_FUN(__glewWindowPos3fMESA)
+#define glWindowPos3fvMESA GLEW_GET_FUN(__glewWindowPos3fvMESA)
+#define glWindowPos3iMESA GLEW_GET_FUN(__glewWindowPos3iMESA)
+#define glWindowPos3ivMESA GLEW_GET_FUN(__glewWindowPos3ivMESA)
+#define glWindowPos3sMESA GLEW_GET_FUN(__glewWindowPos3sMESA)
+#define glWindowPos3svMESA GLEW_GET_FUN(__glewWindowPos3svMESA)
+#define glWindowPos4dMESA GLEW_GET_FUN(__glewWindowPos4dMESA)
+#define glWindowPos4dvMESA GLEW_GET_FUN(__glewWindowPos4dvMESA)
+#define glWindowPos4fMESA GLEW_GET_FUN(__glewWindowPos4fMESA)
+#define glWindowPos4fvMESA GLEW_GET_FUN(__glewWindowPos4fvMESA)
+#define glWindowPos4iMESA GLEW_GET_FUN(__glewWindowPos4iMESA)
+#define glWindowPos4ivMESA GLEW_GET_FUN(__glewWindowPos4ivMESA)
+#define glWindowPos4sMESA GLEW_GET_FUN(__glewWindowPos4sMESA)
+#define glWindowPos4svMESA GLEW_GET_FUN(__glewWindowPos4svMESA)
+
+#define GLEW_MESA_window_pos GLEW_GET_VAR(__GLEW_MESA_window_pos)
+
+#endif /* GL_MESA_window_pos */
+
+    /* ------------------------- GL_MESA_ycbcr_texture ------------------------- */
+
+#ifndef GL_MESA_ycbcr_texture
+#define GL_MESA_ycbcr_texture 1
+
+#define GL_UNSIGNED_SHORT_8_8_MESA 0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_MESA 0x85BB
+#define GL_YCBCR_MESA 0x8757
+
+#define GLEW_MESA_ycbcr_texture GLEW_GET_VAR(__GLEW_MESA_ycbcr_texture)
+
+#endif /* GL_MESA_ycbcr_texture */
+
+    /* --------------------------- GL_NV_blend_square -------------------------- */
+
+#ifndef GL_NV_blend_square
+#define GL_NV_blend_square 1
+
+#define GLEW_NV_blend_square GLEW_GET_VAR(__GLEW_NV_blend_square)
+
+#endif /* GL_NV_blend_square */
+
+    /* ------------------------ GL_NV_conditional_render ----------------------- */
+
+#ifndef GL_NV_conditional_render
+#define GL_NV_conditional_render 1
+
+#define GL_QUERY_WAIT_NV 0x8E13
+#define GL_QUERY_NO_WAIT_NV 0x8E14
+#define GL_QUERY_BY_REGION_WAIT_NV 0x8E15
+#define GL_QUERY_BY_REGION_NO_WAIT_NV 0x8E16
+
+    typedef void (GLAPIENTRY *PFNGLBEGINCONDITIONALRENDERNVPROC)(GLuint id, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLENDCONDITIONALRENDERNVPROC)(void);
+
+#define glBeginConditionalRenderNV GLEW_GET_FUN(__glewBeginConditionalRenderNV)
+#define glEndConditionalRenderNV GLEW_GET_FUN(__glewEndConditionalRenderNV)
+
+#define GLEW_NV_conditional_render GLEW_GET_VAR(__GLEW_NV_conditional_render)
+
+#endif /* GL_NV_conditional_render */
+
+    /* ----------------------- GL_NV_copy_depth_to_color ----------------------- */
+
+#ifndef GL_NV_copy_depth_to_color
+#define GL_NV_copy_depth_to_color 1
+
+#define GL_DEPTH_STENCIL_TO_RGBA_NV 0x886E
+#define GL_DEPTH_STENCIL_TO_BGRA_NV 0x886F
+
+#define GLEW_NV_copy_depth_to_color GLEW_GET_VAR(__GLEW_NV_copy_depth_to_color)
+
+#endif /* GL_NV_copy_depth_to_color */
+
+    /* ---------------------------- GL_NV_copy_image --------------------------- */
+
+#ifndef GL_NV_copy_image
+#define GL_NV_copy_image 1
+
+    typedef void (GLAPIENTRY *PFNGLCOPYIMAGESUBDATANVPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
+
+#define glCopyImageSubDataNV GLEW_GET_FUN(__glewCopyImageSubDataNV)
+
+#define GLEW_NV_copy_image GLEW_GET_VAR(__GLEW_NV_copy_image)
+
+#endif /* GL_NV_copy_image */
+
+    /* ------------------------ GL_NV_depth_buffer_float ----------------------- */
+
+#ifndef GL_NV_depth_buffer_float
+#define GL_NV_depth_buffer_float 1
+
+#define GL_DEPTH_COMPONENT32F_NV 0x8DAB
+#define GL_DEPTH32F_STENCIL8_NV 0x8DAC
+#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV 0x8DAD
+#define GL_DEPTH_BUFFER_FLOAT_MODE_NV 0x8DAF
+
+    typedef void (GLAPIENTRY *PFNGLCLEARDEPTHDNVPROC)(GLdouble depth);
+    typedef void (GLAPIENTRY *PFNGLDEPTHBOUNDSDNVPROC)(GLdouble zmin, GLdouble zmax);
+    typedef void (GLAPIENTRY *PFNGLDEPTHRANGEDNVPROC)(GLdouble zNear, GLdouble zFar);
+
+#define glClearDepthdNV GLEW_GET_FUN(__glewClearDepthdNV)
+#define glDepthBoundsdNV GLEW_GET_FUN(__glewDepthBoundsdNV)
+#define glDepthRangedNV GLEW_GET_FUN(__glewDepthRangedNV)
+
+#define GLEW_NV_depth_buffer_float GLEW_GET_VAR(__GLEW_NV_depth_buffer_float)
+
+#endif /* GL_NV_depth_buffer_float */
+
+    /* --------------------------- GL_NV_depth_clamp --------------------------- */
+
+#ifndef GL_NV_depth_clamp
+#define GL_NV_depth_clamp 1
+
+#define GL_DEPTH_CLAMP_NV 0x864F
+
+#define GLEW_NV_depth_clamp GLEW_GET_VAR(__GLEW_NV_depth_clamp)
+
+#endif /* GL_NV_depth_clamp */
+
+    /* ---------------------- GL_NV_depth_range_unclamped ---------------------- */
+
+#ifndef GL_NV_depth_range_unclamped
+#define GL_NV_depth_range_unclamped 1
+
+#define GL_SAMPLE_COUNT_BITS_NV 0x8864
+#define GL_CURRENT_SAMPLE_COUNT_QUERY_NV 0x8865
+#define GL_QUERY_RESULT_NV 0x8866
+#define GL_QUERY_RESULT_AVAILABLE_NV 0x8867
+#define GL_SAMPLE_COUNT_NV 0x8914
+
+#define GLEW_NV_depth_range_unclamped GLEW_GET_VAR(__GLEW_NV_depth_range_unclamped)
+
+#endif /* GL_NV_depth_range_unclamped */
+
+    /* ---------------------------- GL_NV_evaluators --------------------------- */
+
+#ifndef GL_NV_evaluators
+#define GL_NV_evaluators 1
+
+#define GL_EVAL_2D_NV 0x86C0
+#define GL_EVAL_TRIANGULAR_2D_NV 0x86C1
+#define GL_MAP_TESSELLATION_NV 0x86C2
+#define GL_MAP_ATTRIB_U_ORDER_NV 0x86C3
+#define GL_MAP_ATTRIB_V_ORDER_NV 0x86C4
+#define GL_EVAL_FRACTIONAL_TESSELLATION_NV 0x86C5
+#define GL_EVAL_VERTEX_ATTRIB0_NV 0x86C6
+#define GL_EVAL_VERTEX_ATTRIB1_NV 0x86C7
+#define GL_EVAL_VERTEX_ATTRIB2_NV 0x86C8
+#define GL_EVAL_VERTEX_ATTRIB3_NV 0x86C9
+#define GL_EVAL_VERTEX_ATTRIB4_NV 0x86CA
+#define GL_EVAL_VERTEX_ATTRIB5_NV 0x86CB
+#define GL_EVAL_VERTEX_ATTRIB6_NV 0x86CC
+#define GL_EVAL_VERTEX_ATTRIB7_NV 0x86CD
+#define GL_EVAL_VERTEX_ATTRIB8_NV 0x86CE
+#define GL_EVAL_VERTEX_ATTRIB9_NV 0x86CF
+#define GL_EVAL_VERTEX_ATTRIB10_NV 0x86D0
+#define GL_EVAL_VERTEX_ATTRIB11_NV 0x86D1
+#define GL_EVAL_VERTEX_ATTRIB12_NV 0x86D2
+#define GL_EVAL_VERTEX_ATTRIB13_NV 0x86D3
+#define GL_EVAL_VERTEX_ATTRIB14_NV 0x86D4
+#define GL_EVAL_VERTEX_ATTRIB15_NV 0x86D5
+#define GL_MAX_MAP_TESSELLATION_NV 0x86D6
+#define GL_MAX_RATIONAL_EVAL_ORDER_NV 0x86D7
+
+    typedef void (GLAPIENTRY *PFNGLEVALMAPSNVPROC)(GLenum target, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLGETMAPATTRIBPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETMAPATTRIBPARAMETERIVNVPROC)(GLenum target, GLuint index, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
+    typedef void (GLAPIENTRY *PFNGLGETMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
+    typedef void (GLAPIENTRY *PFNGLMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, const GLint *params);
+
+#define glEvalMapsNV GLEW_GET_FUN(__glewEvalMapsNV)
+#define glGetMapAttribParameterfvNV GLEW_GET_FUN(__glewGetMapAttribParameterfvNV)
+#define glGetMapAttribParameterivNV GLEW_GET_FUN(__glewGetMapAttribParameterivNV)
+#define glGetMapControlPointsNV GLEW_GET_FUN(__glewGetMapControlPointsNV)
+#define glGetMapParameterfvNV GLEW_GET_FUN(__glewGetMapParameterfvNV)
+#define glGetMapParameterivNV GLEW_GET_FUN(__glewGetMapParameterivNV)
+#define glMapControlPointsNV GLEW_GET_FUN(__glewMapControlPointsNV)
+#define glMapParameterfvNV GLEW_GET_FUN(__glewMapParameterfvNV)
+#define glMapParameterivNV GLEW_GET_FUN(__glewMapParameterivNV)
+
+#define GLEW_NV_evaluators GLEW_GET_VAR(__GLEW_NV_evaluators)
+
+#endif /* GL_NV_evaluators */
+
+    /* ----------------------- GL_NV_explicit_multisample ---------------------- */
+
+#ifndef GL_NV_explicit_multisample
+#define GL_NV_explicit_multisample 1
+
+#define GL_SAMPLE_POSITION_NV 0x8E50
+#define GL_SAMPLE_MASK_NV 0x8E51
+#define GL_SAMPLE_MASK_VALUE_NV 0x8E52
+#define GL_TEXTURE_BINDING_RENDERBUFFER_NV 0x8E53
+#define GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV 0x8E54
+#define GL_TEXTURE_RENDERBUFFER_NV 0x8E55
+#define GL_SAMPLER_RENDERBUFFER_NV 0x8E56
+#define GL_INT_SAMPLER_RENDERBUFFER_NV 0x8E57
+#define GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV 0x8E58
+#define GL_MAX_SAMPLE_MASK_WORDS_NV 0x8E59
+
+    typedef void (GLAPIENTRY *PFNGLGETMULTISAMPLEFVNVPROC)(GLenum pname, GLuint index, GLfloat *val);
+    typedef void (GLAPIENTRY *PFNGLSAMPLEMASKINDEXEDNVPROC)(GLuint index, GLbitfield mask);
+    typedef void (GLAPIENTRY *PFNGLTEXRENDERBUFFERNVPROC)(GLenum target, GLuint renderbuffer);
+
+#define glGetMultisamplefvNV GLEW_GET_FUN(__glewGetMultisamplefvNV)
+#define glSampleMaskIndexedNV GLEW_GET_FUN(__glewSampleMaskIndexedNV)
+#define glTexRenderbufferNV GLEW_GET_FUN(__glewTexRenderbufferNV)
+
+#define GLEW_NV_explicit_multisample GLEW_GET_VAR(__GLEW_NV_explicit_multisample)
+
+#endif /* GL_NV_explicit_multisample */
+
+    /* ------------------------------ GL_NV_fence ------------------------------ */
+
+#ifndef GL_NV_fence
+#define GL_NV_fence 1
+
+#define GL_ALL_COMPLETED_NV 0x84F2
+#define GL_FENCE_STATUS_NV 0x84F3
+#define GL_FENCE_CONDITION_NV 0x84F4
+
+    typedef void (GLAPIENTRY *PFNGLDELETEFENCESNVPROC)(GLsizei n, const GLuint *fences);
+    typedef void (GLAPIENTRY *PFNGLFINISHFENCENVPROC)(GLuint fence);
+    typedef void (GLAPIENTRY *PFNGLGENFENCESNVPROC)(GLsizei n, GLuint *fences);
+    typedef void (GLAPIENTRY *PFNGLGETFENCEIVNVPROC)(GLuint fence, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISFENCENVPROC)(GLuint fence);
+    typedef void (GLAPIENTRY *PFNGLSETFENCENVPROC)(GLuint fence, GLenum condition);
+    typedef GLboolean(GLAPIENTRY *PFNGLTESTFENCENVPROC)(GLuint fence);
+
+#define glDeleteFencesNV GLEW_GET_FUN(__glewDeleteFencesNV)
+#define glFinishFenceNV GLEW_GET_FUN(__glewFinishFenceNV)
+#define glGenFencesNV GLEW_GET_FUN(__glewGenFencesNV)
+#define glGetFenceivNV GLEW_GET_FUN(__glewGetFenceivNV)
+#define glIsFenceNV GLEW_GET_FUN(__glewIsFenceNV)
+#define glSetFenceNV GLEW_GET_FUN(__glewSetFenceNV)
+#define glTestFenceNV GLEW_GET_FUN(__glewTestFenceNV)
+
+#define GLEW_NV_fence GLEW_GET_VAR(__GLEW_NV_fence)
+
+#endif /* GL_NV_fence */
+
+    /* --------------------------- GL_NV_float_buffer -------------------------- */
+
+#ifndef GL_NV_float_buffer
+#define GL_NV_float_buffer 1
+
+#define GL_FLOAT_R_NV 0x8880
+#define GL_FLOAT_RG_NV 0x8881
+#define GL_FLOAT_RGB_NV 0x8882
+#define GL_FLOAT_RGBA_NV 0x8883
+#define GL_FLOAT_R16_NV 0x8884
+#define GL_FLOAT_R32_NV 0x8885
+#define GL_FLOAT_RG16_NV 0x8886
+#define GL_FLOAT_RG32_NV 0x8887
+#define GL_FLOAT_RGB16_NV 0x8888
+#define GL_FLOAT_RGB32_NV 0x8889
+#define GL_FLOAT_RGBA16_NV 0x888A
+#define GL_FLOAT_RGBA32_NV 0x888B
+#define GL_TEXTURE_FLOAT_COMPONENTS_NV 0x888C
+#define GL_FLOAT_CLEAR_COLOR_VALUE_NV 0x888D
+#define GL_FLOAT_RGBA_MODE_NV 0x888E
+
+#define GLEW_NV_float_buffer GLEW_GET_VAR(__GLEW_NV_float_buffer)
+
+#endif /* GL_NV_float_buffer */
+
+    /* --------------------------- GL_NV_fog_distance -------------------------- */
+
+#ifndef GL_NV_fog_distance
+#define GL_NV_fog_distance 1
+
+#define GL_FOG_DISTANCE_MODE_NV 0x855A
+#define GL_EYE_RADIAL_NV 0x855B
+#define GL_EYE_PLANE_ABSOLUTE_NV 0x855C
+
+#define GLEW_NV_fog_distance GLEW_GET_VAR(__GLEW_NV_fog_distance)
+
+#endif /* GL_NV_fog_distance */
+
+    /* ------------------------- GL_NV_fragment_program ------------------------ */
+
+#ifndef GL_NV_fragment_program
+#define GL_NV_fragment_program 1
+
+#define GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV 0x8868
+#define GL_FRAGMENT_PROGRAM_NV 0x8870
+#define GL_MAX_TEXTURE_COORDS_NV 0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_NV 0x8872
+#define GL_FRAGMENT_PROGRAM_BINDING_NV 0x8873
+#define GL_PROGRAM_ERROR_STRING_NV 0x8874
+
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, const GLdouble v[]);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, const GLfloat v[]);
+
+#define glGetProgramNamedParameterdvNV GLEW_GET_FUN(__glewGetProgramNamedParameterdvNV)
+#define glGetProgramNamedParameterfvNV GLEW_GET_FUN(__glewGetProgramNamedParameterfvNV)
+#define glProgramNamedParameter4dNV GLEW_GET_FUN(__glewProgramNamedParameter4dNV)
+#define glProgramNamedParameter4dvNV GLEW_GET_FUN(__glewProgramNamedParameter4dvNV)
+#define glProgramNamedParameter4fNV GLEW_GET_FUN(__glewProgramNamedParameter4fNV)
+#define glProgramNamedParameter4fvNV GLEW_GET_FUN(__glewProgramNamedParameter4fvNV)
+
+#define GLEW_NV_fragment_program GLEW_GET_VAR(__GLEW_NV_fragment_program)
+
+#endif /* GL_NV_fragment_program */
+
+    /* ------------------------ GL_NV_fragment_program2 ------------------------ */
+
+#ifndef GL_NV_fragment_program2
+#define GL_NV_fragment_program2 1
+
+#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
+#define GL_MAX_PROGRAM_CALL_DEPTH_NV 0x88F5
+#define GL_MAX_PROGRAM_IF_DEPTH_NV 0x88F6
+#define GL_MAX_PROGRAM_LOOP_DEPTH_NV 0x88F7
+#define GL_MAX_PROGRAM_LOOP_COUNT_NV 0x88F8
+
+#define GLEW_NV_fragment_program2 GLEW_GET_VAR(__GLEW_NV_fragment_program2)
+
+#endif /* GL_NV_fragment_program2 */
+
+    /* ------------------------ GL_NV_fragment_program4 ------------------------ */
+
+#ifndef GL_NV_fragment_program4
+#define GL_NV_fragment_program4 1
+
+#define GLEW_NV_fragment_program4 GLEW_GET_VAR(__GLEW_NV_fragment_program4)
+
+#endif /* GL_NV_fragment_program4 */
+
+    /* --------------------- GL_NV_fragment_program_option --------------------- */
+
+#ifndef GL_NV_fragment_program_option
+#define GL_NV_fragment_program_option 1
+
+#define GLEW_NV_fragment_program_option GLEW_GET_VAR(__GLEW_NV_fragment_program_option)
+
+#endif /* GL_NV_fragment_program_option */
+
+    /* ----------------- GL_NV_framebuffer_multisample_coverage ---------------- */
+
+#ifndef GL_NV_framebuffer_multisample_coverage
+#define GL_NV_framebuffer_multisample_coverage 1
+
+#define GL_RENDERBUFFER_COVERAGE_SAMPLES_NV 0x8CAB
+#define GL_RENDERBUFFER_COLOR_SAMPLES_NV 0x8E10
+#define GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV 0x8E11
+#define GL_MULTISAMPLE_COVERAGE_MODES_NV 0x8E12
+
+    typedef void (GLAPIENTRY *PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
+
+#define glRenderbufferStorageMultisampleCoverageNV GLEW_GET_FUN(__glewRenderbufferStorageMultisampleCoverageNV)
+
+#define GLEW_NV_framebuffer_multisample_coverage GLEW_GET_VAR(__GLEW_NV_framebuffer_multisample_coverage)
+
+#endif /* GL_NV_framebuffer_multisample_coverage */
+
+    /* ------------------------ GL_NV_geometry_program4 ------------------------ */
+
+#ifndef GL_NV_geometry_program4
+#define GL_NV_geometry_program4 1
+
+#define GL_GEOMETRY_PROGRAM_NV 0x8C26
+#define GL_MAX_PROGRAM_OUTPUT_VERTICES_NV 0x8C27
+#define GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV 0x8C28
+
+    typedef void (GLAPIENTRY *PFNGLPROGRAMVERTEXLIMITNVPROC)(GLenum target, GLint limit);
+
+#define glProgramVertexLimitNV GLEW_GET_FUN(__glewProgramVertexLimitNV)
+
+#define GLEW_NV_geometry_program4 GLEW_GET_VAR(__GLEW_NV_geometry_program4)
+
+#endif /* GL_NV_geometry_program4 */
+
+    /* ------------------------- GL_NV_geometry_shader4 ------------------------ */
+
+#ifndef GL_NV_geometry_shader4
+#define GL_NV_geometry_shader4 1
+
+#define GLEW_NV_geometry_shader4 GLEW_GET_VAR(__GLEW_NV_geometry_shader4)
+
+#endif /* GL_NV_geometry_shader4 */
+
+    /* --------------------------- GL_NV_gpu_program4 -------------------------- */
+
+#ifndef GL_NV_gpu_program4
+#define GL_NV_gpu_program4 1
+
+#define GL_MIN_PROGRAM_TEXEL_OFFSET_NV 0x8904
+#define GL_MAX_PROGRAM_TEXEL_OFFSET_NV 0x8905
+#define GL_PROGRAM_ATTRIB_COMPONENTS_NV 0x8906
+#define GL_PROGRAM_RESULT_COMPONENTS_NV 0x8907
+#define GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV 0x8908
+#define GL_MAX_PROGRAM_RESULT_COMPONENTS_NV 0x8909
+#define GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV 0x8DA5
+#define GL_MAX_PROGRAM_GENERIC_RESULTS_NV 0x8DA6
+
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint *params);
+
+#define glProgramEnvParameterI4iNV GLEW_GET_FUN(__glewProgramEnvParameterI4iNV)
+#define glProgramEnvParameterI4ivNV GLEW_GET_FUN(__glewProgramEnvParameterI4ivNV)
+#define glProgramEnvParameterI4uiNV GLEW_GET_FUN(__glewProgramEnvParameterI4uiNV)
+#define glProgramEnvParameterI4uivNV GLEW_GET_FUN(__glewProgramEnvParameterI4uivNV)
+#define glProgramEnvParametersI4ivNV GLEW_GET_FUN(__glewProgramEnvParametersI4ivNV)
+#define glProgramEnvParametersI4uivNV GLEW_GET_FUN(__glewProgramEnvParametersI4uivNV)
+#define glProgramLocalParameterI4iNV GLEW_GET_FUN(__glewProgramLocalParameterI4iNV)
+#define glProgramLocalParameterI4ivNV GLEW_GET_FUN(__glewProgramLocalParameterI4ivNV)
+#define glProgramLocalParameterI4uiNV GLEW_GET_FUN(__glewProgramLocalParameterI4uiNV)
+#define glProgramLocalParameterI4uivNV GLEW_GET_FUN(__glewProgramLocalParameterI4uivNV)
+#define glProgramLocalParametersI4ivNV GLEW_GET_FUN(__glewProgramLocalParametersI4ivNV)
+#define glProgramLocalParametersI4uivNV GLEW_GET_FUN(__glewProgramLocalParametersI4uivNV)
+
+#define GLEW_NV_gpu_program4 GLEW_GET_VAR(__GLEW_NV_gpu_program4)
+
+#endif /* GL_NV_gpu_program4 */
+
+    /* -------------------------- GL_NV_gpu_program4_1 ------------------------- */
+
+#ifndef GL_NV_gpu_program4_1
+#define GL_NV_gpu_program4_1 1
+
+#define GLEW_NV_gpu_program4_1 GLEW_GET_VAR(__GLEW_NV_gpu_program4_1)
+
+#endif /* GL_NV_gpu_program4_1 */
+
+    /* --------------------------- GL_NV_gpu_program5 -------------------------- */
+
+#ifndef GL_NV_gpu_program5
+#define GL_NV_gpu_program5 1
+
+#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_NV 0x00000001
+#define GL_ELEMENT_ARRAY_BARRIER_BIT_NV 0x00000002
+#define GL_UNIFORM_BARRIER_BIT_NV 0x00000004
+#define GL_TEXTURE_FETCH_BARRIER_BIT_NV 0x00000008
+#define GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV 0x00000010
+#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_NV 0x00000020
+#define GL_COMMAND_BARRIER_BIT_NV 0x00000040
+#define GL_PIXEL_BUFFER_BARRIER_BIT_NV 0x00000080
+#define GL_TEXTURE_UPDATE_BARRIER_BIT_NV 0x00000100
+#define GL_BUFFER_UPDATE_BARRIER_BIT_NV 0x00000200
+#define GL_FRAMEBUFFER_BARRIER_BIT_NV 0x00000400
+#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT_NV 0x00000800
+#define GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV 0x8E5A
+#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV 0x8E5B
+#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV 0x8E5C
+#define GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV 0x8E5D
+#define GL_ALL_BARRIER_BITS_NV 0xFFFFFFFF
+
+#define GLEW_NV_gpu_program5 GLEW_GET_VAR(__GLEW_NV_gpu_program5)
+
+#endif /* GL_NV_gpu_program5 */
+
+    /* ------------------------- GL_NV_gpu_program_fp64 ------------------------ */
+
+#ifndef GL_NV_gpu_program_fp64
+#define GL_NV_gpu_program_fp64 1
+
+#define GLEW_NV_gpu_program_fp64 GLEW_GET_VAR(__GLEW_NV_gpu_program_fp64)
+
+#endif /* GL_NV_gpu_program_fp64 */
+
+    /* --------------------------- GL_NV_gpu_shader5 --------------------------- */
+
+#ifndef GL_NV_gpu_shader5
+#define GL_NV_gpu_shader5 1
+
+#define GL_INT64_NV 0x140E
+#define GL_UNSIGNED_INT64_NV 0x140F
+#define GL_INT8_NV 0x8FE0
+#define GL_INT8_VEC2_NV 0x8FE1
+#define GL_INT8_VEC3_NV 0x8FE2
+#define GL_INT8_VEC4_NV 0x8FE3
+#define GL_INT16_NV 0x8FE4
+#define GL_INT16_VEC2_NV 0x8FE5
+#define GL_INT16_VEC3_NV 0x8FE6
+#define GL_INT16_VEC4_NV 0x8FE7
+#define GL_INT64_VEC2_NV 0x8FE9
+#define GL_INT64_VEC3_NV 0x8FEA
+#define GL_INT64_VEC4_NV 0x8FEB
+#define GL_UNSIGNED_INT8_NV 0x8FEC
+#define GL_UNSIGNED_INT8_VEC2_NV 0x8FED
+#define GL_UNSIGNED_INT8_VEC3_NV 0x8FEE
+#define GL_UNSIGNED_INT8_VEC4_NV 0x8FEF
+#define GL_UNSIGNED_INT16_NV 0x8FF0
+#define GL_UNSIGNED_INT16_VEC2_NV 0x8FF1
+#define GL_UNSIGNED_INT16_VEC3_NV 0x8FF2
+#define GL_UNSIGNED_INT16_VEC4_NV 0x8FF3
+#define GL_UNSIGNED_INT64_VEC2_NV 0x8FF5
+#define GL_UNSIGNED_INT64_VEC3_NV 0x8FF6
+#define GL_UNSIGNED_INT64_VEC4_NV 0x8FF7
+#define GL_FLOAT16_NV 0x8FF8
+#define GL_FLOAT16_VEC2_NV 0x8FF9
+#define GL_FLOAT16_VEC3_NV 0x8FFA
+#define GL_FLOAT16_VEC4_NV 0x8FFB
+
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMI64VNVPROC)(GLuint program, GLint location, GLint64EXT *params);
+    typedef void (GLAPIENTRY *PFNGLGETUNIFORMUI64VNVPROC)(GLuint program, GLint location, GLint64EXT *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1I64NVPROC)(GLuint program, GLint location, GLint64EXT x);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM1UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM2UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM3UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORM4UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1I64NVPROC)(GLint location, GLint64EXT x);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1UI64NVPROC)(GLint location, GLuint64EXT x);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM1UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM2UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM3UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
+    typedef void (GLAPIENTRY *PFNGLUNIFORM4UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
+
+#define glGetUniformi64vNV GLEW_GET_FUN(__glewGetUniformi64vNV)
+#define glGetUniformui64vNV GLEW_GET_FUN(__glewGetUniformui64vNV)
+#define glProgramUniform1i64NV GLEW_GET_FUN(__glewProgramUniform1i64NV)
+#define glProgramUniform1i64vNV GLEW_GET_FUN(__glewProgramUniform1i64vNV)
+#define glProgramUniform1ui64NV GLEW_GET_FUN(__glewProgramUniform1ui64NV)
+#define glProgramUniform1ui64vNV GLEW_GET_FUN(__glewProgramUniform1ui64vNV)
+#define glProgramUniform2i64NV GLEW_GET_FUN(__glewProgramUniform2i64NV)
+#define glProgramUniform2i64vNV GLEW_GET_FUN(__glewProgramUniform2i64vNV)
+#define glProgramUniform2ui64NV GLEW_GET_FUN(__glewProgramUniform2ui64NV)
+#define glProgramUniform2ui64vNV GLEW_GET_FUN(__glewProgramUniform2ui64vNV)
+#define glProgramUniform3i64NV GLEW_GET_FUN(__glewProgramUniform3i64NV)
+#define glProgramUniform3i64vNV GLEW_GET_FUN(__glewProgramUniform3i64vNV)
+#define glProgramUniform3ui64NV GLEW_GET_FUN(__glewProgramUniform3ui64NV)
+#define glProgramUniform3ui64vNV GLEW_GET_FUN(__glewProgramUniform3ui64vNV)
+#define glProgramUniform4i64NV GLEW_GET_FUN(__glewProgramUniform4i64NV)
+#define glProgramUniform4i64vNV GLEW_GET_FUN(__glewProgramUniform4i64vNV)
+#define glProgramUniform4ui64NV GLEW_GET_FUN(__glewProgramUniform4ui64NV)
+#define glProgramUniform4ui64vNV GLEW_GET_FUN(__glewProgramUniform4ui64vNV)
+#define glUniform1i64NV GLEW_GET_FUN(__glewUniform1i64NV)
+#define glUniform1i64vNV GLEW_GET_FUN(__glewUniform1i64vNV)
+#define glUniform1ui64NV GLEW_GET_FUN(__glewUniform1ui64NV)
+#define glUniform1ui64vNV GLEW_GET_FUN(__glewUniform1ui64vNV)
+#define glUniform2i64NV GLEW_GET_FUN(__glewUniform2i64NV)
+#define glUniform2i64vNV GLEW_GET_FUN(__glewUniform2i64vNV)
+#define glUniform2ui64NV GLEW_GET_FUN(__glewUniform2ui64NV)
+#define glUniform2ui64vNV GLEW_GET_FUN(__glewUniform2ui64vNV)
+#define glUniform3i64NV GLEW_GET_FUN(__glewUniform3i64NV)
+#define glUniform3i64vNV GLEW_GET_FUN(__glewUniform3i64vNV)
+#define glUniform3ui64NV GLEW_GET_FUN(__glewUniform3ui64NV)
+#define glUniform3ui64vNV GLEW_GET_FUN(__glewUniform3ui64vNV)
+#define glUniform4i64NV GLEW_GET_FUN(__glewUniform4i64NV)
+#define glUniform4i64vNV GLEW_GET_FUN(__glewUniform4i64vNV)
+#define glUniform4ui64NV GLEW_GET_FUN(__glewUniform4ui64NV)
+#define glUniform4ui64vNV GLEW_GET_FUN(__glewUniform4ui64vNV)
+
+#define GLEW_NV_gpu_shader5 GLEW_GET_VAR(__GLEW_NV_gpu_shader5)
+
+#endif /* GL_NV_gpu_shader5 */
+
+    /* ---------------------------- GL_NV_half_float --------------------------- */
+
+#ifndef GL_NV_half_float
+#define GL_NV_half_float 1
+
+#define GL_HALF_FLOAT_NV 0x140B
+
+    typedef unsigned short GLhalf;
+
+    typedef void (GLAPIENTRY *PFNGLCOLOR3HNVPROC)(GLhalf red, GLhalf green, GLhalf blue);
+    typedef void (GLAPIENTRY *PFNGLCOLOR3HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLCOLOR4HNVPROC)(GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
+    typedef void (GLAPIENTRY *PFNGLCOLOR4HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDHNVPROC)(GLhalf fog);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDHVNVPROC)(const GLhalf *fog);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1HNVPROC)(GLenum target, GLhalf s);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD1HVNVPROC)(GLenum target, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2HNVPROC)(GLenum target, GLhalf s, GLhalf t);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD2HVNVPROC)(GLenum target, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3HNVPROC)(GLenum target, GLhalf s, GLhalf t, GLhalf r);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD3HVNVPROC)(GLenum target, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4HNVPROC)(GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
+    typedef void (GLAPIENTRY *PFNGLMULTITEXCOORD4HVNVPROC)(GLenum target, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLNORMAL3HNVPROC)(GLhalf nx, GLhalf ny, GLhalf nz);
+    typedef void (GLAPIENTRY *PFNGLNORMAL3HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3HNVPROC)(GLhalf red, GLhalf green, GLhalf blue);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLOR3HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD1HNVPROC)(GLhalf s);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD1HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2HNVPROC)(GLhalf s, GLhalf t);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD3HNVPROC)(GLhalf s, GLhalf t, GLhalf r);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD3HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD4HNVPROC)(GLhalf s, GLhalf t, GLhalf r, GLhalf q);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD4HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEX2HNVPROC)(GLhalf x, GLhalf y);
+    typedef void (GLAPIENTRY *PFNGLVERTEX2HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEX3HNVPROC)(GLhalf x, GLhalf y, GLhalf z);
+    typedef void (GLAPIENTRY *PFNGLVERTEX3HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEX4HNVPROC)(GLhalf x, GLhalf y, GLhalf z, GLhalf w);
+    typedef void (GLAPIENTRY *PFNGLVERTEX4HVNVPROC)(const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1HNVPROC)(GLuint index, GLhalf x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1HVNVPROC)(GLuint index, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2HNVPROC)(GLuint index, GLhalf x, GLhalf y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2HVNVPROC)(GLuint index, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3HNVPROC)(GLuint index, GLhalf x, GLhalf y, GLhalf z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3HVNVPROC)(GLuint index, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4HNVPROC)(GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4HVNVPROC)(GLuint index, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS1HVNVPROC)(GLuint index, GLsizei n, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS2HVNVPROC)(GLuint index, GLsizei n, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS3HVNVPROC)(GLuint index, GLsizei n, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS4HVNVPROC)(GLuint index, GLsizei n, const GLhalf *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXWEIGHTHNVPROC)(GLhalf weight);
+    typedef void (GLAPIENTRY *PFNGLVERTEXWEIGHTHVNVPROC)(const GLhalf *weight);
+
+#define glColor3hNV GLEW_GET_FUN(__glewColor3hNV)
+#define glColor3hvNV GLEW_GET_FUN(__glewColor3hvNV)
+#define glColor4hNV GLEW_GET_FUN(__glewColor4hNV)
+#define glColor4hvNV GLEW_GET_FUN(__glewColor4hvNV)
+#define glFogCoordhNV GLEW_GET_FUN(__glewFogCoordhNV)
+#define glFogCoordhvNV GLEW_GET_FUN(__glewFogCoordhvNV)
+#define glMultiTexCoord1hNV GLEW_GET_FUN(__glewMultiTexCoord1hNV)
+#define glMultiTexCoord1hvNV GLEW_GET_FUN(__glewMultiTexCoord1hvNV)
+#define glMultiTexCoord2hNV GLEW_GET_FUN(__glewMultiTexCoord2hNV)
+#define glMultiTexCoord2hvNV GLEW_GET_FUN(__glewMultiTexCoord2hvNV)
+#define glMultiTexCoord3hNV GLEW_GET_FUN(__glewMultiTexCoord3hNV)
+#define glMultiTexCoord3hvNV GLEW_GET_FUN(__glewMultiTexCoord3hvNV)
+#define glMultiTexCoord4hNV GLEW_GET_FUN(__glewMultiTexCoord4hNV)
+#define glMultiTexCoord4hvNV GLEW_GET_FUN(__glewMultiTexCoord4hvNV)
+#define glNormal3hNV GLEW_GET_FUN(__glewNormal3hNV)
+#define glNormal3hvNV GLEW_GET_FUN(__glewNormal3hvNV)
+#define glSecondaryColor3hNV GLEW_GET_FUN(__glewSecondaryColor3hNV)
+#define glSecondaryColor3hvNV GLEW_GET_FUN(__glewSecondaryColor3hvNV)
+#define glTexCoord1hNV GLEW_GET_FUN(__glewTexCoord1hNV)
+#define glTexCoord1hvNV GLEW_GET_FUN(__glewTexCoord1hvNV)
+#define glTexCoord2hNV GLEW_GET_FUN(__glewTexCoord2hNV)
+#define glTexCoord2hvNV GLEW_GET_FUN(__glewTexCoord2hvNV)
+#define glTexCoord3hNV GLEW_GET_FUN(__glewTexCoord3hNV)
+#define glTexCoord3hvNV GLEW_GET_FUN(__glewTexCoord3hvNV)
+#define glTexCoord4hNV GLEW_GET_FUN(__glewTexCoord4hNV)
+#define glTexCoord4hvNV GLEW_GET_FUN(__glewTexCoord4hvNV)
+#define glVertex2hNV GLEW_GET_FUN(__glewVertex2hNV)
+#define glVertex2hvNV GLEW_GET_FUN(__glewVertex2hvNV)
+#define glVertex3hNV GLEW_GET_FUN(__glewVertex3hNV)
+#define glVertex3hvNV GLEW_GET_FUN(__glewVertex3hvNV)
+#define glVertex4hNV GLEW_GET_FUN(__glewVertex4hNV)
+#define glVertex4hvNV GLEW_GET_FUN(__glewVertex4hvNV)
+#define glVertexAttrib1hNV GLEW_GET_FUN(__glewVertexAttrib1hNV)
+#define glVertexAttrib1hvNV GLEW_GET_FUN(__glewVertexAttrib1hvNV)
+#define glVertexAttrib2hNV GLEW_GET_FUN(__glewVertexAttrib2hNV)
+#define glVertexAttrib2hvNV GLEW_GET_FUN(__glewVertexAttrib2hvNV)
+#define glVertexAttrib3hNV GLEW_GET_FUN(__glewVertexAttrib3hNV)
+#define glVertexAttrib3hvNV GLEW_GET_FUN(__glewVertexAttrib3hvNV)
+#define glVertexAttrib4hNV GLEW_GET_FUN(__glewVertexAttrib4hNV)
+#define glVertexAttrib4hvNV GLEW_GET_FUN(__glewVertexAttrib4hvNV)
+#define glVertexAttribs1hvNV GLEW_GET_FUN(__glewVertexAttribs1hvNV)
+#define glVertexAttribs2hvNV GLEW_GET_FUN(__glewVertexAttribs2hvNV)
+#define glVertexAttribs3hvNV GLEW_GET_FUN(__glewVertexAttribs3hvNV)
+#define glVertexAttribs4hvNV GLEW_GET_FUN(__glewVertexAttribs4hvNV)
+#define glVertexWeighthNV GLEW_GET_FUN(__glewVertexWeighthNV)
+#define glVertexWeighthvNV GLEW_GET_FUN(__glewVertexWeighthvNV)
+
+#define GLEW_NV_half_float GLEW_GET_VAR(__GLEW_NV_half_float)
+
+#endif /* GL_NV_half_float */
+
+    /* ------------------------ GL_NV_light_max_exponent ----------------------- */
+
+#ifndef GL_NV_light_max_exponent
+#define GL_NV_light_max_exponent 1
+
+#define GL_MAX_SHININESS_NV 0x8504
+#define GL_MAX_SPOT_EXPONENT_NV 0x8505
+
+#define GLEW_NV_light_max_exponent GLEW_GET_VAR(__GLEW_NV_light_max_exponent)
+
+#endif /* GL_NV_light_max_exponent */
+
+    /* --------------------- GL_NV_multisample_filter_hint --------------------- */
+
+#ifndef GL_NV_multisample_filter_hint
+#define GL_NV_multisample_filter_hint 1
+
+#define GL_MULTISAMPLE_FILTER_HINT_NV 0x8534
+
+#define GLEW_NV_multisample_filter_hint GLEW_GET_VAR(__GLEW_NV_multisample_filter_hint)
+
+#endif /* GL_NV_multisample_filter_hint */
+
+    /* ------------------------- GL_NV_occlusion_query ------------------------- */
+
+#ifndef GL_NV_occlusion_query
+#define GL_NV_occlusion_query 1
+
+#define GL_PIXEL_COUNTER_BITS_NV 0x8864
+#define GL_CURRENT_OCCLUSION_QUERY_ID_NV 0x8865
+#define GL_PIXEL_COUNT_NV 0x8866
+#define GL_PIXEL_COUNT_AVAILABLE_NV 0x8867
+
+    typedef void (GLAPIENTRY *PFNGLBEGINOCCLUSIONQUERYNVPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLDELETEOCCLUSIONQUERIESNVPROC)(GLsizei n, const GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLENDOCCLUSIONQUERYNVPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLGENOCCLUSIONQUERIESNVPROC)(GLsizei n, GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLGETOCCLUSIONQUERYIVNVPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETOCCLUSIONQUERYUIVNVPROC)(GLuint id, GLenum pname, GLuint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISOCCLUSIONQUERYNVPROC)(GLuint id);
+
+#define glBeginOcclusionQueryNV GLEW_GET_FUN(__glewBeginOcclusionQueryNV)
+#define glDeleteOcclusionQueriesNV GLEW_GET_FUN(__glewDeleteOcclusionQueriesNV)
+#define glEndOcclusionQueryNV GLEW_GET_FUN(__glewEndOcclusionQueryNV)
+#define glGenOcclusionQueriesNV GLEW_GET_FUN(__glewGenOcclusionQueriesNV)
+#define glGetOcclusionQueryivNV GLEW_GET_FUN(__glewGetOcclusionQueryivNV)
+#define glGetOcclusionQueryuivNV GLEW_GET_FUN(__glewGetOcclusionQueryuivNV)
+#define glIsOcclusionQueryNV GLEW_GET_FUN(__glewIsOcclusionQueryNV)
+
+#define GLEW_NV_occlusion_query GLEW_GET_VAR(__GLEW_NV_occlusion_query)
+
+#endif /* GL_NV_occlusion_query */
+
+    /* ----------------------- GL_NV_packed_depth_stencil ---------------------- */
+
+#ifndef GL_NV_packed_depth_stencil
+#define GL_NV_packed_depth_stencil 1
+
+#define GL_DEPTH_STENCIL_NV 0x84F9
+#define GL_UNSIGNED_INT_24_8_NV 0x84FA
+
+#define GLEW_NV_packed_depth_stencil GLEW_GET_VAR(__GLEW_NV_packed_depth_stencil)
+
+#endif /* GL_NV_packed_depth_stencil */
+
+    /* --------------------- GL_NV_parameter_buffer_object --------------------- */
+
+#ifndef GL_NV_parameter_buffer_object
+#define GL_NV_parameter_buffer_object 1
+
+#define GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV 0x8DA0
+#define GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV 0x8DA1
+#define GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV 0x8DA2
+#define GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV 0x8DA3
+#define GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV 0x8DA4
+
+    typedef void (GLAPIENTRY *PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
+
+#define glProgramBufferParametersIivNV GLEW_GET_FUN(__glewProgramBufferParametersIivNV)
+#define glProgramBufferParametersIuivNV GLEW_GET_FUN(__glewProgramBufferParametersIuivNV)
+#define glProgramBufferParametersfvNV GLEW_GET_FUN(__glewProgramBufferParametersfvNV)
+
+#define GLEW_NV_parameter_buffer_object GLEW_GET_VAR(__GLEW_NV_parameter_buffer_object)
+
+#endif /* GL_NV_parameter_buffer_object */
+
+    /* --------------------- GL_NV_parameter_buffer_object2 -------------------- */
+
+#ifndef GL_NV_parameter_buffer_object2
+#define GL_NV_parameter_buffer_object2 1
+
+#define GLEW_NV_parameter_buffer_object2 GLEW_GET_VAR(__GLEW_NV_parameter_buffer_object2)
+
+#endif /* GL_NV_parameter_buffer_object2 */
+
+    /* ------------------------- GL_NV_pixel_data_range ------------------------ */
+
+#ifndef GL_NV_pixel_data_range
+#define GL_NV_pixel_data_range 1
+
+#define GL_WRITE_PIXEL_DATA_RANGE_NV 0x8878
+#define GL_READ_PIXEL_DATA_RANGE_NV 0x8879
+#define GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV 0x887A
+#define GL_READ_PIXEL_DATA_RANGE_LENGTH_NV 0x887B
+#define GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV 0x887C
+#define GL_READ_PIXEL_DATA_RANGE_POINTER_NV 0x887D
+
+    typedef void (GLAPIENTRY *PFNGLFLUSHPIXELDATARANGENVPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLPIXELDATARANGENVPROC)(GLenum target, GLsizei length, void *pointer);
+
+#define glFlushPixelDataRangeNV GLEW_GET_FUN(__glewFlushPixelDataRangeNV)
+#define glPixelDataRangeNV GLEW_GET_FUN(__glewPixelDataRangeNV)
+
+#define GLEW_NV_pixel_data_range GLEW_GET_VAR(__GLEW_NV_pixel_data_range)
+
+#endif /* GL_NV_pixel_data_range */
+
+    /* --------------------------- GL_NV_point_sprite -------------------------- */
+
+#ifndef GL_NV_point_sprite
+#define GL_NV_point_sprite 1
+
+#define GL_POINT_SPRITE_NV 0x8861
+#define GL_COORD_REPLACE_NV 0x8862
+#define GL_POINT_SPRITE_R_MODE_NV 0x8863
+
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERINVPROC)(GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLPOINTPARAMETERIVNVPROC)(GLenum pname, const GLint *params);
+
+#define glPointParameteriNV GLEW_GET_FUN(__glewPointParameteriNV)
+#define glPointParameterivNV GLEW_GET_FUN(__glewPointParameterivNV)
+
+#define GLEW_NV_point_sprite GLEW_GET_VAR(__GLEW_NV_point_sprite)
+
+#endif /* GL_NV_point_sprite */
+
+    /* -------------------------- GL_NV_present_video -------------------------- */
+
+#ifndef GL_NV_present_video
+#define GL_NV_present_video 1
+
+#define GL_FRAME_NV 0x8E26
+#define GL_FIELDS_NV 0x8E27
+#define GL_CURRENT_TIME_NV 0x8E28
+#define GL_NUM_FILL_STREAMS_NV 0x8E29
+#define GL_PRESENT_TIME_NV 0x8E2A
+#define GL_PRESENT_DURATION_NV 0x8E2B
+
+    typedef void (GLAPIENTRY *PFNGLGETVIDEOI64VNVPROC)(GLuint video_slot, GLenum pname, GLint64EXT *params);
+    typedef void (GLAPIENTRY *PFNGLGETVIDEOIVNVPROC)(GLuint video_slot, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETVIDEOUI64VNVPROC)(GLuint video_slot, GLenum pname, GLuint64EXT *params);
+    typedef void (GLAPIENTRY *PFNGLGETVIDEOUIVNVPROC)(GLuint video_slot, GLenum pname, GLuint *params);
+    typedef void (GLAPIENTRY *PFNGLPRESENTFRAMEDUALFILLNVPROC)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
+    typedef void (GLAPIENTRY *PFNGLPRESENTFRAMEKEYEDNVPROC)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
+
+#define glGetVideoi64vNV GLEW_GET_FUN(__glewGetVideoi64vNV)
+#define glGetVideoivNV GLEW_GET_FUN(__glewGetVideoivNV)
+#define glGetVideoui64vNV GLEW_GET_FUN(__glewGetVideoui64vNV)
+#define glGetVideouivNV GLEW_GET_FUN(__glewGetVideouivNV)
+#define glPresentFrameDualFillNV GLEW_GET_FUN(__glewPresentFrameDualFillNV)
+#define glPresentFrameKeyedNV GLEW_GET_FUN(__glewPresentFrameKeyedNV)
+
+#define GLEW_NV_present_video GLEW_GET_VAR(__GLEW_NV_present_video)
+
+#endif /* GL_NV_present_video */
+
+    /* ------------------------ GL_NV_primitive_restart ------------------------ */
+
+#ifndef GL_NV_primitive_restart
+#define GL_NV_primitive_restart 1
+
+#define GL_PRIMITIVE_RESTART_NV 0x8558
+#define GL_PRIMITIVE_RESTART_INDEX_NV 0x8559
+
+    typedef void (GLAPIENTRY *PFNGLPRIMITIVERESTARTINDEXNVPROC)(GLuint index);
+    typedef void (GLAPIENTRY *PFNGLPRIMITIVERESTARTNVPROC)(void);
+
+#define glPrimitiveRestartIndexNV GLEW_GET_FUN(__glewPrimitiveRestartIndexNV)
+#define glPrimitiveRestartNV GLEW_GET_FUN(__glewPrimitiveRestartNV)
+
+#define GLEW_NV_primitive_restart GLEW_GET_VAR(__GLEW_NV_primitive_restart)
+
+#endif /* GL_NV_primitive_restart */
+
+    /* ------------------------ GL_NV_register_combiners ----------------------- */
+
+#ifndef GL_NV_register_combiners
+#define GL_NV_register_combiners 1
+
+#define GL_REGISTER_COMBINERS_NV 0x8522
+#define GL_VARIABLE_A_NV 0x8523
+#define GL_VARIABLE_B_NV 0x8524
+#define GL_VARIABLE_C_NV 0x8525
+#define GL_VARIABLE_D_NV 0x8526
+#define GL_VARIABLE_E_NV 0x8527
+#define GL_VARIABLE_F_NV 0x8528
+#define GL_VARIABLE_G_NV 0x8529
+#define GL_CONSTANT_COLOR0_NV 0x852A
+#define GL_CONSTANT_COLOR1_NV 0x852B
+#define GL_PRIMARY_COLOR_NV 0x852C
+#define GL_SECONDARY_COLOR_NV 0x852D
+#define GL_SPARE0_NV 0x852E
+#define GL_SPARE1_NV 0x852F
+#define GL_DISCARD_NV 0x8530
+#define GL_E_TIMES_F_NV 0x8531
+#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV 0x8532
+#define GL_UNSIGNED_IDENTITY_NV 0x8536
+#define GL_UNSIGNED_INVERT_NV 0x8537
+#define GL_EXPAND_NORMAL_NV 0x8538
+#define GL_EXPAND_NEGATE_NV 0x8539
+#define GL_HALF_BIAS_NORMAL_NV 0x853A
+#define GL_HALF_BIAS_NEGATE_NV 0x853B
+#define GL_SIGNED_IDENTITY_NV 0x853C
+#define GL_SIGNED_NEGATE_NV 0x853D
+#define GL_SCALE_BY_TWO_NV 0x853E
+#define GL_SCALE_BY_FOUR_NV 0x853F
+#define GL_SCALE_BY_ONE_HALF_NV 0x8540
+#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV 0x8541
+#define GL_COMBINER_INPUT_NV 0x8542
+#define GL_COMBINER_MAPPING_NV 0x8543
+#define GL_COMBINER_COMPONENT_USAGE_NV 0x8544
+#define GL_COMBINER_AB_DOT_PRODUCT_NV 0x8545
+#define GL_COMBINER_CD_DOT_PRODUCT_NV 0x8546
+#define GL_COMBINER_MUX_SUM_NV 0x8547
+#define GL_COMBINER_SCALE_NV 0x8548
+#define GL_COMBINER_BIAS_NV 0x8549
+#define GL_COMBINER_AB_OUTPUT_NV 0x854A
+#define GL_COMBINER_CD_OUTPUT_NV 0x854B
+#define GL_COMBINER_SUM_OUTPUT_NV 0x854C
+#define GL_MAX_GENERAL_COMBINERS_NV 0x854D
+#define GL_NUM_GENERAL_COMBINERS_NV 0x854E
+#define GL_COLOR_SUM_CLAMP_NV 0x854F
+#define GL_COMBINER0_NV 0x8550
+#define GL_COMBINER1_NV 0x8551
+#define GL_COMBINER2_NV 0x8552
+#define GL_COMBINER3_NV 0x8553
+#define GL_COMBINER4_NV 0x8554
+#define GL_COMBINER5_NV 0x8555
+#define GL_COMBINER6_NV 0x8556
+#define GL_COMBINER7_NV 0x8557
+
+    typedef void (GLAPIENTRY *PFNGLCOMBINERINPUTNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
+    typedef void (GLAPIENTRY *PFNGLCOMBINEROUTPUTNVPROC)(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
+    typedef void (GLAPIENTRY *PFNGLCOMBINERPARAMETERFNVPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLCOMBINERPARAMETERFVNVPROC)(GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLCOMBINERPARAMETERINVPROC)(GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLCOMBINERPARAMETERIVNVPROC)(GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLFINALCOMBINERINPUTNVPROC)(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
+    typedef void (GLAPIENTRY *PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)(GLenum variable, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)(GLenum variable, GLenum pname, GLint *params);
+
+#define glCombinerInputNV GLEW_GET_FUN(__glewCombinerInputNV)
+#define glCombinerOutputNV GLEW_GET_FUN(__glewCombinerOutputNV)
+#define glCombinerParameterfNV GLEW_GET_FUN(__glewCombinerParameterfNV)
+#define glCombinerParameterfvNV GLEW_GET_FUN(__glewCombinerParameterfvNV)
+#define glCombinerParameteriNV GLEW_GET_FUN(__glewCombinerParameteriNV)
+#define glCombinerParameterivNV GLEW_GET_FUN(__glewCombinerParameterivNV)
+#define glFinalCombinerInputNV GLEW_GET_FUN(__glewFinalCombinerInputNV)
+#define glGetCombinerInputParameterfvNV GLEW_GET_FUN(__glewGetCombinerInputParameterfvNV)
+#define glGetCombinerInputParameterivNV GLEW_GET_FUN(__glewGetCombinerInputParameterivNV)
+#define glGetCombinerOutputParameterfvNV GLEW_GET_FUN(__glewGetCombinerOutputParameterfvNV)
+#define glGetCombinerOutputParameterivNV GLEW_GET_FUN(__glewGetCombinerOutputParameterivNV)
+#define glGetFinalCombinerInputParameterfvNV GLEW_GET_FUN(__glewGetFinalCombinerInputParameterfvNV)
+#define glGetFinalCombinerInputParameterivNV GLEW_GET_FUN(__glewGetFinalCombinerInputParameterivNV)
+
+#define GLEW_NV_register_combiners GLEW_GET_VAR(__GLEW_NV_register_combiners)
+
+#endif /* GL_NV_register_combiners */
+
+    /* ----------------------- GL_NV_register_combiners2 ----------------------- */
+
+#ifndef GL_NV_register_combiners2
+#define GL_NV_register_combiners2 1
+
+#define GL_PER_STAGE_CONSTANTS_NV 0x8535
+
+    typedef void (GLAPIENTRY *PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, GLfloat *params);
+
+#define glCombinerStageParameterfvNV GLEW_GET_FUN(__glewCombinerStageParameterfvNV)
+#define glGetCombinerStageParameterfvNV GLEW_GET_FUN(__glewGetCombinerStageParameterfvNV)
+
+#define GLEW_NV_register_combiners2 GLEW_GET_VAR(__GLEW_NV_register_combiners2)
+
+#endif /* GL_NV_register_combiners2 */
+
+    /* ------------------------ GL_NV_shader_buffer_load ----------------------- */
+
+#ifndef GL_NV_shader_buffer_load
+#define GL_NV_shader_buffer_load 1
+
+#define GL_BUFFER_GPU_ADDRESS_NV 0x8F1D
+#define GL_GPU_ADDRESS_NV 0x8F34
+#define GL_MAX_SHADER_BUFFER_ADDRESS_NV 0x8F35
+
+    typedef void (GLAPIENTRY *PFNGLGETBUFFERPARAMETERUI64VNVPROC)(GLenum target, GLenum pname, GLuint64EXT *params);
+    typedef void (GLAPIENTRY *PFNGLGETINTEGERUI64VNVPROC)(GLenum value, GLuint64EXT *result);
+    typedef void (GLAPIENTRY *PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC)(GLuint buffer, GLenum pname, GLuint64EXT *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISBUFFERRESIDENTNVPROC)(GLenum target);
+    typedef GLboolean(GLAPIENTRY *PFNGLISNAMEDBUFFERRESIDENTNVPROC)(GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLMAKEBUFFERNONRESIDENTNVPROC)(GLenum target);
+    typedef void (GLAPIENTRY *PFNGLMAKEBUFFERRESIDENTNVPROC)(GLenum target, GLenum access);
+    typedef void (GLAPIENTRY *PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC)(GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLMAKENAMEDBUFFERRESIDENTNVPROC)(GLuint buffer, GLenum access);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMUI64NVPROC)(GLuint program, GLint location, GLuint64EXT value);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMUNIFORMUI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMUI64NVPROC)(GLint location, GLuint64EXT value);
+    typedef void (GLAPIENTRY *PFNGLUNIFORMUI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
+
+#define glGetBufferParameterui64vNV GLEW_GET_FUN(__glewGetBufferParameterui64vNV)
+#define glGetIntegerui64vNV GLEW_GET_FUN(__glewGetIntegerui64vNV)
+#define glGetNamedBufferParameterui64vNV GLEW_GET_FUN(__glewGetNamedBufferParameterui64vNV)
+#define glIsBufferResidentNV GLEW_GET_FUN(__glewIsBufferResidentNV)
+#define glIsNamedBufferResidentNV GLEW_GET_FUN(__glewIsNamedBufferResidentNV)
+#define glMakeBufferNonResidentNV GLEW_GET_FUN(__glewMakeBufferNonResidentNV)
+#define glMakeBufferResidentNV GLEW_GET_FUN(__glewMakeBufferResidentNV)
+#define glMakeNamedBufferNonResidentNV GLEW_GET_FUN(__glewMakeNamedBufferNonResidentNV)
+#define glMakeNamedBufferResidentNV GLEW_GET_FUN(__glewMakeNamedBufferResidentNV)
+#define glProgramUniformui64NV GLEW_GET_FUN(__glewProgramUniformui64NV)
+#define glProgramUniformui64vNV GLEW_GET_FUN(__glewProgramUniformui64vNV)
+#define glUniformui64NV GLEW_GET_FUN(__glewUniformui64NV)
+#define glUniformui64vNV GLEW_GET_FUN(__glewUniformui64vNV)
+
+#define GLEW_NV_shader_buffer_load GLEW_GET_VAR(__GLEW_NV_shader_buffer_load)
+
+#endif /* GL_NV_shader_buffer_load */
+
+    /* ---------------------- GL_NV_tessellation_program5 ---------------------- */
+
+#ifndef GL_NV_tessellation_program5
+#define GL_NV_tessellation_program5 1
+
+#define GL_PATCHES_NV 0xE
+#define GL_MAX_PROGRAM_PATCH_ATTRIBS_NV 0x86D8
+#define GL_TESS_CONTROL_PROGRAM_NV 0x891E
+#define GL_TESS_EVALUATION_PROGRAM_NV 0x891F
+#define GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV 0x8C74
+#define GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV 0x8C75
+#define GL_PATCH_VERTICES_NV 0x8E72
+#define GL_PATCH_DEFAULT_INNER_LEVEL_NV 0x8E73
+#define GL_PATCH_DEFAULT_OUTER_LEVEL_NV 0x8E74
+#define GL_MAX_PATCH_VERTICES_NV 0x8E7D
+#define GL_MAX_TESS_GEN_LEVEL_NV 0x8E7E
+#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_NV 0x8E81
+#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_NV 0x8E82
+
+    typedef void (GLAPIENTRY *PFNGLPATCHPARAMETERFVNVPROC)(GLenum pname, const GLfloat *values);
+    typedef void (GLAPIENTRY *PFNGLPATCHPARAMETERINVPROC)(GLenum pname, GLint value);
+
+#define glPatchParameterfvNV GLEW_GET_FUN(__glewPatchParameterfvNV)
+#define glPatchParameteriNV GLEW_GET_FUN(__glewPatchParameteriNV)
+
+#define GLEW_NV_tessellation_program5 GLEW_GET_VAR(__GLEW_NV_tessellation_program5)
+
+#endif /* GL_NV_tessellation_program5 */
+
+    /* -------------------------- GL_NV_texgen_emboss -------------------------- */
+
+#ifndef GL_NV_texgen_emboss
+#define GL_NV_texgen_emboss 1
+
+#define GL_EMBOSS_LIGHT_NV 0x855D
+#define GL_EMBOSS_CONSTANT_NV 0x855E
+#define GL_EMBOSS_MAP_NV 0x855F
+
+#define GLEW_NV_texgen_emboss GLEW_GET_VAR(__GLEW_NV_texgen_emboss)
+
+#endif /* GL_NV_texgen_emboss */
+
+    /* ------------------------ GL_NV_texgen_reflection ------------------------ */
+
+#ifndef GL_NV_texgen_reflection
+#define GL_NV_texgen_reflection 1
+
+#define GL_NORMAL_MAP_NV 0x8511
+#define GL_REFLECTION_MAP_NV 0x8512
+
+#define GLEW_NV_texgen_reflection GLEW_GET_VAR(__GLEW_NV_texgen_reflection)
+
+#endif /* GL_NV_texgen_reflection */
+
+    /* ------------------------- GL_NV_texture_barrier ------------------------- */
+
+#ifndef GL_NV_texture_barrier
+#define GL_NV_texture_barrier 1
+
+    typedef void (GLAPIENTRY *PFNGLTEXTUREBARRIERNVPROC)(void);
+
+#define glTextureBarrierNV GLEW_GET_FUN(__glewTextureBarrierNV)
+
+#define GLEW_NV_texture_barrier GLEW_GET_VAR(__GLEW_NV_texture_barrier)
+
+#endif /* GL_NV_texture_barrier */
+
+    /* --------------------- GL_NV_texture_compression_vtc --------------------- */
+
+#ifndef GL_NV_texture_compression_vtc
+#define GL_NV_texture_compression_vtc 1
+
+#define GLEW_NV_texture_compression_vtc GLEW_GET_VAR(__GLEW_NV_texture_compression_vtc)
+
+#endif /* GL_NV_texture_compression_vtc */
+
+    /* ----------------------- GL_NV_texture_env_combine4 ---------------------- */
+
+#ifndef GL_NV_texture_env_combine4
+#define GL_NV_texture_env_combine4 1
+
+#define GL_COMBINE4_NV 0x8503
+#define GL_SOURCE3_RGB_NV 0x8583
+#define GL_SOURCE3_ALPHA_NV 0x858B
+#define GL_OPERAND3_RGB_NV 0x8593
+#define GL_OPERAND3_ALPHA_NV 0x859B
+
+#define GLEW_NV_texture_env_combine4 GLEW_GET_VAR(__GLEW_NV_texture_env_combine4)
+
+#endif /* GL_NV_texture_env_combine4 */
+
+    /* ---------------------- GL_NV_texture_expand_normal ---------------------- */
+
+#ifndef GL_NV_texture_expand_normal
+#define GL_NV_texture_expand_normal 1
+
+#define GL_TEXTURE_UNSIGNED_REMAP_MODE_NV 0x888F
+
+#define GLEW_NV_texture_expand_normal GLEW_GET_VAR(__GLEW_NV_texture_expand_normal)
+
+#endif /* GL_NV_texture_expand_normal */
+
+    /* ----------------------- GL_NV_texture_multisample ----------------------- */
+
+#ifndef GL_NV_texture_multisample
+#define GL_NV_texture_multisample 1
+
+#define GL_TEXTURE_COVERAGE_SAMPLES_NV 0x9045
+#define GL_TEXTURE_COLOR_SAMPLES_NV 0x9046
+
+    typedef void (GLAPIENTRY *PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
+    typedef void (GLAPIENTRY *PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
+    typedef void (GLAPIENTRY *PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
+
+#define glTexImage2DMultisampleCoverageNV GLEW_GET_FUN(__glewTexImage2DMultisampleCoverageNV)
+#define glTexImage3DMultisampleCoverageNV GLEW_GET_FUN(__glewTexImage3DMultisampleCoverageNV)
+#define glTextureImage2DMultisampleCoverageNV GLEW_GET_FUN(__glewTextureImage2DMultisampleCoverageNV)
+#define glTextureImage2DMultisampleNV GLEW_GET_FUN(__glewTextureImage2DMultisampleNV)
+#define glTextureImage3DMultisampleCoverageNV GLEW_GET_FUN(__glewTextureImage3DMultisampleCoverageNV)
+#define glTextureImage3DMultisampleNV GLEW_GET_FUN(__glewTextureImage3DMultisampleNV)
+
+#define GLEW_NV_texture_multisample GLEW_GET_VAR(__GLEW_NV_texture_multisample)
+
+#endif /* GL_NV_texture_multisample */
+
+    /* ------------------------ GL_NV_texture_rectangle ------------------------ */
+
+#ifndef GL_NV_texture_rectangle
+#define GL_NV_texture_rectangle 1
+
+#define GL_TEXTURE_RECTANGLE_NV 0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE_NV 0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE_NV 0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE_NV 0x84F8
+
+#define GLEW_NV_texture_rectangle GLEW_GET_VAR(__GLEW_NV_texture_rectangle)
+
+#endif /* GL_NV_texture_rectangle */
+
+    /* -------------------------- GL_NV_texture_shader ------------------------- */
+
+#ifndef GL_NV_texture_shader
+#define GL_NV_texture_shader 1
+
+#define GL_OFFSET_TEXTURE_RECTANGLE_NV 0x864C
+#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV 0x864D
+#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV 0x864E
+#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV 0x86D9
+#define GL_UNSIGNED_INT_S8_S8_8_8_NV 0x86DA
+#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV 0x86DB
+#define GL_DSDT_MAG_INTENSITY_NV 0x86DC
+#define GL_SHADER_CONSISTENT_NV 0x86DD
+#define GL_TEXTURE_SHADER_NV 0x86DE
+#define GL_SHADER_OPERATION_NV 0x86DF
+#define GL_CULL_MODES_NV 0x86E0
+#define GL_OFFSET_TEXTURE_2D_MATRIX_NV 0x86E1
+#define GL_OFFSET_TEXTURE_MATRIX_NV 0x86E1
+#define GL_OFFSET_TEXTURE_2D_SCALE_NV 0x86E2
+#define GL_OFFSET_TEXTURE_SCALE_NV 0x86E2
+#define GL_OFFSET_TEXTURE_BIAS_NV 0x86E3
+#define GL_OFFSET_TEXTURE_2D_BIAS_NV 0x86E3
+#define GL_PREVIOUS_TEXTURE_INPUT_NV 0x86E4
+#define GL_CONST_EYE_NV 0x86E5
+#define GL_PASS_THROUGH_NV 0x86E6
+#define GL_CULL_FRAGMENT_NV 0x86E7
+#define GL_OFFSET_TEXTURE_2D_NV 0x86E8
+#define GL_DEPENDENT_AR_TEXTURE_2D_NV 0x86E9
+#define GL_DEPENDENT_GB_TEXTURE_2D_NV 0x86EA
+#define GL_DOT_PRODUCT_NV 0x86EC
+#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV 0x86ED
+#define GL_DOT_PRODUCT_TEXTURE_2D_NV 0x86EE
+#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV 0x86F0
+#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV 0x86F1
+#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV 0x86F2
+#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3
+#define GL_HILO_NV 0x86F4
+#define GL_DSDT_NV 0x86F5
+#define GL_DSDT_MAG_NV 0x86F6
+#define GL_DSDT_MAG_VIB_NV 0x86F7
+#define GL_HILO16_NV 0x86F8
+#define GL_SIGNED_HILO_NV 0x86F9
+#define GL_SIGNED_HILO16_NV 0x86FA
+#define GL_SIGNED_RGBA_NV 0x86FB
+#define GL_SIGNED_RGBA8_NV 0x86FC
+#define GL_SIGNED_RGB_NV 0x86FE
+#define GL_SIGNED_RGB8_NV 0x86FF
+#define GL_SIGNED_LUMINANCE_NV 0x8701
+#define GL_SIGNED_LUMINANCE8_NV 0x8702
+#define GL_SIGNED_LUMINANCE_ALPHA_NV 0x8703
+#define GL_SIGNED_LUMINANCE8_ALPHA8_NV 0x8704
+#define GL_SIGNED_ALPHA_NV 0x8705
+#define GL_SIGNED_ALPHA8_NV 0x8706
+#define GL_SIGNED_INTENSITY_NV 0x8707
+#define GL_SIGNED_INTENSITY8_NV 0x8708
+#define GL_DSDT8_NV 0x8709
+#define GL_DSDT8_MAG8_NV 0x870A
+#define GL_DSDT8_MAG8_INTENSITY8_NV 0x870B
+#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV 0x870C
+#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
+#define GL_HI_SCALE_NV 0x870E
+#define GL_LO_SCALE_NV 0x870F
+#define GL_DS_SCALE_NV 0x8710
+#define GL_DT_SCALE_NV 0x8711
+#define GL_MAGNITUDE_SCALE_NV 0x8712
+#define GL_VIBRANCE_SCALE_NV 0x8713
+#define GL_HI_BIAS_NV 0x8714
+#define GL_LO_BIAS_NV 0x8715
+#define GL_DS_BIAS_NV 0x8716
+#define GL_DT_BIAS_NV 0x8717
+#define GL_MAGNITUDE_BIAS_NV 0x8718
+#define GL_VIBRANCE_BIAS_NV 0x8719
+#define GL_TEXTURE_BORDER_VALUES_NV 0x871A
+#define GL_TEXTURE_HI_SIZE_NV 0x871B
+#define GL_TEXTURE_LO_SIZE_NV 0x871C
+#define GL_TEXTURE_DS_SIZE_NV 0x871D
+#define GL_TEXTURE_DT_SIZE_NV 0x871E
+#define GL_TEXTURE_MAG_SIZE_NV 0x871F
+
+#define GLEW_NV_texture_shader GLEW_GET_VAR(__GLEW_NV_texture_shader)
+
+#endif /* GL_NV_texture_shader */
+
+    /* ------------------------- GL_NV_texture_shader2 ------------------------- */
+
+#ifndef GL_NV_texture_shader2
+#define GL_NV_texture_shader2 1
+
+#define GL_UNSIGNED_INT_S8_S8_8_8_NV 0x86DA
+#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV 0x86DB
+#define GL_DSDT_MAG_INTENSITY_NV 0x86DC
+#define GL_DOT_PRODUCT_TEXTURE_3D_NV 0x86EF
+#define GL_HILO_NV 0x86F4
+#define GL_DSDT_NV 0x86F5
+#define GL_DSDT_MAG_NV 0x86F6
+#define GL_DSDT_MAG_VIB_NV 0x86F7
+#define GL_HILO16_NV 0x86F8
+#define GL_SIGNED_HILO_NV 0x86F9
+#define GL_SIGNED_HILO16_NV 0x86FA
+#define GL_SIGNED_RGBA_NV 0x86FB
+#define GL_SIGNED_RGBA8_NV 0x86FC
+#define GL_SIGNED_RGB_NV 0x86FE
+#define GL_SIGNED_RGB8_NV 0x86FF
+#define GL_SIGNED_LUMINANCE_NV 0x8701
+#define GL_SIGNED_LUMINANCE8_NV 0x8702
+#define GL_SIGNED_LUMINANCE_ALPHA_NV 0x8703
+#define GL_SIGNED_LUMINANCE8_ALPHA8_NV 0x8704
+#define GL_SIGNED_ALPHA_NV 0x8705
+#define GL_SIGNED_ALPHA8_NV 0x8706
+#define GL_SIGNED_INTENSITY_NV 0x8707
+#define GL_SIGNED_INTENSITY8_NV 0x8708
+#define GL_DSDT8_NV 0x8709
+#define GL_DSDT8_MAG8_NV 0x870A
+#define GL_DSDT8_MAG8_INTENSITY8_NV 0x870B
+#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV 0x870C
+#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
+
+#define GLEW_NV_texture_shader2 GLEW_GET_VAR(__GLEW_NV_texture_shader2)
+
+#endif /* GL_NV_texture_shader2 */
+
+    /* ------------------------- GL_NV_texture_shader3 ------------------------- */
+
+#ifndef GL_NV_texture_shader3
+#define GL_NV_texture_shader3 1
+
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV 0x8850
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV 0x8851
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8852
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV 0x8853
+#define GL_OFFSET_HILO_TEXTURE_2D_NV 0x8854
+#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV 0x8855
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV 0x8856
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8857
+#define GL_DEPENDENT_HILO_TEXTURE_2D_NV 0x8858
+#define GL_DEPENDENT_RGB_TEXTURE_3D_NV 0x8859
+#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV 0x885A
+#define GL_DOT_PRODUCT_PASS_THROUGH_NV 0x885B
+#define GL_DOT_PRODUCT_TEXTURE_1D_NV 0x885C
+#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV 0x885D
+#define GL_HILO8_NV 0x885E
+#define GL_SIGNED_HILO8_NV 0x885F
+#define GL_FORCE_BLUE_TO_ONE_NV 0x8860
+
+#define GLEW_NV_texture_shader3 GLEW_GET_VAR(__GLEW_NV_texture_shader3)
+
+#endif /* GL_NV_texture_shader3 */
+
+    /* ------------------------ GL_NV_transform_feedback ----------------------- */
+
+#ifndef GL_NV_transform_feedback
+#define GL_NV_transform_feedback 1
+
+#define GL_BACK_PRIMARY_COLOR_NV 0x8C77
+#define GL_BACK_SECONDARY_COLOR_NV 0x8C78
+#define GL_TEXTURE_COORD_NV 0x8C79
+#define GL_CLIP_DISTANCE_NV 0x8C7A
+#define GL_VERTEX_ID_NV 0x8C7B
+#define GL_PRIMITIVE_ID_NV 0x8C7C
+#define GL_GENERIC_ATTRIB_NV 0x8C7D
+#define GL_TRANSFORM_FEEDBACK_ATTRIBS_NV 0x8C7E
+#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV 0x8C7F
+#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV 0x8C80
+#define GL_ACTIVE_VARYINGS_NV 0x8C81
+#define GL_ACTIVE_VARYING_MAX_LENGTH_NV 0x8C82
+#define GL_TRANSFORM_FEEDBACK_VARYINGS_NV 0x8C83
+#define GL_TRANSFORM_FEEDBACK_BUFFER_START_NV 0x8C84
+#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV 0x8C85
+#define GL_TRANSFORM_FEEDBACK_RECORD_NV 0x8C86
+#define GL_PRIMITIVES_GENERATED_NV 0x8C87
+#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV 0x8C88
+#define GL_RASTERIZER_DISCARD_NV 0x8C89
+#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV 0x8C8A
+#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV 0x8C8B
+#define GL_INTERLEAVED_ATTRIBS_NV 0x8C8C
+#define GL_SEPARATE_ATTRIBS_NV 0x8C8D
+#define GL_TRANSFORM_FEEDBACK_BUFFER_NV 0x8C8E
+#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV 0x8C8F
+
+    typedef void (GLAPIENTRY *PFNGLACTIVEVARYINGNVPROC)(GLuint program, const GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLBEGINTRANSFORMFEEDBACKNVPROC)(GLenum primitiveMode);
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFERBASENVPROC)(GLenum target, GLuint index, GLuint buffer);
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFEROFFSETNVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
+    typedef void (GLAPIENTRY *PFNGLBINDBUFFERRANGENVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
+    typedef void (GLAPIENTRY *PFNGLENDTRANSFORMFEEDBACKNVPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLGETACTIVEVARYINGNVPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)(GLuint program, GLuint index, GLint *location);
+    typedef GLint(GLAPIENTRY *PFNGLGETVARYINGLOCATIONNVPROC)(GLuint program, const GLchar *name);
+    typedef void (GLAPIENTRY *PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)(GLuint count, const GLint *attribs, GLenum bufferMode);
+    typedef void (GLAPIENTRY *PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
+
+#define glActiveVaryingNV GLEW_GET_FUN(__glewActiveVaryingNV)
+#define glBeginTransformFeedbackNV GLEW_GET_FUN(__glewBeginTransformFeedbackNV)
+#define glBindBufferBaseNV GLEW_GET_FUN(__glewBindBufferBaseNV)
+#define glBindBufferOffsetNV GLEW_GET_FUN(__glewBindBufferOffsetNV)
+#define glBindBufferRangeNV GLEW_GET_FUN(__glewBindBufferRangeNV)
+#define glEndTransformFeedbackNV GLEW_GET_FUN(__glewEndTransformFeedbackNV)
+#define glGetActiveVaryingNV GLEW_GET_FUN(__glewGetActiveVaryingNV)
+#define glGetTransformFeedbackVaryingNV GLEW_GET_FUN(__glewGetTransformFeedbackVaryingNV)
+#define glGetVaryingLocationNV GLEW_GET_FUN(__glewGetVaryingLocationNV)
+#define glTransformFeedbackAttribsNV GLEW_GET_FUN(__glewTransformFeedbackAttribsNV)
+#define glTransformFeedbackVaryingsNV GLEW_GET_FUN(__glewTransformFeedbackVaryingsNV)
+
+#define GLEW_NV_transform_feedback GLEW_GET_VAR(__GLEW_NV_transform_feedback)
+
+#endif /* GL_NV_transform_feedback */
+
+    /* ----------------------- GL_NV_transform_feedback2 ----------------------- */
+
+#ifndef GL_NV_transform_feedback2
+#define GL_NV_transform_feedback2 1
+
+#define GL_TRANSFORM_FEEDBACK_NV 0x8E22
+#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV 0x8E23
+#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV 0x8E24
+#define GL_TRANSFORM_FEEDBACK_BINDING_NV 0x8E25
+
+    typedef void (GLAPIENTRY *PFNGLBINDTRANSFORMFEEDBACKNVPROC)(GLenum target, GLuint id);
+    typedef void (GLAPIENTRY *PFNGLDELETETRANSFORMFEEDBACKSNVPROC)(GLsizei n, const GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLDRAWTRANSFORMFEEDBACKNVPROC)(GLenum mode, GLuint id);
+    typedef void (GLAPIENTRY *PFNGLGENTRANSFORMFEEDBACKSNVPROC)(GLsizei n, GLuint *ids);
+    typedef GLboolean(GLAPIENTRY *PFNGLISTRANSFORMFEEDBACKNVPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLPAUSETRANSFORMFEEDBACKNVPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLRESUMETRANSFORMFEEDBACKNVPROC)(void);
+
+#define glBindTransformFeedbackNV GLEW_GET_FUN(__glewBindTransformFeedbackNV)
+#define glDeleteTransformFeedbacksNV GLEW_GET_FUN(__glewDeleteTransformFeedbacksNV)
+#define glDrawTransformFeedbackNV GLEW_GET_FUN(__glewDrawTransformFeedbackNV)
+#define glGenTransformFeedbacksNV GLEW_GET_FUN(__glewGenTransformFeedbacksNV)
+#define glIsTransformFeedbackNV GLEW_GET_FUN(__glewIsTransformFeedbackNV)
+#define glPauseTransformFeedbackNV GLEW_GET_FUN(__glewPauseTransformFeedbackNV)
+#define glResumeTransformFeedbackNV GLEW_GET_FUN(__glewResumeTransformFeedbackNV)
+
+#define GLEW_NV_transform_feedback2 GLEW_GET_VAR(__GLEW_NV_transform_feedback2)
+
+#endif /* GL_NV_transform_feedback2 */
+
+    /* ------------------------ GL_NV_vertex_array_range ----------------------- */
+
+#ifndef GL_NV_vertex_array_range
+#define GL_NV_vertex_array_range 1
+
+#define GL_VERTEX_ARRAY_RANGE_NV 0x851D
+#define GL_VERTEX_ARRAY_RANGE_LENGTH_NV 0x851E
+#define GL_VERTEX_ARRAY_RANGE_VALID_NV 0x851F
+#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV 0x8520
+#define GL_VERTEX_ARRAY_RANGE_POINTER_NV 0x8521
+
+    typedef void (GLAPIENTRY *PFNGLFLUSHVERTEXARRAYRANGENVPROC)(void);
+    typedef void (GLAPIENTRY *PFNGLVERTEXARRAYRANGENVPROC)(GLsizei length, void *pointer);
+
+#define glFlushVertexArrayRangeNV GLEW_GET_FUN(__glewFlushVertexArrayRangeNV)
+#define glVertexArrayRangeNV GLEW_GET_FUN(__glewVertexArrayRangeNV)
+
+#define GLEW_NV_vertex_array_range GLEW_GET_VAR(__GLEW_NV_vertex_array_range)
+
+#endif /* GL_NV_vertex_array_range */
+
+    /* ----------------------- GL_NV_vertex_array_range2 ----------------------- */
+
+#ifndef GL_NV_vertex_array_range2
+#define GL_NV_vertex_array_range2 1
+
+#define GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV 0x8533
+
+#define GLEW_NV_vertex_array_range2 GLEW_GET_VAR(__GLEW_NV_vertex_array_range2)
+
+#endif /* GL_NV_vertex_array_range2 */
+
+    /* ------------------- GL_NV_vertex_attrib_integer_64bit ------------------- */
+
+#ifndef GL_NV_vertex_attrib_integer_64bit
+#define GL_NV_vertex_attrib_integer_64bit 1
+
+#define GL_INT64_NV 0x140E
+#define GL_UNSIGNED_INT64_NV 0x140F
+
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBLI64VNVPROC)(GLuint index, GLenum pname, GLint64EXT *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBLUI64VNVPROC)(GLuint index, GLenum pname, GLuint64EXT *params);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL1I64NVPROC)(GLuint index, GLint64EXT x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL1I64VNVPROC)(GLuint index, const GLint64EXT *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL1UI64NVPROC)(GLuint index, GLuint64EXT x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL1UI64VNVPROC)(GLuint index, const GLuint64EXT *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL2I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL2I64VNVPROC)(GLuint index, const GLint64EXT *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL2UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL2UI64VNVPROC)(GLuint index, const GLuint64EXT *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL3I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL3I64VNVPROC)(GLuint index, const GLint64EXT *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL3UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL3UI64VNVPROC)(GLuint index, const GLuint64EXT *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL4I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL4I64VNVPROC)(GLuint index, const GLint64EXT *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL4UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBL4UI64VNVPROC)(GLuint index, const GLuint64EXT *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBLFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride);
+
+#define glGetVertexAttribLi64vNV GLEW_GET_FUN(__glewGetVertexAttribLi64vNV)
+#define glGetVertexAttribLui64vNV GLEW_GET_FUN(__glewGetVertexAttribLui64vNV)
+#define glVertexAttribL1i64NV GLEW_GET_FUN(__glewVertexAttribL1i64NV)
+#define glVertexAttribL1i64vNV GLEW_GET_FUN(__glewVertexAttribL1i64vNV)
+#define glVertexAttribL1ui64NV GLEW_GET_FUN(__glewVertexAttribL1ui64NV)
+#define glVertexAttribL1ui64vNV GLEW_GET_FUN(__glewVertexAttribL1ui64vNV)
+#define glVertexAttribL2i64NV GLEW_GET_FUN(__glewVertexAttribL2i64NV)
+#define glVertexAttribL2i64vNV GLEW_GET_FUN(__glewVertexAttribL2i64vNV)
+#define glVertexAttribL2ui64NV GLEW_GET_FUN(__glewVertexAttribL2ui64NV)
+#define glVertexAttribL2ui64vNV GLEW_GET_FUN(__glewVertexAttribL2ui64vNV)
+#define glVertexAttribL3i64NV GLEW_GET_FUN(__glewVertexAttribL3i64NV)
+#define glVertexAttribL3i64vNV GLEW_GET_FUN(__glewVertexAttribL3i64vNV)
+#define glVertexAttribL3ui64NV GLEW_GET_FUN(__glewVertexAttribL3ui64NV)
+#define glVertexAttribL3ui64vNV GLEW_GET_FUN(__glewVertexAttribL3ui64vNV)
+#define glVertexAttribL4i64NV GLEW_GET_FUN(__glewVertexAttribL4i64NV)
+#define glVertexAttribL4i64vNV GLEW_GET_FUN(__glewVertexAttribL4i64vNV)
+#define glVertexAttribL4ui64NV GLEW_GET_FUN(__glewVertexAttribL4ui64NV)
+#define glVertexAttribL4ui64vNV GLEW_GET_FUN(__glewVertexAttribL4ui64vNV)
+#define glVertexAttribLFormatNV GLEW_GET_FUN(__glewVertexAttribLFormatNV)
+
+#define GLEW_NV_vertex_attrib_integer_64bit GLEW_GET_VAR(__GLEW_NV_vertex_attrib_integer_64bit)
+
+#endif /* GL_NV_vertex_attrib_integer_64bit */
+
+    /* ------------------- GL_NV_vertex_buffer_unified_memory ------------------ */
+
+#ifndef GL_NV_vertex_buffer_unified_memory
+#define GL_NV_vertex_buffer_unified_memory 1
+
+#define GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV 0x8F1E
+#define GL_ELEMENT_ARRAY_UNIFIED_NV 0x8F1F
+#define GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV 0x8F20
+#define GL_VERTEX_ARRAY_ADDRESS_NV 0x8F21
+#define GL_NORMAL_ARRAY_ADDRESS_NV 0x8F22
+#define GL_COLOR_ARRAY_ADDRESS_NV 0x8F23
+#define GL_INDEX_ARRAY_ADDRESS_NV 0x8F24
+#define GL_TEXTURE_COORD_ARRAY_ADDRESS_NV 0x8F25
+#define GL_EDGE_FLAG_ARRAY_ADDRESS_NV 0x8F26
+#define GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV 0x8F27
+#define GL_FOG_COORD_ARRAY_ADDRESS_NV 0x8F28
+#define GL_ELEMENT_ARRAY_ADDRESS_NV 0x8F29
+#define GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV 0x8F2A
+#define GL_VERTEX_ARRAY_LENGTH_NV 0x8F2B
+#define GL_NORMAL_ARRAY_LENGTH_NV 0x8F2C
+#define GL_COLOR_ARRAY_LENGTH_NV 0x8F2D
+#define GL_INDEX_ARRAY_LENGTH_NV 0x8F2E
+#define GL_TEXTURE_COORD_ARRAY_LENGTH_NV 0x8F2F
+#define GL_EDGE_FLAG_ARRAY_LENGTH_NV 0x8F30
+#define GL_SECONDARY_COLOR_ARRAY_LENGTH_NV 0x8F31
+#define GL_FOG_COORD_ARRAY_LENGTH_NV 0x8F32
+#define GL_ELEMENT_ARRAY_LENGTH_NV 0x8F33
+
+    typedef void (GLAPIENTRY *PFNGLBUFFERADDRESSRANGENVPROC)(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
+    typedef void (GLAPIENTRY *PFNGLCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLEDGEFLAGFORMATNVPROC)(GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLFOGCOORDFORMATNVPROC)(GLenum type, GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLGETINTEGERUI64I_VNVPROC)(GLenum value, GLuint index, GLuint64EXT result[]);
+    typedef void (GLAPIENTRY *PFNGLINDEXFORMATNVPROC)(GLenum type, GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLNORMALFORMATNVPROC)(GLenum type, GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLSECONDARYCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORDFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBIFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride);
+    typedef void (GLAPIENTRY *PFNGLVERTEXFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
+
+#define glBufferAddressRangeNV GLEW_GET_FUN(__glewBufferAddressRangeNV)
+#define glColorFormatNV GLEW_GET_FUN(__glewColorFormatNV)
+#define glEdgeFlagFormatNV GLEW_GET_FUN(__glewEdgeFlagFormatNV)
+#define glFogCoordFormatNV GLEW_GET_FUN(__glewFogCoordFormatNV)
+#define glGetIntegerui64i_vNV GLEW_GET_FUN(__glewGetIntegerui64i_vNV)
+#define glIndexFormatNV GLEW_GET_FUN(__glewIndexFormatNV)
+#define glNormalFormatNV GLEW_GET_FUN(__glewNormalFormatNV)
+#define glSecondaryColorFormatNV GLEW_GET_FUN(__glewSecondaryColorFormatNV)
+#define glTexCoordFormatNV GLEW_GET_FUN(__glewTexCoordFormatNV)
+#define glVertexAttribFormatNV GLEW_GET_FUN(__glewVertexAttribFormatNV)
+#define glVertexAttribIFormatNV GLEW_GET_FUN(__glewVertexAttribIFormatNV)
+#define glVertexFormatNV GLEW_GET_FUN(__glewVertexFormatNV)
+
+#define GLEW_NV_vertex_buffer_unified_memory GLEW_GET_VAR(__GLEW_NV_vertex_buffer_unified_memory)
+
+#endif /* GL_NV_vertex_buffer_unified_memory */
+
+    /* -------------------------- GL_NV_vertex_program ------------------------- */
+
+#ifndef GL_NV_vertex_program
+#define GL_NV_vertex_program 1
+
+#define GL_VERTEX_PROGRAM_NV 0x8620
+#define GL_VERTEX_STATE_PROGRAM_NV 0x8621
+#define GL_ATTRIB_ARRAY_SIZE_NV 0x8623
+#define GL_ATTRIB_ARRAY_STRIDE_NV 0x8624
+#define GL_ATTRIB_ARRAY_TYPE_NV 0x8625
+#define GL_CURRENT_ATTRIB_NV 0x8626
+#define GL_PROGRAM_LENGTH_NV 0x8627
+#define GL_PROGRAM_STRING_NV 0x8628
+#define GL_MODELVIEW_PROJECTION_NV 0x8629
+#define GL_IDENTITY_NV 0x862A
+#define GL_INVERSE_NV 0x862B
+#define GL_TRANSPOSE_NV 0x862C
+#define GL_INVERSE_TRANSPOSE_NV 0x862D
+#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV 0x862E
+#define GL_MAX_TRACK_MATRICES_NV 0x862F
+#define GL_MATRIX0_NV 0x8630
+#define GL_MATRIX1_NV 0x8631
+#define GL_MATRIX2_NV 0x8632
+#define GL_MATRIX3_NV 0x8633
+#define GL_MATRIX4_NV 0x8634
+#define GL_MATRIX5_NV 0x8635
+#define GL_MATRIX6_NV 0x8636
+#define GL_MATRIX7_NV 0x8637
+#define GL_CURRENT_MATRIX_STACK_DEPTH_NV 0x8640
+#define GL_CURRENT_MATRIX_NV 0x8641
+#define GL_VERTEX_PROGRAM_POINT_SIZE_NV 0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_NV 0x8643
+#define GL_PROGRAM_PARAMETER_NV 0x8644
+#define GL_ATTRIB_ARRAY_POINTER_NV 0x8645
+#define GL_PROGRAM_TARGET_NV 0x8646
+#define GL_PROGRAM_RESIDENT_NV 0x8647
+#define GL_TRACK_MATRIX_NV 0x8648
+#define GL_TRACK_MATRIX_TRANSFORM_NV 0x8649
+#define GL_VERTEX_PROGRAM_BINDING_NV 0x864A
+#define GL_PROGRAM_ERROR_POSITION_NV 0x864B
+#define GL_VERTEX_ATTRIB_ARRAY0_NV 0x8650
+#define GL_VERTEX_ATTRIB_ARRAY1_NV 0x8651
+#define GL_VERTEX_ATTRIB_ARRAY2_NV 0x8652
+#define GL_VERTEX_ATTRIB_ARRAY3_NV 0x8653
+#define GL_VERTEX_ATTRIB_ARRAY4_NV 0x8654
+#define GL_VERTEX_ATTRIB_ARRAY5_NV 0x8655
+#define GL_VERTEX_ATTRIB_ARRAY6_NV 0x8656
+#define GL_VERTEX_ATTRIB_ARRAY7_NV 0x8657
+#define GL_VERTEX_ATTRIB_ARRAY8_NV 0x8658
+#define GL_VERTEX_ATTRIB_ARRAY9_NV 0x8659
+#define GL_VERTEX_ATTRIB_ARRAY10_NV 0x865A
+#define GL_VERTEX_ATTRIB_ARRAY11_NV 0x865B
+#define GL_VERTEX_ATTRIB_ARRAY12_NV 0x865C
+#define GL_VERTEX_ATTRIB_ARRAY13_NV 0x865D
+#define GL_VERTEX_ATTRIB_ARRAY14_NV 0x865E
+#define GL_VERTEX_ATTRIB_ARRAY15_NV 0x865F
+#define GL_MAP1_VERTEX_ATTRIB0_4_NV 0x8660
+#define GL_MAP1_VERTEX_ATTRIB1_4_NV 0x8661
+#define GL_MAP1_VERTEX_ATTRIB2_4_NV 0x8662
+#define GL_MAP1_VERTEX_ATTRIB3_4_NV 0x8663
+#define GL_MAP1_VERTEX_ATTRIB4_4_NV 0x8664
+#define GL_MAP1_VERTEX_ATTRIB5_4_NV 0x8665
+#define GL_MAP1_VERTEX_ATTRIB6_4_NV 0x8666
+#define GL_MAP1_VERTEX_ATTRIB7_4_NV 0x8667
+#define GL_MAP1_VERTEX_ATTRIB8_4_NV 0x8668
+#define GL_MAP1_VERTEX_ATTRIB9_4_NV 0x8669
+#define GL_MAP1_VERTEX_ATTRIB10_4_NV 0x866A
+#define GL_MAP1_VERTEX_ATTRIB11_4_NV 0x866B
+#define GL_MAP1_VERTEX_ATTRIB12_4_NV 0x866C
+#define GL_MAP1_VERTEX_ATTRIB13_4_NV 0x866D
+#define GL_MAP1_VERTEX_ATTRIB14_4_NV 0x866E
+#define GL_MAP1_VERTEX_ATTRIB15_4_NV 0x866F
+#define GL_MAP2_VERTEX_ATTRIB0_4_NV 0x8670
+#define GL_MAP2_VERTEX_ATTRIB1_4_NV 0x8671
+#define GL_MAP2_VERTEX_ATTRIB2_4_NV 0x8672
+#define GL_MAP2_VERTEX_ATTRIB3_4_NV 0x8673
+#define GL_MAP2_VERTEX_ATTRIB4_4_NV 0x8674
+#define GL_MAP2_VERTEX_ATTRIB5_4_NV 0x8675
+#define GL_MAP2_VERTEX_ATTRIB6_4_NV 0x8676
+#define GL_MAP2_VERTEX_ATTRIB7_4_NV 0x8677
+#define GL_MAP2_VERTEX_ATTRIB8_4_NV 0x8678
+#define GL_MAP2_VERTEX_ATTRIB9_4_NV 0x8679
+#define GL_MAP2_VERTEX_ATTRIB10_4_NV 0x867A
+#define GL_MAP2_VERTEX_ATTRIB11_4_NV 0x867B
+#define GL_MAP2_VERTEX_ATTRIB12_4_NV 0x867C
+#define GL_MAP2_VERTEX_ATTRIB13_4_NV 0x867D
+#define GL_MAP2_VERTEX_ATTRIB14_4_NV 0x867E
+#define GL_MAP2_VERTEX_ATTRIB15_4_NV 0x867F
+
+    typedef GLboolean(GLAPIENTRY *PFNGLAREPROGRAMSRESIDENTNVPROC)(GLsizei n, const GLuint *ids, GLboolean *residences);
+    typedef void (GLAPIENTRY *PFNGLBINDPROGRAMNVPROC)(GLenum target, GLuint id);
+    typedef void (GLAPIENTRY *PFNGLDELETEPROGRAMSNVPROC)(GLsizei n, const GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLEXECUTEPROGRAMNVPROC)(GLenum target, GLuint id, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGENPROGRAMSNVPROC)(GLsizei n, GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMPARAMETERDVNVPROC)(GLenum target, GLuint index, GLenum pname, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMSTRINGNVPROC)(GLuint id, GLenum pname, GLubyte *program);
+    typedef void (GLAPIENTRY *PFNGLGETPROGRAMIVNVPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETTRACKMATRIXIVNVPROC)(GLenum target, GLuint address, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBPOINTERVNVPROC)(GLuint index, GLenum pname, GLvoid **pointer);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBDVNVPROC)(GLuint index, GLenum pname, GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBFVNVPROC)(GLuint index, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETVERTEXATTRIBIVNVPROC)(GLuint index, GLenum pname, GLint *params);
+    typedef GLboolean(GLAPIENTRY *PFNGLISPROGRAMNVPROC)(GLuint id);
+    typedef void (GLAPIENTRY *PFNGLLOADPROGRAMNVPROC)(GLenum target, GLuint id, GLsizei len, const GLubyte *program);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMPARAMETER4DNVPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMPARAMETER4DVNVPROC)(GLenum target, GLuint index, const GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMPARAMETER4FNVPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMPARAMETER4FVNVPROC)(GLenum target, GLuint index, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMPARAMETERS4DVNVPROC)(GLenum target, GLuint index, GLuint num, const GLdouble *params);
+    typedef void (GLAPIENTRY *PFNGLPROGRAMPARAMETERS4FVNVPROC)(GLenum target, GLuint index, GLuint num, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLREQUESTRESIDENTPROGRAMSNVPROC)(GLsizei n, GLuint *ids);
+    typedef void (GLAPIENTRY *PFNGLTRACKMATRIXNVPROC)(GLenum target, GLuint address, GLenum matrix, GLenum transform);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1DNVPROC)(GLuint index, GLdouble x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1DVNVPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1FNVPROC)(GLuint index, GLfloat x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1FVNVPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1SNVPROC)(GLuint index, GLshort x);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB1SVNVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2DNVPROC)(GLuint index, GLdouble x, GLdouble y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2DVNVPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2FNVPROC)(GLuint index, GLfloat x, GLfloat y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2FVNVPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2SNVPROC)(GLuint index, GLshort x, GLshort y);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB2SVNVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3DVNVPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3FVNVPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB3SVNVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4DVNVPROC)(GLuint index, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4FVNVPROC)(GLuint index, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4SVNVPROC)(GLuint index, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4UBNVPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIB4UBVNVPROC)(GLuint index, const GLubyte *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBPOINTERNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS1DVNVPROC)(GLuint index, GLsizei n, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS1FVNVPROC)(GLuint index, GLsizei n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS1SVNVPROC)(GLuint index, GLsizei n, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS2DVNVPROC)(GLuint index, GLsizei n, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS2FVNVPROC)(GLuint index, GLsizei n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS2SVNVPROC)(GLuint index, GLsizei n, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS3DVNVPROC)(GLuint index, GLsizei n, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS3FVNVPROC)(GLuint index, GLsizei n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS3SVNVPROC)(GLuint index, GLsizei n, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS4DVNVPROC)(GLuint index, GLsizei n, const GLdouble *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS4FVNVPROC)(GLuint index, GLsizei n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS4SVNVPROC)(GLuint index, GLsizei n, const GLshort *v);
+    typedef void (GLAPIENTRY *PFNGLVERTEXATTRIBS4UBVNVPROC)(GLuint index, GLsizei n, const GLubyte *v);
+
+#define glAreProgramsResidentNV GLEW_GET_FUN(__glewAreProgramsResidentNV)
+#define glBindProgramNV GLEW_GET_FUN(__glewBindProgramNV)
+#define glDeleteProgramsNV GLEW_GET_FUN(__glewDeleteProgramsNV)
+#define glExecuteProgramNV GLEW_GET_FUN(__glewExecuteProgramNV)
+#define glGenProgramsNV GLEW_GET_FUN(__glewGenProgramsNV)
+#define glGetProgramParameterdvNV GLEW_GET_FUN(__glewGetProgramParameterdvNV)
+#define glGetProgramParameterfvNV GLEW_GET_FUN(__glewGetProgramParameterfvNV)
+#define glGetProgramStringNV GLEW_GET_FUN(__glewGetProgramStringNV)
+#define glGetProgramivNV GLEW_GET_FUN(__glewGetProgramivNV)
+#define glGetTrackMatrixivNV GLEW_GET_FUN(__glewGetTrackMatrixivNV)
+#define glGetVertexAttribPointervNV GLEW_GET_FUN(__glewGetVertexAttribPointervNV)
+#define glGetVertexAttribdvNV GLEW_GET_FUN(__glewGetVertexAttribdvNV)
+#define glGetVertexAttribfvNV GLEW_GET_FUN(__glewGetVertexAttribfvNV)
+#define glGetVertexAttribivNV GLEW_GET_FUN(__glewGetVertexAttribivNV)
+#define glIsProgramNV GLEW_GET_FUN(__glewIsProgramNV)
+#define glLoadProgramNV GLEW_GET_FUN(__glewLoadProgramNV)
+#define glProgramParameter4dNV GLEW_GET_FUN(__glewProgramParameter4dNV)
+#define glProgramParameter4dvNV GLEW_GET_FUN(__glewProgramParameter4dvNV)
+#define glProgramParameter4fNV GLEW_GET_FUN(__glewProgramParameter4fNV)
+#define glProgramParameter4fvNV GLEW_GET_FUN(__glewProgramParameter4fvNV)
+#define glProgramParameters4dvNV GLEW_GET_FUN(__glewProgramParameters4dvNV)
+#define glProgramParameters4fvNV GLEW_GET_FUN(__glewProgramParameters4fvNV)
+#define glRequestResidentProgramsNV GLEW_GET_FUN(__glewRequestResidentProgramsNV)
+#define glTrackMatrixNV GLEW_GET_FUN(__glewTrackMatrixNV)
+#define glVertexAttrib1dNV GLEW_GET_FUN(__glewVertexAttrib1dNV)
+#define glVertexAttrib1dvNV GLEW_GET_FUN(__glewVertexAttrib1dvNV)
+#define glVertexAttrib1fNV GLEW_GET_FUN(__glewVertexAttrib1fNV)
+#define glVertexAttrib1fvNV GLEW_GET_FUN(__glewVertexAttrib1fvNV)
+#define glVertexAttrib1sNV GLEW_GET_FUN(__glewVertexAttrib1sNV)
+#define glVertexAttrib1svNV GLEW_GET_FUN(__glewVertexAttrib1svNV)
+#define glVertexAttrib2dNV GLEW_GET_FUN(__glewVertexAttrib2dNV)
+#define glVertexAttrib2dvNV GLEW_GET_FUN(__glewVertexAttrib2dvNV)
+#define glVertexAttrib2fNV GLEW_GET_FUN(__glewVertexAttrib2fNV)
+#define glVertexAttrib2fvNV GLEW_GET_FUN(__glewVertexAttrib2fvNV)
+#define glVertexAttrib2sNV GLEW_GET_FUN(__glewVertexAttrib2sNV)
+#define glVertexAttrib2svNV GLEW_GET_FUN(__glewVertexAttrib2svNV)
+#define glVertexAttrib3dNV GLEW_GET_FUN(__glewVertexAttrib3dNV)
+#define glVertexAttrib3dvNV GLEW_GET_FUN(__glewVertexAttrib3dvNV)
+#define glVertexAttrib3fNV GLEW_GET_FUN(__glewVertexAttrib3fNV)
+#define glVertexAttrib3fvNV GLEW_GET_FUN(__glewVertexAttrib3fvNV)
+#define glVertexAttrib3sNV GLEW_GET_FUN(__glewVertexAttrib3sNV)
+#define glVertexAttrib3svNV GLEW_GET_FUN(__glewVertexAttrib3svNV)
+#define glVertexAttrib4dNV GLEW_GET_FUN(__glewVertexAttrib4dNV)
+#define glVertexAttrib4dvNV GLEW_GET_FUN(__glewVertexAttrib4dvNV)
+#define glVertexAttrib4fNV GLEW_GET_FUN(__glewVertexAttrib4fNV)
+#define glVertexAttrib4fvNV GLEW_GET_FUN(__glewVertexAttrib4fvNV)
+#define glVertexAttrib4sNV GLEW_GET_FUN(__glewVertexAttrib4sNV)
+#define glVertexAttrib4svNV GLEW_GET_FUN(__glewVertexAttrib4svNV)
+#define glVertexAttrib4ubNV GLEW_GET_FUN(__glewVertexAttrib4ubNV)
+#define glVertexAttrib4ubvNV GLEW_GET_FUN(__glewVertexAttrib4ubvNV)
+#define glVertexAttribPointerNV GLEW_GET_FUN(__glewVertexAttribPointerNV)
+#define glVertexAttribs1dvNV GLEW_GET_FUN(__glewVertexAttribs1dvNV)
+#define glVertexAttribs1fvNV GLEW_GET_FUN(__glewVertexAttribs1fvNV)
+#define glVertexAttribs1svNV GLEW_GET_FUN(__glewVertexAttribs1svNV)
+#define glVertexAttribs2dvNV GLEW_GET_FUN(__glewVertexAttribs2dvNV)
+#define glVertexAttribs2fvNV GLEW_GET_FUN(__glewVertexAttribs2fvNV)
+#define glVertexAttribs2svNV GLEW_GET_FUN(__glewVertexAttribs2svNV)
+#define glVertexAttribs3dvNV GLEW_GET_FUN(__glewVertexAttribs3dvNV)
+#define glVertexAttribs3fvNV GLEW_GET_FUN(__glewVertexAttribs3fvNV)
+#define glVertexAttribs3svNV GLEW_GET_FUN(__glewVertexAttribs3svNV)
+#define glVertexAttribs4dvNV GLEW_GET_FUN(__glewVertexAttribs4dvNV)
+#define glVertexAttribs4fvNV GLEW_GET_FUN(__glewVertexAttribs4fvNV)
+#define glVertexAttribs4svNV GLEW_GET_FUN(__glewVertexAttribs4svNV)
+#define glVertexAttribs4ubvNV GLEW_GET_FUN(__glewVertexAttribs4ubvNV)
+
+#define GLEW_NV_vertex_program GLEW_GET_VAR(__GLEW_NV_vertex_program)
+
+#endif /* GL_NV_vertex_program */
+
+    /* ------------------------ GL_NV_vertex_program1_1 ------------------------ */
+
+#ifndef GL_NV_vertex_program1_1
+#define GL_NV_vertex_program1_1 1
+
+#define GLEW_NV_vertex_program1_1 GLEW_GET_VAR(__GLEW_NV_vertex_program1_1)
+
+#endif /* GL_NV_vertex_program1_1 */
+
+    /* ------------------------- GL_NV_vertex_program2 ------------------------- */
+
+#ifndef GL_NV_vertex_program2
+#define GL_NV_vertex_program2 1
+
+#define GLEW_NV_vertex_program2 GLEW_GET_VAR(__GLEW_NV_vertex_program2)
+
+#endif /* GL_NV_vertex_program2 */
+
+    /* ---------------------- GL_NV_vertex_program2_option --------------------- */
+
+#ifndef GL_NV_vertex_program2_option
+#define GL_NV_vertex_program2_option 1
+
+#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
+#define GL_MAX_PROGRAM_CALL_DEPTH_NV 0x88F5
+
+#define GLEW_NV_vertex_program2_option GLEW_GET_VAR(__GLEW_NV_vertex_program2_option)
+
+#endif /* GL_NV_vertex_program2_option */
+
+    /* ------------------------- GL_NV_vertex_program3 ------------------------- */
+
+#ifndef GL_NV_vertex_program3
+#define GL_NV_vertex_program3 1
+
+#define MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB 0x8B4C
+
+#define GLEW_NV_vertex_program3 GLEW_GET_VAR(__GLEW_NV_vertex_program3)
+
+#endif /* GL_NV_vertex_program3 */
+
+    /* ------------------------- GL_NV_vertex_program4 ------------------------- */
+
+#ifndef GL_NV_vertex_program4
+#define GL_NV_vertex_program4 1
+
+#define GLEW_NV_vertex_program4 GLEW_GET_VAR(__GLEW_NV_vertex_program4)
+
+#endif /* GL_NV_vertex_program4 */
+
+    /* ------------------------ GL_OES_byte_coordinates ------------------------ */
+
+#ifndef GL_OES_byte_coordinates
+#define GL_OES_byte_coordinates 1
+
+#define GL_BYTE 0x1400
+
+#define GLEW_OES_byte_coordinates GLEW_GET_VAR(__GLEW_OES_byte_coordinates)
+
+#endif /* GL_OES_byte_coordinates */
+
+    /* ------------------- GL_OES_compressed_paletted_texture ------------------ */
+
+#ifndef GL_OES_compressed_paletted_texture
+#define GL_OES_compressed_paletted_texture 1
+
+#define GL_PALETTE4_RGB8_OES 0x8B90
+#define GL_PALETTE4_RGBA8_OES 0x8B91
+#define GL_PALETTE4_R5_G6_B5_OES 0x8B92
+#define GL_PALETTE4_RGBA4_OES 0x8B93
+#define GL_PALETTE4_RGB5_A1_OES 0x8B94
+#define GL_PALETTE8_RGB8_OES 0x8B95
+#define GL_PALETTE8_RGBA8_OES 0x8B96
+#define GL_PALETTE8_R5_G6_B5_OES 0x8B97
+#define GL_PALETTE8_RGBA4_OES 0x8B98
+#define GL_PALETTE8_RGB5_A1_OES 0x8B99
+
+#define GLEW_OES_compressed_paletted_texture GLEW_GET_VAR(__GLEW_OES_compressed_paletted_texture)
+
+#endif /* GL_OES_compressed_paletted_texture */
+
+    /* --------------------------- GL_OES_read_format -------------------------- */
+
+#ifndef GL_OES_read_format
+#define GL_OES_read_format 1
+
+#define GL_IMPLEMENTATION_COLOR_READ_TYPE_OES 0x8B9A
+#define GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES 0x8B9B
+
+#define GLEW_OES_read_format GLEW_GET_VAR(__GLEW_OES_read_format)
+
+#endif /* GL_OES_read_format */
+
+    /* ------------------------ GL_OES_single_precision ------------------------ */
+
+#ifndef GL_OES_single_precision
+#define GL_OES_single_precision 1
+
+    typedef void (GLAPIENTRY *PFNGLCLEARDEPTHFOESPROC)(GLclampd depth);
+    typedef void (GLAPIENTRY *PFNGLCLIPPLANEFOESPROC)(GLenum plane, const GLfloat *equation);
+    typedef void (GLAPIENTRY *PFNGLDEPTHRANGEFOESPROC)(GLclampf n, GLclampf f);
+    typedef void (GLAPIENTRY *PFNGLFRUSTUMFOESPROC)(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
+    typedef void (GLAPIENTRY *PFNGLGETCLIPPLANEFOESPROC)(GLenum plane, GLfloat *equation);
+    typedef void (GLAPIENTRY *PFNGLORTHOFOESPROC)(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
+
+#define glClearDepthfOES GLEW_GET_FUN(__glewClearDepthfOES)
+#define glClipPlanefOES GLEW_GET_FUN(__glewClipPlanefOES)
+#define glDepthRangefOES GLEW_GET_FUN(__glewDepthRangefOES)
+#define glFrustumfOES GLEW_GET_FUN(__glewFrustumfOES)
+#define glGetClipPlanefOES GLEW_GET_FUN(__glewGetClipPlanefOES)
+#define glOrthofOES GLEW_GET_FUN(__glewOrthofOES)
+
+#define GLEW_OES_single_precision GLEW_GET_VAR(__GLEW_OES_single_precision)
+
+#endif /* GL_OES_single_precision */
+
+    /* ---------------------------- GL_OML_interlace --------------------------- */
+
+#ifndef GL_OML_interlace
+#define GL_OML_interlace 1
+
+#define GL_INTERLACE_OML 0x8980
+#define GL_INTERLACE_READ_OML 0x8981
+
+#define GLEW_OML_interlace GLEW_GET_VAR(__GLEW_OML_interlace)
+
+#endif /* GL_OML_interlace */
+
+    /* ---------------------------- GL_OML_resample ---------------------------- */
+
+#ifndef GL_OML_resample
+#define GL_OML_resample 1
+
+#define GL_PACK_RESAMPLE_OML 0x8984
+#define GL_UNPACK_RESAMPLE_OML 0x8985
+#define GL_RESAMPLE_REPLICATE_OML 0x8986
+#define GL_RESAMPLE_ZERO_FILL_OML 0x8987
+#define GL_RESAMPLE_AVERAGE_OML 0x8988
+#define GL_RESAMPLE_DECIMATE_OML 0x8989
+
+#define GLEW_OML_resample GLEW_GET_VAR(__GLEW_OML_resample)
+
+#endif /* GL_OML_resample */
+
+    /* ---------------------------- GL_OML_subsample --------------------------- */
+
+#ifndef GL_OML_subsample
+#define GL_OML_subsample 1
+
+#define GL_FORMAT_SUBSAMPLE_24_24_OML 0x8982
+#define GL_FORMAT_SUBSAMPLE_244_244_OML 0x8983
+
+#define GLEW_OML_subsample GLEW_GET_VAR(__GLEW_OML_subsample)
+
+#endif /* GL_OML_subsample */
+
+    /* --------------------------- GL_PGI_misc_hints --------------------------- */
+
+#ifndef GL_PGI_misc_hints
+#define GL_PGI_misc_hints 1
+
+#define GL_PREFER_DOUBLEBUFFER_HINT_PGI 107000
+#define GL_CONSERVE_MEMORY_HINT_PGI 107005
+#define GL_RECLAIM_MEMORY_HINT_PGI 107006
+#define GL_NATIVE_GRAPHICS_HANDLE_PGI 107010
+#define GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI 107011
+#define GL_NATIVE_GRAPHICS_END_HINT_PGI 107012
+#define GL_ALWAYS_FAST_HINT_PGI 107020
+#define GL_ALWAYS_SOFT_HINT_PGI 107021
+#define GL_ALLOW_DRAW_OBJ_HINT_PGI 107022
+#define GL_ALLOW_DRAW_WIN_HINT_PGI 107023
+#define GL_ALLOW_DRAW_FRG_HINT_PGI 107024
+#define GL_ALLOW_DRAW_MEM_HINT_PGI 107025
+#define GL_STRICT_DEPTHFUNC_HINT_PGI 107030
+#define GL_STRICT_LIGHTING_HINT_PGI 107031
+#define GL_STRICT_SCISSOR_HINT_PGI 107032
+#define GL_FULL_STIPPLE_HINT_PGI 107033
+#define GL_CLIP_NEAR_HINT_PGI 107040
+#define GL_CLIP_FAR_HINT_PGI 107041
+#define GL_WIDE_LINE_HINT_PGI 107042
+#define GL_BACK_NORMALS_HINT_PGI 107043
+
+#define GLEW_PGI_misc_hints GLEW_GET_VAR(__GLEW_PGI_misc_hints)
+
+#endif /* GL_PGI_misc_hints */
+
+    /* -------------------------- GL_PGI_vertex_hints -------------------------- */
+
+#ifndef GL_PGI_vertex_hints
+#define GL_PGI_vertex_hints 1
+
+#define GL_VERTEX23_BIT_PGI 0x00000004
+#define GL_VERTEX4_BIT_PGI 0x00000008
+#define GL_COLOR3_BIT_PGI 0x00010000
+#define GL_COLOR4_BIT_PGI 0x00020000
+#define GL_EDGEFLAG_BIT_PGI 0x00040000
+#define GL_INDEX_BIT_PGI 0x00080000
+#define GL_MAT_AMBIENT_BIT_PGI 0x00100000
+#define GL_VERTEX_DATA_HINT_PGI 107050
+#define GL_VERTEX_CONSISTENT_HINT_PGI 107051
+#define GL_MATERIAL_SIDE_HINT_PGI 107052
+#define GL_MAX_VERTEX_HINT_PGI 107053
+#define GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI 0x00200000
+#define GL_MAT_DIFFUSE_BIT_PGI 0x00400000
+#define GL_MAT_EMISSION_BIT_PGI 0x00800000
+#define GL_MAT_COLOR_INDEXES_BIT_PGI 0x01000000
+#define GL_MAT_SHININESS_BIT_PGI 0x02000000
+#define GL_MAT_SPECULAR_BIT_PGI 0x04000000
+#define GL_NORMAL_BIT_PGI 0x08000000
+#define GL_TEXCOORD1_BIT_PGI 0x10000000
+#define GL_TEXCOORD2_BIT_PGI 0x20000000
+#define GL_TEXCOORD3_BIT_PGI 0x40000000
+#define GL_TEXCOORD4_BIT_PGI 0x80000000
+
+#define GLEW_PGI_vertex_hints GLEW_GET_VAR(__GLEW_PGI_vertex_hints)
+
+#endif /* GL_PGI_vertex_hints */
+
+    /* ----------------------- GL_REND_screen_coordinates ---------------------- */
+
+#ifndef GL_REND_screen_coordinates
+#define GL_REND_screen_coordinates 1
+
+#define GL_SCREEN_COORDINATES_REND 0x8490
+#define GL_INVERTED_SCREEN_W_REND 0x8491
+
+#define GLEW_REND_screen_coordinates GLEW_GET_VAR(__GLEW_REND_screen_coordinates)
+
+#endif /* GL_REND_screen_coordinates */
+
+    /* ------------------------------- GL_S3_s3tc ------------------------------ */
+
+#ifndef GL_S3_s3tc
+#define GL_S3_s3tc 1
+
+#define GL_RGB_S3TC 0x83A0
+#define GL_RGB4_S3TC 0x83A1
+#define GL_RGBA_S3TC 0x83A2
+#define GL_RGBA4_S3TC 0x83A3
+#define GL_RGBA_DXT5_S3TC 0x83A4
+#define GL_RGBA4_DXT5_S3TC 0x83A5
+
+#define GLEW_S3_s3tc GLEW_GET_VAR(__GLEW_S3_s3tc)
+
+#endif /* GL_S3_s3tc */
+
+    /* -------------------------- GL_SGIS_color_range -------------------------- */
+
+#ifndef GL_SGIS_color_range
+#define GL_SGIS_color_range 1
+
+#define GL_EXTENDED_RANGE_SGIS 0x85A5
+#define GL_MIN_RED_SGIS 0x85A6
+#define GL_MAX_RED_SGIS 0x85A7
+#define GL_MIN_GREEN_SGIS 0x85A8
+#define GL_MAX_GREEN_SGIS 0x85A9
+#define GL_MIN_BLUE_SGIS 0x85AA
+#define GL_MAX_BLUE_SGIS 0x85AB
+#define GL_MIN_ALPHA_SGIS 0x85AC
+#define GL_MAX_ALPHA_SGIS 0x85AD
+
+#define GLEW_SGIS_color_range GLEW_GET_VAR(__GLEW_SGIS_color_range)
+
+#endif /* GL_SGIS_color_range */
+
+    /* ------------------------- GL_SGIS_detail_texture ------------------------ */
+
+#ifndef GL_SGIS_detail_texture
+#define GL_SGIS_detail_texture 1
+
+    typedef void (GLAPIENTRY *PFNGLDETAILTEXFUNCSGISPROC)(GLenum target, GLsizei n, const GLfloat *points);
+    typedef void (GLAPIENTRY *PFNGLGETDETAILTEXFUNCSGISPROC)(GLenum target, GLfloat *points);
+
+#define glDetailTexFuncSGIS GLEW_GET_FUN(__glewDetailTexFuncSGIS)
+#define glGetDetailTexFuncSGIS GLEW_GET_FUN(__glewGetDetailTexFuncSGIS)
+
+#define GLEW_SGIS_detail_texture GLEW_GET_VAR(__GLEW_SGIS_detail_texture)
+
+#endif /* GL_SGIS_detail_texture */
+
+    /* -------------------------- GL_SGIS_fog_function ------------------------- */
+
+#ifndef GL_SGIS_fog_function
+#define GL_SGIS_fog_function 1
+
+    typedef void (GLAPIENTRY *PFNGLFOGFUNCSGISPROC)(GLsizei n, const GLfloat *points);
+    typedef void (GLAPIENTRY *PFNGLGETFOGFUNCSGISPROC)(GLfloat *points);
+
+#define glFogFuncSGIS GLEW_GET_FUN(__glewFogFuncSGIS)
+#define glGetFogFuncSGIS GLEW_GET_FUN(__glewGetFogFuncSGIS)
+
+#define GLEW_SGIS_fog_function GLEW_GET_VAR(__GLEW_SGIS_fog_function)
+
+#endif /* GL_SGIS_fog_function */
+
+    /* ------------------------ GL_SGIS_generate_mipmap ------------------------ */
+
+#ifndef GL_SGIS_generate_mipmap
+#define GL_SGIS_generate_mipmap 1
+
+#define GL_GENERATE_MIPMAP_SGIS 0x8191
+#define GL_GENERATE_MIPMAP_HINT_SGIS 0x8192
+
+#define GLEW_SGIS_generate_mipmap GLEW_GET_VAR(__GLEW_SGIS_generate_mipmap)
+
+#endif /* GL_SGIS_generate_mipmap */
+
+    /* -------------------------- GL_SGIS_multisample -------------------------- */
+
+#ifndef GL_SGIS_multisample
+#define GL_SGIS_multisample 1
+
+#define GL_MULTISAMPLE_SGIS 0x809D
+#define GL_SAMPLE_ALPHA_TO_MASK_SGIS 0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_SGIS 0x809F
+#define GL_SAMPLE_MASK_SGIS 0x80A0
+#define GL_1PASS_SGIS 0x80A1
+#define GL_2PASS_0_SGIS 0x80A2
+#define GL_2PASS_1_SGIS 0x80A3
+#define GL_4PASS_0_SGIS 0x80A4
+#define GL_4PASS_1_SGIS 0x80A5
+#define GL_4PASS_2_SGIS 0x80A6
+#define GL_4PASS_3_SGIS 0x80A7
+#define GL_SAMPLE_BUFFERS_SGIS 0x80A8
+#define GL_SAMPLES_SGIS 0x80A9
+#define GL_SAMPLE_MASK_VALUE_SGIS 0x80AA
+#define GL_SAMPLE_MASK_INVERT_SGIS 0x80AB
+#define GL_SAMPLE_PATTERN_SGIS 0x80AC
+#define GL_MULTISAMPLE_BIT_EXT 0x20000000
+
+    typedef void (GLAPIENTRY *PFNGLSAMPLEMASKSGISPROC)(GLclampf value, GLboolean invert);
+    typedef void (GLAPIENTRY *PFNGLSAMPLEPATTERNSGISPROC)(GLenum pattern);
+
+#define glSampleMaskSGIS GLEW_GET_FUN(__glewSampleMaskSGIS)
+#define glSamplePatternSGIS GLEW_GET_FUN(__glewSamplePatternSGIS)
+
+#define GLEW_SGIS_multisample GLEW_GET_VAR(__GLEW_SGIS_multisample)
+
+#endif /* GL_SGIS_multisample */
+
+    /* ------------------------- GL_SGIS_pixel_texture ------------------------- */
+
+#ifndef GL_SGIS_pixel_texture
+#define GL_SGIS_pixel_texture 1
+
+#define GLEW_SGIS_pixel_texture GLEW_GET_VAR(__GLEW_SGIS_pixel_texture)
+
+#endif /* GL_SGIS_pixel_texture */
+
+    /* ----------------------- GL_SGIS_point_line_texgen ----------------------- */
+
+#ifndef GL_SGIS_point_line_texgen
+#define GL_SGIS_point_line_texgen 1
+
+#define GL_EYE_DISTANCE_TO_POINT_SGIS 0x81F0
+#define GL_OBJECT_DISTANCE_TO_POINT_SGIS 0x81F1
+#define GL_EYE_DISTANCE_TO_LINE_SGIS 0x81F2
+#define GL_OBJECT_DISTANCE_TO_LINE_SGIS 0x81F3
+#define GL_EYE_POINT_SGIS 0x81F4
+#define GL_OBJECT_POINT_SGIS 0x81F5
+#define GL_EYE_LINE_SGIS 0x81F6
+#define GL_OBJECT_LINE_SGIS 0x81F7
+
+#define GLEW_SGIS_point_line_texgen GLEW_GET_VAR(__GLEW_SGIS_point_line_texgen)
+
+#endif /* GL_SGIS_point_line_texgen */
+
+    /* ------------------------ GL_SGIS_sharpen_texture ------------------------ */
+
+#ifndef GL_SGIS_sharpen_texture
+#define GL_SGIS_sharpen_texture 1
+
+    typedef void (GLAPIENTRY *PFNGLGETSHARPENTEXFUNCSGISPROC)(GLenum target, GLfloat *points);
+    typedef void (GLAPIENTRY *PFNGLSHARPENTEXFUNCSGISPROC)(GLenum target, GLsizei n, const GLfloat *points);
+
+#define glGetSharpenTexFuncSGIS GLEW_GET_FUN(__glewGetSharpenTexFuncSGIS)
+#define glSharpenTexFuncSGIS GLEW_GET_FUN(__glewSharpenTexFuncSGIS)
+
+#define GLEW_SGIS_sharpen_texture GLEW_GET_VAR(__GLEW_SGIS_sharpen_texture)
+
+#endif /* GL_SGIS_sharpen_texture */
+
+    /* --------------------------- GL_SGIS_texture4D --------------------------- */
+
+#ifndef GL_SGIS_texture4D
+#define GL_SGIS_texture4D 1
+
+    typedef void (GLAPIENTRY *PFNGLTEXIMAGE4DSGISPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const void *pixels);
+    typedef void (GLAPIENTRY *PFNGLTEXSUBIMAGE4DSGISPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const void *pixels);
+
+#define glTexImage4DSGIS GLEW_GET_FUN(__glewTexImage4DSGIS)
+#define glTexSubImage4DSGIS GLEW_GET_FUN(__glewTexSubImage4DSGIS)
+
+#define GLEW_SGIS_texture4D GLEW_GET_VAR(__GLEW_SGIS_texture4D)
+
+#endif /* GL_SGIS_texture4D */
+
+    /* ---------------------- GL_SGIS_texture_border_clamp --------------------- */
+
+#ifndef GL_SGIS_texture_border_clamp
+#define GL_SGIS_texture_border_clamp 1
+
+#define GL_CLAMP_TO_BORDER_SGIS 0x812D
+
+#define GLEW_SGIS_texture_border_clamp GLEW_GET_VAR(__GLEW_SGIS_texture_border_clamp)
+
+#endif /* GL_SGIS_texture_border_clamp */
+
+    /* ----------------------- GL_SGIS_texture_edge_clamp ---------------------- */
+
+#ifndef GL_SGIS_texture_edge_clamp
+#define GL_SGIS_texture_edge_clamp 1
+
+#define GL_CLAMP_TO_EDGE_SGIS 0x812F
+
+#define GLEW_SGIS_texture_edge_clamp GLEW_GET_VAR(__GLEW_SGIS_texture_edge_clamp)
+
+#endif /* GL_SGIS_texture_edge_clamp */
+
+    /* ------------------------ GL_SGIS_texture_filter4 ------------------------ */
+
+#ifndef GL_SGIS_texture_filter4
+#define GL_SGIS_texture_filter4 1
+
+    typedef void (GLAPIENTRY *PFNGLGETTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLfloat *weights);
+    typedef void (GLAPIENTRY *PFNGLTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);
+
+#define glGetTexFilterFuncSGIS GLEW_GET_FUN(__glewGetTexFilterFuncSGIS)
+#define glTexFilterFuncSGIS GLEW_GET_FUN(__glewTexFilterFuncSGIS)
+
+#define GLEW_SGIS_texture_filter4 GLEW_GET_VAR(__GLEW_SGIS_texture_filter4)
+
+#endif /* GL_SGIS_texture_filter4 */
+
+    /* -------------------------- GL_SGIS_texture_lod -------------------------- */
+
+#ifndef GL_SGIS_texture_lod
+#define GL_SGIS_texture_lod 1
+
+#define GL_TEXTURE_MIN_LOD_SGIS 0x813A
+#define GL_TEXTURE_MAX_LOD_SGIS 0x813B
+#define GL_TEXTURE_BASE_LEVEL_SGIS 0x813C
+#define GL_TEXTURE_MAX_LEVEL_SGIS 0x813D
+
+#define GLEW_SGIS_texture_lod GLEW_GET_VAR(__GLEW_SGIS_texture_lod)
+
+#endif /* GL_SGIS_texture_lod */
+
+    /* ------------------------- GL_SGIS_texture_select ------------------------ */
+
+#ifndef GL_SGIS_texture_select
+#define GL_SGIS_texture_select 1
+
+#define GLEW_SGIS_texture_select GLEW_GET_VAR(__GLEW_SGIS_texture_select)
+
+#endif /* GL_SGIS_texture_select */
+
+    /* ----------------------------- GL_SGIX_async ----------------------------- */
+
+#ifndef GL_SGIX_async
+#define GL_SGIX_async 1
+
+#define GL_ASYNC_MARKER_SGIX 0x8329
+
+    typedef void (GLAPIENTRY *PFNGLASYNCMARKERSGIXPROC)(GLuint marker);
+    typedef void (GLAPIENTRY *PFNGLDELETEASYNCMARKERSSGIXPROC)(GLuint marker, GLsizei range);
+    typedef GLint(GLAPIENTRY *PFNGLFINISHASYNCSGIXPROC)(GLuint *markerp);
+    typedef GLuint(GLAPIENTRY *PFNGLGENASYNCMARKERSSGIXPROC)(GLsizei range);
+    typedef GLboolean(GLAPIENTRY *PFNGLISASYNCMARKERSGIXPROC)(GLuint marker);
+    typedef GLint(GLAPIENTRY *PFNGLPOLLASYNCSGIXPROC)(GLuint *markerp);
+
+#define glAsyncMarkerSGIX GLEW_GET_FUN(__glewAsyncMarkerSGIX)
+#define glDeleteAsyncMarkersSGIX GLEW_GET_FUN(__glewDeleteAsyncMarkersSGIX)
+#define glFinishAsyncSGIX GLEW_GET_FUN(__glewFinishAsyncSGIX)
+#define glGenAsyncMarkersSGIX GLEW_GET_FUN(__glewGenAsyncMarkersSGIX)
+#define glIsAsyncMarkerSGIX GLEW_GET_FUN(__glewIsAsyncMarkerSGIX)
+#define glPollAsyncSGIX GLEW_GET_FUN(__glewPollAsyncSGIX)
+
+#define GLEW_SGIX_async GLEW_GET_VAR(__GLEW_SGIX_async)
+
+#endif /* GL_SGIX_async */
+
+    /* ------------------------ GL_SGIX_async_histogram ------------------------ */
+
+#ifndef GL_SGIX_async_histogram
+#define GL_SGIX_async_histogram 1
+
+#define GL_ASYNC_HISTOGRAM_SGIX 0x832C
+#define GL_MAX_ASYNC_HISTOGRAM_SGIX 0x832D
+
+#define GLEW_SGIX_async_histogram GLEW_GET_VAR(__GLEW_SGIX_async_histogram)
+
+#endif /* GL_SGIX_async_histogram */
+
+    /* -------------------------- GL_SGIX_async_pixel -------------------------- */
+
+#ifndef GL_SGIX_async_pixel
+#define GL_SGIX_async_pixel 1
+
+#define GL_ASYNC_TEX_IMAGE_SGIX 0x835C
+#define GL_ASYNC_DRAW_PIXELS_SGIX 0x835D
+#define GL_ASYNC_READ_PIXELS_SGIX 0x835E
+#define GL_MAX_ASYNC_TEX_IMAGE_SGIX 0x835F
+#define GL_MAX_ASYNC_DRAW_PIXELS_SGIX 0x8360
+#define GL_MAX_ASYNC_READ_PIXELS_SGIX 0x8361
+
+#define GLEW_SGIX_async_pixel GLEW_GET_VAR(__GLEW_SGIX_async_pixel)
+
+#endif /* GL_SGIX_async_pixel */
+
+    /* ----------------------- GL_SGIX_blend_alpha_minmax ---------------------- */
+
+#ifndef GL_SGIX_blend_alpha_minmax
+#define GL_SGIX_blend_alpha_minmax 1
+
+#define GL_ALPHA_MIN_SGIX 0x8320
+#define GL_ALPHA_MAX_SGIX 0x8321
+
+#define GLEW_SGIX_blend_alpha_minmax GLEW_GET_VAR(__GLEW_SGIX_blend_alpha_minmax)
+
+#endif /* GL_SGIX_blend_alpha_minmax */
+
+    /* ---------------------------- GL_SGIX_clipmap ---------------------------- */
+
+#ifndef GL_SGIX_clipmap
+#define GL_SGIX_clipmap 1
+
+#define GLEW_SGIX_clipmap GLEW_GET_VAR(__GLEW_SGIX_clipmap)
+
+#endif /* GL_SGIX_clipmap */
+
+    /* ---------------------- GL_SGIX_convolution_accuracy --------------------- */
+
+#ifndef GL_SGIX_convolution_accuracy
+#define GL_SGIX_convolution_accuracy 1
+
+#define GL_CONVOLUTION_HINT_SGIX 0x8316
+
+#define GLEW_SGIX_convolution_accuracy GLEW_GET_VAR(__GLEW_SGIX_convolution_accuracy)
+
+#endif /* GL_SGIX_convolution_accuracy */
+
+    /* ------------------------- GL_SGIX_depth_texture ------------------------- */
+
+#ifndef GL_SGIX_depth_texture
+#define GL_SGIX_depth_texture 1
+
+#define GL_DEPTH_COMPONENT16_SGIX 0x81A5
+#define GL_DEPTH_COMPONENT24_SGIX 0x81A6
+#define GL_DEPTH_COMPONENT32_SGIX 0x81A7
+
+#define GLEW_SGIX_depth_texture GLEW_GET_VAR(__GLEW_SGIX_depth_texture)
+
+#endif /* GL_SGIX_depth_texture */
+
+    /* -------------------------- GL_SGIX_flush_raster ------------------------- */
+
+#ifndef GL_SGIX_flush_raster
+#define GL_SGIX_flush_raster 1
+
+    typedef void (GLAPIENTRY *PFNGLFLUSHRASTERSGIXPROC)(void);
+
+#define glFlushRasterSGIX GLEW_GET_FUN(__glewFlushRasterSGIX)
+
+#define GLEW_SGIX_flush_raster GLEW_GET_VAR(__GLEW_SGIX_flush_raster)
+
+#endif /* GL_SGIX_flush_raster */
+
+    /* --------------------------- GL_SGIX_fog_offset -------------------------- */
+
+#ifndef GL_SGIX_fog_offset
+#define GL_SGIX_fog_offset 1
+
+#define GL_FOG_OFFSET_SGIX 0x8198
+#define GL_FOG_OFFSET_VALUE_SGIX 0x8199
+
+#define GLEW_SGIX_fog_offset GLEW_GET_VAR(__GLEW_SGIX_fog_offset)
+
+#endif /* GL_SGIX_fog_offset */
+
+    /* -------------------------- GL_SGIX_fog_texture -------------------------- */
+
+#ifndef GL_SGIX_fog_texture
+#define GL_SGIX_fog_texture 1
+
+#define GL_TEXTURE_FOG_SGIX 0
+#define GL_FOG_PATCHY_FACTOR_SGIX 0
+#define GL_FRAGMENT_FOG_SGIX 0
+
+    typedef void (GLAPIENTRY *PFNGLTEXTUREFOGSGIXPROC)(GLenum pname);
+
+#define glTextureFogSGIX GLEW_GET_FUN(__glewTextureFogSGIX)
+
+#define GLEW_SGIX_fog_texture GLEW_GET_VAR(__GLEW_SGIX_fog_texture)
+
+#endif /* GL_SGIX_fog_texture */
+
+    /* ------------------- GL_SGIX_fragment_specular_lighting ------------------ */
+
+#ifndef GL_SGIX_fragment_specular_lighting
+#define GL_SGIX_fragment_specular_lighting 1
+
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTCOLORMATERIALSGIXPROC)(GLenum face, GLenum mode);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTMODELFSGIXPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTMODELFVSGIXPROC)(GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTMODELISGIXPROC)(GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTMODELIVSGIXPROC)(GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTFSGIXPROC)(GLenum light, GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTISGIXPROC)(GLenum light, GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTMATERIALFSGIXPROC)(GLenum face, GLenum pname, const GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTMATERIALISGIXPROC)(GLenum face, GLenum pname, const GLint param);
+    typedef void (GLAPIENTRY *PFNGLFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum value, GLfloat *data);
+    typedef void (GLAPIENTRY *PFNGLGETFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum value, GLint *data);
+    typedef void (GLAPIENTRY *PFNGLGETFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname, const GLfloat *data);
+    typedef void (GLAPIENTRY *PFNGLGETFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname, const GLint *data);
+
+#define glFragmentColorMaterialSGIX GLEW_GET_FUN(__glewFragmentColorMaterialSGIX)
+#define glFragmentLightModelfSGIX GLEW_GET_FUN(__glewFragmentLightModelfSGIX)
+#define glFragmentLightModelfvSGIX GLEW_GET_FUN(__glewFragmentLightModelfvSGIX)
+#define glFragmentLightModeliSGIX GLEW_GET_FUN(__glewFragmentLightModeliSGIX)
+#define glFragmentLightModelivSGIX GLEW_GET_FUN(__glewFragmentLightModelivSGIX)
+#define glFragmentLightfSGIX GLEW_GET_FUN(__glewFragmentLightfSGIX)
+#define glFragmentLightfvSGIX GLEW_GET_FUN(__glewFragmentLightfvSGIX)
+#define glFragmentLightiSGIX GLEW_GET_FUN(__glewFragmentLightiSGIX)
+#define glFragmentLightivSGIX GLEW_GET_FUN(__glewFragmentLightivSGIX)
+#define glFragmentMaterialfSGIX GLEW_GET_FUN(__glewFragmentMaterialfSGIX)
+#define glFragmentMaterialfvSGIX GLEW_GET_FUN(__glewFragmentMaterialfvSGIX)
+#define glFragmentMaterialiSGIX GLEW_GET_FUN(__glewFragmentMaterialiSGIX)
+#define glFragmentMaterialivSGIX GLEW_GET_FUN(__glewFragmentMaterialivSGIX)
+#define glGetFragmentLightfvSGIX GLEW_GET_FUN(__glewGetFragmentLightfvSGIX)
+#define glGetFragmentLightivSGIX GLEW_GET_FUN(__glewGetFragmentLightivSGIX)
+#define glGetFragmentMaterialfvSGIX GLEW_GET_FUN(__glewGetFragmentMaterialfvSGIX)
+#define glGetFragmentMaterialivSGIX GLEW_GET_FUN(__glewGetFragmentMaterialivSGIX)
+
+#define GLEW_SGIX_fragment_specular_lighting GLEW_GET_VAR(__GLEW_SGIX_fragment_specular_lighting)
+
+#endif /* GL_SGIX_fragment_specular_lighting */
+
+    /* --------------------------- GL_SGIX_framezoom --------------------------- */
+
+#ifndef GL_SGIX_framezoom
+#define GL_SGIX_framezoom 1
+
+    typedef void (GLAPIENTRY *PFNGLFRAMEZOOMSGIXPROC)(GLint factor);
+
+#define glFrameZoomSGIX GLEW_GET_FUN(__glewFrameZoomSGIX)
+
+#define GLEW_SGIX_framezoom GLEW_GET_VAR(__GLEW_SGIX_framezoom)
+
+#endif /* GL_SGIX_framezoom */
+
+    /* --------------------------- GL_SGIX_interlace --------------------------- */
+
+#ifndef GL_SGIX_interlace
+#define GL_SGIX_interlace 1
+
+#define GL_INTERLACE_SGIX 0x8094
+
+#define GLEW_SGIX_interlace GLEW_GET_VAR(__GLEW_SGIX_interlace)
+
+#endif /* GL_SGIX_interlace */
+
+    /* ------------------------- GL_SGIX_ir_instrument1 ------------------------ */
+
+#ifndef GL_SGIX_ir_instrument1
+#define GL_SGIX_ir_instrument1 1
+
+#define GLEW_SGIX_ir_instrument1 GLEW_GET_VAR(__GLEW_SGIX_ir_instrument1)
+
+#endif /* GL_SGIX_ir_instrument1 */
+
+    /* ------------------------- GL_SGIX_list_priority ------------------------- */
+
+#ifndef GL_SGIX_list_priority
+#define GL_SGIX_list_priority 1
+
+#define GLEW_SGIX_list_priority GLEW_GET_VAR(__GLEW_SGIX_list_priority)
+
+#endif /* GL_SGIX_list_priority */
+
+    /* ------------------------- GL_SGIX_pixel_texture ------------------------- */
+
+#ifndef GL_SGIX_pixel_texture
+#define GL_SGIX_pixel_texture 1
+
+    typedef void (GLAPIENTRY *PFNGLPIXELTEXGENSGIXPROC)(GLenum mode);
+
+#define glPixelTexGenSGIX GLEW_GET_FUN(__glewPixelTexGenSGIX)
+
+#define GLEW_SGIX_pixel_texture GLEW_GET_VAR(__GLEW_SGIX_pixel_texture)
+
+#endif /* GL_SGIX_pixel_texture */
+
+    /* ----------------------- GL_SGIX_pixel_texture_bits ---------------------- */
+
+#ifndef GL_SGIX_pixel_texture_bits
+#define GL_SGIX_pixel_texture_bits 1
+
+#define GLEW_SGIX_pixel_texture_bits GLEW_GET_VAR(__GLEW_SGIX_pixel_texture_bits)
+
+#endif /* GL_SGIX_pixel_texture_bits */
+
+    /* ------------------------ GL_SGIX_reference_plane ------------------------ */
+
+#ifndef GL_SGIX_reference_plane
+#define GL_SGIX_reference_plane 1
+
+    typedef void (GLAPIENTRY *PFNGLREFERENCEPLANESGIXPROC)(const GLdouble *equation);
+
+#define glReferencePlaneSGIX GLEW_GET_FUN(__glewReferencePlaneSGIX)
+
+#define GLEW_SGIX_reference_plane GLEW_GET_VAR(__GLEW_SGIX_reference_plane)
+
+#endif /* GL_SGIX_reference_plane */
+
+    /* ---------------------------- GL_SGIX_resample --------------------------- */
+
+#ifndef GL_SGIX_resample
+#define GL_SGIX_resample 1
+
+#define GL_PACK_RESAMPLE_SGIX 0x842E
+#define GL_UNPACK_RESAMPLE_SGIX 0x842F
+#define GL_RESAMPLE_DECIMATE_SGIX 0x8430
+#define GL_RESAMPLE_REPLICATE_SGIX 0x8433
+#define GL_RESAMPLE_ZERO_FILL_SGIX 0x8434
+
+#define GLEW_SGIX_resample GLEW_GET_VAR(__GLEW_SGIX_resample)
+
+#endif /* GL_SGIX_resample */
+
+    /* ----------------------------- GL_SGIX_shadow ---------------------------- */
+
+#ifndef GL_SGIX_shadow
+#define GL_SGIX_shadow 1
+
+#define GL_TEXTURE_COMPARE_SGIX 0x819A
+#define GL_TEXTURE_COMPARE_OPERATOR_SGIX 0x819B
+#define GL_TEXTURE_LEQUAL_R_SGIX 0x819C
+#define GL_TEXTURE_GEQUAL_R_SGIX 0x819D
+
+#define GLEW_SGIX_shadow GLEW_GET_VAR(__GLEW_SGIX_shadow)
+
+#endif /* GL_SGIX_shadow */
+
+    /* ------------------------- GL_SGIX_shadow_ambient ------------------------ */
+
+#ifndef GL_SGIX_shadow_ambient
+#define GL_SGIX_shadow_ambient 1
+
+#define GL_SHADOW_AMBIENT_SGIX 0x80BF
+
+#define GLEW_SGIX_shadow_ambient GLEW_GET_VAR(__GLEW_SGIX_shadow_ambient)
+
+#endif /* GL_SGIX_shadow_ambient */
+
+    /* ----------------------------- GL_SGIX_sprite ---------------------------- */
+
+#ifndef GL_SGIX_sprite
+#define GL_SGIX_sprite 1
+
+    typedef void (GLAPIENTRY *PFNGLSPRITEPARAMETERFSGIXPROC)(GLenum pname, GLfloat param);
+    typedef void (GLAPIENTRY *PFNGLSPRITEPARAMETERFVSGIXPROC)(GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLSPRITEPARAMETERISGIXPROC)(GLenum pname, GLint param);
+    typedef void (GLAPIENTRY *PFNGLSPRITEPARAMETERIVSGIXPROC)(GLenum pname, GLint *params);
+
+#define glSpriteParameterfSGIX GLEW_GET_FUN(__glewSpriteParameterfSGIX)
+#define glSpriteParameterfvSGIX GLEW_GET_FUN(__glewSpriteParameterfvSGIX)
+#define glSpriteParameteriSGIX GLEW_GET_FUN(__glewSpriteParameteriSGIX)
+#define glSpriteParameterivSGIX GLEW_GET_FUN(__glewSpriteParameterivSGIX)
+
+#define GLEW_SGIX_sprite GLEW_GET_VAR(__GLEW_SGIX_sprite)
+
+#endif /* GL_SGIX_sprite */
+
+    /* ----------------------- GL_SGIX_tag_sample_buffer ----------------------- */
+
+#ifndef GL_SGIX_tag_sample_buffer
+#define GL_SGIX_tag_sample_buffer 1
+
+    typedef void (GLAPIENTRY *PFNGLTAGSAMPLEBUFFERSGIXPROC)(void);
+
+#define glTagSampleBufferSGIX GLEW_GET_FUN(__glewTagSampleBufferSGIX)
+
+#define GLEW_SGIX_tag_sample_buffer GLEW_GET_VAR(__GLEW_SGIX_tag_sample_buffer)
+
+#endif /* GL_SGIX_tag_sample_buffer */
+
+    /* ------------------------ GL_SGIX_texture_add_env ------------------------ */
+
+#ifndef GL_SGIX_texture_add_env
+#define GL_SGIX_texture_add_env 1
+
+#define GLEW_SGIX_texture_add_env GLEW_GET_VAR(__GLEW_SGIX_texture_add_env)
+
+#endif /* GL_SGIX_texture_add_env */
+
+    /* -------------------- GL_SGIX_texture_coordinate_clamp ------------------- */
+
+#ifndef GL_SGIX_texture_coordinate_clamp
+#define GL_SGIX_texture_coordinate_clamp 1
+
+#define GL_TEXTURE_MAX_CLAMP_S_SGIX 0x8369
+#define GL_TEXTURE_MAX_CLAMP_T_SGIX 0x836A
+#define GL_TEXTURE_MAX_CLAMP_R_SGIX 0x836B
+
+#define GLEW_SGIX_texture_coordinate_clamp GLEW_GET_VAR(__GLEW_SGIX_texture_coordinate_clamp)
+
+#endif /* GL_SGIX_texture_coordinate_clamp */
+
+    /* ------------------------ GL_SGIX_texture_lod_bias ----------------------- */
+
+#ifndef GL_SGIX_texture_lod_bias
+#define GL_SGIX_texture_lod_bias 1
+
+#define GLEW_SGIX_texture_lod_bias GLEW_GET_VAR(__GLEW_SGIX_texture_lod_bias)
+
+#endif /* GL_SGIX_texture_lod_bias */
+
+    /* ---------------------- GL_SGIX_texture_multi_buffer --------------------- */
+
+#ifndef GL_SGIX_texture_multi_buffer
+#define GL_SGIX_texture_multi_buffer 1
+
+#define GL_TEXTURE_MULTI_BUFFER_HINT_SGIX 0x812E
+
+#define GLEW_SGIX_texture_multi_buffer GLEW_GET_VAR(__GLEW_SGIX_texture_multi_buffer)
+
+#endif /* GL_SGIX_texture_multi_buffer */
+
+    /* ------------------------- GL_SGIX_texture_range ------------------------- */
+
+#ifndef GL_SGIX_texture_range
+#define GL_SGIX_texture_range 1
+
+#define GL_RGB_SIGNED_SGIX 0x85E0
+#define GL_RGBA_SIGNED_SGIX 0x85E1
+#define GL_ALPHA_SIGNED_SGIX 0x85E2
+#define GL_LUMINANCE_SIGNED_SGIX 0x85E3
+#define GL_INTENSITY_SIGNED_SGIX 0x85E4
+#define GL_LUMINANCE_ALPHA_SIGNED_SGIX 0x85E5
+#define GL_RGB16_SIGNED_SGIX 0x85E6
+#define GL_RGBA16_SIGNED_SGIX 0x85E7
+#define GL_ALPHA16_SIGNED_SGIX 0x85E8
+#define GL_LUMINANCE16_SIGNED_SGIX 0x85E9
+#define GL_INTENSITY16_SIGNED_SGIX 0x85EA
+#define GL_LUMINANCE16_ALPHA16_SIGNED_SGIX 0x85EB
+#define GL_RGB_EXTENDED_RANGE_SGIX 0x85EC
+#define GL_RGBA_EXTENDED_RANGE_SGIX 0x85ED
+#define GL_ALPHA_EXTENDED_RANGE_SGIX 0x85EE
+#define GL_LUMINANCE_EXTENDED_RANGE_SGIX 0x85EF
+#define GL_INTENSITY_EXTENDED_RANGE_SGIX 0x85F0
+#define GL_LUMINANCE_ALPHA_EXTENDED_RANGE_SGIX 0x85F1
+#define GL_RGB16_EXTENDED_RANGE_SGIX 0x85F2
+#define GL_RGBA16_EXTENDED_RANGE_SGIX 0x85F3
+#define GL_ALPHA16_EXTENDED_RANGE_SGIX 0x85F4
+#define GL_LUMINANCE16_EXTENDED_RANGE_SGIX 0x85F5
+#define GL_INTENSITY16_EXTENDED_RANGE_SGIX 0x85F6
+#define GL_LUMINANCE16_ALPHA16_EXTENDED_RANGE_SGIX 0x85F7
+#define GL_MIN_LUMINANCE_SGIS 0x85F8
+#define GL_MAX_LUMINANCE_SGIS 0x85F9
+#define GL_MIN_INTENSITY_SGIS 0x85FA
+#define GL_MAX_INTENSITY_SGIS 0x85FB
+
+#define GLEW_SGIX_texture_range GLEW_GET_VAR(__GLEW_SGIX_texture_range)
+
+#endif /* GL_SGIX_texture_range */
+
+    /* ----------------------- GL_SGIX_texture_scale_bias ---------------------- */
+
+#ifndef GL_SGIX_texture_scale_bias
+#define GL_SGIX_texture_scale_bias 1
+
+#define GL_POST_TEXTURE_FILTER_BIAS_SGIX 0x8179
+#define GL_POST_TEXTURE_FILTER_SCALE_SGIX 0x817A
+#define GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX 0x817B
+#define GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX 0x817C
+
+#define GLEW_SGIX_texture_scale_bias GLEW_GET_VAR(__GLEW_SGIX_texture_scale_bias)
+
+#endif /* GL_SGIX_texture_scale_bias */
+
+    /* ------------------------- GL_SGIX_vertex_preclip ------------------------ */
+
+#ifndef GL_SGIX_vertex_preclip
+#define GL_SGIX_vertex_preclip 1
+
+#define GL_VERTEX_PRECLIP_SGIX 0x83EE
+#define GL_VERTEX_PRECLIP_HINT_SGIX 0x83EF
+
+#define GLEW_SGIX_vertex_preclip GLEW_GET_VAR(__GLEW_SGIX_vertex_preclip)
+
+#endif /* GL_SGIX_vertex_preclip */
+
+    /* ---------------------- GL_SGIX_vertex_preclip_hint ---------------------- */
+
+#ifndef GL_SGIX_vertex_preclip_hint
+#define GL_SGIX_vertex_preclip_hint 1
+
+#define GL_VERTEX_PRECLIP_SGIX 0x83EE
+#define GL_VERTEX_PRECLIP_HINT_SGIX 0x83EF
+
+#define GLEW_SGIX_vertex_preclip_hint GLEW_GET_VAR(__GLEW_SGIX_vertex_preclip_hint)
+
+#endif /* GL_SGIX_vertex_preclip_hint */
+
+    /* ----------------------------- GL_SGIX_ycrcb ----------------------------- */
+
+#ifndef GL_SGIX_ycrcb
+#define GL_SGIX_ycrcb 1
+
+#define GLEW_SGIX_ycrcb GLEW_GET_VAR(__GLEW_SGIX_ycrcb)
+
+#endif /* GL_SGIX_ycrcb */
+
+    /* -------------------------- GL_SGI_color_matrix -------------------------- */
+
+#ifndef GL_SGI_color_matrix
+#define GL_SGI_color_matrix 1
+
+#define GL_COLOR_MATRIX_SGI 0x80B1
+#define GL_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B2
+#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B3
+#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI 0x80B4
+#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI 0x80B5
+#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI 0x80B6
+#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI 0x80B7
+#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI 0x80B8
+#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI 0x80B9
+#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI 0x80BA
+#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI 0x80BB
+
+#define GLEW_SGI_color_matrix GLEW_GET_VAR(__GLEW_SGI_color_matrix)
+
+#endif /* GL_SGI_color_matrix */
+
+    /* --------------------------- GL_SGI_color_table -------------------------- */
+
+#ifndef GL_SGI_color_table
+#define GL_SGI_color_table 1
+
+#define GL_COLOR_TABLE_SGI 0x80D0
+#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D1
+#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D2
+#define GL_PROXY_COLOR_TABLE_SGI 0x80D3
+#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D4
+#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D5
+#define GL_COLOR_TABLE_SCALE_SGI 0x80D6
+#define GL_COLOR_TABLE_BIAS_SGI 0x80D7
+#define GL_COLOR_TABLE_FORMAT_SGI 0x80D8
+#define GL_COLOR_TABLE_WIDTH_SGI 0x80D9
+#define GL_COLOR_TABLE_RED_SIZE_SGI 0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE_SGI 0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE_SGI 0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE_SGI 0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI 0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI 0x80DF
+
+    typedef void (GLAPIENTRY *PFNGLCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (GLAPIENTRY *PFNGLCOLORTABLESGIPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
+    typedef void (GLAPIENTRY *PFNGLCOPYCOLORTABLESGIPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (GLAPIENTRY *PFNGLGETCOLORTABLESGIPROC)(GLenum target, GLenum format, GLenum type, void *table);
+
+#define glColorTableParameterfvSGI GLEW_GET_FUN(__glewColorTableParameterfvSGI)
+#define glColorTableParameterivSGI GLEW_GET_FUN(__glewColorTableParameterivSGI)
+#define glColorTableSGI GLEW_GET_FUN(__glewColorTableSGI)
+#define glCopyColorTableSGI GLEW_GET_FUN(__glewCopyColorTableSGI)
+#define glGetColorTableParameterfvSGI GLEW_GET_FUN(__glewGetColorTableParameterfvSGI)
+#define glGetColorTableParameterivSGI GLEW_GET_FUN(__glewGetColorTableParameterivSGI)
+#define glGetColorTableSGI GLEW_GET_FUN(__glewGetColorTableSGI)
+
+#define GLEW_SGI_color_table GLEW_GET_VAR(__GLEW_SGI_color_table)
+
+#endif /* GL_SGI_color_table */
+
+    /* ----------------------- GL_SGI_texture_color_table ---------------------- */
+
+#ifndef GL_SGI_texture_color_table
+#define GL_SGI_texture_color_table 1
+
+#define GL_TEXTURE_COLOR_TABLE_SGI 0x80BC
+#define GL_PROXY_TEXTURE_COLOR_TABLE_SGI 0x80BD
+
+#define GLEW_SGI_texture_color_table GLEW_GET_VAR(__GLEW_SGI_texture_color_table)
+
+#endif /* GL_SGI_texture_color_table */
+
+    /* ------------------------- GL_SUNX_constant_data ------------------------- */
+
+#ifndef GL_SUNX_constant_data
+#define GL_SUNX_constant_data 1
+
+#define GL_UNPACK_CONSTANT_DATA_SUNX 0x81D5
+#define GL_TEXTURE_CONSTANT_DATA_SUNX 0x81D6
+
+    typedef void (GLAPIENTRY *PFNGLFINISHTEXTURESUNXPROC)(void);
+
+#define glFinishTextureSUNX GLEW_GET_FUN(__glewFinishTextureSUNX)
+
+#define GLEW_SUNX_constant_data GLEW_GET_VAR(__GLEW_SUNX_constant_data)
+
+#endif /* GL_SUNX_constant_data */
+
+    /* -------------------- GL_SUN_convolution_border_modes -------------------- */
+
+#ifndef GL_SUN_convolution_border_modes
+#define GL_SUN_convolution_border_modes 1
+
+#define GL_WRAP_BORDER_SUN 0x81D4
+
+#define GLEW_SUN_convolution_border_modes GLEW_GET_VAR(__GLEW_SUN_convolution_border_modes)
+
+#endif /* GL_SUN_convolution_border_modes */
+
+    /* -------------------------- GL_SUN_global_alpha -------------------------- */
+
+#ifndef GL_SUN_global_alpha
+#define GL_SUN_global_alpha 1
+
+#define GL_GLOBAL_ALPHA_SUN 0x81D9
+#define GL_GLOBAL_ALPHA_FACTOR_SUN 0x81DA
+
+    typedef void (GLAPIENTRY *PFNGLGLOBALALPHAFACTORBSUNPROC)(GLbyte factor);
+    typedef void (GLAPIENTRY *PFNGLGLOBALALPHAFACTORDSUNPROC)(GLdouble factor);
+    typedef void (GLAPIENTRY *PFNGLGLOBALALPHAFACTORFSUNPROC)(GLfloat factor);
+    typedef void (GLAPIENTRY *PFNGLGLOBALALPHAFACTORISUNPROC)(GLint factor);
+    typedef void (GLAPIENTRY *PFNGLGLOBALALPHAFACTORSSUNPROC)(GLshort factor);
+    typedef void (GLAPIENTRY *PFNGLGLOBALALPHAFACTORUBSUNPROC)(GLubyte factor);
+    typedef void (GLAPIENTRY *PFNGLGLOBALALPHAFACTORUISUNPROC)(GLuint factor);
+    typedef void (GLAPIENTRY *PFNGLGLOBALALPHAFACTORUSSUNPROC)(GLushort factor);
+
+#define glGlobalAlphaFactorbSUN GLEW_GET_FUN(__glewGlobalAlphaFactorbSUN)
+#define glGlobalAlphaFactordSUN GLEW_GET_FUN(__glewGlobalAlphaFactordSUN)
+#define glGlobalAlphaFactorfSUN GLEW_GET_FUN(__glewGlobalAlphaFactorfSUN)
+#define glGlobalAlphaFactoriSUN GLEW_GET_FUN(__glewGlobalAlphaFactoriSUN)
+#define glGlobalAlphaFactorsSUN GLEW_GET_FUN(__glewGlobalAlphaFactorsSUN)
+#define glGlobalAlphaFactorubSUN GLEW_GET_FUN(__glewGlobalAlphaFactorubSUN)
+#define glGlobalAlphaFactoruiSUN GLEW_GET_FUN(__glewGlobalAlphaFactoruiSUN)
+#define glGlobalAlphaFactorusSUN GLEW_GET_FUN(__glewGlobalAlphaFactorusSUN)
+
+#define GLEW_SUN_global_alpha GLEW_GET_VAR(__GLEW_SUN_global_alpha)
+
+#endif /* GL_SUN_global_alpha */
+
+    /* --------------------------- GL_SUN_mesh_array --------------------------- */
+
+#ifndef GL_SUN_mesh_array
+#define GL_SUN_mesh_array 1
+
+#define GL_QUAD_MESH_SUN 0x8614
+#define GL_TRIANGLE_MESH_SUN 0x8615
+
+#define GLEW_SUN_mesh_array GLEW_GET_VAR(__GLEW_SUN_mesh_array)
+
+#endif /* GL_SUN_mesh_array */
+
+    /* ------------------------ GL_SUN_read_video_pixels ----------------------- */
+
+#ifndef GL_SUN_read_video_pixels
+#define GL_SUN_read_video_pixels 1
+
+    typedef void (GLAPIENTRY *PFNGLREADVIDEOPIXELSSUNPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+
+#define glReadVideoPixelsSUN GLEW_GET_FUN(__glewReadVideoPixelsSUN)
+
+#define GLEW_SUN_read_video_pixels GLEW_GET_VAR(__GLEW_SUN_read_video_pixels)
+
+#endif /* GL_SUN_read_video_pixels */
+
+    /* --------------------------- GL_SUN_slice_accum -------------------------- */
+
+#ifndef GL_SUN_slice_accum
+#define GL_SUN_slice_accum 1
+
+#define GL_SLICE_ACCUM_SUN 0x85CC
+
+#define GLEW_SUN_slice_accum GLEW_GET_VAR(__GLEW_SUN_slice_accum)
+
+#endif /* GL_SUN_slice_accum */
+
+    /* -------------------------- GL_SUN_triangle_list ------------------------- */
+
+#ifndef GL_SUN_triangle_list
+#define GL_SUN_triangle_list 1
+
+#define GL_RESTART_SUN 0x01
+#define GL_REPLACE_MIDDLE_SUN 0x02
+#define GL_REPLACE_OLDEST_SUN 0x03
+#define GL_TRIANGLE_LIST_SUN 0x81D7
+#define GL_REPLACEMENT_CODE_SUN 0x81D8
+#define GL_REPLACEMENT_CODE_ARRAY_SUN 0x85C0
+#define GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN 0x85C1
+#define GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN 0x85C2
+#define GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN 0x85C3
+#define GL_R1UI_V3F_SUN 0x85C4
+#define GL_R1UI_C4UB_V3F_SUN 0x85C5
+#define GL_R1UI_C3F_V3F_SUN 0x85C6
+#define GL_R1UI_N3F_V3F_SUN 0x85C7
+#define GL_R1UI_C4F_N3F_V3F_SUN 0x85C8
+#define GL_R1UI_T2F_V3F_SUN 0x85C9
+#define GL_R1UI_T2F_N3F_V3F_SUN 0x85CA
+#define GL_R1UI_T2F_C4F_N3F_V3F_SUN 0x85CB
+
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEPOINTERSUNPROC)(GLenum type, GLsizei stride, const void *pointer);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUBSUNPROC)(GLubyte code);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUBVSUNPROC)(const GLubyte *code);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUISUNPROC)(GLuint code);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUIVSUNPROC)(const GLuint *code);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUSSUNPROC)(GLushort code);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUSVSUNPROC)(const GLushort *code);
+
+#define glReplacementCodePointerSUN GLEW_GET_FUN(__glewReplacementCodePointerSUN)
+#define glReplacementCodeubSUN GLEW_GET_FUN(__glewReplacementCodeubSUN)
+#define glReplacementCodeubvSUN GLEW_GET_FUN(__glewReplacementCodeubvSUN)
+#define glReplacementCodeuiSUN GLEW_GET_FUN(__glewReplacementCodeuiSUN)
+#define glReplacementCodeuivSUN GLEW_GET_FUN(__glewReplacementCodeuivSUN)
+#define glReplacementCodeusSUN GLEW_GET_FUN(__glewReplacementCodeusSUN)
+#define glReplacementCodeusvSUN GLEW_GET_FUN(__glewReplacementCodeusvSUN)
+
+#define GLEW_SUN_triangle_list GLEW_GET_VAR(__GLEW_SUN_triangle_list)
+
+#endif /* GL_SUN_triangle_list */
+
+    /* ----------------------------- GL_SUN_vertex ----------------------------- */
+
+#ifndef GL_SUN_vertex
+#define GL_SUN_vertex 1
+
+    typedef void (GLAPIENTRY *PFNGLCOLOR3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLCOLOR3FVERTEX3FVSUNPROC)(const GLfloat *c, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLCOLOR4UBVERTEX2FSUNPROC)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
+    typedef void (GLAPIENTRY *PFNGLCOLOR4UBVERTEX2FVSUNPROC)(const GLubyte *c, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLCOLOR4UBVERTEX3FSUNPROC)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLCOLOR4UBVERTEX3FVSUNPROC)(const GLubyte *c, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLNORMAL3FVERTEX3FSUNPROC)(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *c, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC)(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC)(const GLuint *rc, const GLubyte *c, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC)(GLuint rc, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC)(const GLfloat *tc, const GLubyte *c, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD2FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD4FVERTEX4FSUNPROC)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (GLAPIENTRY *PFNGLTEXCOORD4FVERTEX4FVSUNPROC)(const GLfloat *tc, const GLfloat *v);
+
+#define glColor3fVertex3fSUN GLEW_GET_FUN(__glewColor3fVertex3fSUN)
+#define glColor3fVertex3fvSUN GLEW_GET_FUN(__glewColor3fVertex3fvSUN)
+#define glColor4fNormal3fVertex3fSUN GLEW_GET_FUN(__glewColor4fNormal3fVertex3fSUN)
+#define glColor4fNormal3fVertex3fvSUN GLEW_GET_FUN(__glewColor4fNormal3fVertex3fvSUN)
+#define glColor4ubVertex2fSUN GLEW_GET_FUN(__glewColor4ubVertex2fSUN)
+#define glColor4ubVertex2fvSUN GLEW_GET_FUN(__glewColor4ubVertex2fvSUN)
+#define glColor4ubVertex3fSUN GLEW_GET_FUN(__glewColor4ubVertex3fSUN)
+#define glColor4ubVertex3fvSUN GLEW_GET_FUN(__glewColor4ubVertex3fvSUN)
+#define glNormal3fVertex3fSUN GLEW_GET_FUN(__glewNormal3fVertex3fSUN)
+#define glNormal3fVertex3fvSUN GLEW_GET_FUN(__glewNormal3fVertex3fvSUN)
+#define glReplacementCodeuiColor3fVertex3fSUN GLEW_GET_FUN(__glewReplacementCodeuiColor3fVertex3fSUN)
+#define glReplacementCodeuiColor3fVertex3fvSUN GLEW_GET_FUN(__glewReplacementCodeuiColor3fVertex3fvSUN)
+#define glReplacementCodeuiColor4fNormal3fVertex3fSUN GLEW_GET_FUN(__glewReplacementCodeuiColor4fNormal3fVertex3fSUN)
+#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN GLEW_GET_FUN(__glewReplacementCodeuiColor4fNormal3fVertex3fvSUN)
+#define glReplacementCodeuiColor4ubVertex3fSUN GLEW_GET_FUN(__glewReplacementCodeuiColor4ubVertex3fSUN)
+#define glReplacementCodeuiColor4ubVertex3fvSUN GLEW_GET_FUN(__glewReplacementCodeuiColor4ubVertex3fvSUN)
+#define glReplacementCodeuiNormal3fVertex3fSUN GLEW_GET_FUN(__glewReplacementCodeuiNormal3fVertex3fSUN)
+#define glReplacementCodeuiNormal3fVertex3fvSUN GLEW_GET_FUN(__glewReplacementCodeuiNormal3fVertex3fvSUN)
+#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN GLEW_GET_FUN(__glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN)
+#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN GLEW_GET_FUN(__glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN)
+#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN GLEW_GET_FUN(__glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN)
+#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN GLEW_GET_FUN(__glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN)
+#define glReplacementCodeuiTexCoord2fVertex3fSUN GLEW_GET_FUN(__glewReplacementCodeuiTexCoord2fVertex3fSUN)
+#define glReplacementCodeuiTexCoord2fVertex3fvSUN GLEW_GET_FUN(__glewReplacementCodeuiTexCoord2fVertex3fvSUN)
+#define glReplacementCodeuiVertex3fSUN GLEW_GET_FUN(__glewReplacementCodeuiVertex3fSUN)
+#define glReplacementCodeuiVertex3fvSUN GLEW_GET_FUN(__glewReplacementCodeuiVertex3fvSUN)
+#define glTexCoord2fColor3fVertex3fSUN GLEW_GET_FUN(__glewTexCoord2fColor3fVertex3fSUN)
+#define glTexCoord2fColor3fVertex3fvSUN GLEW_GET_FUN(__glewTexCoord2fColor3fVertex3fvSUN)
+#define glTexCoord2fColor4fNormal3fVertex3fSUN GLEW_GET_FUN(__glewTexCoord2fColor4fNormal3fVertex3fSUN)
+#define glTexCoord2fColor4fNormal3fVertex3fvSUN GLEW_GET_FUN(__glewTexCoord2fColor4fNormal3fVertex3fvSUN)
+#define glTexCoord2fColor4ubVertex3fSUN GLEW_GET_FUN(__glewTexCoord2fColor4ubVertex3fSUN)
+#define glTexCoord2fColor4ubVertex3fvSUN GLEW_GET_FUN(__glewTexCoord2fColor4ubVertex3fvSUN)
+#define glTexCoord2fNormal3fVertex3fSUN GLEW_GET_FUN(__glewTexCoord2fNormal3fVertex3fSUN)
+#define glTexCoord2fNormal3fVertex3fvSUN GLEW_GET_FUN(__glewTexCoord2fNormal3fVertex3fvSUN)
+#define glTexCoord2fVertex3fSUN GLEW_GET_FUN(__glewTexCoord2fVertex3fSUN)
+#define glTexCoord2fVertex3fvSUN GLEW_GET_FUN(__glewTexCoord2fVertex3fvSUN)
+#define glTexCoord4fColor4fNormal3fVertex4fSUN GLEW_GET_FUN(__glewTexCoord4fColor4fNormal3fVertex4fSUN)
+#define glTexCoord4fColor4fNormal3fVertex4fvSUN GLEW_GET_FUN(__glewTexCoord4fColor4fNormal3fVertex4fvSUN)
+#define glTexCoord4fVertex4fSUN GLEW_GET_FUN(__glewTexCoord4fVertex4fSUN)
+#define glTexCoord4fVertex4fvSUN GLEW_GET_FUN(__glewTexCoord4fVertex4fvSUN)
+
+#define GLEW_SUN_vertex GLEW_GET_VAR(__GLEW_SUN_vertex)
+
+#endif /* GL_SUN_vertex */
+
+    /* -------------------------- GL_WIN_phong_shading ------------------------- */
+
+#ifndef GL_WIN_phong_shading
+#define GL_WIN_phong_shading 1
+
+#define GL_PHONG_WIN 0x80EA
+#define GL_PHONG_HINT_WIN 0x80EB
+
+#define GLEW_WIN_phong_shading GLEW_GET_VAR(__GLEW_WIN_phong_shading)
+
+#endif /* GL_WIN_phong_shading */
+
+    /* -------------------------- GL_WIN_specular_fog -------------------------- */
+
+#ifndef GL_WIN_specular_fog
+#define GL_WIN_specular_fog 1
+
+#define GL_FOG_SPECULAR_TEXTURE_WIN 0x80EC
+
+#define GLEW_WIN_specular_fog GLEW_GET_VAR(__GLEW_WIN_specular_fog)
+
+#endif /* GL_WIN_specular_fog */
+
+    /* ---------------------------- GL_WIN_swap_hint --------------------------- */
+
+#ifndef GL_WIN_swap_hint
+#define GL_WIN_swap_hint 1
+
+    typedef void (GLAPIENTRY *PFNGLADDSWAPHINTRECTWINPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
+
+#define glAddSwapHintRectWIN GLEW_GET_FUN(__glewAddSwapHintRectWIN)
+
+#define GLEW_WIN_swap_hint GLEW_GET_VAR(__GLEW_WIN_swap_hint)
+
+#endif /* GL_WIN_swap_hint */
+
+    /* ------------------------------------------------------------------------- */
+
+#if defined(GLEW_MX) && defined(_WIN32)
+#define GLEW_FUN_EXPORT
+#else
+#define GLEW_FUN_EXPORT GLEWAPI
+#endif /* GLEW_MX */
+
+#if defined(GLEW_MX)
+#define GLEW_VAR_EXPORT
+#else
+#define GLEW_VAR_EXPORT GLEWAPI
+#endif /* GLEW_MX */
+
+#if defined(GLEW_MX) && defined(_WIN32)
+    struct GLEWContextStruct
+    {
+#endif /* GLEW_MX */
+
+        GLEW_FUN_EXPORT PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
+        GLEW_FUN_EXPORT PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
+        GLEW_FUN_EXPORT PFNGLTEXIMAGE3DPROC __glewTexImage3D;
+        GLEW_FUN_EXPORT PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;
+
+        GLEW_FUN_EXPORT PFNGLACTIVETEXTUREPROC __glewActiveTexture;
+        GLEW_FUN_EXPORT PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
+        GLEW_FUN_EXPORT PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
+        GLEW_FUN_EXPORT PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
+        GLEW_FUN_EXPORT PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
+        GLEW_FUN_EXPORT PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
+        GLEW_FUN_EXPORT PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
+        GLEW_FUN_EXPORT PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;
+
+        GLEW_FUN_EXPORT PFNGLBLENDCOLORPROC __glewBlendColor;
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONPROC __glewBlendEquation;
+        GLEW_FUN_EXPORT PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDDPROC __glewFogCoordd;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDDVPROC __glewFogCoorddv;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDFPROC __glewFogCoordf;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDFVPROC __glewFogCoordfv;
+        GLEW_FUN_EXPORT PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
+        GLEW_FUN_EXPORT PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;
+
+        GLEW_FUN_EXPORT PFNGLBEGINQUERYPROC __glewBeginQuery;
+        GLEW_FUN_EXPORT PFNGLBINDBUFFERPROC __glewBindBuffer;
+        GLEW_FUN_EXPORT PFNGLBUFFERDATAPROC __glewBufferData;
+        GLEW_FUN_EXPORT PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
+        GLEW_FUN_EXPORT PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
+        GLEW_FUN_EXPORT PFNGLDELETEQUERIESPROC __glewDeleteQueries;
+        GLEW_FUN_EXPORT PFNGLENDQUERYPROC __glewEndQuery;
+        GLEW_FUN_EXPORT PFNGLGENBUFFERSPROC __glewGenBuffers;
+        GLEW_FUN_EXPORT PFNGLGENQUERIESPROC __glewGenQueries;
+        GLEW_FUN_EXPORT PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
+        GLEW_FUN_EXPORT PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
+        GLEW_FUN_EXPORT PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
+        GLEW_FUN_EXPORT PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
+        GLEW_FUN_EXPORT PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
+        GLEW_FUN_EXPORT PFNGLGETQUERYIVPROC __glewGetQueryiv;
+        GLEW_FUN_EXPORT PFNGLISBUFFERPROC __glewIsBuffer;
+        GLEW_FUN_EXPORT PFNGLISQUERYPROC __glewIsQuery;
+        GLEW_FUN_EXPORT PFNGLMAPBUFFERPROC __glewMapBuffer;
+        GLEW_FUN_EXPORT PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;
+
+        GLEW_FUN_EXPORT PFNGLATTACHSHADERPROC __glewAttachShader;
+        GLEW_FUN_EXPORT PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
+        GLEW_FUN_EXPORT PFNGLCOMPILESHADERPROC __glewCompileShader;
+        GLEW_FUN_EXPORT PFNGLCREATEPROGRAMPROC __glewCreateProgram;
+        GLEW_FUN_EXPORT PFNGLCREATESHADERPROC __glewCreateShader;
+        GLEW_FUN_EXPORT PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
+        GLEW_FUN_EXPORT PFNGLDELETESHADERPROC __glewDeleteShader;
+        GLEW_FUN_EXPORT PFNGLDETACHSHADERPROC __glewDetachShader;
+        GLEW_FUN_EXPORT PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
+        GLEW_FUN_EXPORT PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
+        GLEW_FUN_EXPORT PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
+        GLEW_FUN_EXPORT PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
+        GLEW_FUN_EXPORT PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
+        GLEW_FUN_EXPORT PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
+        GLEW_FUN_EXPORT PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
+        GLEW_FUN_EXPORT PFNGLGETSHADERIVPROC __glewGetShaderiv;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
+        GLEW_FUN_EXPORT PFNGLISPROGRAMPROC __glewIsProgram;
+        GLEW_FUN_EXPORT PFNGLISSHADERPROC __glewIsShader;
+        GLEW_FUN_EXPORT PFNGLLINKPROGRAMPROC __glewLinkProgram;
+        GLEW_FUN_EXPORT PFNGLSHADERSOURCEPROC __glewShaderSource;
+        GLEW_FUN_EXPORT PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
+        GLEW_FUN_EXPORT PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
+        GLEW_FUN_EXPORT PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1FPROC __glewUniform1f;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1FVPROC __glewUniform1fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1IPROC __glewUniform1i;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1IVPROC __glewUniform1iv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2FPROC __glewUniform2f;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2FVPROC __glewUniform2fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2IPROC __glewUniform2i;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2IVPROC __glewUniform2iv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3FPROC __glewUniform3f;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3FVPROC __glewUniform3fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3IPROC __glewUniform3i;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3IVPROC __glewUniform3iv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4FPROC __glewUniform4f;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4FVPROC __glewUniform4fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4IPROC __glewUniform4i;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4IVPROC __glewUniform4iv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
+        GLEW_FUN_EXPORT PFNGLUSEPROGRAMPROC __glewUseProgram;
+        GLEW_FUN_EXPORT PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;
+
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;
+
+        GLEW_FUN_EXPORT PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
+        GLEW_FUN_EXPORT PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
+        GLEW_FUN_EXPORT PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
+        GLEW_FUN_EXPORT PFNGLCLAMPCOLORPROC __glewClampColor;
+        GLEW_FUN_EXPORT PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
+        GLEW_FUN_EXPORT PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
+        GLEW_FUN_EXPORT PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
+        GLEW_FUN_EXPORT PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
+        GLEW_FUN_EXPORT PFNGLCOLORMASKIPROC __glewColorMaski;
+        GLEW_FUN_EXPORT PFNGLDISABLEIPROC __glewDisablei;
+        GLEW_FUN_EXPORT PFNGLENABLEIPROC __glewEnablei;
+        GLEW_FUN_EXPORT PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
+        GLEW_FUN_EXPORT PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
+        GLEW_FUN_EXPORT PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
+        GLEW_FUN_EXPORT PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
+        GLEW_FUN_EXPORT PFNGLGETSTRINGIPROC __glewGetStringi;
+        GLEW_FUN_EXPORT PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
+        GLEW_FUN_EXPORT PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
+        GLEW_FUN_EXPORT PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
+        GLEW_FUN_EXPORT PFNGLISENABLEDIPROC __glewIsEnabledi;
+        GLEW_FUN_EXPORT PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
+        GLEW_FUN_EXPORT PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
+        GLEW_FUN_EXPORT PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1UIPROC __glewUniform1ui;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2UIPROC __glewUniform2ui;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3UIPROC __glewUniform3ui;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4UIPROC __glewUniform4ui;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;
+
+        GLEW_FUN_EXPORT PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
+        GLEW_FUN_EXPORT PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
+        GLEW_FUN_EXPORT PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
+        GLEW_FUN_EXPORT PFNGLTEXBUFFERPROC __glewTexBuffer;
+
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
+        GLEW_FUN_EXPORT PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
+        GLEW_FUN_EXPORT PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;
+
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
+        GLEW_FUN_EXPORT PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
+        GLEW_FUN_EXPORT PFNGLBLENDFUNCIPROC __glewBlendFunci;
+        GLEW_FUN_EXPORT PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;
+
+        GLEW_FUN_EXPORT PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;
+
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
+        GLEW_FUN_EXPORT PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
+        GLEW_FUN_EXPORT PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;
+
+        GLEW_FUN_EXPORT PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
+        GLEW_FUN_EXPORT PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
+        GLEW_FUN_EXPORT PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
+        GLEW_FUN_EXPORT PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
+        GLEW_FUN_EXPORT PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
+        GLEW_FUN_EXPORT PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
+        GLEW_FUN_EXPORT PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
+        GLEW_FUN_EXPORT PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
+        GLEW_FUN_EXPORT PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
+        GLEW_FUN_EXPORT PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
+        GLEW_FUN_EXPORT PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;
+
+        GLEW_FUN_EXPORT PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
+        GLEW_FUN_EXPORT PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;
+
+        GLEW_FUN_EXPORT PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
+        GLEW_FUN_EXPORT PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
+        GLEW_FUN_EXPORT PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
+        GLEW_FUN_EXPORT PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
+        GLEW_FUN_EXPORT PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;
+
+        GLEW_FUN_EXPORT PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
+        GLEW_FUN_EXPORT PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
+        GLEW_FUN_EXPORT PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
+        GLEW_FUN_EXPORT PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
+        GLEW_FUN_EXPORT PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
+        GLEW_FUN_EXPORT PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
+        GLEW_FUN_EXPORT PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
+        GLEW_FUN_EXPORT PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;
+
+        GLEW_FUN_EXPORT PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
+        GLEW_FUN_EXPORT PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;
+
+        GLEW_FUN_EXPORT PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
+        GLEW_FUN_EXPORT PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
+        GLEW_FUN_EXPORT PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;
+
+        GLEW_FUN_EXPORT PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
+        GLEW_FUN_EXPORT PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;
+
+        GLEW_FUN_EXPORT PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
+        GLEW_FUN_EXPORT PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
+        GLEW_FUN_EXPORT PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
+        GLEW_FUN_EXPORT PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;
+
+        GLEW_FUN_EXPORT PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;
+
+        GLEW_FUN_EXPORT PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
+        GLEW_FUN_EXPORT PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
+        GLEW_FUN_EXPORT PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
+        GLEW_FUN_EXPORT PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
+        GLEW_FUN_EXPORT PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
+        GLEW_FUN_EXPORT PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
+        GLEW_FUN_EXPORT PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;
+
+        GLEW_FUN_EXPORT PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
+        GLEW_FUN_EXPORT PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;
+
+        GLEW_FUN_EXPORT PFNGLCLAMPCOLORARBPROC __glewClampColorARB;
+
+        GLEW_FUN_EXPORT PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;
+
+        GLEW_FUN_EXPORT PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;
+
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
+        GLEW_FUN_EXPORT PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
+        GLEW_FUN_EXPORT PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;
+
+        GLEW_FUN_EXPORT PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
+        GLEW_FUN_EXPORT PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
+        GLEW_FUN_EXPORT PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
+        GLEW_FUN_EXPORT PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;
+
+        GLEW_FUN_EXPORT PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
+        GLEW_FUN_EXPORT PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;
+
+        GLEW_FUN_EXPORT PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
+        GLEW_FUN_EXPORT PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
+
+        GLEW_FUN_EXPORT PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
+        GLEW_FUN_EXPORT PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
+        GLEW_FUN_EXPORT PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
+        GLEW_FUN_EXPORT PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
+        GLEW_FUN_EXPORT PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
+        GLEW_FUN_EXPORT PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
+        GLEW_FUN_EXPORT PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
+        GLEW_FUN_EXPORT PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
+        GLEW_FUN_EXPORT PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
+        GLEW_FUN_EXPORT PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
+        GLEW_FUN_EXPORT PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
+        GLEW_FUN_EXPORT PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
+        GLEW_FUN_EXPORT PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
+        GLEW_FUN_EXPORT PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
+        GLEW_FUN_EXPORT PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;
+
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;
+
+        GLEW_FUN_EXPORT PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
+        GLEW_FUN_EXPORT PFNGLCOLORTABLEPROC __glewColorTable;
+        GLEW_FUN_EXPORT PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
+        GLEW_FUN_EXPORT PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
+        GLEW_FUN_EXPORT PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
+        GLEW_FUN_EXPORT PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
+        GLEW_FUN_EXPORT PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
+        GLEW_FUN_EXPORT PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLEPROC __glewGetColorTable;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
+        GLEW_FUN_EXPORT PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
+        GLEW_FUN_EXPORT PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
+        GLEW_FUN_EXPORT PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
+        GLEW_FUN_EXPORT PFNGLGETHISTOGRAMPROC __glewGetHistogram;
+        GLEW_FUN_EXPORT PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
+        GLEW_FUN_EXPORT PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
+        GLEW_FUN_EXPORT PFNGLGETMINMAXPROC __glewGetMinmax;
+        GLEW_FUN_EXPORT PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
+        GLEW_FUN_EXPORT PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
+        GLEW_FUN_EXPORT PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
+        GLEW_FUN_EXPORT PFNGLHISTOGRAMPROC __glewHistogram;
+        GLEW_FUN_EXPORT PFNGLMINMAXPROC __glewMinmax;
+        GLEW_FUN_EXPORT PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
+        GLEW_FUN_EXPORT PFNGLRESETMINMAXPROC __glewResetMinmax;
+        GLEW_FUN_EXPORT PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;
+
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;
+
+        GLEW_FUN_EXPORT PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
+        GLEW_FUN_EXPORT PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;
+
+        GLEW_FUN_EXPORT PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
+        GLEW_FUN_EXPORT PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
+        GLEW_FUN_EXPORT PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
+        GLEW_FUN_EXPORT PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
+        GLEW_FUN_EXPORT PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;
+
+        GLEW_FUN_EXPORT PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;
+
+        GLEW_FUN_EXPORT PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
+        GLEW_FUN_EXPORT PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;
+
+        GLEW_FUN_EXPORT PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
+        GLEW_FUN_EXPORT PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
+        GLEW_FUN_EXPORT PFNGLENDQUERYARBPROC __glewEndQueryARB;
+        GLEW_FUN_EXPORT PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
+        GLEW_FUN_EXPORT PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
+        GLEW_FUN_EXPORT PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
+        GLEW_FUN_EXPORT PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
+        GLEW_FUN_EXPORT PFNGLISQUERYARBPROC __glewIsQueryARB;
+
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;
+
+        GLEW_FUN_EXPORT PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;
+
+        GLEW_FUN_EXPORT PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;
+
+        GLEW_FUN_EXPORT PFNGLBINDSAMPLERPROC __glewBindSampler;
+        GLEW_FUN_EXPORT PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
+        GLEW_FUN_EXPORT PFNGLGENSAMPLERSPROC __glewGenSamplers;
+        GLEW_FUN_EXPORT PFNGLISSAMPLERPROC __glewIsSampler;
+
+        GLEW_FUN_EXPORT PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
+        GLEW_FUN_EXPORT PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
+        GLEW_FUN_EXPORT PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
+        GLEW_FUN_EXPORT PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
+        GLEW_FUN_EXPORT PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
+        GLEW_FUN_EXPORT PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
+        GLEW_FUN_EXPORT PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
+        GLEW_FUN_EXPORT PFNGLGETHANDLEARBPROC __glewGetHandleARB;
+        GLEW_FUN_EXPORT PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
+        GLEW_FUN_EXPORT PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
+        GLEW_FUN_EXPORT PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
+        GLEW_FUN_EXPORT PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
+        GLEW_FUN_EXPORT PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
+        GLEW_FUN_EXPORT PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
+        GLEW_FUN_EXPORT PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
+        GLEW_FUN_EXPORT PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
+        GLEW_FUN_EXPORT PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;
+
+        GLEW_FUN_EXPORT PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
+        GLEW_FUN_EXPORT PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
+        GLEW_FUN_EXPORT PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
+        GLEW_FUN_EXPORT PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
+        GLEW_FUN_EXPORT PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
+        GLEW_FUN_EXPORT PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;
+
+        GLEW_FUN_EXPORT PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
+        GLEW_FUN_EXPORT PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
+        GLEW_FUN_EXPORT PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
+        GLEW_FUN_EXPORT PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;
+
+        GLEW_FUN_EXPORT PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
+        GLEW_FUN_EXPORT PFNGLDELETESYNCPROC __glewDeleteSync;
+        GLEW_FUN_EXPORT PFNGLFENCESYNCPROC __glewFenceSync;
+        GLEW_FUN_EXPORT PFNGLGETINTEGER64VPROC __glewGetInteger64v;
+        GLEW_FUN_EXPORT PFNGLGETSYNCIVPROC __glewGetSynciv;
+        GLEW_FUN_EXPORT PFNGLISSYNCPROC __glewIsSync;
+        GLEW_FUN_EXPORT PFNGLWAITSYNCPROC __glewWaitSync;
+
+        GLEW_FUN_EXPORT PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
+        GLEW_FUN_EXPORT PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;
+
+        GLEW_FUN_EXPORT PFNGLTEXBUFFERARBPROC __glewTexBufferARB;
+
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
+        GLEW_FUN_EXPORT PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;
+
+        GLEW_FUN_EXPORT PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
+        GLEW_FUN_EXPORT PFNGLSAMPLEMASKIPROC __glewSampleMaski;
+        GLEW_FUN_EXPORT PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
+        GLEW_FUN_EXPORT PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;
+
+        GLEW_FUN_EXPORT PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
+        GLEW_FUN_EXPORT PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
+        GLEW_FUN_EXPORT PFNGLQUERYCOUNTERPROC __glewQueryCounter;
+
+        GLEW_FUN_EXPORT PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
+        GLEW_FUN_EXPORT PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
+        GLEW_FUN_EXPORT PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
+        GLEW_FUN_EXPORT PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
+        GLEW_FUN_EXPORT PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
+        GLEW_FUN_EXPORT PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
+        GLEW_FUN_EXPORT PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;
+
+        GLEW_FUN_EXPORT PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
+        GLEW_FUN_EXPORT PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
+        GLEW_FUN_EXPORT PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
+        GLEW_FUN_EXPORT PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;
+
+        GLEW_FUN_EXPORT PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
+        GLEW_FUN_EXPORT PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
+        GLEW_FUN_EXPORT PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
+        GLEW_FUN_EXPORT PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;
+
+        GLEW_FUN_EXPORT PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
+        GLEW_FUN_EXPORT PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
+        GLEW_FUN_EXPORT PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
+        GLEW_FUN_EXPORT PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;
+
+        GLEW_FUN_EXPORT PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
+        GLEW_FUN_EXPORT PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
+        GLEW_FUN_EXPORT PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
+        GLEW_FUN_EXPORT PFNGLISVERTEXARRAYPROC __glewIsVertexArray;
+
+        GLEW_FUN_EXPORT PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTIVARBPROC __glewWeightivARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
+        GLEW_FUN_EXPORT PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;
+
+        GLEW_FUN_EXPORT PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
+        GLEW_FUN_EXPORT PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
+        GLEW_FUN_EXPORT PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
+        GLEW_FUN_EXPORT PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
+        GLEW_FUN_EXPORT PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
+        GLEW_FUN_EXPORT PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
+        GLEW_FUN_EXPORT PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
+        GLEW_FUN_EXPORT PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
+        GLEW_FUN_EXPORT PFNGLISBUFFERARBPROC __glewIsBufferARB;
+        GLEW_FUN_EXPORT PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
+        GLEW_FUN_EXPORT PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;
+
+        GLEW_FUN_EXPORT PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
+        GLEW_FUN_EXPORT PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
+        GLEW_FUN_EXPORT PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
+        GLEW_FUN_EXPORT PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
+        GLEW_FUN_EXPORT PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
+        GLEW_FUN_EXPORT PFNGLISPROGRAMARBPROC __glewIsProgramARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
+        GLEW_FUN_EXPORT PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;
+
+        GLEW_FUN_EXPORT PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
+        GLEW_FUN_EXPORT PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;
+
+        GLEW_FUN_EXPORT PFNGLCOLORP3UIPROC __glewColorP3ui;
+        GLEW_FUN_EXPORT PFNGLCOLORP3UIVPROC __glewColorP3uiv;
+        GLEW_FUN_EXPORT PFNGLCOLORP4UIPROC __glewColorP4ui;
+        GLEW_FUN_EXPORT PFNGLCOLORP4UIVPROC __glewColorP4uiv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
+        GLEW_FUN_EXPORT PFNGLNORMALP3UIPROC __glewNormalP3ui;
+        GLEW_FUN_EXPORT PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXP2UIPROC __glewVertexP2ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXP3UIPROC __glewVertexP3ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
+        GLEW_FUN_EXPORT PFNGLVERTEXP4UIPROC __glewVertexP4ui;
+        GLEW_FUN_EXPORT PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;
+
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;
+
+        GLEW_FUN_EXPORT PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;
+
+        GLEW_FUN_EXPORT PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
+        GLEW_FUN_EXPORT PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
+        GLEW_FUN_EXPORT PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;
+
+        GLEW_FUN_EXPORT PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
+        GLEW_FUN_EXPORT PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
+        GLEW_FUN_EXPORT PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
+        GLEW_FUN_EXPORT PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;
+
+        GLEW_FUN_EXPORT PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
+        GLEW_FUN_EXPORT PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
+        GLEW_FUN_EXPORT PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
+        GLEW_FUN_EXPORT PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
+        GLEW_FUN_EXPORT PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
+        GLEW_FUN_EXPORT PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
+        GLEW_FUN_EXPORT PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
+        GLEW_FUN_EXPORT PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
+        GLEW_FUN_EXPORT PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
+        GLEW_FUN_EXPORT PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
+        GLEW_FUN_EXPORT PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
+        GLEW_FUN_EXPORT PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
+        GLEW_FUN_EXPORT PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
+        GLEW_FUN_EXPORT PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;
+
+        GLEW_FUN_EXPORT PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
+        GLEW_FUN_EXPORT PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;
+
+        GLEW_FUN_EXPORT PFNGLPNTRIANGLESFATIPROC __glPNTrianglewesfATI;
+        GLEW_FUN_EXPORT PFNGLPNTRIANGLESIATIPROC __glPNTrianglewesiATI;
+
+        GLEW_FUN_EXPORT PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
+        GLEW_FUN_EXPORT PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;
+
+        GLEW_FUN_EXPORT PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
+        GLEW_FUN_EXPORT PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
+        GLEW_FUN_EXPORT PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
+        GLEW_FUN_EXPORT PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
+        GLEW_FUN_EXPORT PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
+        GLEW_FUN_EXPORT PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
+        GLEW_FUN_EXPORT PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
+        GLEW_FUN_EXPORT PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
+        GLEW_FUN_EXPORT PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
+        GLEW_FUN_EXPORT PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
+        GLEW_FUN_EXPORT PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
+        GLEW_FUN_EXPORT PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;
+
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;
+
+        GLEW_FUN_EXPORT PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
+        GLEW_FUN_EXPORT PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
+        GLEW_FUN_EXPORT PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;
+
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;
+
+        GLEW_FUN_EXPORT PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;
+
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;
+
+        GLEW_FUN_EXPORT PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;
+
+        GLEW_FUN_EXPORT PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;
+
+        GLEW_FUN_EXPORT PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;
+
+        GLEW_FUN_EXPORT PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
+        GLEW_FUN_EXPORT PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;
+
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
+        GLEW_FUN_EXPORT PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
+        GLEW_FUN_EXPORT PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
+        GLEW_FUN_EXPORT PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
+        GLEW_FUN_EXPORT PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;
+
+        GLEW_FUN_EXPORT PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
+        GLEW_FUN_EXPORT PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;
+
+        GLEW_FUN_EXPORT PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;
+
+        GLEW_FUN_EXPORT PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
+        GLEW_FUN_EXPORT PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;
+
+        GLEW_FUN_EXPORT PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;
+
+        GLEW_FUN_EXPORT PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
+        GLEW_FUN_EXPORT PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
+        GLEW_FUN_EXPORT PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
+        GLEW_FUN_EXPORT PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
+        GLEW_FUN_EXPORT PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
+        GLEW_FUN_EXPORT PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
+        GLEW_FUN_EXPORT PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
+        GLEW_FUN_EXPORT PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
+        GLEW_FUN_EXPORT PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
+        GLEW_FUN_EXPORT PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
+        GLEW_FUN_EXPORT PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
+        GLEW_FUN_EXPORT PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
+        GLEW_FUN_EXPORT PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
+        GLEW_FUN_EXPORT PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
+        GLEW_FUN_EXPORT PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
+        GLEW_FUN_EXPORT PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
+        GLEW_FUN_EXPORT PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
+        GLEW_FUN_EXPORT PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
+        GLEW_FUN_EXPORT PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
+        GLEW_FUN_EXPORT PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
+        GLEW_FUN_EXPORT PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
+        GLEW_FUN_EXPORT PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
+        GLEW_FUN_EXPORT PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
+        GLEW_FUN_EXPORT PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
+        GLEW_FUN_EXPORT PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
+        GLEW_FUN_EXPORT PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
+        GLEW_FUN_EXPORT PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;
+
+        GLEW_FUN_EXPORT PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
+        GLEW_FUN_EXPORT PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
+        GLEW_FUN_EXPORT PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
+        GLEW_FUN_EXPORT PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
+        GLEW_FUN_EXPORT PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
+        GLEW_FUN_EXPORT PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;
+
+        GLEW_FUN_EXPORT PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
+        GLEW_FUN_EXPORT PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;
+
+        GLEW_FUN_EXPORT PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;
+
+        GLEW_FUN_EXPORT PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;
+
+        GLEW_FUN_EXPORT PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
+        GLEW_FUN_EXPORT PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
+        GLEW_FUN_EXPORT PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
+        GLEW_FUN_EXPORT PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;
+
+        GLEW_FUN_EXPORT PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;
+
+        GLEW_FUN_EXPORT PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;
+
+        GLEW_FUN_EXPORT PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
+        GLEW_FUN_EXPORT PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
+        GLEW_FUN_EXPORT PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
+        GLEW_FUN_EXPORT PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
+        GLEW_FUN_EXPORT PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
+        GLEW_FUN_EXPORT PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
+        GLEW_FUN_EXPORT PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
+        GLEW_FUN_EXPORT PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
+        GLEW_FUN_EXPORT PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
+        GLEW_FUN_EXPORT PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
+        GLEW_FUN_EXPORT PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;
+
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
+        GLEW_FUN_EXPORT PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;
+
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;
+
+        GLEW_FUN_EXPORT PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
+        GLEW_FUN_EXPORT PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;
+
+        GLEW_FUN_EXPORT PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
+        GLEW_FUN_EXPORT PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
+        GLEW_FUN_EXPORT PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
+        GLEW_FUN_EXPORT PFNGLMINMAXEXTPROC __glewMinmaxEXT;
+        GLEW_FUN_EXPORT PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
+        GLEW_FUN_EXPORT PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;
+
+        GLEW_FUN_EXPORT PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;
+
+        GLEW_FUN_EXPORT PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;
+
+        GLEW_FUN_EXPORT PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
+        GLEW_FUN_EXPORT PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;
+
+        GLEW_FUN_EXPORT PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
+        GLEW_FUN_EXPORT PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;
+
+        GLEW_FUN_EXPORT PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
+        GLEW_FUN_EXPORT PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;
+
+        GLEW_FUN_EXPORT PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;
+
+        GLEW_FUN_EXPORT PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
+        GLEW_FUN_EXPORT PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
+        GLEW_FUN_EXPORT PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
+        GLEW_FUN_EXPORT PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
+        GLEW_FUN_EXPORT PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;
+
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;
+
+        GLEW_FUN_EXPORT PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;
+
+        GLEW_FUN_EXPORT PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;
+
+        GLEW_FUN_EXPORT PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
+        GLEW_FUN_EXPORT PFNGLENDSCENEEXTPROC __glewEndSceneEXT;
+
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;
+
+        GLEW_FUN_EXPORT PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
+        GLEW_FUN_EXPORT PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
+        GLEW_FUN_EXPORT PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;
+
+        GLEW_FUN_EXPORT PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
+        GLEW_FUN_EXPORT PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;
+
+        GLEW_FUN_EXPORT PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;
+
+        GLEW_FUN_EXPORT PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
+        GLEW_FUN_EXPORT PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
+        GLEW_FUN_EXPORT PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;
+
+        GLEW_FUN_EXPORT PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;
+
+        GLEW_FUN_EXPORT PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;
+
+        GLEW_FUN_EXPORT PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
+        GLEW_FUN_EXPORT PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
+        GLEW_FUN_EXPORT PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
+        GLEW_FUN_EXPORT PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
+        GLEW_FUN_EXPORT PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;
+
+        GLEW_FUN_EXPORT PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
+        GLEW_FUN_EXPORT PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
+        GLEW_FUN_EXPORT PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
+        GLEW_FUN_EXPORT PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
+        GLEW_FUN_EXPORT PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
+        GLEW_FUN_EXPORT PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;
+
+        GLEW_FUN_EXPORT PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;
+
+        GLEW_FUN_EXPORT PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
+        GLEW_FUN_EXPORT PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;
+
+        GLEW_FUN_EXPORT PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
+        GLEW_FUN_EXPORT PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
+        GLEW_FUN_EXPORT PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
+        GLEW_FUN_EXPORT PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
+        GLEW_FUN_EXPORT PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
+        GLEW_FUN_EXPORT PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;
+
+        GLEW_FUN_EXPORT PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
+        GLEW_FUN_EXPORT PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
+        GLEW_FUN_EXPORT PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
+        GLEW_FUN_EXPORT PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
+        GLEW_FUN_EXPORT PFNGLGETPOINTERVEXTPROC __glewGetPointervEXT;
+        GLEW_FUN_EXPORT PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
+        GLEW_FUN_EXPORT PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;
+
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;
+
+        GLEW_FUN_EXPORT PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
+        GLEW_FUN_EXPORT PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
+        GLEW_FUN_EXPORT PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
+        GLEW_FUN_EXPORT PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
+        GLEW_FUN_EXPORT PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
+        GLEW_FUN_EXPORT PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
+        GLEW_FUN_EXPORT PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
+        GLEW_FUN_EXPORT PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
+        GLEW_FUN_EXPORT PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
+        GLEW_FUN_EXPORT PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
+        GLEW_FUN_EXPORT PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
+        GLEW_FUN_EXPORT PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
+        GLEW_FUN_EXPORT PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
+        GLEW_FUN_EXPORT PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
+        GLEW_FUN_EXPORT PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
+        GLEW_FUN_EXPORT PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
+        GLEW_FUN_EXPORT PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
+        GLEW_FUN_EXPORT PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
+        GLEW_FUN_EXPORT PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
+        GLEW_FUN_EXPORT PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
+        GLEW_FUN_EXPORT PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
+        GLEW_FUN_EXPORT PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
+        GLEW_FUN_EXPORT PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
+        GLEW_FUN_EXPORT PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
+        GLEW_FUN_EXPORT PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
+        GLEW_FUN_EXPORT PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
+        GLEW_FUN_EXPORT PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
+        GLEW_FUN_EXPORT PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
+        GLEW_FUN_EXPORT PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
+        GLEW_FUN_EXPORT PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
+        GLEW_FUN_EXPORT PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
+        GLEW_FUN_EXPORT PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
+        GLEW_FUN_EXPORT PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
+        GLEW_FUN_EXPORT PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;
+
+        GLEW_FUN_EXPORT PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
+        GLEW_FUN_EXPORT PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;
+
+        GLEW_FUN_EXPORT PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;
+
+        GLEW_FUN_EXPORT PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;
+
+        GLEW_FUN_EXPORT PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
+        GLEW_FUN_EXPORT PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
+        GLEW_FUN_EXPORT PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
+        GLEW_FUN_EXPORT PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
+        GLEW_FUN_EXPORT PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
+        GLEW_FUN_EXPORT PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;
+
+        GLEW_FUN_EXPORT PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
+        GLEW_FUN_EXPORT PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;
+
+        GLEW_FUN_EXPORT PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
+        GLEW_FUN_EXPORT PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
+        GLEW_FUN_EXPORT PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
+        GLEW_FUN_EXPORT PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
+        GLEW_FUN_EXPORT PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;
+
+        GLEW_FUN_EXPORT PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
+        GLEW_FUN_EXPORT PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
+        GLEW_FUN_EXPORT PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;
+
+        GLEW_FUN_EXPORT PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
+        GLEW_FUN_EXPORT PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;
+
+        GLEW_FUN_EXPORT PFNGLBUFFERREGIONENABLEDEXTPROC __glewBufferRegionEnabledEXT;
+        GLEW_FUN_EXPORT PFNGLDELETEBUFFERREGIONEXTPROC __glewDeleteBufferRegionEXT;
+        GLEW_FUN_EXPORT PFNGLDRAWBUFFERREGIONEXTPROC __glewDrawBufferRegionEXT;
+        GLEW_FUN_EXPORT PFNGLNEWBUFFERREGIONEXTPROC __glewNewBufferRegionEXT;
+        GLEW_FUN_EXPORT PFNGLREADBUFFERREGIONEXTPROC __glewReadBufferRegionEXT;
+
+        GLEW_FUN_EXPORT PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;
+
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
+        GLEW_FUN_EXPORT PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;
+
+        GLEW_FUN_EXPORT PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
+        GLEW_FUN_EXPORT PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;
+
+        GLEW_FUN_EXPORT PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;
+
+        GLEW_FUN_EXPORT PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
+        GLEW_FUN_EXPORT PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
+        GLEW_FUN_EXPORT PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;
+
+        GLEW_FUN_EXPORT PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
+        GLEW_FUN_EXPORT PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
+        GLEW_FUN_EXPORT PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
+        GLEW_FUN_EXPORT PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
+        GLEW_FUN_EXPORT PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
+        GLEW_FUN_EXPORT PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;
+
+        GLEW_FUN_EXPORT PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
+        GLEW_FUN_EXPORT PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
+        GLEW_FUN_EXPORT PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;
+
+        GLEW_FUN_EXPORT PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
+        GLEW_FUN_EXPORT PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
+        GLEW_FUN_EXPORT PFNGLGENFENCESNVPROC __glewGenFencesNV;
+        GLEW_FUN_EXPORT PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
+        GLEW_FUN_EXPORT PFNGLISFENCENVPROC __glewIsFenceNV;
+        GLEW_FUN_EXPORT PFNGLSETFENCENVPROC __glewSetFenceNV;
+        GLEW_FUN_EXPORT PFNGLTESTFENCENVPROC __glewTestFenceNV;
+
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;
+
+        GLEW_FUN_EXPORT PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;
+
+        GLEW_FUN_EXPORT PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;
+
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;
+
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
+        GLEW_FUN_EXPORT PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;
+
+        GLEW_FUN_EXPORT PFNGLCOLOR3HNVPROC __glewColor3hNV;
+        GLEW_FUN_EXPORT PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
+        GLEW_FUN_EXPORT PFNGLCOLOR4HNVPROC __glewColor4hNV;
+        GLEW_FUN_EXPORT PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
+        GLEW_FUN_EXPORT PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
+        GLEW_FUN_EXPORT PFNGLNORMAL3HNVPROC __glewNormal3hNV;
+        GLEW_FUN_EXPORT PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEX2HNVPROC __glewVertex2hNV;
+        GLEW_FUN_EXPORT PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEX3HNVPROC __glewVertex3hNV;
+        GLEW_FUN_EXPORT PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEX4HNVPROC __glewVertex4hNV;
+        GLEW_FUN_EXPORT PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;
+
+        GLEW_FUN_EXPORT PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
+        GLEW_FUN_EXPORT PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
+        GLEW_FUN_EXPORT PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
+        GLEW_FUN_EXPORT PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
+        GLEW_FUN_EXPORT PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
+        GLEW_FUN_EXPORT PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
+        GLEW_FUN_EXPORT PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;
+
+        GLEW_FUN_EXPORT PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;
+
+        GLEW_FUN_EXPORT PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
+        GLEW_FUN_EXPORT PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;
+
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
+        GLEW_FUN_EXPORT PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;
+
+        GLEW_FUN_EXPORT PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
+        GLEW_FUN_EXPORT PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
+        GLEW_FUN_EXPORT PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
+        GLEW_FUN_EXPORT PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
+        GLEW_FUN_EXPORT PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
+        GLEW_FUN_EXPORT PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;
+
+        GLEW_FUN_EXPORT PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
+        GLEW_FUN_EXPORT PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;
+
+        GLEW_FUN_EXPORT PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
+        GLEW_FUN_EXPORT PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
+        GLEW_FUN_EXPORT PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
+        GLEW_FUN_EXPORT PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
+        GLEW_FUN_EXPORT PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
+        GLEW_FUN_EXPORT PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
+        GLEW_FUN_EXPORT PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
+        GLEW_FUN_EXPORT PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
+        GLEW_FUN_EXPORT PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;
+
+        GLEW_FUN_EXPORT PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;
+
+        GLEW_FUN_EXPORT PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
+        GLEW_FUN_EXPORT PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
+        GLEW_FUN_EXPORT PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
+        GLEW_FUN_EXPORT PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
+        GLEW_FUN_EXPORT PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
+        GLEW_FUN_EXPORT PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
+        GLEW_FUN_EXPORT PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
+        GLEW_FUN_EXPORT PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
+        GLEW_FUN_EXPORT PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
+        GLEW_FUN_EXPORT PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
+        GLEW_FUN_EXPORT PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;
+
+        GLEW_FUN_EXPORT PFNGLPATCHPARAMETERFVNVPROC __glewPatchParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLPATCHPARAMETERINVPROC __glewPatchParameteriNV;
+
+        GLEW_FUN_EXPORT PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;
+
+        GLEW_FUN_EXPORT PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
+        GLEW_FUN_EXPORT PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
+        GLEW_FUN_EXPORT PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
+        GLEW_FUN_EXPORT PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
+        GLEW_FUN_EXPORT PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
+        GLEW_FUN_EXPORT PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;
+
+        GLEW_FUN_EXPORT PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
+        GLEW_FUN_EXPORT PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
+        GLEW_FUN_EXPORT PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
+        GLEW_FUN_EXPORT PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
+        GLEW_FUN_EXPORT PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
+        GLEW_FUN_EXPORT PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
+        GLEW_FUN_EXPORT PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
+        GLEW_FUN_EXPORT PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
+        GLEW_FUN_EXPORT PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
+        GLEW_FUN_EXPORT PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
+        GLEW_FUN_EXPORT PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;
+
+        GLEW_FUN_EXPORT PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
+        GLEW_FUN_EXPORT PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
+        GLEW_FUN_EXPORT PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
+        GLEW_FUN_EXPORT PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
+        GLEW_FUN_EXPORT PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
+        GLEW_FUN_EXPORT PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
+        GLEW_FUN_EXPORT PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;
+
+        GLEW_FUN_EXPORT PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;
+
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;
+
+        GLEW_FUN_EXPORT PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
+        GLEW_FUN_EXPORT PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
+        GLEW_FUN_EXPORT PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
+        GLEW_FUN_EXPORT PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
+        GLEW_FUN_EXPORT PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
+        GLEW_FUN_EXPORT PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
+        GLEW_FUN_EXPORT PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
+        GLEW_FUN_EXPORT PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
+        GLEW_FUN_EXPORT PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;
+
+        GLEW_FUN_EXPORT PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
+        GLEW_FUN_EXPORT PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
+        GLEW_FUN_EXPORT PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
+        GLEW_FUN_EXPORT PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
+        GLEW_FUN_EXPORT PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
+        GLEW_FUN_EXPORT PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
+        GLEW_FUN_EXPORT PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
+        GLEW_FUN_EXPORT PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
+        GLEW_FUN_EXPORT PFNGLISPROGRAMNVPROC __glewIsProgramNV;
+        GLEW_FUN_EXPORT PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
+        GLEW_FUN_EXPORT PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
+        GLEW_FUN_EXPORT PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
+        GLEW_FUN_EXPORT PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
+        GLEW_FUN_EXPORT PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;
+
+        GLEW_FUN_EXPORT PFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES;
+        GLEW_FUN_EXPORT PFNGLCLIPPLANEFOESPROC __glewClipPlanefOES;
+        GLEW_FUN_EXPORT PFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES;
+        GLEW_FUN_EXPORT PFNGLFRUSTUMFOESPROC __glewFrustumfOES;
+        GLEW_FUN_EXPORT PFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES;
+        GLEW_FUN_EXPORT PFNGLORTHOFOESPROC __glewOrthofOES;
+
+        GLEW_FUN_EXPORT PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
+        GLEW_FUN_EXPORT PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;
+
+        GLEW_FUN_EXPORT PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
+        GLEW_FUN_EXPORT PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;
+
+        GLEW_FUN_EXPORT PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
+        GLEW_FUN_EXPORT PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;
+
+        GLEW_FUN_EXPORT PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
+        GLEW_FUN_EXPORT PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;
+
+        GLEW_FUN_EXPORT PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
+        GLEW_FUN_EXPORT PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;
+
+        GLEW_FUN_EXPORT PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
+        GLEW_FUN_EXPORT PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;
+
+        GLEW_FUN_EXPORT PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
+        GLEW_FUN_EXPORT PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
+        GLEW_FUN_EXPORT PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
+        GLEW_FUN_EXPORT PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
+        GLEW_FUN_EXPORT PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
+        GLEW_FUN_EXPORT PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;
+
+        GLEW_FUN_EXPORT PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;
+
+        GLEW_FUN_EXPORT PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;
+
+        GLEW_FUN_EXPORT PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
+        GLEW_FUN_EXPORT PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
+        GLEW_FUN_EXPORT PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
+        GLEW_FUN_EXPORT PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
+        GLEW_FUN_EXPORT PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
+        GLEW_FUN_EXPORT PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;
+
+        GLEW_FUN_EXPORT PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;
+
+        GLEW_FUN_EXPORT PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;
+
+        GLEW_FUN_EXPORT PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;
+
+        GLEW_FUN_EXPORT PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
+        GLEW_FUN_EXPORT PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
+        GLEW_FUN_EXPORT PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
+        GLEW_FUN_EXPORT PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;
+
+        GLEW_FUN_EXPORT PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;
+
+        GLEW_FUN_EXPORT PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
+        GLEW_FUN_EXPORT PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
+        GLEW_FUN_EXPORT PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
+        GLEW_FUN_EXPORT PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
+        GLEW_FUN_EXPORT PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;
+
+        GLEW_FUN_EXPORT PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;
+
+        GLEW_FUN_EXPORT PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
+        GLEW_FUN_EXPORT PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
+        GLEW_FUN_EXPORT PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
+        GLEW_FUN_EXPORT PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
+        GLEW_FUN_EXPORT PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
+        GLEW_FUN_EXPORT PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
+        GLEW_FUN_EXPORT PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
+        GLEW_FUN_EXPORT PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;
+
+        GLEW_FUN_EXPORT PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;
+
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;
+
+        GLEW_FUN_EXPORT PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
+        GLEW_FUN_EXPORT PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
+        GLEW_FUN_EXPORT PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
+        GLEW_FUN_EXPORT PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;
+
+        GLEW_FUN_EXPORT PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;
+
+#if defined(GLEW_MX) && !defined(_WIN32)
+        struct GLEWContextStruct
+        {
+#endif /* GLEW_MX */
+
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_1_1;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_1_2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_1_3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_1_4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_1_5;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_2_0;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_2_1;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_3_0;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_3_1;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_3_2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_3_3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_4_0;
+            GLEW_VAR_EXPORT GLboolean __GLEW_3DFX_multisample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_3DFX_tbuffer;
+            GLEW_VAR_EXPORT GLboolean __GLEW_3DFX_texture_compression_FXT1;
+            GLEW_VAR_EXPORT GLboolean __GLEW_AMD_draw_buffers_blend;
+            GLEW_VAR_EXPORT GLboolean __GLEW_AMD_performance_monitor;
+            GLEW_VAR_EXPORT GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_AMD_shader_stencil_export;
+            GLEW_VAR_EXPORT GLboolean __GLEW_AMD_texture_texture4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_AMD_vertex_shader_tessellator;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_aux_depth_stencil;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_client_storage;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_element_array;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_fence;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_float_pixels;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_flush_buffer_range;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_object_purgeable;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_pixel_buffer;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_rgb_422;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_row_bytes;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_specular_vector;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_texture_range;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_transform_hint;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_vertex_array_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_vertex_array_range;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_vertex_program_evaluators;
+            GLEW_VAR_EXPORT GLboolean __GLEW_APPLE_ycbcr_422;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_blend_func_extended;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_color_buffer_float;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_compatibility;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_copy_buffer;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_depth_buffer_float;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_depth_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_depth_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_draw_buffers;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_draw_buffers_blend;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_draw_elements_base_vertex;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_draw_indirect;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_draw_instanced;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_explicit_attrib_location;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_fragment_coord_conventions;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_fragment_program;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_fragment_program_shadow;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_fragment_shader;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_framebuffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_framebuffer_sRGB;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_geometry_shader4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_gpu_shader5;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_gpu_shader_fp64;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_half_float_pixel;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_half_float_vertex;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_imaging;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_instanced_arrays;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_map_buffer_range;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_matrix_palette;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_multisample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_multitexture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_occlusion_query;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_occlusion_query2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_pixel_buffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_point_parameters;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_point_sprite;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_provoking_vertex;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_sample_shading;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_sampler_objects;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_seamless_cube_map;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_shader_bit_encoding;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_shader_objects;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_shader_subroutine;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_shader_texture_lod;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_shading_language_100;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_shading_language_include;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_shadow;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_shadow_ambient;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_sync;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_tessellation_shader;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_border_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_buffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_compression;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_compression_bptc;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_compression_rgtc;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_cube_map;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_cube_map_array;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_env_add;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_env_combine;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_env_crossbar;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_env_dot3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_float;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_gather;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_mirrored_repeat;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_multisample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_non_power_of_two;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_query_lod;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_rectangle;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_rg;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_rgb10_a2ui;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_texture_swizzle;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_timer_query;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_transform_feedback2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_transform_feedback3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_transpose_matrix;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_uniform_buffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_vertex_array_bgra;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_vertex_array_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_vertex_blend;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_vertex_buffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_vertex_program;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_vertex_shader;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ARB_window_pos;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATIX_point_sprites;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATIX_texture_env_combine3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATIX_texture_env_route;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_draw_buffers;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_element_array;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_envmap_bumpmap;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_fragment_shader;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_map_object_buffer;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_meminfo;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_pn_triangles;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_separate_stencil;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_shader_texture_lod;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_text_fragment_shader;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_texture_compression_3dc;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_texture_env_combine3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_texture_float;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_texture_mirror_once;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_vertex_array_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_vertex_attrib_array_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_ATI_vertex_streams;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_422_pixels;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_Cg_shader;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_abgr;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_bgra;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_bindable_uniform;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_blend_color;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_blend_equation_separate;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_blend_func_separate;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_blend_logic_op;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_blend_minmax;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_blend_subtract;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_clip_volume_hint;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_cmyka;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_color_subtable;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_compiled_vertex_array;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_convolution;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_coordinate_frame;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_copy_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_cull_vertex;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_depth_bounds_test;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_direct_state_access;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_draw_buffers2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_draw_instanced;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_draw_range_elements;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_fog_coord;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_fragment_lighting;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_framebuffer_blit;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_framebuffer_multisample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_framebuffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_framebuffer_sRGB;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_geometry_shader4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_gpu_program_parameters;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_gpu_shader4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_histogram;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_index_array_formats;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_index_func;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_index_material;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_index_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_light_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_misc_attribute;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_multi_draw_arrays;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_multisample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_packed_depth_stencil;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_packed_float;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_packed_pixels;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_paletted_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_pixel_buffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_pixel_transform;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_pixel_transform_color_table;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_point_parameters;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_polygon_offset;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_provoking_vertex;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_rescale_normal;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_scene_marker;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_secondary_color;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_separate_shader_objects;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_separate_specular_color;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_shader_image_load_store;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_shadow_funcs;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_shared_texture_palette;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_stencil_clear_tag;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_stencil_two_side;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_stencil_wrap;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_subtexture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture3D;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_array;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_buffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_compression_dxt1;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_compression_latc;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_compression_rgtc;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_compression_s3tc;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_cube_map;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_edge_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_env;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_env_add;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_env_combine;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_env_dot3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_filter_anisotropic;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_integer;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_lod_bias;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_mirror_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_perturb_normal;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_rectangle;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_sRGB;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_shared_exponent;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_snorm;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_texture_swizzle;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_timer_query;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_transform_feedback;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_vertex_array;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_vertex_array_bgra;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_vertex_attrib_64bit;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_vertex_shader;
+            GLEW_VAR_EXPORT GLboolean __GLEW_EXT_vertex_weighting;
+            GLEW_VAR_EXPORT GLboolean __GLEW_GREMEDY_frame_terminator;
+            GLEW_VAR_EXPORT GLboolean __GLEW_GREMEDY_string_marker;
+            GLEW_VAR_EXPORT GLboolean __GLEW_HP_convolution_border_modes;
+            GLEW_VAR_EXPORT GLboolean __GLEW_HP_image_transform;
+            GLEW_VAR_EXPORT GLboolean __GLEW_HP_occlusion_test;
+            GLEW_VAR_EXPORT GLboolean __GLEW_HP_texture_lighting;
+            GLEW_VAR_EXPORT GLboolean __GLEW_IBM_cull_vertex;
+            GLEW_VAR_EXPORT GLboolean __GLEW_IBM_multimode_draw_arrays;
+            GLEW_VAR_EXPORT GLboolean __GLEW_IBM_rasterpos_clip;
+            GLEW_VAR_EXPORT GLboolean __GLEW_IBM_static_data;
+            GLEW_VAR_EXPORT GLboolean __GLEW_IBM_texture_mirrored_repeat;
+            GLEW_VAR_EXPORT GLboolean __GLEW_IBM_vertex_array_lists;
+            GLEW_VAR_EXPORT GLboolean __GLEW_INGR_color_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_INGR_interlace_read;
+            GLEW_VAR_EXPORT GLboolean __GLEW_INTEL_parallel_arrays;
+            GLEW_VAR_EXPORT GLboolean __GLEW_INTEL_texture_scissor;
+            GLEW_VAR_EXPORT GLboolean __GLEW_KTX_buffer_region;
+            GLEW_VAR_EXPORT GLboolean __GLEW_MESAX_texture_stack;
+            GLEW_VAR_EXPORT GLboolean __GLEW_MESA_pack_invert;
+            GLEW_VAR_EXPORT GLboolean __GLEW_MESA_resize_buffers;
+            GLEW_VAR_EXPORT GLboolean __GLEW_MESA_window_pos;
+            GLEW_VAR_EXPORT GLboolean __GLEW_MESA_ycbcr_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_blend_square;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_conditional_render;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_copy_depth_to_color;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_copy_image;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_depth_buffer_float;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_depth_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_depth_range_unclamped;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_evaluators;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_explicit_multisample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_fence;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_float_buffer;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_fog_distance;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_fragment_program;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_fragment_program2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_fragment_program4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_fragment_program_option;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_framebuffer_multisample_coverage;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_geometry_program4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_geometry_shader4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_gpu_program4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_gpu_program4_1;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_gpu_program5;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_gpu_program_fp64;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_gpu_shader5;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_half_float;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_light_max_exponent;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_multisample_filter_hint;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_occlusion_query;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_packed_depth_stencil;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_parameter_buffer_object;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_parameter_buffer_object2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_pixel_data_range;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_point_sprite;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_present_video;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_primitive_restart;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_register_combiners;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_register_combiners2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_shader_buffer_load;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_tessellation_program5;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texgen_emboss;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texgen_reflection;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_barrier;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_compression_vtc;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_env_combine4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_expand_normal;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_multisample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_rectangle;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_shader;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_shader2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_texture_shader3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_transform_feedback;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_transform_feedback2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_array_range;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_array_range2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_buffer_unified_memory;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_program;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_program1_1;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_program2;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_program2_option;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_program3;
+            GLEW_VAR_EXPORT GLboolean __GLEW_NV_vertex_program4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_OES_byte_coordinates;
+            GLEW_VAR_EXPORT GLboolean __GLEW_OES_compressed_paletted_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_OES_read_format;
+            GLEW_VAR_EXPORT GLboolean __GLEW_OES_single_precision;
+            GLEW_VAR_EXPORT GLboolean __GLEW_OML_interlace;
+            GLEW_VAR_EXPORT GLboolean __GLEW_OML_resample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_OML_subsample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_PGI_misc_hints;
+            GLEW_VAR_EXPORT GLboolean __GLEW_PGI_vertex_hints;
+            GLEW_VAR_EXPORT GLboolean __GLEW_REND_screen_coordinates;
+            GLEW_VAR_EXPORT GLboolean __GLEW_S3_s3tc;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_color_range;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_detail_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_fog_function;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_generate_mipmap;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_multisample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_pixel_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_point_line_texgen;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_sharpen_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_texture4D;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_texture_border_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_texture_edge_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_texture_filter4;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_texture_lod;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIS_texture_select;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_async;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_async_histogram;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_async_pixel;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_blend_alpha_minmax;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_clipmap;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_convolution_accuracy;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_depth_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_flush_raster;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_fog_offset;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_fog_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_fragment_specular_lighting;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_framezoom;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_interlace;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_ir_instrument1;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_list_priority;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_pixel_texture;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_pixel_texture_bits;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_reference_plane;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_resample;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_shadow;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_shadow_ambient;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_sprite;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_tag_sample_buffer;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_texture_add_env;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_texture_coordinate_clamp;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_texture_lod_bias;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_texture_multi_buffer;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_texture_range;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_texture_scale_bias;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_vertex_preclip;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_vertex_preclip_hint;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGIX_ycrcb;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGI_color_matrix;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGI_color_table;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SGI_texture_color_table;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SUNX_constant_data;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SUN_convolution_border_modes;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SUN_global_alpha;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SUN_mesh_array;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SUN_read_video_pixels;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SUN_slice_accum;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SUN_triangle_list;
+            GLEW_VAR_EXPORT GLboolean __GLEW_SUN_vertex;
+            GLEW_VAR_EXPORT GLboolean __GLEW_WIN_phong_shading;
+            GLEW_VAR_EXPORT GLboolean __GLEW_WIN_specular_fog;
+            GLEW_VAR_EXPORT GLboolean __GLEW_WIN_swap_hint;
+
+#ifdef GLEW_MX
+        }; /* GLEWContextStruct */
+#endif /* GLEW_MX */
+
+        /* ------------------------------------------------------------------------- */
+
+        /* error codes */
+#define GLEW_OK 0
+#define GLEW_NO_ERROR 0
+#define GLEW_ERROR_NO_GL_VERSION 1  /* missing GL version */
+#define GLEW_ERROR_GL_VERSION_10_ONLY 2  /* GL 1.1 and up are not supported */
+#define GLEW_ERROR_GLX_VERSION_11_ONLY 3  /* GLX 1.2 and up are not supported */
+
+        /* string codes */
+#define GLEW_VERSION 1
+#define GLEW_VERSION_MAJOR 2
+#define GLEW_VERSION_MINOR 3
+#define GLEW_VERSION_MICRO 4
+
+        /* API */
+#ifdef GLEW_MX
+
+        typedef struct GLEWContextStruct GLEWContext;
+        GLEWAPI GLenum glewContextInit(GLEWContext *ctx);
+        GLEWAPI GLboolean glewContextIsSupported(GLEWContext *ctx, const char *name);
+
+#define glewInit() glewContextInit(glewGetContext())
+#define glewIsSupported(x) glewContextIsSupported(glewGetContext(), x)
+#define glewIsExtensionSupported(x) glewIsSupported(x)
+
+#define GLEW_GET_VAR(x) (*(const GLboolean*)&(glewGetContext()->x))
+#ifdef _WIN32
+#  define GLEW_GET_FUN(x) glewGetContext()->x
+#else
+#  define GLEW_GET_FUN(x) x
+#endif
+
+#else /* GLEW_MX */
+
+        GLEWAPI GLenum glewInit();
+        GLEWAPI GLboolean glewIsSupported(const char *name);
+#define glewIsExtensionSupported(x) glewIsSupported(x)
+
+#define GLEW_GET_VAR(x) (*(const GLboolean*)&x)
+#define GLEW_GET_FUN(x) x
+
+#endif /* GLEW_MX */
+
+        GLEWAPI GLboolean glewExperimental;
+        GLEWAPI GLboolean glewGetExtension(const char *name);
+        GLEWAPI const GLubyte *glewGetErrorString(GLenum error);
+        GLEWAPI const GLubyte *glewGetString(GLenum name);
+
+#ifdef __cplusplus
+    }
+#endif
+
+#ifdef GLEW_APIENTRY_DEFINED
+#undef GLEW_APIENTRY_DEFINED
+#undef APIENTRY
+#undef GLAPIENTRY
+#define GLAPIENTRY
+#endif
+
+#ifdef GLEW_CALLBACK_DEFINED
+#undef GLEW_CALLBACK_DEFINED
+#undef CALLBACK
+#endif
+
+#ifdef GLEW_WINGDIAPI_DEFINED
+#undef GLEW_WINGDIAPI_DEFINED
+#undef WINGDIAPI
+#endif
+
+#undef GLAPI
+    /* #undef GLEWAPI */
+
+#endif /* __glew_h__ */
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/glext.h gpu-rodinia_new/cuda/cfd/common/inc/GL/glext.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/glext.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/glext.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,7125 @@
+#ifndef __glext_h_
+#define __glext_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /******************************************************************************
+
+     Copyright NVIDIA Corporation 2006
+
+     TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
+     *AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
+     OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL
+     NVIDIA OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR
+     CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
+     LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION,
+     OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE
+     THIS SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+     DAMAGES.
+
+    ******************************************************************************/
+
+    /*
+    ** License Applicability. Except to the extent portions of this file are
+    ** made subject to an alternative license as permitted in the SGI Free
+    ** Software License B, Version 1.1 (the "License"), the contents of this
+    ** file are subject only to the provisions of the License. You may not use
+    ** this file except in compliance with the License. You may obtain a copy
+    ** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
+    ** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
+    **
+    ** http://oss.sgi.com/projects/FreeB
+    **
+    ** Note that, as provided in the License, the Software is distributed on an
+    ** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
+    ** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
+    ** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
+    ** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
+    **
+    ** Original Code. The Original Code is: OpenGL Sample Implementation,
+    ** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
+    ** Inc. The Original Code is Copyright (c) 1991-2004 Silicon Graphics, Inc.
+    ** Copyright in any portions created by third parties is as indicated
+    ** elsewhere herein. All Rights Reserved.
+    **
+    ** Additional Notice Provisions: This software was created using the
+    ** OpenGL(R) version 1.2.1 Sample Implementation published by SGI, but has
+    ** not been independently verified as being compliant with the OpenGL(R)
+    ** version 1.2.1 Specification.
+    */
+
+#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
+#define WIN32_LEAN_AND_MEAN 1
+#include <windows.h>
+#endif
+
+#ifndef APIENTRY
+#define APIENTRY
+#endif
+#ifndef APIENTRYP
+#define APIENTRYP APIENTRY *
+#endif
+#ifndef extern
+#define extern extern
+#endif
+
+    /*************************************************************/
+
+    /* Header file version number, required by OpenGL ABI for Linux */
+    /* glext.h last updated 2005/06/06 */
+    /* Current version at http://oss.sgi.com/projects/ogl-sample/registry/ */
+#define GL_GLEXT_VERSION 28
+
+#ifndef GL_VERSION_1_2
+#define GL_UNSIGNED_BYTE_3_3_2            0x8032
+#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
+#define GL_UNSIGNED_INT_8_8_8_8           0x8035
+#define GL_UNSIGNED_INT_10_10_10_2        0x8036
+#define GL_RESCALE_NORMAL                 0x803A
+#define GL_TEXTURE_BINDING_3D             0x806A
+#define GL_PACK_SKIP_IMAGES               0x806B
+#define GL_PACK_IMAGE_HEIGHT              0x806C
+#define GL_UNPACK_SKIP_IMAGES             0x806D
+#define GL_UNPACK_IMAGE_HEIGHT            0x806E
+#define GL_TEXTURE_3D                     0x806F
+#define GL_PROXY_TEXTURE_3D               0x8070
+#define GL_TEXTURE_DEPTH                  0x8071
+#define GL_TEXTURE_WRAP_R                 0x8072
+#define GL_MAX_3D_TEXTURE_SIZE            0x8073
+#define GL_UNSIGNED_BYTE_2_3_3_REV        0x8362
+#define GL_UNSIGNED_SHORT_5_6_5           0x8363
+#define GL_UNSIGNED_SHORT_5_6_5_REV       0x8364
+#define GL_UNSIGNED_SHORT_4_4_4_4_REV     0x8365
+#define GL_UNSIGNED_SHORT_1_5_5_5_REV     0x8366
+#define GL_UNSIGNED_INT_8_8_8_8_REV       0x8367
+#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368
+#define GL_BGR                            0x80E0
+#define GL_BGRA                           0x80E1
+#define GL_MAX_ELEMENTS_VERTICES          0x80E8
+#define GL_MAX_ELEMENTS_INDICES           0x80E9
+#define GL_CLAMP_TO_EDGE                  0x812F
+#define GL_TEXTURE_MIN_LOD                0x813A
+#define GL_TEXTURE_MAX_LOD                0x813B
+#define GL_TEXTURE_BASE_LEVEL             0x813C
+#define GL_TEXTURE_MAX_LEVEL              0x813D
+#define GL_LIGHT_MODEL_COLOR_CONTROL      0x81F8
+#define GL_SINGLE_COLOR                   0x81F9
+#define GL_SEPARATE_SPECULAR_COLOR        0x81FA
+#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
+#define GL_SMOOTH_POINT_SIZE_GRANULARITY  0x0B13
+#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
+#define GL_SMOOTH_LINE_WIDTH_GRANULARITY  0x0B23
+#define GL_ALIASED_POINT_SIZE_RANGE       0x846D
+#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
+#endif
+
+#ifndef GL_ARB_imaging
+#define GL_CONSTANT_COLOR                 0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
+#define GL_CONSTANT_ALPHA                 0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
+#define GL_BLEND_COLOR                    0x8005
+#define GL_FUNC_ADD                       0x8006
+#define GL_MIN                            0x8007
+#define GL_MAX                            0x8008
+#define GL_BLEND_EQUATION                 0x8009
+#define GL_FUNC_SUBTRACT                  0x800A
+#define GL_FUNC_REVERSE_SUBTRACT          0x800B
+#define GL_CONVOLUTION_1D                 0x8010
+#define GL_CONVOLUTION_2D                 0x8011
+#define GL_SEPARABLE_2D                   0x8012
+#define GL_CONVOLUTION_BORDER_MODE        0x8013
+#define GL_CONVOLUTION_FILTER_SCALE       0x8014
+#define GL_CONVOLUTION_FILTER_BIAS        0x8015
+#define GL_REDUCE                         0x8016
+#define GL_CONVOLUTION_FORMAT             0x8017
+#define GL_CONVOLUTION_WIDTH              0x8018
+#define GL_CONVOLUTION_HEIGHT             0x8019
+#define GL_MAX_CONVOLUTION_WIDTH          0x801A
+#define GL_MAX_CONVOLUTION_HEIGHT         0x801B
+#define GL_POST_CONVOLUTION_RED_SCALE     0x801C
+#define GL_POST_CONVOLUTION_GREEN_SCALE   0x801D
+#define GL_POST_CONVOLUTION_BLUE_SCALE    0x801E
+#define GL_POST_CONVOLUTION_ALPHA_SCALE   0x801F
+#define GL_POST_CONVOLUTION_RED_BIAS      0x8020
+#define GL_POST_CONVOLUTION_GREEN_BIAS    0x8021
+#define GL_POST_CONVOLUTION_BLUE_BIAS     0x8022
+#define GL_POST_CONVOLUTION_ALPHA_BIAS    0x8023
+#define GL_HISTOGRAM                      0x8024
+#define GL_PROXY_HISTOGRAM                0x8025
+#define GL_HISTOGRAM_WIDTH                0x8026
+#define GL_HISTOGRAM_FORMAT               0x8027
+#define GL_HISTOGRAM_RED_SIZE             0x8028
+#define GL_HISTOGRAM_GREEN_SIZE           0x8029
+#define GL_HISTOGRAM_BLUE_SIZE            0x802A
+#define GL_HISTOGRAM_ALPHA_SIZE           0x802B
+#define GL_HISTOGRAM_LUMINANCE_SIZE       0x802C
+#define GL_HISTOGRAM_SINK                 0x802D
+#define GL_MINMAX                         0x802E
+#define GL_MINMAX_FORMAT                  0x802F
+#define GL_MINMAX_SINK                    0x8030
+#define GL_TABLE_TOO_LARGE                0x8031
+#define GL_COLOR_MATRIX                   0x80B1
+#define GL_COLOR_MATRIX_STACK_DEPTH       0x80B2
+#define GL_MAX_COLOR_MATRIX_STACK_DEPTH   0x80B3
+#define GL_POST_COLOR_MATRIX_RED_SCALE    0x80B4
+#define GL_POST_COLOR_MATRIX_GREEN_SCALE  0x80B5
+#define GL_POST_COLOR_MATRIX_BLUE_SCALE   0x80B6
+#define GL_POST_COLOR_MATRIX_ALPHA_SCALE  0x80B7
+#define GL_POST_COLOR_MATRIX_RED_BIAS     0x80B8
+#define GL_POST_COLOR_MATRIX_GREEN_BIAS   0x80B9
+#define GL_POST_COLOR_MATRIX_BLUE_BIAS    0x80BA
+#define GL_POST_COLOR_MATRIX_ALPHA_BIAS   0x80BB
+#define GL_COLOR_TABLE                    0x80D0
+#define GL_POST_CONVOLUTION_COLOR_TABLE   0x80D1
+#define GL_POST_COLOR_MATRIX_COLOR_TABLE  0x80D2
+#define GL_PROXY_COLOR_TABLE              0x80D3
+#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE 0x80D4
+#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE 0x80D5
+#define GL_COLOR_TABLE_SCALE              0x80D6
+#define GL_COLOR_TABLE_BIAS               0x80D7
+#define GL_COLOR_TABLE_FORMAT             0x80D8
+#define GL_COLOR_TABLE_WIDTH              0x80D9
+#define GL_COLOR_TABLE_RED_SIZE           0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE         0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE          0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE         0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE     0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE     0x80DF
+#define GL_CONSTANT_BORDER                0x8151
+#define GL_REPLICATE_BORDER               0x8153
+#define GL_CONVOLUTION_BORDER_COLOR       0x8154
+#endif
+
+#ifndef GL_VERSION_1_3
+#define GL_TEXTURE0                       0x84C0
+#define GL_TEXTURE1                       0x84C1
+#define GL_TEXTURE2                       0x84C2
+#define GL_TEXTURE3                       0x84C3
+#define GL_TEXTURE4                       0x84C4
+#define GL_TEXTURE5                       0x84C5
+#define GL_TEXTURE6                       0x84C6
+#define GL_TEXTURE7                       0x84C7
+#define GL_TEXTURE8                       0x84C8
+#define GL_TEXTURE9                       0x84C9
+#define GL_TEXTURE10                      0x84CA
+#define GL_TEXTURE11                      0x84CB
+#define GL_TEXTURE12                      0x84CC
+#define GL_TEXTURE13                      0x84CD
+#define GL_TEXTURE14                      0x84CE
+#define GL_TEXTURE15                      0x84CF
+#define GL_TEXTURE16                      0x84D0
+#define GL_TEXTURE17                      0x84D1
+#define GL_TEXTURE18                      0x84D2
+#define GL_TEXTURE19                      0x84D3
+#define GL_TEXTURE20                      0x84D4
+#define GL_TEXTURE21                      0x84D5
+#define GL_TEXTURE22                      0x84D6
+#define GL_TEXTURE23                      0x84D7
+#define GL_TEXTURE24                      0x84D8
+#define GL_TEXTURE25                      0x84D9
+#define GL_TEXTURE26                      0x84DA
+#define GL_TEXTURE27                      0x84DB
+#define GL_TEXTURE28                      0x84DC
+#define GL_TEXTURE29                      0x84DD
+#define GL_TEXTURE30                      0x84DE
+#define GL_TEXTURE31                      0x84DF
+#define GL_ACTIVE_TEXTURE                 0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE          0x84E1
+#define GL_MAX_TEXTURE_UNITS              0x84E2
+#define GL_TRANSPOSE_MODELVIEW_MATRIX     0x84E3
+#define GL_TRANSPOSE_PROJECTION_MATRIX    0x84E4
+#define GL_TRANSPOSE_TEXTURE_MATRIX       0x84E5
+#define GL_TRANSPOSE_COLOR_MATRIX         0x84E6
+#define GL_MULTISAMPLE                    0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
+#define GL_SAMPLE_COVERAGE                0x80A0
+#define GL_SAMPLE_BUFFERS                 0x80A8
+#define GL_SAMPLES                        0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
+#define GL_MULTISAMPLE_BIT                0x20000000
+#define GL_NORMAL_MAP                     0x8511
+#define GL_REFLECTION_MAP                 0x8512
+#define GL_TEXTURE_CUBE_MAP               0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP         0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
+#define GL_COMPRESSED_ALPHA               0x84E9
+#define GL_COMPRESSED_LUMINANCE           0x84EA
+#define GL_COMPRESSED_LUMINANCE_ALPHA     0x84EB
+#define GL_COMPRESSED_INTENSITY           0x84EC
+#define GL_COMPRESSED_RGB                 0x84ED
+#define GL_COMPRESSED_RGBA                0x84EE
+#define GL_TEXTURE_COMPRESSION_HINT       0x84EF
+#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE  0x86A0
+#define GL_TEXTURE_COMPRESSED             0x86A1
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
+#define GL_CLAMP_TO_BORDER                0x812D
+#define GL_COMBINE                        0x8570
+#define GL_COMBINE_RGB                    0x8571
+#define GL_COMBINE_ALPHA                  0x8572
+#define GL_SOURCE0_RGB                    0x8580
+#define GL_SOURCE1_RGB                    0x8581
+#define GL_SOURCE2_RGB                    0x8582
+#define GL_SOURCE0_ALPHA                  0x8588
+#define GL_SOURCE1_ALPHA                  0x8589
+#define GL_SOURCE2_ALPHA                  0x858A
+#define GL_OPERAND0_RGB                   0x8590
+#define GL_OPERAND1_RGB                   0x8591
+#define GL_OPERAND2_RGB                   0x8592
+#define GL_OPERAND0_ALPHA                 0x8598
+#define GL_OPERAND1_ALPHA                 0x8599
+#define GL_OPERAND2_ALPHA                 0x859A
+#define GL_RGB_SCALE                      0x8573
+#define GL_ADD_SIGNED                     0x8574
+#define GL_INTERPOLATE                    0x8575
+#define GL_SUBTRACT                       0x84E7
+#define GL_CONSTANT                       0x8576
+#define GL_PRIMARY_COLOR                  0x8577
+#define GL_PREVIOUS                       0x8578
+#define GL_DOT3_RGB                       0x86AE
+#define GL_DOT3_RGBA                      0x86AF
+#endif
+
+#ifndef GL_VERSION_1_4
+#define GL_BLEND_DST_RGB                  0x80C8
+#define GL_BLEND_SRC_RGB                  0x80C9
+#define GL_BLEND_DST_ALPHA                0x80CA
+#define GL_BLEND_SRC_ALPHA                0x80CB
+#define GL_POINT_SIZE_MIN                 0x8126
+#define GL_POINT_SIZE_MAX                 0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE      0x8128
+#define GL_POINT_DISTANCE_ATTENUATION     0x8129
+#define GL_GENERATE_MIPMAP                0x8191
+#define GL_GENERATE_MIPMAP_HINT           0x8192
+#define GL_DEPTH_COMPONENT16              0x81A5
+#define GL_DEPTH_COMPONENT24              0x81A6
+#define GL_DEPTH_COMPONENT32              0x81A7
+#define GL_MIRRORED_REPEAT                0x8370
+#define GL_FOG_COORDINATE_SOURCE          0x8450
+#define GL_FOG_COORDINATE                 0x8451
+#define GL_FRAGMENT_DEPTH                 0x8452
+#define GL_CURRENT_FOG_COORDINATE         0x8453
+#define GL_FOG_COORDINATE_ARRAY_TYPE      0x8454
+#define GL_FOG_COORDINATE_ARRAY_STRIDE    0x8455
+#define GL_FOG_COORDINATE_ARRAY_POINTER   0x8456
+#define GL_FOG_COORDINATE_ARRAY           0x8457
+#define GL_COLOR_SUM                      0x8458
+#define GL_CURRENT_SECONDARY_COLOR        0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE     0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE     0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE   0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER  0x845D
+#define GL_SECONDARY_COLOR_ARRAY          0x845E
+#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
+#define GL_TEXTURE_FILTER_CONTROL         0x8500
+#define GL_TEXTURE_LOD_BIAS               0x8501
+#define GL_INCR_WRAP                      0x8507
+#define GL_DECR_WRAP                      0x8508
+#define GL_TEXTURE_DEPTH_SIZE             0x884A
+#define GL_DEPTH_TEXTURE_MODE             0x884B
+#define GL_TEXTURE_COMPARE_MODE           0x884C
+#define GL_TEXTURE_COMPARE_FUNC           0x884D
+#define GL_COMPARE_R_TO_TEXTURE           0x884E
+#endif
+
+#ifndef GL_VERSION_1_5
+#define GL_BUFFER_SIZE                    0x8764
+#define GL_BUFFER_USAGE                   0x8765
+#define GL_QUERY_COUNTER_BITS             0x8864
+#define GL_CURRENT_QUERY                  0x8865
+#define GL_QUERY_RESULT                   0x8866
+#define GL_QUERY_RESULT_AVAILABLE         0x8867
+#define GL_ARRAY_BUFFER                   0x8892
+#define GL_ELEMENT_ARRAY_BUFFER           0x8893
+#define GL_ARRAY_BUFFER_BINDING           0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING    0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING    0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING     0x8898
+#define GL_INDEX_ARRAY_BUFFER_BINDING     0x8899
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING 0x889A
+#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING 0x889B
+#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING 0x889C
+#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING 0x889D
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING    0x889E
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
+#define GL_READ_ONLY                      0x88B8
+#define GL_WRITE_ONLY                     0x88B9
+#define GL_READ_WRITE                     0x88BA
+#define GL_BUFFER_ACCESS                  0x88BB
+#define GL_BUFFER_MAPPED                  0x88BC
+#define GL_BUFFER_MAP_POINTER             0x88BD
+#define GL_STREAM_DRAW                    0x88E0
+#define GL_STREAM_READ                    0x88E1
+#define GL_STREAM_COPY                    0x88E2
+#define GL_STATIC_DRAW                    0x88E4
+#define GL_STATIC_READ                    0x88E5
+#define GL_STATIC_COPY                    0x88E6
+#define GL_DYNAMIC_DRAW                   0x88E8
+#define GL_DYNAMIC_READ                   0x88E9
+#define GL_DYNAMIC_COPY                   0x88EA
+#define GL_SAMPLES_PASSED                 0x8914
+#define GL_FOG_COORD_SRC                  GL_FOG_COORDINATE_SOURCE
+#define GL_FOG_COORD                      GL_FOG_COORDINATE
+#define GL_CURRENT_FOG_COORD              GL_CURRENT_FOG_COORDINATE
+#define GL_FOG_COORD_ARRAY_TYPE           GL_FOG_COORDINATE_ARRAY_TYPE
+#define GL_FOG_COORD_ARRAY_STRIDE         GL_FOG_COORDINATE_ARRAY_STRIDE
+#define GL_FOG_COORD_ARRAY_POINTER        GL_FOG_COORDINATE_ARRAY_POINTER
+#define GL_FOG_COORD_ARRAY                GL_FOG_COORDINATE_ARRAY
+#define GL_FOG_COORD_ARRAY_BUFFER_BINDING GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING
+#define GL_SRC0_RGB                       GL_SOURCE0_RGB
+#define GL_SRC1_RGB                       GL_SOURCE1_RGB
+#define GL_SRC2_RGB                       GL_SOURCE2_RGB
+#define GL_SRC0_ALPHA                     GL_SOURCE0_ALPHA
+#define GL_SRC1_ALPHA                     GL_SOURCE1_ALPHA
+#define GL_SRC2_ALPHA                     GL_SOURCE2_ALPHA
+#endif
+
+#ifndef GL_VERSION_2_0
+#define GL_BLEND_EQUATION_RGB             GL_BLEND_EQUATION
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED    0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE       0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE     0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE       0x8625
+#define GL_CURRENT_VERTEX_ATTRIB          0x8626
+#define GL_VERTEX_PROGRAM_POINT_SIZE      0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE        0x8643
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER    0x8645
+#define GL_STENCIL_BACK_FUNC              0x8800
+#define GL_STENCIL_BACK_FAIL              0x8801
+#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
+#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
+#define GL_MAX_DRAW_BUFFERS               0x8824
+#define GL_DRAW_BUFFER0                   0x8825
+#define GL_DRAW_BUFFER1                   0x8826
+#define GL_DRAW_BUFFER2                   0x8827
+#define GL_DRAW_BUFFER3                   0x8828
+#define GL_DRAW_BUFFER4                   0x8829
+#define GL_DRAW_BUFFER5                   0x882A
+#define GL_DRAW_BUFFER6                   0x882B
+#define GL_DRAW_BUFFER7                   0x882C
+#define GL_DRAW_BUFFER8                   0x882D
+#define GL_DRAW_BUFFER9                   0x882E
+#define GL_DRAW_BUFFER10                  0x882F
+#define GL_DRAW_BUFFER11                  0x8830
+#define GL_DRAW_BUFFER12                  0x8831
+#define GL_DRAW_BUFFER13                  0x8832
+#define GL_DRAW_BUFFER14                  0x8833
+#define GL_DRAW_BUFFER15                  0x8834
+#define GL_BLEND_EQUATION_ALPHA           0x883D
+#define GL_POINT_SPRITE                   0x8861
+#define GL_COORD_REPLACE                  0x8862
+#define GL_MAX_VERTEX_ATTRIBS             0x8869
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
+#define GL_MAX_TEXTURE_COORDS             0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS        0x8872
+#define GL_FRAGMENT_SHADER                0x8B30
+#define GL_VERTEX_SHADER                  0x8B31
+#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
+#define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A
+#define GL_MAX_VARYING_FLOATS             0x8B4B
+#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
+#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
+#define GL_SHADER_TYPE                    0x8B4F
+#define GL_FLOAT_VEC2                     0x8B50
+#define GL_FLOAT_VEC3                     0x8B51
+#define GL_FLOAT_VEC4                     0x8B52
+#define GL_INT_VEC2                       0x8B53
+#define GL_INT_VEC3                       0x8B54
+#define GL_INT_VEC4                       0x8B55
+#define GL_BOOL                           0x8B56
+#define GL_BOOL_VEC2                      0x8B57
+#define GL_BOOL_VEC3                      0x8B58
+#define GL_BOOL_VEC4                      0x8B59
+#define GL_FLOAT_MAT2                     0x8B5A
+#define GL_FLOAT_MAT3                     0x8B5B
+#define GL_FLOAT_MAT4                     0x8B5C
+#define GL_SAMPLER_1D                     0x8B5D
+#define GL_SAMPLER_2D                     0x8B5E
+#define GL_SAMPLER_3D                     0x8B5F
+#define GL_SAMPLER_CUBE                   0x8B60
+#define GL_SAMPLER_1D_SHADOW              0x8B61
+#define GL_SAMPLER_2D_SHADOW              0x8B62
+#define GL_DELETE_STATUS                  0x8B80
+#define GL_COMPILE_STATUS                 0x8B81
+#define GL_LINK_STATUS                    0x8B82
+#define GL_VALIDATE_STATUS                0x8B83
+#define GL_INFO_LOG_LENGTH                0x8B84
+#define GL_ATTACHED_SHADERS               0x8B85
+#define GL_ACTIVE_UNIFORMS                0x8B86
+#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
+#define GL_SHADER_SOURCE_LENGTH           0x8B88
+#define GL_ACTIVE_ATTRIBUTES              0x8B89
+#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    0x8B8A
+#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
+#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
+#define GL_CURRENT_PROGRAM                0x8B8D
+#define GL_POINT_SPRITE_COORD_ORIGIN      0x8CA0
+#define GL_LOWER_LEFT                     0x8CA1
+#define GL_UPPER_LEFT                     0x8CA2
+#define GL_STENCIL_BACK_REF               0x8CA3
+#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
+#define GL_STENCIL_BACK_WRITEMASK         0x8CA5
+#endif
+
+#ifndef GL_VERSION_2_1
+#define GL_PIXEL_PACK_BUFFER              0x88EB
+#define GL_PIXEL_UNPACK_BUFFER            0x88EC
+#define GL_PIXEL_PACK_BUFFER_BINDING      0x88ED
+#define GL_PIXEL_UNPACK_BUFFER_BINDING    0x88EF
+#define GL_SRGB                           0x8C40
+#define GL_SRGB8                          0x8C41
+#define GL_SRGB_ALPHA                     0x8C42
+#define GL_SRGB8_ALPHA8                   0x8C43
+#define GL_SLUMINANCE_ALPHA               0x8C44
+#define GL_SLUMINANCE8_ALPHA8             0x8C45
+#define GL_SLUMINANCE                     0x8C46
+#define GL_SLUMINANCE8                    0x8C47
+#define GL_COMPRESSED_SRGB                0x8C48
+#define GL_COMPRESSED_SRGB_ALPHA          0x8C49
+#define GL_COMPRESSED_SLUMINANCE          0x8C4A
+#define GL_COMPRESSED_SLUMINANCE_ALPHA    0x8C4B
+#define GL_FLOAT_MAT2x3                   0x8B65
+#define GL_FLOAT_MAT2x4                   0x8B66
+#define GL_FLOAT_MAT3x2                   0x8B67
+#define GL_FLOAT_MAT3x4                   0x8B68
+#define GL_FLOAT_MAT4x2                   0x8B69
+#define GL_FLOAT_MAT4x3                   0x8B6A
+#define GL_CURRENT_RASTER_SECONDARY_COLOR 0x845F
+#endif
+
+#ifndef GL_ARB_multitexture
+#define GL_TEXTURE0_ARB                   0x84C0
+#define GL_TEXTURE1_ARB                   0x84C1
+#define GL_TEXTURE2_ARB                   0x84C2
+#define GL_TEXTURE3_ARB                   0x84C3
+#define GL_TEXTURE4_ARB                   0x84C4
+#define GL_TEXTURE5_ARB                   0x84C5
+#define GL_TEXTURE6_ARB                   0x84C6
+#define GL_TEXTURE7_ARB                   0x84C7
+#define GL_TEXTURE8_ARB                   0x84C8
+#define GL_TEXTURE9_ARB                   0x84C9
+#define GL_TEXTURE10_ARB                  0x84CA
+#define GL_TEXTURE11_ARB                  0x84CB
+#define GL_TEXTURE12_ARB                  0x84CC
+#define GL_TEXTURE13_ARB                  0x84CD
+#define GL_TEXTURE14_ARB                  0x84CE
+#define GL_TEXTURE15_ARB                  0x84CF
+#define GL_TEXTURE16_ARB                  0x84D0
+#define GL_TEXTURE17_ARB                  0x84D1
+#define GL_TEXTURE18_ARB                  0x84D2
+#define GL_TEXTURE19_ARB                  0x84D3
+#define GL_TEXTURE20_ARB                  0x84D4
+#define GL_TEXTURE21_ARB                  0x84D5
+#define GL_TEXTURE22_ARB                  0x84D6
+#define GL_TEXTURE23_ARB                  0x84D7
+#define GL_TEXTURE24_ARB                  0x84D8
+#define GL_TEXTURE25_ARB                  0x84D9
+#define GL_TEXTURE26_ARB                  0x84DA
+#define GL_TEXTURE27_ARB                  0x84DB
+#define GL_TEXTURE28_ARB                  0x84DC
+#define GL_TEXTURE29_ARB                  0x84DD
+#define GL_TEXTURE30_ARB                  0x84DE
+#define GL_TEXTURE31_ARB                  0x84DF
+#define GL_ACTIVE_TEXTURE_ARB             0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE_ARB      0x84E1
+#define GL_MAX_TEXTURE_UNITS_ARB          0x84E2
+#endif
+
+#ifndef GL_ARB_transpose_matrix
+#define GL_TRANSPOSE_MODELVIEW_MATRIX_ARB 0x84E3
+#define GL_TRANSPOSE_PROJECTION_MATRIX_ARB 0x84E4
+#define GL_TRANSPOSE_TEXTURE_MATRIX_ARB   0x84E5
+#define GL_TRANSPOSE_COLOR_MATRIX_ARB     0x84E6
+#endif
+
+#ifndef GL_ARB_multisample
+#define GL_MULTISAMPLE_ARB                0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE_ARB   0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_ARB        0x809F
+#define GL_SAMPLE_COVERAGE_ARB            0x80A0
+#define GL_SAMPLE_BUFFERS_ARB             0x80A8
+#define GL_SAMPLES_ARB                    0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE_ARB      0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT_ARB     0x80AB
+#define GL_MULTISAMPLE_BIT_ARB            0x20000000
+#endif
+
+#ifndef GL_ARB_texture_env_add
+#endif
+
+#ifndef GL_ARB_texture_cube_map
+#define GL_NORMAL_MAP_ARB                 0x8511
+#define GL_REFLECTION_MAP_ARB             0x8512
+#define GL_TEXTURE_CUBE_MAP_ARB           0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_ARB   0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP_ARB     0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB  0x851C
+#endif
+
+#ifndef GL_ARB_texture_compression
+#define GL_COMPRESSED_ALPHA_ARB           0x84E9
+#define GL_COMPRESSED_LUMINANCE_ARB       0x84EA
+#define GL_COMPRESSED_LUMINANCE_ALPHA_ARB 0x84EB
+#define GL_COMPRESSED_INTENSITY_ARB       0x84EC
+#define GL_COMPRESSED_RGB_ARB             0x84ED
+#define GL_COMPRESSED_RGBA_ARB            0x84EE
+#define GL_TEXTURE_COMPRESSION_HINT_ARB   0x84EF
+#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB 0x86A0
+#define GL_TEXTURE_COMPRESSED_ARB         0x86A1
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3
+#endif
+
+#ifndef GL_ARB_texture_border_clamp
+#define GL_CLAMP_TO_BORDER_ARB            0x812D
+#endif
+
+#ifndef GL_ARB_point_parameters
+#define GL_POINT_SIZE_MIN_ARB             0x8126
+#define GL_POINT_SIZE_MAX_ARB             0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_ARB  0x8128
+#define GL_POINT_DISTANCE_ATTENUATION_ARB 0x8129
+#endif
+
+#ifndef GL_ARB_vertex_blend
+#define GL_MAX_VERTEX_UNITS_ARB           0x86A4
+#define GL_ACTIVE_VERTEX_UNITS_ARB        0x86A5
+#define GL_WEIGHT_SUM_UNITY_ARB           0x86A6
+#define GL_VERTEX_BLEND_ARB               0x86A7
+#define GL_CURRENT_WEIGHT_ARB             0x86A8
+#define GL_WEIGHT_ARRAY_TYPE_ARB          0x86A9
+#define GL_WEIGHT_ARRAY_STRIDE_ARB        0x86AA
+#define GL_WEIGHT_ARRAY_SIZE_ARB          0x86AB
+#define GL_WEIGHT_ARRAY_POINTER_ARB       0x86AC
+#define GL_WEIGHT_ARRAY_ARB               0x86AD
+#define GL_MODELVIEW0_ARB                 0x1700
+#define GL_MODELVIEW1_ARB                 0x850A
+#define GL_MODELVIEW2_ARB                 0x8722
+#define GL_MODELVIEW3_ARB                 0x8723
+#define GL_MODELVIEW4_ARB                 0x8724
+#define GL_MODELVIEW5_ARB                 0x8725
+#define GL_MODELVIEW6_ARB                 0x8726
+#define GL_MODELVIEW7_ARB                 0x8727
+#define GL_MODELVIEW8_ARB                 0x8728
+#define GL_MODELVIEW9_ARB                 0x8729
+#define GL_MODELVIEW10_ARB                0x872A
+#define GL_MODELVIEW11_ARB                0x872B
+#define GL_MODELVIEW12_ARB                0x872C
+#define GL_MODELVIEW13_ARB                0x872D
+#define GL_MODELVIEW14_ARB                0x872E
+#define GL_MODELVIEW15_ARB                0x872F
+#define GL_MODELVIEW16_ARB                0x8730
+#define GL_MODELVIEW17_ARB                0x8731
+#define GL_MODELVIEW18_ARB                0x8732
+#define GL_MODELVIEW19_ARB                0x8733
+#define GL_MODELVIEW20_ARB                0x8734
+#define GL_MODELVIEW21_ARB                0x8735
+#define GL_MODELVIEW22_ARB                0x8736
+#define GL_MODELVIEW23_ARB                0x8737
+#define GL_MODELVIEW24_ARB                0x8738
+#define GL_MODELVIEW25_ARB                0x8739
+#define GL_MODELVIEW26_ARB                0x873A
+#define GL_MODELVIEW27_ARB                0x873B
+#define GL_MODELVIEW28_ARB                0x873C
+#define GL_MODELVIEW29_ARB                0x873D
+#define GL_MODELVIEW30_ARB                0x873E
+#define GL_MODELVIEW31_ARB                0x873F
+#endif
+
+#ifndef GL_ARB_matrix_palette
+#define GL_MATRIX_PALETTE_ARB             0x8840
+#define GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB 0x8841
+#define GL_MAX_PALETTE_MATRICES_ARB       0x8842
+#define GL_CURRENT_PALETTE_MATRIX_ARB     0x8843
+#define GL_MATRIX_INDEX_ARRAY_ARB         0x8844
+#define GL_CURRENT_MATRIX_INDEX_ARB       0x8845
+#define GL_MATRIX_INDEX_ARRAY_SIZE_ARB    0x8846
+#define GL_MATRIX_INDEX_ARRAY_TYPE_ARB    0x8847
+#define GL_MATRIX_INDEX_ARRAY_STRIDE_ARB  0x8848
+#define GL_MATRIX_INDEX_ARRAY_POINTER_ARB 0x8849
+#endif
+
+#ifndef GL_ARB_texture_env_combine
+#define GL_COMBINE_ARB                    0x8570
+#define GL_COMBINE_RGB_ARB                0x8571
+#define GL_COMBINE_ALPHA_ARB              0x8572
+#define GL_SOURCE0_RGB_ARB                0x8580
+#define GL_SOURCE1_RGB_ARB                0x8581
+#define GL_SOURCE2_RGB_ARB                0x8582
+#define GL_SOURCE0_ALPHA_ARB              0x8588
+#define GL_SOURCE1_ALPHA_ARB              0x8589
+#define GL_SOURCE2_ALPHA_ARB              0x858A
+#define GL_OPERAND0_RGB_ARB               0x8590
+#define GL_OPERAND1_RGB_ARB               0x8591
+#define GL_OPERAND2_RGB_ARB               0x8592
+#define GL_OPERAND0_ALPHA_ARB             0x8598
+#define GL_OPERAND1_ALPHA_ARB             0x8599
+#define GL_OPERAND2_ALPHA_ARB             0x859A
+#define GL_RGB_SCALE_ARB                  0x8573
+#define GL_ADD_SIGNED_ARB                 0x8574
+#define GL_INTERPOLATE_ARB                0x8575
+#define GL_SUBTRACT_ARB                   0x84E7
+#define GL_CONSTANT_ARB                   0x8576
+#define GL_PRIMARY_COLOR_ARB              0x8577
+#define GL_PREVIOUS_ARB                   0x8578
+#endif
+
+#ifndef GL_ARB_texture_env_crossbar
+#endif
+
+#ifndef GL_ARB_texture_env_dot3
+#define GL_DOT3_RGB_ARB                   0x86AE
+#define GL_DOT3_RGBA_ARB                  0x86AF
+#endif
+
+#ifndef GL_ARB_texture_mirrored_repeat
+#define GL_MIRRORED_REPEAT_ARB            0x8370
+#endif
+
+#ifndef GL_ARB_depth_texture
+#define GL_DEPTH_COMPONENT16_ARB          0x81A5
+#define GL_DEPTH_COMPONENT24_ARB          0x81A6
+#define GL_DEPTH_COMPONENT32_ARB          0x81A7
+#define GL_TEXTURE_DEPTH_SIZE_ARB         0x884A
+#define GL_DEPTH_TEXTURE_MODE_ARB         0x884B
+#endif
+
+#ifndef GL_ARB_shadow
+#define GL_TEXTURE_COMPARE_MODE_ARB       0x884C
+#define GL_TEXTURE_COMPARE_FUNC_ARB       0x884D
+#define GL_COMPARE_R_TO_TEXTURE_ARB       0x884E
+#endif
+
+#ifndef GL_ARB_shadow_ambient
+#define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB 0x80BF
+#endif
+
+#ifndef GL_ARB_window_pos
+#endif
+
+#ifndef GL_ARB_vertex_program
+#define GL_COLOR_SUM_ARB                  0x8458
+#define GL_VERTEX_PROGRAM_ARB             0x8620
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB 0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB   0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB 0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB   0x8625
+#define GL_CURRENT_VERTEX_ATTRIB_ARB      0x8626
+#define GL_PROGRAM_LENGTH_ARB             0x8627
+#define GL_PROGRAM_STRING_ARB             0x8628
+#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB 0x862E
+#define GL_MAX_PROGRAM_MATRICES_ARB       0x862F
+#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB 0x8640
+#define GL_CURRENT_MATRIX_ARB             0x8641
+#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB  0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB    0x8643
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB 0x8645
+#define GL_PROGRAM_ERROR_POSITION_ARB     0x864B
+#define GL_PROGRAM_BINDING_ARB            0x8677
+#define GL_MAX_VERTEX_ATTRIBS_ARB         0x8869
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB 0x886A
+#define GL_PROGRAM_ERROR_STRING_ARB       0x8874
+#define GL_PROGRAM_FORMAT_ASCII_ARB       0x8875
+#define GL_PROGRAM_FORMAT_ARB             0x8876
+#define GL_PROGRAM_INSTRUCTIONS_ARB       0x88A0
+#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB   0x88A1
+#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A2
+#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A3
+#define GL_PROGRAM_TEMPORARIES_ARB        0x88A4
+#define GL_MAX_PROGRAM_TEMPORARIES_ARB    0x88A5
+#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A6
+#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A7
+#define GL_PROGRAM_PARAMETERS_ARB         0x88A8
+#define GL_MAX_PROGRAM_PARAMETERS_ARB     0x88A9
+#define GL_PROGRAM_NATIVE_PARAMETERS_ARB  0x88AA
+#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AB
+#define GL_PROGRAM_ATTRIBS_ARB            0x88AC
+#define GL_MAX_PROGRAM_ATTRIBS_ARB        0x88AD
+#define GL_PROGRAM_NATIVE_ATTRIBS_ARB     0x88AE
+#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AF
+#define GL_PROGRAM_ADDRESS_REGISTERS_ARB  0x88B0
+#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B1
+#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B2
+#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B3
+#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB 0x88B4
+#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB 0x88B5
+#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB 0x88B6
+#define GL_TRANSPOSE_CURRENT_MATRIX_ARB   0x88B7
+#define GL_MATRIX0_ARB                    0x88C0
+#define GL_MATRIX1_ARB                    0x88C1
+#define GL_MATRIX2_ARB                    0x88C2
+#define GL_MATRIX3_ARB                    0x88C3
+#define GL_MATRIX4_ARB                    0x88C4
+#define GL_MATRIX5_ARB                    0x88C5
+#define GL_MATRIX6_ARB                    0x88C6
+#define GL_MATRIX7_ARB                    0x88C7
+#define GL_MATRIX8_ARB                    0x88C8
+#define GL_MATRIX9_ARB                    0x88C9
+#define GL_MATRIX10_ARB                   0x88CA
+#define GL_MATRIX11_ARB                   0x88CB
+#define GL_MATRIX12_ARB                   0x88CC
+#define GL_MATRIX13_ARB                   0x88CD
+#define GL_MATRIX14_ARB                   0x88CE
+#define GL_MATRIX15_ARB                   0x88CF
+#define GL_MATRIX16_ARB                   0x88D0
+#define GL_MATRIX17_ARB                   0x88D1
+#define GL_MATRIX18_ARB                   0x88D2
+#define GL_MATRIX19_ARB                   0x88D3
+#define GL_MATRIX20_ARB                   0x88D4
+#define GL_MATRIX21_ARB                   0x88D5
+#define GL_MATRIX22_ARB                   0x88D6
+#define GL_MATRIX23_ARB                   0x88D7
+#define GL_MATRIX24_ARB                   0x88D8
+#define GL_MATRIX25_ARB                   0x88D9
+#define GL_MATRIX26_ARB                   0x88DA
+#define GL_MATRIX27_ARB                   0x88DB
+#define GL_MATRIX28_ARB                   0x88DC
+#define GL_MATRIX29_ARB                   0x88DD
+#define GL_MATRIX30_ARB                   0x88DE
+#define GL_MATRIX31_ARB                   0x88DF
+#endif
+
+#ifndef GL_ARB_fragment_program
+#define GL_FRAGMENT_PROGRAM_ARB           0x8804
+#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB   0x8805
+#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB   0x8806
+#define GL_PROGRAM_TEX_INDIRECTIONS_ARB   0x8807
+#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x8808
+#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x8809
+#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x880A
+#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB 0x880B
+#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB 0x880C
+#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB 0x880D
+#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x880E
+#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x880F
+#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x8810
+#define GL_MAX_TEXTURE_COORDS_ARB         0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB    0x8872
+#endif
+
+#ifndef GL_ARB_vertex_buffer_object
+#define GL_BUFFER_SIZE_ARB                0x8764
+#define GL_BUFFER_USAGE_ARB               0x8765
+#define GL_ARRAY_BUFFER_ARB               0x8892
+#define GL_ELEMENT_ARRAY_BUFFER_ARB       0x8893
+#define GL_ARRAY_BUFFER_BINDING_ARB       0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB 0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB 0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB 0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB 0x8898
+#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB 0x8899
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB 0x889A
+#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB 0x889B
+#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB 0x889C
+#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB 0x889D
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB 0x889E
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB 0x889F
+#define GL_READ_ONLY_ARB                  0x88B8
+#define GL_WRITE_ONLY_ARB                 0x88B9
+#define GL_READ_WRITE_ARB                 0x88BA
+#define GL_BUFFER_ACCESS_ARB              0x88BB
+#define GL_BUFFER_MAPPED_ARB              0x88BC
+#define GL_BUFFER_MAP_POINTER_ARB         0x88BD
+#define GL_STREAM_DRAW_ARB                0x88E0
+#define GL_STREAM_READ_ARB                0x88E1
+#define GL_STREAM_COPY_ARB                0x88E2
+#define GL_STATIC_DRAW_ARB                0x88E4
+#define GL_STATIC_READ_ARB                0x88E5
+#define GL_STATIC_COPY_ARB                0x88E6
+#define GL_DYNAMIC_DRAW_ARB               0x88E8
+#define GL_DYNAMIC_READ_ARB               0x88E9
+#define GL_DYNAMIC_COPY_ARB               0x88EA
+#endif
+
+#ifndef GL_ARB_occlusion_query
+#define GL_QUERY_COUNTER_BITS_ARB         0x8864
+#define GL_CURRENT_QUERY_ARB              0x8865
+#define GL_QUERY_RESULT_ARB               0x8866
+#define GL_QUERY_RESULT_AVAILABLE_ARB     0x8867
+#define GL_SAMPLES_PASSED_ARB             0x8914
+#endif
+
+#ifndef GL_ARB_shader_objects
+#define GL_PROGRAM_OBJECT_ARB             0x8B40
+#define GL_SHADER_OBJECT_ARB              0x8B48
+#define GL_OBJECT_TYPE_ARB                0x8B4E
+#define GL_OBJECT_SUBTYPE_ARB             0x8B4F
+#define GL_FLOAT_VEC2_ARB                 0x8B50
+#define GL_FLOAT_VEC3_ARB                 0x8B51
+#define GL_FLOAT_VEC4_ARB                 0x8B52
+#define GL_INT_VEC2_ARB                   0x8B53
+#define GL_INT_VEC3_ARB                   0x8B54
+#define GL_INT_VEC4_ARB                   0x8B55
+#define GL_BOOL_ARB                       0x8B56
+#define GL_BOOL_VEC2_ARB                  0x8B57
+#define GL_BOOL_VEC3_ARB                  0x8B58
+#define GL_BOOL_VEC4_ARB                  0x8B59
+#define GL_FLOAT_MAT2_ARB                 0x8B5A
+#define GL_FLOAT_MAT3_ARB                 0x8B5B
+#define GL_FLOAT_MAT4_ARB                 0x8B5C
+#define GL_SAMPLER_1D_ARB                 0x8B5D
+#define GL_SAMPLER_2D_ARB                 0x8B5E
+#define GL_SAMPLER_3D_ARB                 0x8B5F
+#define GL_SAMPLER_CUBE_ARB               0x8B60
+#define GL_SAMPLER_1D_SHADOW_ARB          0x8B61
+#define GL_SAMPLER_2D_SHADOW_ARB          0x8B62
+#define GL_SAMPLER_2D_RECT_ARB            0x8B63
+#define GL_SAMPLER_2D_RECT_SHADOW_ARB     0x8B64
+#define GL_OBJECT_DELETE_STATUS_ARB       0x8B80
+#define GL_OBJECT_COMPILE_STATUS_ARB      0x8B81
+#define GL_OBJECT_LINK_STATUS_ARB         0x8B82
+#define GL_OBJECT_VALIDATE_STATUS_ARB     0x8B83
+#define GL_OBJECT_INFO_LOG_LENGTH_ARB     0x8B84
+#define GL_OBJECT_ATTACHED_OBJECTS_ARB    0x8B85
+#define GL_OBJECT_ACTIVE_UNIFORMS_ARB     0x8B86
+#define GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB 0x8B87
+#define GL_OBJECT_SHADER_SOURCE_LENGTH_ARB 0x8B88
+#endif
+
+#ifndef GL_ARB_vertex_shader
+#define GL_VERTEX_SHADER_ARB              0x8B31
+#define GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB 0x8B4A
+#define GL_MAX_VARYING_FLOATS_ARB         0x8B4B
+#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB 0x8B4C
+#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB 0x8B4D
+#define GL_OBJECT_ACTIVE_ATTRIBUTES_ARB   0x8B89
+#define GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB 0x8B8A
+#endif
+
+#ifndef GL_ARB_fragment_shader
+#define GL_FRAGMENT_SHADER_ARB            0x8B30
+#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB 0x8B49
+#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB 0x8B8B
+#endif
+
+#ifndef GL_ARB_shading_language_100
+#define GL_SHADING_LANGUAGE_VERSION_ARB   0x8B8C
+#endif
+
+#ifndef GL_ARB_texture_non_power_of_two
+#endif
+
+#ifndef GL_ARB_point_sprite
+#define GL_POINT_SPRITE_ARB               0x8861
+#define GL_COORD_REPLACE_ARB              0x8862
+#endif
+
+#ifndef GL_ARB_fragment_program_shadow
+#endif
+
+#ifndef GL_ARB_draw_buffers
+#define GL_MAX_DRAW_BUFFERS_ARB           0x8824
+#define GL_DRAW_BUFFER0_ARB               0x8825
+#define GL_DRAW_BUFFER1_ARB               0x8826
+#define GL_DRAW_BUFFER2_ARB               0x8827
+#define GL_DRAW_BUFFER3_ARB               0x8828
+#define GL_DRAW_BUFFER4_ARB               0x8829
+#define GL_DRAW_BUFFER5_ARB               0x882A
+#define GL_DRAW_BUFFER6_ARB               0x882B
+#define GL_DRAW_BUFFER7_ARB               0x882C
+#define GL_DRAW_BUFFER8_ARB               0x882D
+#define GL_DRAW_BUFFER9_ARB               0x882E
+#define GL_DRAW_BUFFER10_ARB              0x882F
+#define GL_DRAW_BUFFER11_ARB              0x8830
+#define GL_DRAW_BUFFER12_ARB              0x8831
+#define GL_DRAW_BUFFER13_ARB              0x8832
+#define GL_DRAW_BUFFER14_ARB              0x8833
+#define GL_DRAW_BUFFER15_ARB              0x8834
+#endif
+
+#ifndef GL_ARB_texture_rectangle
+#define GL_TEXTURE_RECTANGLE_ARB          0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE_ARB  0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE_ARB    0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB 0x84F8
+#endif
+
+#ifndef GL_ARB_color_buffer_float
+#define GL_RGBA_FLOAT_MODE_ARB            0x8820
+#define GL_CLAMP_VERTEX_COLOR_ARB         0x891A
+#define GL_CLAMP_FRAGMENT_COLOR_ARB       0x891B
+#define GL_CLAMP_READ_COLOR_ARB           0x891C
+#define GL_FIXED_ONLY_ARB                 0x891D
+#endif
+
+#ifndef GL_ARB_half_float_pixel
+#define GL_HALF_FLOAT_ARB                 0x140B
+#endif
+
+#ifndef GL_ARB_texture_float
+#define GL_TEXTURE_RED_TYPE_ARB           0x8C10
+#define GL_TEXTURE_GREEN_TYPE_ARB         0x8C11
+#define GL_TEXTURE_BLUE_TYPE_ARB          0x8C12
+#define GL_TEXTURE_ALPHA_TYPE_ARB         0x8C13
+#define GL_TEXTURE_LUMINANCE_TYPE_ARB     0x8C14
+#define GL_TEXTURE_INTENSITY_TYPE_ARB     0x8C15
+#define GL_TEXTURE_DEPTH_TYPE_ARB         0x8C16
+#define GL_UNSIGNED_NORMALIZED_ARB        0x8C17
+#define GL_RGBA32F_ARB                    0x8814
+#define GL_RGB32F_ARB                     0x8815
+#define GL_ALPHA32F_ARB                   0x8816
+#define GL_INTENSITY32F_ARB               0x8817
+#define GL_LUMINANCE32F_ARB               0x8818
+#define GL_LUMINANCE_ALPHA32F_ARB         0x8819
+#define GL_RGBA16F_ARB                    0x881A
+#define GL_RGB16F_ARB                     0x881B
+#define GL_ALPHA16F_ARB                   0x881C
+#define GL_INTENSITY16F_ARB               0x881D
+#define GL_LUMINANCE16F_ARB               0x881E
+#define GL_LUMINANCE_ALPHA16F_ARB         0x881F
+#endif
+
+#ifndef GL_ARB_pixel_buffer_object
+#define GL_PIXEL_PACK_BUFFER_ARB          0x88EB
+#define GL_PIXEL_UNPACK_BUFFER_ARB        0x88EC
+#define GL_PIXEL_PACK_BUFFER_BINDING_ARB  0x88ED
+#define GL_PIXEL_UNPACK_BUFFER_BINDING_ARB 0x88EF
+#endif
+
+#ifndef GL_EXT_abgr
+#define GL_ABGR_EXT                       0x8000
+#endif
+
+#ifndef GL_EXT_blend_color
+#define GL_CONSTANT_COLOR_EXT             0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR_EXT   0x8002
+#define GL_CONSTANT_ALPHA_EXT             0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT   0x8004
+#define GL_BLEND_COLOR_EXT                0x8005
+#endif
+
+#ifndef GL_EXT_polygon_offset
+#define GL_POLYGON_OFFSET_EXT             0x8037
+#define GL_POLYGON_OFFSET_FACTOR_EXT      0x8038
+#define GL_POLYGON_OFFSET_BIAS_EXT        0x8039
+#endif
+
+#ifndef GL_EXT_texture
+#define GL_ALPHA4_EXT                     0x803B
+#define GL_ALPHA8_EXT                     0x803C
+#define GL_ALPHA12_EXT                    0x803D
+#define GL_ALPHA16_EXT                    0x803E
+#define GL_LUMINANCE4_EXT                 0x803F
+#define GL_LUMINANCE8_EXT                 0x8040
+#define GL_LUMINANCE12_EXT                0x8041
+#define GL_LUMINANCE16_EXT                0x8042
+#define GL_LUMINANCE4_ALPHA4_EXT          0x8043
+#define GL_LUMINANCE6_ALPHA2_EXT          0x8044
+#define GL_LUMINANCE8_ALPHA8_EXT          0x8045
+#define GL_LUMINANCE12_ALPHA4_EXT         0x8046
+#define GL_LUMINANCE12_ALPHA12_EXT        0x8047
+#define GL_LUMINANCE16_ALPHA16_EXT        0x8048
+#define GL_INTENSITY_EXT                  0x8049
+#define GL_INTENSITY4_EXT                 0x804A
+#define GL_INTENSITY8_EXT                 0x804B
+#define GL_INTENSITY12_EXT                0x804C
+#define GL_INTENSITY16_EXT                0x804D
+#define GL_RGB2_EXT                       0x804E
+#define GL_RGB4_EXT                       0x804F
+#define GL_RGB5_EXT                       0x8050
+#define GL_RGB8_EXT                       0x8051
+#define GL_RGB10_EXT                      0x8052
+#define GL_RGB12_EXT                      0x8053
+#define GL_RGB16_EXT                      0x8054
+#define GL_RGBA2_EXT                      0x8055
+#define GL_RGBA4_EXT                      0x8056
+#define GL_RGB5_A1_EXT                    0x8057
+#define GL_RGBA8_EXT                      0x8058
+#define GL_RGB10_A2_EXT                   0x8059
+#define GL_RGBA12_EXT                     0x805A
+#define GL_RGBA16_EXT                     0x805B
+#define GL_TEXTURE_RED_SIZE_EXT           0x805C
+#define GL_TEXTURE_GREEN_SIZE_EXT         0x805D
+#define GL_TEXTURE_BLUE_SIZE_EXT          0x805E
+#define GL_TEXTURE_ALPHA_SIZE_EXT         0x805F
+#define GL_TEXTURE_LUMINANCE_SIZE_EXT     0x8060
+#define GL_TEXTURE_INTENSITY_SIZE_EXT     0x8061
+#define GL_REPLACE_EXT                    0x8062
+#define GL_PROXY_TEXTURE_1D_EXT           0x8063
+#define GL_PROXY_TEXTURE_2D_EXT           0x8064
+#define GL_TEXTURE_TOO_LARGE_EXT          0x8065
+#endif
+
+#ifndef GL_EXT_texture3D
+#define GL_PACK_SKIP_IMAGES_EXT           0x806B
+#define GL_PACK_IMAGE_HEIGHT_EXT          0x806C
+#define GL_UNPACK_SKIP_IMAGES_EXT         0x806D
+#define GL_UNPACK_IMAGE_HEIGHT_EXT        0x806E
+#define GL_TEXTURE_3D_EXT                 0x806F
+#define GL_PROXY_TEXTURE_3D_EXT           0x8070
+#define GL_TEXTURE_DEPTH_EXT              0x8071
+#define GL_TEXTURE_WRAP_R_EXT             0x8072
+#define GL_MAX_3D_TEXTURE_SIZE_EXT        0x8073
+#endif
+
+#ifndef GL_SGIS_texture_filter4
+#define GL_FILTER4_SGIS                   0x8146
+#define GL_TEXTURE_FILTER4_SIZE_SGIS      0x8147
+#endif
+
+#ifndef GL_EXT_subtexture
+#endif
+
+#ifndef GL_EXT_copy_texture
+#endif
+
+#ifndef GL_EXT_histogram
+#define GL_HISTOGRAM_EXT                  0x8024
+#define GL_PROXY_HISTOGRAM_EXT            0x8025
+#define GL_HISTOGRAM_WIDTH_EXT            0x8026
+#define GL_HISTOGRAM_FORMAT_EXT           0x8027
+#define GL_HISTOGRAM_RED_SIZE_EXT         0x8028
+#define GL_HISTOGRAM_GREEN_SIZE_EXT       0x8029
+#define GL_HISTOGRAM_BLUE_SIZE_EXT        0x802A
+#define GL_HISTOGRAM_ALPHA_SIZE_EXT       0x802B
+#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT   0x802C
+#define GL_HISTOGRAM_SINK_EXT             0x802D
+#define GL_MINMAX_EXT                     0x802E
+#define GL_MINMAX_FORMAT_EXT              0x802F
+#define GL_MINMAX_SINK_EXT                0x8030
+#define GL_TABLE_TOO_LARGE_EXT            0x8031
+#endif
+
+#ifndef GL_EXT_convolution
+#define GL_CONVOLUTION_1D_EXT             0x8010
+#define GL_CONVOLUTION_2D_EXT             0x8011
+#define GL_SEPARABLE_2D_EXT               0x8012
+#define GL_CONVOLUTION_BORDER_MODE_EXT    0x8013
+#define GL_CONVOLUTION_FILTER_SCALE_EXT   0x8014
+#define GL_CONVOLUTION_FILTER_BIAS_EXT    0x8015
+#define GL_REDUCE_EXT                     0x8016
+#define GL_CONVOLUTION_FORMAT_EXT         0x8017
+#define GL_CONVOLUTION_WIDTH_EXT          0x8018
+#define GL_CONVOLUTION_HEIGHT_EXT         0x8019
+#define GL_MAX_CONVOLUTION_WIDTH_EXT      0x801A
+#define GL_MAX_CONVOLUTION_HEIGHT_EXT     0x801B
+#define GL_POST_CONVOLUTION_RED_SCALE_EXT 0x801C
+#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT 0x801D
+#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT 0x801E
+#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT 0x801F
+#define GL_POST_CONVOLUTION_RED_BIAS_EXT  0x8020
+#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT 0x8021
+#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT 0x8022
+#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT 0x8023
+#endif
+
+#ifndef GL_SGI_color_matrix
+#define GL_COLOR_MATRIX_SGI               0x80B1
+#define GL_COLOR_MATRIX_STACK_DEPTH_SGI   0x80B2
+#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B3
+#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI 0x80B4
+#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI 0x80B5
+#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI 0x80B6
+#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI 0x80B7
+#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI 0x80B8
+#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI 0x80B9
+#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI 0x80BA
+#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI 0x80BB
+#endif
+
+#ifndef GL_SGI_color_table
+#define GL_COLOR_TABLE_SGI                0x80D0
+#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D1
+#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D2
+#define GL_PROXY_COLOR_TABLE_SGI          0x80D3
+#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D4
+#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D5
+#define GL_COLOR_TABLE_SCALE_SGI          0x80D6
+#define GL_COLOR_TABLE_BIAS_SGI           0x80D7
+#define GL_COLOR_TABLE_FORMAT_SGI         0x80D8
+#define GL_COLOR_TABLE_WIDTH_SGI          0x80D9
+#define GL_COLOR_TABLE_RED_SIZE_SGI       0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE_SGI     0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE_SGI      0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE_SGI     0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI 0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI 0x80DF
+#endif
+
+#ifndef GL_SGIS_pixel_texture
+#define GL_PIXEL_TEXTURE_SGIS             0x8353
+#define GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS 0x8354
+#define GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS 0x8355
+#define GL_PIXEL_GROUP_COLOR_SGIS         0x8356
+#endif
+
+#ifndef GL_SGIX_pixel_texture
+#define GL_PIXEL_TEX_GEN_SGIX             0x8139
+#define GL_PIXEL_TEX_GEN_MODE_SGIX        0x832B
+#endif
+
+#ifndef GL_SGIS_texture4D
+#define GL_PACK_SKIP_VOLUMES_SGIS         0x8130
+#define GL_PACK_IMAGE_DEPTH_SGIS          0x8131
+#define GL_UNPACK_SKIP_VOLUMES_SGIS       0x8132
+#define GL_UNPACK_IMAGE_DEPTH_SGIS        0x8133
+#define GL_TEXTURE_4D_SGIS                0x8134
+#define GL_PROXY_TEXTURE_4D_SGIS          0x8135
+#define GL_TEXTURE_4DSIZE_SGIS            0x8136
+#define GL_TEXTURE_WRAP_Q_SGIS            0x8137
+#define GL_MAX_4D_TEXTURE_SIZE_SGIS       0x8138
+#define GL_TEXTURE_4D_BINDING_SGIS        0x814F
+#endif
+
+#ifndef GL_SGI_texture_color_table
+#define GL_TEXTURE_COLOR_TABLE_SGI        0x80BC
+#define GL_PROXY_TEXTURE_COLOR_TABLE_SGI  0x80BD
+#endif
+
+#ifndef GL_EXT_cmyka
+#define GL_CMYK_EXT                       0x800C
+#define GL_CMYKA_EXT                      0x800D
+#define GL_PACK_CMYK_HINT_EXT             0x800E
+#define GL_UNPACK_CMYK_HINT_EXT           0x800F
+#endif
+
+#ifndef GL_EXT_texture_object
+#define GL_TEXTURE_PRIORITY_EXT           0x8066
+#define GL_TEXTURE_RESIDENT_EXT           0x8067
+#define GL_TEXTURE_1D_BINDING_EXT         0x8068
+#define GL_TEXTURE_2D_BINDING_EXT         0x8069
+#define GL_TEXTURE_3D_BINDING_EXT         0x806A
+#endif
+
+#ifndef GL_SGIS_detail_texture
+#define GL_DETAIL_TEXTURE_2D_SGIS         0x8095
+#define GL_DETAIL_TEXTURE_2D_BINDING_SGIS 0x8096
+#define GL_LINEAR_DETAIL_SGIS             0x8097
+#define GL_LINEAR_DETAIL_ALPHA_SGIS       0x8098
+#define GL_LINEAR_DETAIL_COLOR_SGIS       0x8099
+#define GL_DETAIL_TEXTURE_LEVEL_SGIS      0x809A
+#define GL_DETAIL_TEXTURE_MODE_SGIS       0x809B
+#define GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS 0x809C
+#endif
+
+#ifndef GL_SGIS_sharpen_texture
+#define GL_LINEAR_SHARPEN_SGIS            0x80AD
+#define GL_LINEAR_SHARPEN_ALPHA_SGIS      0x80AE
+#define GL_LINEAR_SHARPEN_COLOR_SGIS      0x80AF
+#define GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS 0x80B0
+#endif
+
+#ifndef GL_EXT_packed_pixels
+#define GL_UNSIGNED_BYTE_3_3_2_EXT        0x8032
+#define GL_UNSIGNED_SHORT_4_4_4_4_EXT     0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1_EXT     0x8034
+#define GL_UNSIGNED_INT_8_8_8_8_EXT       0x8035
+#define GL_UNSIGNED_INT_10_10_10_2_EXT    0x8036
+#endif
+
+#ifndef GL_SGIS_texture_lod
+#define GL_TEXTURE_MIN_LOD_SGIS           0x813A
+#define GL_TEXTURE_MAX_LOD_SGIS           0x813B
+#define GL_TEXTURE_BASE_LEVEL_SGIS        0x813C
+#define GL_TEXTURE_MAX_LEVEL_SGIS         0x813D
+#endif
+
+#ifndef GL_SGIS_multisample
+#define GL_MULTISAMPLE_SGIS               0x809D
+#define GL_SAMPLE_ALPHA_TO_MASK_SGIS      0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_SGIS       0x809F
+#define GL_SAMPLE_MASK_SGIS               0x80A0
+#define GL_1PASS_SGIS                     0x80A1
+#define GL_2PASS_0_SGIS                   0x80A2
+#define GL_2PASS_1_SGIS                   0x80A3
+#define GL_4PASS_0_SGIS                   0x80A4
+#define GL_4PASS_1_SGIS                   0x80A5
+#define GL_4PASS_2_SGIS                   0x80A6
+#define GL_4PASS_3_SGIS                   0x80A7
+#define GL_SAMPLE_BUFFERS_SGIS            0x80A8
+#define GL_SAMPLES_SGIS                   0x80A9
+#define GL_SAMPLE_MASK_VALUE_SGIS         0x80AA
+#define GL_SAMPLE_MASK_INVERT_SGIS        0x80AB
+#define GL_SAMPLE_PATTERN_SGIS            0x80AC
+#endif
+
+#ifndef GL_EXT_rescale_normal
+#define GL_RESCALE_NORMAL_EXT             0x803A
+#endif
+
+#ifndef GL_EXT_vertex_array
+#define GL_VERTEX_ARRAY_EXT               0x8074
+#define GL_NORMAL_ARRAY_EXT               0x8075
+#define GL_COLOR_ARRAY_EXT                0x8076
+#define GL_INDEX_ARRAY_EXT                0x8077
+#define GL_TEXTURE_COORD_ARRAY_EXT        0x8078
+#define GL_EDGE_FLAG_ARRAY_EXT            0x8079
+#define GL_VERTEX_ARRAY_SIZE_EXT          0x807A
+#define GL_VERTEX_ARRAY_TYPE_EXT          0x807B
+#define GL_VERTEX_ARRAY_STRIDE_EXT        0x807C
+#define GL_VERTEX_ARRAY_COUNT_EXT         0x807D
+#define GL_NORMAL_ARRAY_TYPE_EXT          0x807E
+#define GL_NORMAL_ARRAY_STRIDE_EXT        0x807F
+#define GL_NORMAL_ARRAY_COUNT_EXT         0x8080
+#define GL_COLOR_ARRAY_SIZE_EXT           0x8081
+#define GL_COLOR_ARRAY_TYPE_EXT           0x8082
+#define GL_COLOR_ARRAY_STRIDE_EXT         0x8083
+#define GL_COLOR_ARRAY_COUNT_EXT          0x8084
+#define GL_INDEX_ARRAY_TYPE_EXT           0x8085
+#define GL_INDEX_ARRAY_STRIDE_EXT         0x8086
+#define GL_INDEX_ARRAY_COUNT_EXT          0x8087
+#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
+#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
+#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
+#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
+#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
+#define GL_EDGE_FLAG_ARRAY_COUNT_EXT      0x808D
+#define GL_VERTEX_ARRAY_POINTER_EXT       0x808E
+#define GL_NORMAL_ARRAY_POINTER_EXT       0x808F
+#define GL_COLOR_ARRAY_POINTER_EXT        0x8090
+#define GL_INDEX_ARRAY_POINTER_EXT        0x8091
+#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
+#define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
+#endif
+
+#ifndef GL_EXT_misc_attribute
+#endif
+
+#ifndef GL_SGIS_generate_mipmap
+#define GL_GENERATE_MIPMAP_SGIS           0x8191
+#define GL_GENERATE_MIPMAP_HINT_SGIS      0x8192
+#endif
+
+#ifndef GL_SGIX_clipmap
+#define GL_LINEAR_CLIPMAP_LINEAR_SGIX     0x8170
+#define GL_TEXTURE_CLIPMAP_CENTER_SGIX    0x8171
+#define GL_TEXTURE_CLIPMAP_FRAME_SGIX     0x8172
+#define GL_TEXTURE_CLIPMAP_OFFSET_SGIX    0x8173
+#define GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX 0x8174
+#define GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX 0x8175
+#define GL_TEXTURE_CLIPMAP_DEPTH_SGIX     0x8176
+#define GL_MAX_CLIPMAP_DEPTH_SGIX         0x8177
+#define GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX 0x8178
+#define GL_NEAREST_CLIPMAP_NEAREST_SGIX   0x844D
+#define GL_NEAREST_CLIPMAP_LINEAR_SGIX    0x844E
+#define GL_LINEAR_CLIPMAP_NEAREST_SGIX    0x844F
+#endif
+
+#ifndef GL_SGIX_shadow
+#define GL_TEXTURE_COMPARE_SGIX           0x819A
+#define GL_TEXTURE_COMPARE_OPERATOR_SGIX  0x819B
+#define GL_TEXTURE_LEQUAL_R_SGIX          0x819C
+#define GL_TEXTURE_GEQUAL_R_SGIX          0x819D
+#endif
+
+#ifndef GL_SGIS_texture_edge_clamp
+#define GL_CLAMP_TO_EDGE_SGIS             0x812F
+#endif
+
+#ifndef GL_SGIS_texture_border_clamp
+#define GL_CLAMP_TO_BORDER_SGIS           0x812D
+#endif
+
+#ifndef GL_EXT_blend_minmax
+#define GL_FUNC_ADD_EXT                   0x8006
+#define GL_MIN_EXT                        0x8007
+#define GL_MAX_EXT                        0x8008
+#define GL_BLEND_EQUATION_EXT             0x8009
+#endif
+
+#ifndef GL_EXT_blend_subtract
+#define GL_FUNC_SUBTRACT_EXT              0x800A
+#define GL_FUNC_REVERSE_SUBTRACT_EXT      0x800B
+#endif
+
+#ifndef GL_EXT_blend_logic_op
+#endif
+
+#ifndef GL_SGIX_interlace
+#define GL_INTERLACE_SGIX                 0x8094
+#endif
+
+#ifndef GL_SGIX_pixel_tiles
+#define GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX 0x813E
+#define GL_PIXEL_TILE_CACHE_INCREMENT_SGIX 0x813F
+#define GL_PIXEL_TILE_WIDTH_SGIX          0x8140
+#define GL_PIXEL_TILE_HEIGHT_SGIX         0x8141
+#define GL_PIXEL_TILE_GRID_WIDTH_SGIX     0x8142
+#define GL_PIXEL_TILE_GRID_HEIGHT_SGIX    0x8143
+#define GL_PIXEL_TILE_GRID_DEPTH_SGIX     0x8144
+#define GL_PIXEL_TILE_CACHE_SIZE_SGIX     0x8145
+#endif
+
+#ifndef GL_SGIS_texture_select
+#define GL_DUAL_ALPHA4_SGIS               0x8110
+#define GL_DUAL_ALPHA8_SGIS               0x8111
+#define GL_DUAL_ALPHA12_SGIS              0x8112
+#define GL_DUAL_ALPHA16_SGIS              0x8113
+#define GL_DUAL_LUMINANCE4_SGIS           0x8114
+#define GL_DUAL_LUMINANCE8_SGIS           0x8115
+#define GL_DUAL_LUMINANCE12_SGIS          0x8116
+#define GL_DUAL_LUMINANCE16_SGIS          0x8117
+#define GL_DUAL_INTENSITY4_SGIS           0x8118
+#define GL_DUAL_INTENSITY8_SGIS           0x8119
+#define GL_DUAL_INTENSITY12_SGIS          0x811A
+#define GL_DUAL_INTENSITY16_SGIS          0x811B
+#define GL_DUAL_LUMINANCE_ALPHA4_SGIS     0x811C
+#define GL_DUAL_LUMINANCE_ALPHA8_SGIS     0x811D
+#define GL_QUAD_ALPHA4_SGIS               0x811E
+#define GL_QUAD_ALPHA8_SGIS               0x811F
+#define GL_QUAD_LUMINANCE4_SGIS           0x8120
+#define GL_QUAD_LUMINANCE8_SGIS           0x8121
+#define GL_QUAD_INTENSITY4_SGIS           0x8122
+#define GL_QUAD_INTENSITY8_SGIS           0x8123
+#define GL_DUAL_TEXTURE_SELECT_SGIS       0x8124
+#define GL_QUAD_TEXTURE_SELECT_SGIS       0x8125
+#endif
+
+#ifndef GL_SGIX_sprite
+#define GL_SPRITE_SGIX                    0x8148
+#define GL_SPRITE_MODE_SGIX               0x8149
+#define GL_SPRITE_AXIS_SGIX               0x814A
+#define GL_SPRITE_TRANSLATION_SGIX        0x814B
+#define GL_SPRITE_AXIAL_SGIX              0x814C
+#define GL_SPRITE_OBJECT_ALIGNED_SGIX     0x814D
+#define GL_SPRITE_EYE_ALIGNED_SGIX        0x814E
+#endif
+
+#ifndef GL_SGIX_texture_multi_buffer
+#define GL_TEXTURE_MULTI_BUFFER_HINT_SGIX 0x812E
+#endif
+
+#ifndef GL_EXT_point_parameters
+#define GL_POINT_SIZE_MIN_EXT             0x8126
+#define GL_POINT_SIZE_MAX_EXT             0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_EXT  0x8128
+#define GL_DISTANCE_ATTENUATION_EXT       0x8129
+#endif
+
+#ifndef GL_SGIS_point_parameters
+#define GL_POINT_SIZE_MIN_SGIS            0x8126
+#define GL_POINT_SIZE_MAX_SGIS            0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_SGIS 0x8128
+#define GL_DISTANCE_ATTENUATION_SGIS      0x8129
+#endif
+
+#ifndef GL_SGIX_instruments
+#define GL_INSTRUMENT_BUFFER_POINTER_SGIX 0x8180
+#define GL_INSTRUMENT_MEASUREMENTS_SGIX   0x8181
+#endif
+
+#ifndef GL_SGIX_texture_scale_bias
+#define GL_POST_TEXTURE_FILTER_BIAS_SGIX  0x8179
+#define GL_POST_TEXTURE_FILTER_SCALE_SGIX 0x817A
+#define GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX 0x817B
+#define GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX 0x817C
+#endif
+
+#ifndef GL_SGIX_framezoom
+#define GL_FRAMEZOOM_SGIX                 0x818B
+#define GL_FRAMEZOOM_FACTOR_SGIX          0x818C
+#define GL_MAX_FRAMEZOOM_FACTOR_SGIX      0x818D
+#endif
+
+#ifndef GL_SGIX_tag_sample_buffer
+#endif
+
+#ifndef GL_FfdMaskSGIX
+#define GL_TEXTURE_DEFORMATION_BIT_SGIX   0x00000001
+#define GL_GEOMETRY_DEFORMATION_BIT_SGIX  0x00000002
+#endif
+
+#ifndef GL_SGIX_polynomial_ffd
+#define GL_GEOMETRY_DEFORMATION_SGIX      0x8194
+#define GL_TEXTURE_DEFORMATION_SGIX       0x8195
+#define GL_DEFORMATIONS_MASK_SGIX         0x8196
+#define GL_MAX_DEFORMATION_ORDER_SGIX     0x8197
+#endif
+
+#ifndef GL_SGIX_reference_plane
+#define GL_REFERENCE_PLANE_SGIX           0x817D
+#define GL_REFERENCE_PLANE_EQUATION_SGIX  0x817E
+#endif
+
+#ifndef GL_SGIX_flush_raster
+#endif
+
+#ifndef GL_SGIX_depth_texture
+#define GL_DEPTH_COMPONENT16_SGIX         0x81A5
+#define GL_DEPTH_COMPONENT24_SGIX         0x81A6
+#define GL_DEPTH_COMPONENT32_SGIX         0x81A7
+#endif
+
+#ifndef GL_SGIS_fog_function
+#define GL_FOG_FUNC_SGIS                  0x812A
+#define GL_FOG_FUNC_POINTS_SGIS           0x812B
+#define GL_MAX_FOG_FUNC_POINTS_SGIS       0x812C
+#endif
+
+#ifndef GL_SGIX_fog_offset
+#define GL_FOG_OFFSET_SGIX                0x8198
+#define GL_FOG_OFFSET_VALUE_SGIX          0x8199
+#endif
+
+#ifndef GL_HP_image_transform
+#define GL_IMAGE_SCALE_X_HP               0x8155
+#define GL_IMAGE_SCALE_Y_HP               0x8156
+#define GL_IMAGE_TRANSLATE_X_HP           0x8157
+#define GL_IMAGE_TRANSLATE_Y_HP           0x8158
+#define GL_IMAGE_ROTATE_ANGLE_HP          0x8159
+#define GL_IMAGE_ROTATE_ORIGIN_X_HP       0x815A
+#define GL_IMAGE_ROTATE_ORIGIN_Y_HP       0x815B
+#define GL_IMAGE_MAG_FILTER_HP            0x815C
+#define GL_IMAGE_MIN_FILTER_HP            0x815D
+#define GL_IMAGE_CUBIC_WEIGHT_HP          0x815E
+#define GL_CUBIC_HP                       0x815F
+#define GL_AVERAGE_HP                     0x8160
+#define GL_IMAGE_TRANSFORM_2D_HP          0x8161
+#define GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP 0x8162
+#define GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP 0x8163
+#endif
+
+#ifndef GL_HP_convolution_border_modes
+#define GL_IGNORE_BORDER_HP               0x8150
+#define GL_CONSTANT_BORDER_HP             0x8151
+#define GL_REPLICATE_BORDER_HP            0x8153
+#define GL_CONVOLUTION_BORDER_COLOR_HP    0x8154
+#endif
+
+#ifndef GL_INGR_palette_buffer
+#endif
+
+#ifndef GL_SGIX_texture_add_env
+#define GL_TEXTURE_ENV_BIAS_SGIX          0x80BE
+#endif
+
+#ifndef GL_EXT_color_subtable
+#endif
+
+#ifndef GL_PGI_vertex_hints
+#define GL_VERTEX_DATA_HINT_PGI           0x1A22A
+#define GL_VERTEX_CONSISTENT_HINT_PGI     0x1A22B
+#define GL_MATERIAL_SIDE_HINT_PGI         0x1A22C
+#define GL_MAX_VERTEX_HINT_PGI            0x1A22D
+#define GL_COLOR3_BIT_PGI                 0x00010000
+#define GL_COLOR4_BIT_PGI                 0x00020000
+#define GL_EDGEFLAG_BIT_PGI               0x00040000
+#define GL_INDEX_BIT_PGI                  0x00080000
+#define GL_MAT_AMBIENT_BIT_PGI            0x00100000
+#define GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI 0x00200000
+#define GL_MAT_DIFFUSE_BIT_PGI            0x00400000
+#define GL_MAT_EMISSION_BIT_PGI           0x00800000
+#define GL_MAT_COLOR_INDEXES_BIT_PGI      0x01000000
+#define GL_MAT_SHININESS_BIT_PGI          0x02000000
+#define GL_MAT_SPECULAR_BIT_PGI           0x04000000
+#define GL_NORMAL_BIT_PGI                 0x08000000
+#define GL_TEXCOORD1_BIT_PGI              0x10000000
+#define GL_TEXCOORD2_BIT_PGI              0x20000000
+#define GL_TEXCOORD3_BIT_PGI              0x40000000
+#define GL_TEXCOORD4_BIT_PGI              0x80000000
+#define GL_VERTEX23_BIT_PGI               0x00000004
+#define GL_VERTEX4_BIT_PGI                0x00000008
+#endif
+
+#ifndef GL_PGI_misc_hints
+#define GL_PREFER_DOUBLEBUFFER_HINT_PGI   0x1A1F8
+#define GL_CONSERVE_MEMORY_HINT_PGI       0x1A1FD
+#define GL_RECLAIM_MEMORY_HINT_PGI        0x1A1FE
+#define GL_NATIVE_GRAPHICS_HANDLE_PGI     0x1A202
+#define GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI 0x1A203
+#define GL_NATIVE_GRAPHICS_END_HINT_PGI   0x1A204
+#define GL_ALWAYS_FAST_HINT_PGI           0x1A20C
+#define GL_ALWAYS_SOFT_HINT_PGI           0x1A20D
+#define GL_ALLOW_DRAW_OBJ_HINT_PGI        0x1A20E
+#define GL_ALLOW_DRAW_WIN_HINT_PGI        0x1A20F
+#define GL_ALLOW_DRAW_FRG_HINT_PGI        0x1A210
+#define GL_ALLOW_DRAW_MEM_HINT_PGI        0x1A211
+#define GL_STRICT_DEPTHFUNC_HINT_PGI      0x1A216
+#define GL_STRICT_LIGHTING_HINT_PGI       0x1A217
+#define GL_STRICT_SCISSOR_HINT_PGI        0x1A218
+#define GL_FULL_STIPPLE_HINT_PGI          0x1A219
+#define GL_CLIP_NEAR_HINT_PGI             0x1A220
+#define GL_CLIP_FAR_HINT_PGI              0x1A221
+#define GL_WIDE_LINE_HINT_PGI             0x1A222
+#define GL_BACK_NORMALS_HINT_PGI          0x1A223
+#endif
+
+#ifndef GL_EXT_paletted_texture
+#define GL_COLOR_INDEX1_EXT               0x80E2
+#define GL_COLOR_INDEX2_EXT               0x80E3
+#define GL_COLOR_INDEX4_EXT               0x80E4
+#define GL_COLOR_INDEX8_EXT               0x80E5
+#define GL_COLOR_INDEX12_EXT              0x80E6
+#define GL_COLOR_INDEX16_EXT              0x80E7
+#define GL_TEXTURE_INDEX_SIZE_EXT         0x80ED
+#endif
+
+#ifndef GL_EXT_clip_volume_hint
+#define GL_CLIP_VOLUME_CLIPPING_HINT_EXT  0x80F0
+#endif
+
+#ifndef GL_SGIX_list_priority
+#define GL_LIST_PRIORITY_SGIX             0x8182
+#endif
+
+#ifndef GL_SGIX_ir_instrument1
+#define GL_IR_INSTRUMENT1_SGIX            0x817F
+#endif
+
+#ifndef GL_SGIX_calligraphic_fragment
+#define GL_CALLIGRAPHIC_FRAGMENT_SGIX     0x8183
+#endif
+
+#ifndef GL_SGIX_texture_lod_bias
+#define GL_TEXTURE_LOD_BIAS_S_SGIX        0x818E
+#define GL_TEXTURE_LOD_BIAS_T_SGIX        0x818F
+#define GL_TEXTURE_LOD_BIAS_R_SGIX        0x8190
+#endif
+
+#ifndef GL_SGIX_shadow_ambient
+#define GL_SHADOW_AMBIENT_SGIX            0x80BF
+#endif
+
+#ifndef GL_EXT_index_texture
+#endif
+
+#ifndef GL_EXT_index_material
+#define GL_INDEX_MATERIAL_EXT             0x81B8
+#define GL_INDEX_MATERIAL_PARAMETER_EXT   0x81B9
+#define GL_INDEX_MATERIAL_FACE_EXT        0x81BA
+#endif
+
+#ifndef GL_EXT_index_func
+#define GL_INDEX_TEST_EXT                 0x81B5
+#define GL_INDEX_TEST_FUNC_EXT            0x81B6
+#define GL_INDEX_TEST_REF_EXT             0x81B7
+#endif
+
+#ifndef GL_EXT_index_array_formats
+#define GL_IUI_V2F_EXT                    0x81AD
+#define GL_IUI_V3F_EXT                    0x81AE
+#define GL_IUI_N3F_V2F_EXT                0x81AF
+#define GL_IUI_N3F_V3F_EXT                0x81B0
+#define GL_T2F_IUI_V2F_EXT                0x81B1
+#define GL_T2F_IUI_V3F_EXT                0x81B2
+#define GL_T2F_IUI_N3F_V2F_EXT            0x81B3
+#define GL_T2F_IUI_N3F_V3F_EXT            0x81B4
+#endif
+
+#ifndef GL_EXT_compiled_vertex_array
+#define GL_ARRAY_ELEMENT_LOCK_FIRST_EXT   0x81A8
+#define GL_ARRAY_ELEMENT_LOCK_COUNT_EXT   0x81A9
+#endif
+
+#ifndef GL_EXT_cull_vertex
+#define GL_CULL_VERTEX_EXT                0x81AA
+#define GL_CULL_VERTEX_EYE_POSITION_EXT   0x81AB
+#define GL_CULL_VERTEX_OBJECT_POSITION_EXT 0x81AC
+#endif
+
+#ifndef GL_SGIX_ycrcb
+#define GL_YCRCB_422_SGIX                 0x81BB
+#define GL_YCRCB_444_SGIX                 0x81BC
+#endif
+
+#ifndef GL_SGIX_fragment_lighting
+#define GL_FRAGMENT_LIGHTING_SGIX         0x8400
+#define GL_FRAGMENT_COLOR_MATERIAL_SGIX   0x8401
+#define GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX 0x8402
+#define GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX 0x8403
+#define GL_MAX_FRAGMENT_LIGHTS_SGIX       0x8404
+#define GL_MAX_ACTIVE_LIGHTS_SGIX         0x8405
+#define GL_CURRENT_RASTER_NORMAL_SGIX     0x8406
+#define GL_LIGHT_ENV_MODE_SGIX            0x8407
+#define GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX 0x8408
+#define GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX 0x8409
+#define GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX 0x840A
+#define GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX 0x840B
+#define GL_FRAGMENT_LIGHT0_SGIX           0x840C
+#define GL_FRAGMENT_LIGHT1_SGIX           0x840D
+#define GL_FRAGMENT_LIGHT2_SGIX           0x840E
+#define GL_FRAGMENT_LIGHT3_SGIX           0x840F
+#define GL_FRAGMENT_LIGHT4_SGIX           0x8410
+#define GL_FRAGMENT_LIGHT5_SGIX           0x8411
+#define GL_FRAGMENT_LIGHT6_SGIX           0x8412
+#define GL_FRAGMENT_LIGHT7_SGIX           0x8413
+#endif
+
+#ifndef GL_IBM_rasterpos_clip
+#define GL_RASTER_POSITION_UNCLIPPED_IBM  0x19262
+#endif
+
+#ifndef GL_HP_texture_lighting
+#define GL_TEXTURE_LIGHTING_MODE_HP       0x8167
+#define GL_TEXTURE_POST_SPECULAR_HP       0x8168
+#define GL_TEXTURE_PRE_SPECULAR_HP        0x8169
+#endif
+
+#ifndef GL_EXT_draw_range_elements
+#define GL_MAX_ELEMENTS_VERTICES_EXT      0x80E8
+#define GL_MAX_ELEMENTS_INDICES_EXT       0x80E9
+#endif
+
+#ifndef GL_WIN_phong_shading
+#define GL_PHONG_WIN                      0x80EA
+#define GL_PHONG_HINT_WIN                 0x80EB
+#endif
+
+#ifndef GL_WIN_specular_fog
+#define GL_FOG_SPECULAR_TEXTURE_WIN       0x80EC
+#endif
+
+#ifndef GL_EXT_light_texture
+#define GL_FRAGMENT_MATERIAL_EXT          0x8349
+#define GL_FRAGMENT_NORMAL_EXT            0x834A
+#define GL_FRAGMENT_COLOR_EXT             0x834C
+#define GL_ATTENUATION_EXT                0x834D
+#define GL_SHADOW_ATTENUATION_EXT         0x834E
+#define GL_TEXTURE_APPLICATION_MODE_EXT   0x834F
+#define GL_TEXTURE_LIGHT_EXT              0x8350
+#define GL_TEXTURE_MATERIAL_FACE_EXT      0x8351
+#define GL_TEXTURE_MATERIAL_PARAMETER_EXT 0x8352
+    /* reuse GL_FRAGMENT_DEPTH_EXT */
+#endif
+
+#ifndef GL_SGIX_blend_alpha_minmax
+#define GL_ALPHA_MIN_SGIX                 0x8320
+#define GL_ALPHA_MAX_SGIX                 0x8321
+#endif
+
+#ifndef GL_SGIX_impact_pixel_texture
+#define GL_PIXEL_TEX_GEN_Q_CEILING_SGIX   0x8184
+#define GL_PIXEL_TEX_GEN_Q_ROUND_SGIX     0x8185
+#define GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX     0x8186
+#define GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX 0x8187
+#define GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX 0x8188
+#define GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX    0x8189
+#define GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX    0x818A
+#endif
+
+#ifndef GL_EXT_bgra
+#define GL_BGR_EXT                        0x80E0
+#define GL_BGRA_EXT                       0x80E1
+#endif
+
+#ifndef GL_SGIX_async
+#define GL_ASYNC_MARKER_SGIX              0x8329
+#endif
+
+#ifndef GL_SGIX_async_pixel
+#define GL_ASYNC_TEX_IMAGE_SGIX           0x835C
+#define GL_ASYNC_DRAW_PIXELS_SGIX         0x835D
+#define GL_ASYNC_READ_PIXELS_SGIX         0x835E
+#define GL_MAX_ASYNC_TEX_IMAGE_SGIX       0x835F
+#define GL_MAX_ASYNC_DRAW_PIXELS_SGIX     0x8360
+#define GL_MAX_ASYNC_READ_PIXELS_SGIX     0x8361
+#endif
+
+#ifndef GL_SGIX_async_histogram
+#define GL_ASYNC_HISTOGRAM_SGIX           0x832C
+#define GL_MAX_ASYNC_HISTOGRAM_SGIX       0x832D
+#endif
+
+#ifndef GL_INTEL_texture_scissor
+#endif
+
+#ifndef GL_INTEL_parallel_arrays
+#define GL_PARALLEL_ARRAYS_INTEL          0x83F4
+#define GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL 0x83F5
+#define GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL 0x83F6
+#define GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL 0x83F7
+#define GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL 0x83F8
+#endif
+
+#ifndef GL_HP_occlusion_test
+#define GL_OCCLUSION_TEST_HP              0x8165
+#define GL_OCCLUSION_TEST_RESULT_HP       0x8166
+#endif
+
+#ifndef GL_EXT_pixel_transform
+#define GL_PIXEL_TRANSFORM_2D_EXT         0x8330
+#define GL_PIXEL_MAG_FILTER_EXT           0x8331
+#define GL_PIXEL_MIN_FILTER_EXT           0x8332
+#define GL_PIXEL_CUBIC_WEIGHT_EXT         0x8333
+#define GL_CUBIC_EXT                      0x8334
+#define GL_AVERAGE_EXT                    0x8335
+#define GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8336
+#define GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8337
+#define GL_PIXEL_TRANSFORM_2D_MATRIX_EXT  0x8338
+#endif
+
+#ifndef GL_EXT_pixel_transform_color_table
+#endif
+
+#ifndef GL_EXT_shared_texture_palette
+#define GL_SHARED_TEXTURE_PALETTE_EXT     0x81FB
+#endif
+
+#ifndef GL_EXT_separate_specular_color
+#define GL_LIGHT_MODEL_COLOR_CONTROL_EXT  0x81F8
+#define GL_SINGLE_COLOR_EXT               0x81F9
+#define GL_SEPARATE_SPECULAR_COLOR_EXT    0x81FA
+#endif
+
+#ifndef GL_EXT_secondary_color
+#define GL_COLOR_SUM_EXT                  0x8458
+#define GL_CURRENT_SECONDARY_COLOR_EXT    0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT 0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT 0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT 0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT 0x845D
+#define GL_SECONDARY_COLOR_ARRAY_EXT      0x845E
+#endif
+
+#ifndef GL_EXT_texture_perturb_normal
+#define GL_PERTURB_EXT                    0x85AE
+#define GL_TEXTURE_NORMAL_EXT             0x85AF
+#endif
+
+#ifndef GL_EXT_multi_draw_arrays
+#endif
+
+#ifndef GL_EXT_fog_coord
+#define GL_FOG_COORDINATE_SOURCE_EXT      0x8450
+#define GL_FOG_COORDINATE_EXT             0x8451
+#define GL_FRAGMENT_DEPTH_EXT             0x8452
+#define GL_CURRENT_FOG_COORDINATE_EXT     0x8453
+#define GL_FOG_COORDINATE_ARRAY_TYPE_EXT  0x8454
+#define GL_FOG_COORDINATE_ARRAY_STRIDE_EXT 0x8455
+#define GL_FOG_COORDINATE_ARRAY_POINTER_EXT 0x8456
+#define GL_FOG_COORDINATE_ARRAY_EXT       0x8457
+#endif
+
+#ifndef GL_REND_screen_coordinates
+#define GL_SCREEN_COORDINATES_REND        0x8490
+#define GL_INVERTED_SCREEN_W_REND         0x8491
+#endif
+
+#ifndef GL_EXT_coordinate_frame
+#define GL_TANGENT_ARRAY_EXT              0x8439
+#define GL_BINORMAL_ARRAY_EXT             0x843A
+#define GL_CURRENT_TANGENT_EXT            0x843B
+#define GL_CURRENT_BINORMAL_EXT           0x843C
+#define GL_TANGENT_ARRAY_TYPE_EXT         0x843E
+#define GL_TANGENT_ARRAY_STRIDE_EXT       0x843F
+#define GL_BINORMAL_ARRAY_TYPE_EXT        0x8440
+#define GL_BINORMAL_ARRAY_STRIDE_EXT      0x8441
+#define GL_TANGENT_ARRAY_POINTER_EXT      0x8442
+#define GL_BINORMAL_ARRAY_POINTER_EXT     0x8443
+#define GL_MAP1_TANGENT_EXT               0x8444
+#define GL_MAP2_TANGENT_EXT               0x8445
+#define GL_MAP1_BINORMAL_EXT              0x8446
+#define GL_MAP2_BINORMAL_EXT              0x8447
+#endif
+
+#ifndef GL_EXT_texture_env_combine
+#define GL_COMBINE_EXT                    0x8570
+#define GL_COMBINE_RGB_EXT                0x8571
+#define GL_COMBINE_ALPHA_EXT              0x8572
+#define GL_RGB_SCALE_EXT                  0x8573
+#define GL_ADD_SIGNED_EXT                 0x8574
+#define GL_INTERPOLATE_EXT                0x8575
+#define GL_CONSTANT_EXT                   0x8576
+#define GL_PRIMARY_COLOR_EXT              0x8577
+#define GL_PREVIOUS_EXT                   0x8578
+#define GL_SOURCE0_RGB_EXT                0x8580
+#define GL_SOURCE1_RGB_EXT                0x8581
+#define GL_SOURCE2_RGB_EXT                0x8582
+#define GL_SOURCE0_ALPHA_EXT              0x8588
+#define GL_SOURCE1_ALPHA_EXT              0x8589
+#define GL_SOURCE2_ALPHA_EXT              0x858A
+#define GL_OPERAND0_RGB_EXT               0x8590
+#define GL_OPERAND1_RGB_EXT               0x8591
+#define GL_OPERAND2_RGB_EXT               0x8592
+#define GL_OPERAND0_ALPHA_EXT             0x8598
+#define GL_OPERAND1_ALPHA_EXT             0x8599
+#define GL_OPERAND2_ALPHA_EXT             0x859A
+#endif
+
+#ifndef GL_APPLE_specular_vector
+#define GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE 0x85B0
+#endif
+
+#ifndef GL_APPLE_transform_hint
+#define GL_TRANSFORM_HINT_APPLE           0x85B1
+#endif
+
+#ifndef GL_SGIX_fog_scale
+#define GL_FOG_SCALE_SGIX                 0x81FC
+#define GL_FOG_SCALE_VALUE_SGIX           0x81FD
+#endif
+
+#ifndef GL_SUNX_constant_data
+#define GL_UNPACK_CONSTANT_DATA_SUNX      0x81D5
+#define GL_TEXTURE_CONSTANT_DATA_SUNX     0x81D6
+#endif
+
+#ifndef GL_SUN_global_alpha
+#define GL_GLOBAL_ALPHA_SUN               0x81D9
+#define GL_GLOBAL_ALPHA_FACTOR_SUN        0x81DA
+#endif
+
+#ifndef GL_SUN_triangle_list
+#define GL_RESTART_SUN                    0x0001
+#define GL_REPLACE_MIDDLE_SUN             0x0002
+#define GL_REPLACE_OLDEST_SUN             0x0003
+#define GL_TRIANGLE_LIST_SUN              0x81D7
+#define GL_REPLACEMENT_CODE_SUN           0x81D8
+#define GL_REPLACEMENT_CODE_ARRAY_SUN     0x85C0
+#define GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN 0x85C1
+#define GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN 0x85C2
+#define GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN 0x85C3
+#define GL_R1UI_V3F_SUN                   0x85C4
+#define GL_R1UI_C4UB_V3F_SUN              0x85C5
+#define GL_R1UI_C3F_V3F_SUN               0x85C6
+#define GL_R1UI_N3F_V3F_SUN               0x85C7
+#define GL_R1UI_C4F_N3F_V3F_SUN           0x85C8
+#define GL_R1UI_T2F_V3F_SUN               0x85C9
+#define GL_R1UI_T2F_N3F_V3F_SUN           0x85CA
+#define GL_R1UI_T2F_C4F_N3F_V3F_SUN       0x85CB
+#endif
+
+#ifndef GL_SUN_vertex
+#endif
+
+#ifndef GL_EXT_blend_func_separate
+#define GL_BLEND_DST_RGB_EXT              0x80C8
+#define GL_BLEND_SRC_RGB_EXT              0x80C9
+#define GL_BLEND_DST_ALPHA_EXT            0x80CA
+#define GL_BLEND_SRC_ALPHA_EXT            0x80CB
+#endif
+
+#ifndef GL_INGR_color_clamp
+#define GL_RED_MIN_CLAMP_INGR             0x8560
+#define GL_GREEN_MIN_CLAMP_INGR           0x8561
+#define GL_BLUE_MIN_CLAMP_INGR            0x8562
+#define GL_ALPHA_MIN_CLAMP_INGR           0x8563
+#define GL_RED_MAX_CLAMP_INGR             0x8564
+#define GL_GREEN_MAX_CLAMP_INGR           0x8565
+#define GL_BLUE_MAX_CLAMP_INGR            0x8566
+#define GL_ALPHA_MAX_CLAMP_INGR           0x8567
+#endif
+
+#ifndef GL_INGR_interlace_read
+#define GL_INTERLACE_READ_INGR            0x8568
+#endif
+
+#ifndef GL_EXT_stencil_wrap
+#define GL_INCR_WRAP_EXT                  0x8507
+#define GL_DECR_WRAP_EXT                  0x8508
+#endif
+
+#ifndef GL_EXT_422_pixels
+#define GL_422_EXT                        0x80CC
+#define GL_422_REV_EXT                    0x80CD
+#define GL_422_AVERAGE_EXT                0x80CE
+#define GL_422_REV_AVERAGE_EXT            0x80CF
+#endif
+
+#ifndef GL_NV_texgen_reflection
+#define GL_NORMAL_MAP_NV                  0x8511
+#define GL_REFLECTION_MAP_NV              0x8512
+#endif
+
+#ifndef GL_EXT_texture_cube_map
+#define GL_NORMAL_MAP_EXT                 0x8511
+#define GL_REFLECTION_MAP_EXT             0x8512
+#define GL_TEXTURE_CUBE_MAP_EXT           0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_EXT   0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP_EXT     0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT  0x851C
+#endif
+
+#ifndef GL_SUN_convolution_border_modes
+#define GL_WRAP_BORDER_SUN                0x81D4
+#endif
+
+#ifndef GL_EXT_texture_env_add
+#endif
+
+#ifndef GL_EXT_texture_lod_bias
+#define GL_MAX_TEXTURE_LOD_BIAS_EXT       0x84FD
+#define GL_TEXTURE_FILTER_CONTROL_EXT     0x8500
+#define GL_TEXTURE_LOD_BIAS_EXT           0x8501
+#endif
+
+#ifndef GL_EXT_texture_filter_anisotropic
+#define GL_TEXTURE_MAX_ANISOTROPY_EXT     0x84FE
+#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
+#endif
+
+#ifndef GL_EXT_vertex_weighting
+#define GL_MODELVIEW0_STACK_DEPTH_EXT     GL_MODELVIEW_STACK_DEPTH
+#define GL_MODELVIEW1_STACK_DEPTH_EXT     0x8502
+#define GL_MODELVIEW0_MATRIX_EXT          GL_MODELVIEW_MATRIX
+#define GL_MODELVIEW1_MATRIX_EXT          0x8506
+#define GL_VERTEX_WEIGHTING_EXT           0x8509
+#define GL_MODELVIEW0_EXT                 GL_MODELVIEW
+#define GL_MODELVIEW1_EXT                 0x850A
+#define GL_CURRENT_VERTEX_WEIGHT_EXT      0x850B
+#define GL_VERTEX_WEIGHT_ARRAY_EXT        0x850C
+#define GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT   0x850D
+#define GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT   0x850E
+#define GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT 0x850F
+#define GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT 0x8510
+#endif
+
+#ifndef GL_NV_light_max_exponent
+#define GL_MAX_SHININESS_NV               0x8504
+#define GL_MAX_SPOT_EXPONENT_NV           0x8505
+#endif
+
+#ifndef GL_NV_vertex_array_range
+#define GL_VERTEX_ARRAY_RANGE_NV          0x851D
+#define GL_VERTEX_ARRAY_RANGE_LENGTH_NV   0x851E
+#define GL_VERTEX_ARRAY_RANGE_VALID_NV    0x851F
+#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV 0x8520
+#define GL_VERTEX_ARRAY_RANGE_POINTER_NV  0x8521
+#endif
+
+#ifndef GL_NV_register_combiners
+#define GL_REGISTER_COMBINERS_NV          0x8522
+#define GL_VARIABLE_A_NV                  0x8523
+#define GL_VARIABLE_B_NV                  0x8524
+#define GL_VARIABLE_C_NV                  0x8525
+#define GL_VARIABLE_D_NV                  0x8526
+#define GL_VARIABLE_E_NV                  0x8527
+#define GL_VARIABLE_F_NV                  0x8528
+#define GL_VARIABLE_G_NV                  0x8529
+#define GL_CONSTANT_COLOR0_NV             0x852A
+#define GL_CONSTANT_COLOR1_NV             0x852B
+#define GL_PRIMARY_COLOR_NV               0x852C
+#define GL_SECONDARY_COLOR_NV             0x852D
+#define GL_SPARE0_NV                      0x852E
+#define GL_SPARE1_NV                      0x852F
+#define GL_DISCARD_NV                     0x8530
+#define GL_E_TIMES_F_NV                   0x8531
+#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV 0x8532
+#define GL_UNSIGNED_IDENTITY_NV           0x8536
+#define GL_UNSIGNED_INVERT_NV             0x8537
+#define GL_EXPAND_NORMAL_NV               0x8538
+#define GL_EXPAND_NEGATE_NV               0x8539
+#define GL_HALF_BIAS_NORMAL_NV            0x853A
+#define GL_HALF_BIAS_NEGATE_NV            0x853B
+#define GL_SIGNED_IDENTITY_NV             0x853C
+#define GL_SIGNED_NEGATE_NV               0x853D
+#define GL_SCALE_BY_TWO_NV                0x853E
+#define GL_SCALE_BY_FOUR_NV               0x853F
+#define GL_SCALE_BY_ONE_HALF_NV           0x8540
+#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV   0x8541
+#define GL_COMBINER_INPUT_NV              0x8542
+#define GL_COMBINER_MAPPING_NV            0x8543
+#define GL_COMBINER_COMPONENT_USAGE_NV    0x8544
+#define GL_COMBINER_AB_DOT_PRODUCT_NV     0x8545
+#define GL_COMBINER_CD_DOT_PRODUCT_NV     0x8546
+#define GL_COMBINER_MUX_SUM_NV            0x8547
+#define GL_COMBINER_SCALE_NV              0x8548
+#define GL_COMBINER_BIAS_NV               0x8549
+#define GL_COMBINER_AB_OUTPUT_NV          0x854A
+#define GL_COMBINER_CD_OUTPUT_NV          0x854B
+#define GL_COMBINER_SUM_OUTPUT_NV         0x854C
+#define GL_MAX_GENERAL_COMBINERS_NV       0x854D
+#define GL_NUM_GENERAL_COMBINERS_NV       0x854E
+#define GL_COLOR_SUM_CLAMP_NV             0x854F
+#define GL_COMBINER0_NV                   0x8550
+#define GL_COMBINER1_NV                   0x8551
+#define GL_COMBINER2_NV                   0x8552
+#define GL_COMBINER3_NV                   0x8553
+#define GL_COMBINER4_NV                   0x8554
+#define GL_COMBINER5_NV                   0x8555
+#define GL_COMBINER6_NV                   0x8556
+#define GL_COMBINER7_NV                   0x8557
+    /* reuse GL_TEXTURE0_ARB */
+    /* reuse GL_TEXTURE1_ARB */
+    /* reuse GL_ZERO */
+    /* reuse GL_NONE */
+    /* reuse GL_FOG */
+#endif
+
+#ifndef GL_NV_fog_distance
+#define GL_FOG_DISTANCE_MODE_NV           0x855A
+#define GL_EYE_RADIAL_NV                  0x855B
+#define GL_EYE_PLANE_ABSOLUTE_NV          0x855C
+    /* reuse GL_EYE_PLANE */
+#endif
+
+#ifndef GL_NV_texgen_emboss
+#define GL_EMBOSS_LIGHT_NV                0x855D
+#define GL_EMBOSS_CONSTANT_NV             0x855E
+#define GL_EMBOSS_MAP_NV                  0x855F
+#endif
+
+#ifndef GL_NV_blend_square
+#endif
+
+#ifndef GL_NV_texture_env_combine4
+#define GL_COMBINE4_NV                    0x8503
+#define GL_SOURCE3_RGB_NV                 0x8583
+#define GL_SOURCE3_ALPHA_NV               0x858B
+#define GL_OPERAND3_RGB_NV                0x8593
+#define GL_OPERAND3_ALPHA_NV              0x859B
+#endif
+
+#ifndef GL_MESA_resize_buffers
+#endif
+
+#ifndef GL_MESA_window_pos
+#endif
+
+#ifndef GL_EXT_texture_compression_s3tc
+#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT   0x83F0
+#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT  0x83F1
+#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT  0x83F2
+#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT  0x83F3
+#endif
+
+#ifndef GL_IBM_cull_vertex
+#define GL_CULL_VERTEX_IBM                103050
+#endif
+
+#ifndef GL_IBM_multimode_draw_arrays
+#endif
+
+#ifndef GL_IBM_vertex_array_lists
+#define GL_VERTEX_ARRAY_LIST_IBM          103070
+#define GL_NORMAL_ARRAY_LIST_IBM          103071
+#define GL_COLOR_ARRAY_LIST_IBM           103072
+#define GL_INDEX_ARRAY_LIST_IBM           103073
+#define GL_TEXTURE_COORD_ARRAY_LIST_IBM   103074
+#define GL_EDGE_FLAG_ARRAY_LIST_IBM       103075
+#define GL_FOG_COORDINATE_ARRAY_LIST_IBM  103076
+#define GL_SECONDARY_COLOR_ARRAY_LIST_IBM 103077
+#define GL_VERTEX_ARRAY_LIST_STRIDE_IBM   103080
+#define GL_NORMAL_ARRAY_LIST_STRIDE_IBM   103081
+#define GL_COLOR_ARRAY_LIST_STRIDE_IBM    103082
+#define GL_INDEX_ARRAY_LIST_STRIDE_IBM    103083
+#define GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM 103084
+#define GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM 103085
+#define GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM 103086
+#define GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM 103087
+#endif
+
+#ifndef GL_SGIX_subsample
+#define GL_PACK_SUBSAMPLE_RATE_SGIX       0x85A0
+#define GL_UNPACK_SUBSAMPLE_RATE_SGIX     0x85A1
+#define GL_PIXEL_SUBSAMPLE_4444_SGIX      0x85A2
+#define GL_PIXEL_SUBSAMPLE_2424_SGIX      0x85A3
+#define GL_PIXEL_SUBSAMPLE_4242_SGIX      0x85A4
+#endif
+
+#ifndef GL_SGIX_ycrcb_subsample
+#endif
+
+#ifndef GL_SGIX_ycrcba
+#define GL_YCRCB_SGIX                     0x8318
+#define GL_YCRCBA_SGIX                    0x8319
+#endif
+
+#ifndef GL_SGI_depth_pass_instrument
+#define GL_DEPTH_PASS_INSTRUMENT_SGIX     0x8310
+#define GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX 0x8311
+#define GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX 0x8312
+#endif
+
+#ifndef GL_3DFX_texture_compression_FXT1
+#define GL_COMPRESSED_RGB_FXT1_3DFX       0x86B0
+#define GL_COMPRESSED_RGBA_FXT1_3DFX      0x86B1
+#endif
+
+#ifndef GL_3DFX_multisample
+#define GL_MULTISAMPLE_3DFX               0x86B2
+#define GL_SAMPLE_BUFFERS_3DFX            0x86B3
+#define GL_SAMPLES_3DFX                   0x86B4
+#define GL_MULTISAMPLE_BIT_3DFX           0x20000000
+#endif
+
+#ifndef GL_3DFX_tbuffer
+#endif
+
+#ifndef GL_EXT_multisample
+#define GL_MULTISAMPLE_EXT                0x809D
+#define GL_SAMPLE_ALPHA_TO_MASK_EXT       0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_EXT        0x809F
+#define GL_SAMPLE_MASK_EXT                0x80A0
+#define GL_1PASS_EXT                      0x80A1
+#define GL_2PASS_0_EXT                    0x80A2
+#define GL_2PASS_1_EXT                    0x80A3
+#define GL_4PASS_0_EXT                    0x80A4
+#define GL_4PASS_1_EXT                    0x80A5
+#define GL_4PASS_2_EXT                    0x80A6
+#define GL_4PASS_3_EXT                    0x80A7
+#define GL_SAMPLE_BUFFERS_EXT             0x80A8
+#define GL_SAMPLES_EXT                    0x80A9
+#define GL_SAMPLE_MASK_VALUE_EXT          0x80AA
+#define GL_SAMPLE_MASK_INVERT_EXT         0x80AB
+#define GL_SAMPLE_PATTERN_EXT             0x80AC
+#define GL_MULTISAMPLE_BIT_EXT            0x20000000
+#endif
+
+#ifndef GL_SGIX_vertex_preclip
+#define GL_VERTEX_PRECLIP_SGIX            0x83EE
+#define GL_VERTEX_PRECLIP_HINT_SGIX       0x83EF
+#endif
+
+#ifndef GL_SGIX_convolution_accuracy
+#define GL_CONVOLUTION_HINT_SGIX          0x8316
+#endif
+
+#ifndef GL_SGIX_resample
+#define GL_PACK_RESAMPLE_SGIX             0x842C
+#define GL_UNPACK_RESAMPLE_SGIX           0x842D
+#define GL_RESAMPLE_REPLICATE_SGIX        0x842E
+#define GL_RESAMPLE_ZERO_FILL_SGIX        0x842F
+#define GL_RESAMPLE_DECIMATE_SGIX         0x8430
+#endif
+
+#ifndef GL_SGIS_point_line_texgen
+#define GL_EYE_DISTANCE_TO_POINT_SGIS     0x81F0
+#define GL_OBJECT_DISTANCE_TO_POINT_SGIS  0x81F1
+#define GL_EYE_DISTANCE_TO_LINE_SGIS      0x81F2
+#define GL_OBJECT_DISTANCE_TO_LINE_SGIS   0x81F3
+#define GL_EYE_POINT_SGIS                 0x81F4
+#define GL_OBJECT_POINT_SGIS              0x81F5
+#define GL_EYE_LINE_SGIS                  0x81F6
+#define GL_OBJECT_LINE_SGIS               0x81F7
+#endif
+
+#ifndef GL_SGIS_texture_color_mask
+#define GL_TEXTURE_COLOR_WRITEMASK_SGIS   0x81EF
+#endif
+
+#ifndef GL_EXT_texture_env_dot3
+#define GL_DOT3_RGB_EXT                   0x8740
+#define GL_DOT3_RGBA_EXT                  0x8741
+#endif
+
+#ifndef GL_ATI_texture_mirror_once
+#define GL_MIRROR_CLAMP_ATI               0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_ATI       0x8743
+#endif
+
+#ifndef GL_NV_fence
+#define GL_ALL_COMPLETED_NV               0x84F2
+#define GL_FENCE_STATUS_NV                0x84F3
+#define GL_FENCE_CONDITION_NV             0x84F4
+#endif
+
+#ifndef GL_IBM_texture_mirrored_repeat
+#define GL_MIRRORED_REPEAT_IBM            0x8370
+#endif
+
+#ifndef GL_NV_evaluators
+#define GL_EVAL_2D_NV                     0x86C0
+#define GL_EVAL_TRIANGULAR_2D_NV          0x86C1
+#define GL_MAP_TESSELLATION_NV            0x86C2
+#define GL_MAP_ATTRIB_U_ORDER_NV          0x86C3
+#define GL_MAP_ATTRIB_V_ORDER_NV          0x86C4
+#define GL_EVAL_FRACTIONAL_TESSELLATION_NV 0x86C5
+#define GL_EVAL_VERTEX_ATTRIB0_NV         0x86C6
+#define GL_EVAL_VERTEX_ATTRIB1_NV         0x86C7
+#define GL_EVAL_VERTEX_ATTRIB2_NV         0x86C8
+#define GL_EVAL_VERTEX_ATTRIB3_NV         0x86C9
+#define GL_EVAL_VERTEX_ATTRIB4_NV         0x86CA
+#define GL_EVAL_VERTEX_ATTRIB5_NV         0x86CB
+#define GL_EVAL_VERTEX_ATTRIB6_NV         0x86CC
+#define GL_EVAL_VERTEX_ATTRIB7_NV         0x86CD
+#define GL_EVAL_VERTEX_ATTRIB8_NV         0x86CE
+#define GL_EVAL_VERTEX_ATTRIB9_NV         0x86CF
+#define GL_EVAL_VERTEX_ATTRIB10_NV        0x86D0
+#define GL_EVAL_VERTEX_ATTRIB11_NV        0x86D1
+#define GL_EVAL_VERTEX_ATTRIB12_NV        0x86D2
+#define GL_EVAL_VERTEX_ATTRIB13_NV        0x86D3
+#define GL_EVAL_VERTEX_ATTRIB14_NV        0x86D4
+#define GL_EVAL_VERTEX_ATTRIB15_NV        0x86D5
+#define GL_MAX_MAP_TESSELLATION_NV        0x86D6
+#define GL_MAX_RATIONAL_EVAL_ORDER_NV     0x86D7
+#endif
+
+#ifndef GL_NV_packed_depth_stencil
+#define GL_DEPTH_STENCIL_NV               0x84F9
+#define GL_UNSIGNED_INT_24_8_NV           0x84FA
+#endif
+
+#ifndef GL_NV_register_combiners2
+#define GL_PER_STAGE_CONSTANTS_NV         0x8535
+#endif
+
+#ifndef GL_NV_texture_compression_vtc
+#endif
+
+#ifndef GL_NV_texture_rectangle
+#define GL_TEXTURE_RECTANGLE_NV           0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE_NV   0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE_NV     0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE_NV  0x84F8
+#endif
+
+#ifndef GL_NV_texture_shader
+#define GL_OFFSET_TEXTURE_RECTANGLE_NV    0x864C
+#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV 0x864D
+#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV 0x864E
+#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV 0x86D9
+#define GL_UNSIGNED_INT_S8_S8_8_8_NV      0x86DA
+#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV  0x86DB
+#define GL_DSDT_MAG_INTENSITY_NV          0x86DC
+#define GL_SHADER_CONSISTENT_NV           0x86DD
+#define GL_TEXTURE_SHADER_NV              0x86DE
+#define GL_SHADER_OPERATION_NV            0x86DF
+#define GL_CULL_MODES_NV                  0x86E0
+#define GL_OFFSET_TEXTURE_MATRIX_NV       0x86E1
+#define GL_OFFSET_TEXTURE_SCALE_NV        0x86E2
+#define GL_OFFSET_TEXTURE_BIAS_NV         0x86E3
+#define GL_OFFSET_TEXTURE_2D_MATRIX_NV    GL_OFFSET_TEXTURE_MATRIX_NV
+#define GL_OFFSET_TEXTURE_2D_SCALE_NV     GL_OFFSET_TEXTURE_SCALE_NV
+#define GL_OFFSET_TEXTURE_2D_BIAS_NV      GL_OFFSET_TEXTURE_BIAS_NV
+#define GL_PREVIOUS_TEXTURE_INPUT_NV      0x86E4
+#define GL_CONST_EYE_NV                   0x86E5
+#define GL_PASS_THROUGH_NV                0x86E6
+#define GL_CULL_FRAGMENT_NV               0x86E7
+#define GL_OFFSET_TEXTURE_2D_NV           0x86E8
+#define GL_DEPENDENT_AR_TEXTURE_2D_NV     0x86E9
+#define GL_DEPENDENT_GB_TEXTURE_2D_NV     0x86EA
+#define GL_DOT_PRODUCT_NV                 0x86EC
+#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV   0x86ED
+#define GL_DOT_PRODUCT_TEXTURE_2D_NV      0x86EE
+#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV 0x86F0
+#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV 0x86F1
+#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV 0x86F2
+#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3
+#define GL_HILO_NV                        0x86F4
+#define GL_DSDT_NV                        0x86F5
+#define GL_DSDT_MAG_NV                    0x86F6
+#define GL_DSDT_MAG_VIB_NV                0x86F7
+#define GL_HILO16_NV                      0x86F8
+#define GL_SIGNED_HILO_NV                 0x86F9
+#define GL_SIGNED_HILO16_NV               0x86FA
+#define GL_SIGNED_RGBA_NV                 0x86FB
+#define GL_SIGNED_RGBA8_NV                0x86FC
+#define GL_SIGNED_RGB_NV                  0x86FE
+#define GL_SIGNED_RGB8_NV                 0x86FF
+#define GL_SIGNED_LUMINANCE_NV            0x8701
+#define GL_SIGNED_LUMINANCE8_NV           0x8702
+#define GL_SIGNED_LUMINANCE_ALPHA_NV      0x8703
+#define GL_SIGNED_LUMINANCE8_ALPHA8_NV    0x8704
+#define GL_SIGNED_ALPHA_NV                0x8705
+#define GL_SIGNED_ALPHA8_NV               0x8706
+#define GL_SIGNED_INTENSITY_NV            0x8707
+#define GL_SIGNED_INTENSITY8_NV           0x8708
+#define GL_DSDT8_NV                       0x8709
+#define GL_DSDT8_MAG8_NV                  0x870A
+#define GL_DSDT8_MAG8_INTENSITY8_NV       0x870B
+#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV   0x870C
+#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
+#define GL_HI_SCALE_NV                    0x870E
+#define GL_LO_SCALE_NV                    0x870F
+#define GL_DS_SCALE_NV                    0x8710
+#define GL_DT_SCALE_NV                    0x8711
+#define GL_MAGNITUDE_SCALE_NV             0x8712
+#define GL_VIBRANCE_SCALE_NV              0x8713
+#define GL_HI_BIAS_NV                     0x8714
+#define GL_LO_BIAS_NV                     0x8715
+#define GL_DS_BIAS_NV                     0x8716
+#define GL_DT_BIAS_NV                     0x8717
+#define GL_MAGNITUDE_BIAS_NV              0x8718
+#define GL_VIBRANCE_BIAS_NV               0x8719
+#define GL_TEXTURE_BORDER_VALUES_NV       0x871A
+#define GL_TEXTURE_HI_SIZE_NV             0x871B
+#define GL_TEXTURE_LO_SIZE_NV             0x871C
+#define GL_TEXTURE_DS_SIZE_NV             0x871D
+#define GL_TEXTURE_DT_SIZE_NV             0x871E
+#define GL_TEXTURE_MAG_SIZE_NV            0x871F
+#endif
+
+#ifndef GL_NV_texture_shader2
+#define GL_DOT_PRODUCT_TEXTURE_3D_NV      0x86EF
+#endif
+
+#ifndef GL_NV_vertex_array_range2
+#define GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV 0x8533
+#endif
+
+#ifndef GL_NV_vertex_program
+#define GL_VERTEX_PROGRAM_NV              0x8620
+#define GL_VERTEX_STATE_PROGRAM_NV        0x8621
+#define GL_ATTRIB_ARRAY_SIZE_NV           0x8623
+#define GL_ATTRIB_ARRAY_STRIDE_NV         0x8624
+#define GL_ATTRIB_ARRAY_TYPE_NV           0x8625
+#define GL_CURRENT_ATTRIB_NV              0x8626
+#define GL_PROGRAM_LENGTH_NV              0x8627
+#define GL_PROGRAM_STRING_NV              0x8628
+#define GL_MODELVIEW_PROJECTION_NV        0x8629
+#define GL_IDENTITY_NV                    0x862A
+#define GL_INVERSE_NV                     0x862B
+#define GL_TRANSPOSE_NV                   0x862C
+#define GL_INVERSE_TRANSPOSE_NV           0x862D
+#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV 0x862E
+#define GL_MAX_TRACK_MATRICES_NV          0x862F
+#define GL_MATRIX0_NV                     0x8630
+#define GL_MATRIX1_NV                     0x8631
+#define GL_MATRIX2_NV                     0x8632
+#define GL_MATRIX3_NV                     0x8633
+#define GL_MATRIX4_NV                     0x8634
+#define GL_MATRIX5_NV                     0x8635
+#define GL_MATRIX6_NV                     0x8636
+#define GL_MATRIX7_NV                     0x8637
+#define GL_CURRENT_MATRIX_STACK_DEPTH_NV  0x8640
+#define GL_CURRENT_MATRIX_NV              0x8641
+#define GL_VERTEX_PROGRAM_POINT_SIZE_NV   0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_NV     0x8643
+#define GL_PROGRAM_PARAMETER_NV           0x8644
+#define GL_ATTRIB_ARRAY_POINTER_NV        0x8645
+#define GL_PROGRAM_TARGET_NV              0x8646
+#define GL_PROGRAM_RESIDENT_NV            0x8647
+#define GL_TRACK_MATRIX_NV                0x8648
+#define GL_TRACK_MATRIX_TRANSFORM_NV      0x8649
+#define GL_VERTEX_PROGRAM_BINDING_NV      0x864A
+#define GL_PROGRAM_ERROR_POSITION_NV      0x864B
+#define GL_VERTEX_ATTRIB_ARRAY0_NV        0x8650
+#define GL_VERTEX_ATTRIB_ARRAY1_NV        0x8651
+#define GL_VERTEX_ATTRIB_ARRAY2_NV        0x8652
+#define GL_VERTEX_ATTRIB_ARRAY3_NV        0x8653
+#define GL_VERTEX_ATTRIB_ARRAY4_NV        0x8654
+#define GL_VERTEX_ATTRIB_ARRAY5_NV        0x8655
+#define GL_VERTEX_ATTRIB_ARRAY6_NV        0x8656
+#define GL_VERTEX_ATTRIB_ARRAY7_NV        0x8657
+#define GL_VERTEX_ATTRIB_ARRAY8_NV        0x8658
+#define GL_VERTEX_ATTRIB_ARRAY9_NV        0x8659
+#define GL_VERTEX_ATTRIB_ARRAY10_NV       0x865A
+#define GL_VERTEX_ATTRIB_ARRAY11_NV       0x865B
+#define GL_VERTEX_ATTRIB_ARRAY12_NV       0x865C
+#define GL_VERTEX_ATTRIB_ARRAY13_NV       0x865D
+#define GL_VERTEX_ATTRIB_ARRAY14_NV       0x865E
+#define GL_VERTEX_ATTRIB_ARRAY15_NV       0x865F
+#define GL_MAP1_VERTEX_ATTRIB0_4_NV       0x8660
+#define GL_MAP1_VERTEX_ATTRIB1_4_NV       0x8661
+#define GL_MAP1_VERTEX_ATTRIB2_4_NV       0x8662
+#define GL_MAP1_VERTEX_ATTRIB3_4_NV       0x8663
+#define GL_MAP1_VERTEX_ATTRIB4_4_NV       0x8664
+#define GL_MAP1_VERTEX_ATTRIB5_4_NV       0x8665
+#define GL_MAP1_VERTEX_ATTRIB6_4_NV       0x8666
+#define GL_MAP1_VERTEX_ATTRIB7_4_NV       0x8667
+#define GL_MAP1_VERTEX_ATTRIB8_4_NV       0x8668
+#define GL_MAP1_VERTEX_ATTRIB9_4_NV       0x8669
+#define GL_MAP1_VERTEX_ATTRIB10_4_NV      0x866A
+#define GL_MAP1_VERTEX_ATTRIB11_4_NV      0x866B
+#define GL_MAP1_VERTEX_ATTRIB12_4_NV      0x866C
+#define GL_MAP1_VERTEX_ATTRIB13_4_NV      0x866D
+#define GL_MAP1_VERTEX_ATTRIB14_4_NV      0x866E
+#define GL_MAP1_VERTEX_ATTRIB15_4_NV      0x866F
+#define GL_MAP2_VERTEX_ATTRIB0_4_NV       0x8670
+#define GL_MAP2_VERTEX_ATTRIB1_4_NV       0x8671
+#define GL_MAP2_VERTEX_ATTRIB2_4_NV       0x8672
+#define GL_MAP2_VERTEX_ATTRIB3_4_NV       0x8673
+#define GL_MAP2_VERTEX_ATTRIB4_4_NV       0x8674
+#define GL_MAP2_VERTEX_ATTRIB5_4_NV       0x8675
+#define GL_MAP2_VERTEX_ATTRIB6_4_NV       0x8676
+#define GL_MAP2_VERTEX_ATTRIB7_4_NV       0x8677
+#define GL_MAP2_VERTEX_ATTRIB8_4_NV       0x8678
+#define GL_MAP2_VERTEX_ATTRIB9_4_NV       0x8679
+#define GL_MAP2_VERTEX_ATTRIB10_4_NV      0x867A
+#define GL_MAP2_VERTEX_ATTRIB11_4_NV      0x867B
+#define GL_MAP2_VERTEX_ATTRIB12_4_NV      0x867C
+#define GL_MAP2_VERTEX_ATTRIB13_4_NV      0x867D
+#define GL_MAP2_VERTEX_ATTRIB14_4_NV      0x867E
+#define GL_MAP2_VERTEX_ATTRIB15_4_NV      0x867F
+#endif
+
+#ifndef GL_SGIX_texture_coordinate_clamp
+#define GL_TEXTURE_MAX_CLAMP_S_SGIX       0x8369
+#define GL_TEXTURE_MAX_CLAMP_T_SGIX       0x836A
+#define GL_TEXTURE_MAX_CLAMP_R_SGIX       0x836B
+#endif
+
+#ifndef GL_SGIX_scalebias_hint
+#define GL_SCALEBIAS_HINT_SGIX            0x8322
+#endif
+
+#ifndef GL_OML_interlace
+#define GL_INTERLACE_OML                  0x8980
+#define GL_INTERLACE_READ_OML             0x8981
+#endif
+
+#ifndef GL_OML_subsample
+#define GL_FORMAT_SUBSAMPLE_24_24_OML     0x8982
+#define GL_FORMAT_SUBSAMPLE_244_244_OML   0x8983
+#endif
+
+#ifndef GL_OML_resample
+#define GL_PACK_RESAMPLE_OML              0x8984
+#define GL_UNPACK_RESAMPLE_OML            0x8985
+#define GL_RESAMPLE_REPLICATE_OML         0x8986
+#define GL_RESAMPLE_ZERO_FILL_OML         0x8987
+#define GL_RESAMPLE_AVERAGE_OML           0x8988
+#define GL_RESAMPLE_DECIMATE_OML          0x8989
+#endif
+
+#ifndef GL_NV_copy_depth_to_color
+#define GL_DEPTH_STENCIL_TO_RGBA_NV       0x886E
+#define GL_DEPTH_STENCIL_TO_BGRA_NV       0x886F
+#endif
+
+#ifndef GL_ATI_envmap_bumpmap
+#define GL_BUMP_ROT_MATRIX_ATI            0x8775
+#define GL_BUMP_ROT_MATRIX_SIZE_ATI       0x8776
+#define GL_BUMP_NUM_TEX_UNITS_ATI         0x8777
+#define GL_BUMP_TEX_UNITS_ATI             0x8778
+#define GL_DUDV_ATI                       0x8779
+#define GL_DU8DV8_ATI                     0x877A
+#define GL_BUMP_ENVMAP_ATI                0x877B
+#define GL_BUMP_TARGET_ATI                0x877C
+#endif
+
+#ifndef GL_ATI_fragment_shader
+#define GL_FRAGMENT_SHADER_ATI            0x8920
+#define GL_REG_0_ATI                      0x8921
+#define GL_REG_1_ATI                      0x8922
+#define GL_REG_2_ATI                      0x8923
+#define GL_REG_3_ATI                      0x8924
+#define GL_REG_4_ATI                      0x8925
+#define GL_REG_5_ATI                      0x8926
+#define GL_REG_6_ATI                      0x8927
+#define GL_REG_7_ATI                      0x8928
+#define GL_REG_8_ATI                      0x8929
+#define GL_REG_9_ATI                      0x892A
+#define GL_REG_10_ATI                     0x892B
+#define GL_REG_11_ATI                     0x892C
+#define GL_REG_12_ATI                     0x892D
+#define GL_REG_13_ATI                     0x892E
+#define GL_REG_14_ATI                     0x892F
+#define GL_REG_15_ATI                     0x8930
+#define GL_REG_16_ATI                     0x8931
+#define GL_REG_17_ATI                     0x8932
+#define GL_REG_18_ATI                     0x8933
+#define GL_REG_19_ATI                     0x8934
+#define GL_REG_20_ATI                     0x8935
+#define GL_REG_21_ATI                     0x8936
+#define GL_REG_22_ATI                     0x8937
+#define GL_REG_23_ATI                     0x8938
+#define GL_REG_24_ATI                     0x8939
+#define GL_REG_25_ATI                     0x893A
+#define GL_REG_26_ATI                     0x893B
+#define GL_REG_27_ATI                     0x893C
+#define GL_REG_28_ATI                     0x893D
+#define GL_REG_29_ATI                     0x893E
+#define GL_REG_30_ATI                     0x893F
+#define GL_REG_31_ATI                     0x8940
+#define GL_CON_0_ATI                      0x8941
+#define GL_CON_1_ATI                      0x8942
+#define GL_CON_2_ATI                      0x8943
+#define GL_CON_3_ATI                      0x8944
+#define GL_CON_4_ATI                      0x8945
+#define GL_CON_5_ATI                      0x8946
+#define GL_CON_6_ATI                      0x8947
+#define GL_CON_7_ATI                      0x8948
+#define GL_CON_8_ATI                      0x8949
+#define GL_CON_9_ATI                      0x894A
+#define GL_CON_10_ATI                     0x894B
+#define GL_CON_11_ATI                     0x894C
+#define GL_CON_12_ATI                     0x894D
+#define GL_CON_13_ATI                     0x894E
+#define GL_CON_14_ATI                     0x894F
+#define GL_CON_15_ATI                     0x8950
+#define GL_CON_16_ATI                     0x8951
+#define GL_CON_17_ATI                     0x8952
+#define GL_CON_18_ATI                     0x8953
+#define GL_CON_19_ATI                     0x8954
+#define GL_CON_20_ATI                     0x8955
+#define GL_CON_21_ATI                     0x8956
+#define GL_CON_22_ATI                     0x8957
+#define GL_CON_23_ATI                     0x8958
+#define GL_CON_24_ATI                     0x8959
+#define GL_CON_25_ATI                     0x895A
+#define GL_CON_26_ATI                     0x895B
+#define GL_CON_27_ATI                     0x895C
+#define GL_CON_28_ATI                     0x895D
+#define GL_CON_29_ATI                     0x895E
+#define GL_CON_30_ATI                     0x895F
+#define GL_CON_31_ATI                     0x8960
+#define GL_MOV_ATI                        0x8961
+#define GL_ADD_ATI                        0x8963
+#define GL_MUL_ATI                        0x8964
+#define GL_SUB_ATI                        0x8965
+#define GL_DOT3_ATI                       0x8966
+#define GL_DOT4_ATI                       0x8967
+#define GL_MAD_ATI                        0x8968
+#define GL_LERP_ATI                       0x8969
+#define GL_CND_ATI                        0x896A
+#define GL_CND0_ATI                       0x896B
+#define GL_DOT2_ADD_ATI                   0x896C
+#define GL_SECONDARY_INTERPOLATOR_ATI     0x896D
+#define GL_NUM_FRAGMENT_REGISTERS_ATI     0x896E
+#define GL_NUM_FRAGMENT_CONSTANTS_ATI     0x896F
+#define GL_NUM_PASSES_ATI                 0x8970
+#define GL_NUM_INSTRUCTIONS_PER_PASS_ATI  0x8971
+#define GL_NUM_INSTRUCTIONS_TOTAL_ATI     0x8972
+#define GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI 0x8973
+#define GL_NUM_LOOPBACK_COMPONENTS_ATI    0x8974
+#define GL_COLOR_ALPHA_PAIRING_ATI        0x8975
+#define GL_SWIZZLE_STR_ATI                0x8976
+#define GL_SWIZZLE_STQ_ATI                0x8977
+#define GL_SWIZZLE_STR_DR_ATI             0x8978
+#define GL_SWIZZLE_STQ_DQ_ATI             0x8979
+#define GL_SWIZZLE_STRQ_ATI               0x897A
+#define GL_SWIZZLE_STRQ_DQ_ATI            0x897B
+#define GL_RED_BIT_ATI                    0x00000001
+#define GL_GREEN_BIT_ATI                  0x00000002
+#define GL_BLUE_BIT_ATI                   0x00000004
+#define GL_2X_BIT_ATI                     0x00000001
+#define GL_4X_BIT_ATI                     0x00000002
+#define GL_8X_BIT_ATI                     0x00000004
+#define GL_HALF_BIT_ATI                   0x00000008
+#define GL_QUARTER_BIT_ATI                0x00000010
+#define GL_EIGHTH_BIT_ATI                 0x00000020
+#define GL_SATURATE_BIT_ATI               0x00000040
+#define GL_COMP_BIT_ATI                   0x00000002
+#define GL_NEGATE_BIT_ATI                 0x00000004
+#define GL_BIAS_BIT_ATI                   0x00000008
+#endif
+
+#ifndef GL_ATI_pn_triangles
+#define GL_PN_TRIANGLES_ATI               0x87F0
+#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F1
+#define GL_PN_TRIANGLES_POINT_MODE_ATI    0x87F2
+#define GL_PN_TRIANGLES_NORMAL_MODE_ATI   0x87F3
+#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F4
+#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI 0x87F5
+#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI 0x87F6
+#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI 0x87F7
+#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI 0x87F8
+#endif
+
+#ifndef GL_ATI_vertex_array_object
+#define GL_STATIC_ATI                     0x8760
+#define GL_DYNAMIC_ATI                    0x8761
+#define GL_PRESERVE_ATI                   0x8762
+#define GL_DISCARD_ATI                    0x8763
+#define GL_OBJECT_BUFFER_SIZE_ATI         0x8764
+#define GL_OBJECT_BUFFER_USAGE_ATI        0x8765
+#define GL_ARRAY_OBJECT_BUFFER_ATI        0x8766
+#define GL_ARRAY_OBJECT_OFFSET_ATI        0x8767
+#endif
+
+#ifndef GL_EXT_vertex_shader
+#define GL_VERTEX_SHADER_EXT              0x8780
+#define GL_VERTEX_SHADER_BINDING_EXT      0x8781
+#define GL_OP_INDEX_EXT                   0x8782
+#define GL_OP_NEGATE_EXT                  0x8783
+#define GL_OP_DOT3_EXT                    0x8784
+#define GL_OP_DOT4_EXT                    0x8785
+#define GL_OP_MUL_EXT                     0x8786
+#define GL_OP_ADD_EXT                     0x8787
+#define GL_OP_MADD_EXT                    0x8788
+#define GL_OP_FRAC_EXT                    0x8789
+#define GL_OP_MAX_EXT                     0x878A
+#define GL_OP_MIN_EXT                     0x878B
+#define GL_OP_SET_GE_EXT                  0x878C
+#define GL_OP_SET_LT_EXT                  0x878D
+#define GL_OP_CLAMP_EXT                   0x878E
+#define GL_OP_FLOOR_EXT                   0x878F
+#define GL_OP_ROUND_EXT                   0x8790
+#define GL_OP_EXP_BASE_2_EXT              0x8791
+#define GL_OP_LOG_BASE_2_EXT              0x8792
+#define GL_OP_POWER_EXT                   0x8793
+#define GL_OP_RECIP_EXT                   0x8794
+#define GL_OP_RECIP_SQRT_EXT              0x8795
+#define GL_OP_SUB_EXT                     0x8796
+#define GL_OP_CROSS_PRODUCT_EXT           0x8797
+#define GL_OP_MULTIPLY_MATRIX_EXT         0x8798
+#define GL_OP_MOV_EXT                     0x8799
+#define GL_OUTPUT_VERTEX_EXT              0x879A
+#define GL_OUTPUT_COLOR0_EXT              0x879B
+#define GL_OUTPUT_COLOR1_EXT              0x879C
+#define GL_OUTPUT_TEXTURE_COORD0_EXT      0x879D
+#define GL_OUTPUT_TEXTURE_COORD1_EXT      0x879E
+#define GL_OUTPUT_TEXTURE_COORD2_EXT      0x879F
+#define GL_OUTPUT_TEXTURE_COORD3_EXT      0x87A0
+#define GL_OUTPUT_TEXTURE_COORD4_EXT      0x87A1
+#define GL_OUTPUT_TEXTURE_COORD5_EXT      0x87A2
+#define GL_OUTPUT_TEXTURE_COORD6_EXT      0x87A3
+#define GL_OUTPUT_TEXTURE_COORD7_EXT      0x87A4
+#define GL_OUTPUT_TEXTURE_COORD8_EXT      0x87A5
+#define GL_OUTPUT_TEXTURE_COORD9_EXT      0x87A6
+#define GL_OUTPUT_TEXTURE_COORD10_EXT     0x87A7
+#define GL_OUTPUT_TEXTURE_COORD11_EXT     0x87A8
+#define GL_OUTPUT_TEXTURE_COORD12_EXT     0x87A9
+#define GL_OUTPUT_TEXTURE_COORD13_EXT     0x87AA
+#define GL_OUTPUT_TEXTURE_COORD14_EXT     0x87AB
+#define GL_OUTPUT_TEXTURE_COORD15_EXT     0x87AC
+#define GL_OUTPUT_TEXTURE_COORD16_EXT     0x87AD
+#define GL_OUTPUT_TEXTURE_COORD17_EXT     0x87AE
+#define GL_OUTPUT_TEXTURE_COORD18_EXT     0x87AF
+#define GL_OUTPUT_TEXTURE_COORD19_EXT     0x87B0
+#define GL_OUTPUT_TEXTURE_COORD20_EXT     0x87B1
+#define GL_OUTPUT_TEXTURE_COORD21_EXT     0x87B2
+#define GL_OUTPUT_TEXTURE_COORD22_EXT     0x87B3
+#define GL_OUTPUT_TEXTURE_COORD23_EXT     0x87B4
+#define GL_OUTPUT_TEXTURE_COORD24_EXT     0x87B5
+#define GL_OUTPUT_TEXTURE_COORD25_EXT     0x87B6
+#define GL_OUTPUT_TEXTURE_COORD26_EXT     0x87B7
+#define GL_OUTPUT_TEXTURE_COORD27_EXT     0x87B8
+#define GL_OUTPUT_TEXTURE_COORD28_EXT     0x87B9
+#define GL_OUTPUT_TEXTURE_COORD29_EXT     0x87BA
+#define GL_OUTPUT_TEXTURE_COORD30_EXT     0x87BB
+#define GL_OUTPUT_TEXTURE_COORD31_EXT     0x87BC
+#define GL_OUTPUT_FOG_EXT                 0x87BD
+#define GL_SCALAR_EXT                     0x87BE
+#define GL_VECTOR_EXT                     0x87BF
+#define GL_MATRIX_EXT                     0x87C0
+#define GL_VARIANT_EXT                    0x87C1
+#define GL_INVARIANT_EXT                  0x87C2
+#define GL_LOCAL_CONSTANT_EXT             0x87C3
+#define GL_LOCAL_EXT                      0x87C4
+#define GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87C5
+#define GL_MAX_VERTEX_SHADER_VARIANTS_EXT 0x87C6
+#define GL_MAX_VERTEX_SHADER_INVARIANTS_EXT 0x87C7
+#define GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87C8
+#define GL_MAX_VERTEX_SHADER_LOCALS_EXT   0x87C9
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CA
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT 0x87CB
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87CC
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT 0x87CD
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT 0x87CE
+#define GL_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CF
+#define GL_VERTEX_SHADER_VARIANTS_EXT     0x87D0
+#define GL_VERTEX_SHADER_INVARIANTS_EXT   0x87D1
+#define GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87D2
+#define GL_VERTEX_SHADER_LOCALS_EXT       0x87D3
+#define GL_VERTEX_SHADER_OPTIMIZED_EXT    0x87D4
+#define GL_X_EXT                          0x87D5
+#define GL_Y_EXT                          0x87D6
+#define GL_Z_EXT                          0x87D7
+#define GL_W_EXT                          0x87D8
+#define GL_NEGATIVE_X_EXT                 0x87D9
+#define GL_NEGATIVE_Y_EXT                 0x87DA
+#define GL_NEGATIVE_Z_EXT                 0x87DB
+#define GL_NEGATIVE_W_EXT                 0x87DC
+#define GL_ZERO_EXT                       0x87DD
+#define GL_ONE_EXT                        0x87DE
+#define GL_NEGATIVE_ONE_EXT               0x87DF
+#define GL_NORMALIZED_RANGE_EXT           0x87E0
+#define GL_FULL_RANGE_EXT                 0x87E1
+#define GL_CURRENT_VERTEX_EXT             0x87E2
+#define GL_MVP_MATRIX_EXT                 0x87E3
+#define GL_VARIANT_VALUE_EXT              0x87E4
+#define GL_VARIANT_DATATYPE_EXT           0x87E5
+#define GL_VARIANT_ARRAY_STRIDE_EXT       0x87E6
+#define GL_VARIANT_ARRAY_TYPE_EXT         0x87E7
+#define GL_VARIANT_ARRAY_EXT              0x87E8
+#define GL_VARIANT_ARRAY_POINTER_EXT      0x87E9
+#define GL_INVARIANT_VALUE_EXT            0x87EA
+#define GL_INVARIANT_DATATYPE_EXT         0x87EB
+#define GL_LOCAL_CONSTANT_VALUE_EXT       0x87EC
+#define GL_LOCAL_CONSTANT_DATATYPE_EXT    0x87ED
+#endif
+
+#ifndef GL_ATI_vertex_streams
+#define GL_MAX_VERTEX_STREAMS_ATI         0x876B
+#define GL_VERTEX_STREAM0_ATI             0x876C
+#define GL_VERTEX_STREAM1_ATI             0x876D
+#define GL_VERTEX_STREAM2_ATI             0x876E
+#define GL_VERTEX_STREAM3_ATI             0x876F
+#define GL_VERTEX_STREAM4_ATI             0x8770
+#define GL_VERTEX_STREAM5_ATI             0x8771
+#define GL_VERTEX_STREAM6_ATI             0x8772
+#define GL_VERTEX_STREAM7_ATI             0x8773
+#define GL_VERTEX_SOURCE_ATI              0x8774
+#endif
+
+#ifndef GL_ATI_element_array
+#define GL_ELEMENT_ARRAY_ATI              0x8768
+#define GL_ELEMENT_ARRAY_TYPE_ATI         0x8769
+#define GL_ELEMENT_ARRAY_POINTER_ATI      0x876A
+#endif
+
+#ifndef GL_SUN_mesh_array
+#define GL_QUAD_MESH_SUN                  0x8614
+#define GL_TRIANGLE_MESH_SUN              0x8615
+#endif
+
+#ifndef GL_SUN_slice_accum
+#define GL_SLICE_ACCUM_SUN                0x85CC
+#endif
+
+#ifndef GL_NV_multisample_filter_hint
+#define GL_MULTISAMPLE_FILTER_HINT_NV     0x8534
+#endif
+
+#ifndef GL_NV_depth_clamp
+#define GL_DEPTH_CLAMP_NV                 0x864F
+#endif
+
+#ifndef GL_NV_occlusion_query
+#define GL_PIXEL_COUNTER_BITS_NV          0x8864
+#define GL_CURRENT_OCCLUSION_QUERY_ID_NV  0x8865
+#define GL_PIXEL_COUNT_NV                 0x8866
+#define GL_PIXEL_COUNT_AVAILABLE_NV       0x8867
+#endif
+
+#ifndef GL_NV_point_sprite
+#define GL_POINT_SPRITE_NV                0x8861
+#define GL_COORD_REPLACE_NV               0x8862
+#define GL_POINT_SPRITE_R_MODE_NV         0x8863
+#endif
+
+#ifndef GL_NV_texture_shader3
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV 0x8850
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV 0x8851
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8852
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV 0x8853
+#define GL_OFFSET_HILO_TEXTURE_2D_NV      0x8854
+#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV 0x8855
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV 0x8856
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8857
+#define GL_DEPENDENT_HILO_TEXTURE_2D_NV   0x8858
+#define GL_DEPENDENT_RGB_TEXTURE_3D_NV    0x8859
+#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV 0x885A
+#define GL_DOT_PRODUCT_PASS_THROUGH_NV    0x885B
+#define GL_DOT_PRODUCT_TEXTURE_1D_NV      0x885C
+#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV 0x885D
+#define GL_HILO8_NV                       0x885E
+#define GL_SIGNED_HILO8_NV                0x885F
+#define GL_FORCE_BLUE_TO_ONE_NV           0x8860
+#endif
+
+#ifndef GL_NV_vertex_program1_1
+#endif
+
+#ifndef GL_EXT_shadow_funcs
+#endif
+
+#ifndef GL_EXT_stencil_two_side
+#define GL_STENCIL_TEST_TWO_SIDE_EXT      0x8910
+#define GL_ACTIVE_STENCIL_FACE_EXT        0x8911
+#endif
+
+#ifndef GL_ATI_text_fragment_shader
+#define GL_TEXT_FRAGMENT_SHADER_ATI       0x8200
+#endif
+
+#ifndef GL_APPLE_client_storage
+#define GL_UNPACK_CLIENT_STORAGE_APPLE    0x85B2
+#endif
+
+#ifndef GL_APPLE_element_array
+#define GL_ELEMENT_ARRAY_APPLE            0x8768
+#define GL_ELEMENT_ARRAY_TYPE_APPLE       0x8769
+#define GL_ELEMENT_ARRAY_POINTER_APPLE    0x876A
+#endif
+
+#ifndef GL_APPLE_fence
+#define GL_DRAW_PIXELS_APPLE              0x8A0A
+#define GL_FENCE_APPLE                    0x8A0B
+#endif
+
+#ifndef GL_APPLE_vertex_array_object
+#define GL_VERTEX_ARRAY_BINDING_APPLE     0x85B5
+#endif
+
+#ifndef GL_APPLE_vertex_array_range
+#define GL_VERTEX_ARRAY_RANGE_APPLE       0x851D
+#define GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE 0x851E
+#define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE 0x851F
+#define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE 0x8521
+#define GL_STORAGE_CACHED_APPLE           0x85BE
+#define GL_STORAGE_SHARED_APPLE           0x85BF
+#endif
+
+#ifndef GL_APPLE_ycbcr_422
+#define GL_YCBCR_422_APPLE                0x85B9
+#define GL_UNSIGNED_SHORT_8_8_APPLE       0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_APPLE   0x85BB
+#endif
+
+#ifndef GL_S3_s3tc
+#define GL_RGB_S3TC                       0x83A0
+#define GL_RGB4_S3TC                      0x83A1
+#define GL_RGBA_S3TC                      0x83A2
+#define GL_RGBA4_S3TC                     0x83A3
+#endif
+
+#ifndef GL_ATI_draw_buffers
+#define GL_MAX_DRAW_BUFFERS_ATI           0x8824
+#define GL_DRAW_BUFFER0_ATI               0x8825
+#define GL_DRAW_BUFFER1_ATI               0x8826
+#define GL_DRAW_BUFFER2_ATI               0x8827
+#define GL_DRAW_BUFFER3_ATI               0x8828
+#define GL_DRAW_BUFFER4_ATI               0x8829
+#define GL_DRAW_BUFFER5_ATI               0x882A
+#define GL_DRAW_BUFFER6_ATI               0x882B
+#define GL_DRAW_BUFFER7_ATI               0x882C
+#define GL_DRAW_BUFFER8_ATI               0x882D
+#define GL_DRAW_BUFFER9_ATI               0x882E
+#define GL_DRAW_BUFFER10_ATI              0x882F
+#define GL_DRAW_BUFFER11_ATI              0x8830
+#define GL_DRAW_BUFFER12_ATI              0x8831
+#define GL_DRAW_BUFFER13_ATI              0x8832
+#define GL_DRAW_BUFFER14_ATI              0x8833
+#define GL_DRAW_BUFFER15_ATI              0x8834
+#endif
+
+#ifndef GL_ATI_pixel_format_float
+#define GL_TYPE_RGBA_FLOAT_ATI            0x8820
+#define GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI 0x8835
+#endif
+
+#ifndef GL_ATI_texture_env_combine3
+#define GL_MODULATE_ADD_ATI               0x8744
+#define GL_MODULATE_SIGNED_ADD_ATI        0x8745
+#define GL_MODULATE_SUBTRACT_ATI          0x8746
+#endif
+
+#ifndef GL_ATI_texture_float
+#define GL_RGBA_FLOAT32_ATI               0x8814
+#define GL_RGB_FLOAT32_ATI                0x8815
+#define GL_ALPHA_FLOAT32_ATI              0x8816
+#define GL_INTENSITY_FLOAT32_ATI          0x8817
+#define GL_LUMINANCE_FLOAT32_ATI          0x8818
+#define GL_LUMINANCE_ALPHA_FLOAT32_ATI    0x8819
+#define GL_RGBA_FLOAT16_ATI               0x881A
+#define GL_RGB_FLOAT16_ATI                0x881B
+#define GL_ALPHA_FLOAT16_ATI              0x881C
+#define GL_INTENSITY_FLOAT16_ATI          0x881D
+#define GL_LUMINANCE_FLOAT16_ATI          0x881E
+#define GL_LUMINANCE_ALPHA_FLOAT16_ATI    0x881F
+#endif
+
+#ifndef GL_NV_float_buffer
+#define GL_FLOAT_R_NV                     0x8880
+#define GL_FLOAT_RG_NV                    0x8881
+#define GL_FLOAT_RGB_NV                   0x8882
+#define GL_FLOAT_RGBA_NV                  0x8883
+#define GL_FLOAT_R16_NV                   0x8884
+#define GL_FLOAT_R32_NV                   0x8885
+#define GL_FLOAT_RG16_NV                  0x8886
+#define GL_FLOAT_RG32_NV                  0x8887
+#define GL_FLOAT_RGB16_NV                 0x8888
+#define GL_FLOAT_RGB32_NV                 0x8889
+#define GL_FLOAT_RGBA16_NV                0x888A
+#define GL_FLOAT_RGBA32_NV                0x888B
+#define GL_TEXTURE_FLOAT_COMPONENTS_NV    0x888C
+#define GL_FLOAT_CLEAR_COLOR_VALUE_NV     0x888D
+#define GL_FLOAT_RGBA_MODE_NV             0x888E
+#endif
+
+#ifndef GL_NV_fragment_program
+#define GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV 0x8868
+#define GL_FRAGMENT_PROGRAM_NV            0x8870
+#define GL_MAX_TEXTURE_COORDS_NV          0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_NV     0x8872
+#define GL_FRAGMENT_PROGRAM_BINDING_NV    0x8873
+#define GL_PROGRAM_ERROR_STRING_NV        0x8874
+#endif
+
+#ifndef GL_NV_half_float
+#define GL_HALF_FLOAT_NV                  0x140B
+#endif
+
+#ifndef GL_NV_pixel_data_range
+#define GL_WRITE_PIXEL_DATA_RANGE_NV      0x8878
+#define GL_READ_PIXEL_DATA_RANGE_NV       0x8879
+#define GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV 0x887A
+#define GL_READ_PIXEL_DATA_RANGE_LENGTH_NV 0x887B
+#define GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV 0x887C
+#define GL_READ_PIXEL_DATA_RANGE_POINTER_NV 0x887D
+#endif
+
+#ifndef GL_NV_primitive_restart
+#define GL_PRIMITIVE_RESTART_NV           0x8558
+#define GL_PRIMITIVE_RESTART_INDEX_NV     0x8559
+#endif
+
+#ifndef GL_NV_texture_expand_normal
+#define GL_TEXTURE_UNSIGNED_REMAP_MODE_NV 0x888F
+#endif
+
+#ifndef GL_NV_vertex_program2
+#endif
+
+#ifndef GL_ATI_map_object_buffer
+#endif
+
+#ifndef GL_ATI_separate_stencil
+#define GL_STENCIL_BACK_FUNC_ATI          0x8800
+#define GL_STENCIL_BACK_FAIL_ATI          0x8801
+#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI 0x8802
+#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI 0x8803
+#endif
+
+#ifndef GL_ATI_vertex_attrib_array_object
+#endif
+
+#ifndef GL_OES_read_format
+#define GL_IMPLEMENTATION_COLOR_READ_TYPE_OES 0x8B9A
+#define GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES 0x8B9B
+#endif
+
+#ifndef GL_EXT_depth_bounds_test
+#define GL_DEPTH_BOUNDS_TEST_EXT          0x8890
+#define GL_DEPTH_BOUNDS_EXT               0x8891
+#endif
+
+#ifndef GL_EXT_texture_mirror_clamp
+#define GL_MIRROR_CLAMP_EXT               0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_EXT       0x8743
+#define GL_MIRROR_CLAMP_TO_BORDER_EXT     0x8912
+#endif
+
+#ifndef GL_EXT_blend_equation_separate
+#define GL_BLEND_EQUATION_RGB_EXT         GL_BLEND_EQUATION
+#define GL_BLEND_EQUATION_ALPHA_EXT       0x883D
+#endif
+
+#ifndef GL_MESA_pack_invert
+#define GL_PACK_INVERT_MESA               0x8758
+#endif
+
+#ifndef GL_MESA_ycbcr_texture
+#define GL_UNSIGNED_SHORT_8_8_MESA        0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_MESA    0x85BB
+#define GL_YCBCR_MESA                     0x8757
+#endif
+
+#ifndef GL_EXT_pixel_buffer_object
+#define GL_PIXEL_PACK_BUFFER_EXT          0x88EB
+#define GL_PIXEL_UNPACK_BUFFER_EXT        0x88EC
+#define GL_PIXEL_PACK_BUFFER_BINDING_EXT  0x88ED
+#define GL_PIXEL_UNPACK_BUFFER_BINDING_EXT 0x88EF
+#endif
+
+#ifndef GL_NV_fragment_program_option
+#endif
+
+#ifndef GL_NV_fragment_program2
+#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
+#define GL_MAX_PROGRAM_CALL_DEPTH_NV      0x88F5
+#define GL_MAX_PROGRAM_IF_DEPTH_NV        0x88F6
+#define GL_MAX_PROGRAM_LOOP_DEPTH_NV      0x88F7
+#define GL_MAX_PROGRAM_LOOP_COUNT_NV      0x88F8
+#endif
+
+#ifndef GL_NV_vertex_program2_option
+    /* reuse GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV */
+    /* reuse GL_MAX_PROGRAM_CALL_DEPTH_NV */
+#endif
+
+#ifndef GL_NV_vertex_program3
+    /* reuse GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB */
+#endif
+
+#ifndef GL_EXT_framebuffer_object
+#define GL_INVALID_FRAMEBUFFER_OPERATION_EXT 0x0506
+#define GL_MAX_RENDERBUFFER_SIZE_EXT      0x84E8
+#define GL_FRAMEBUFFER_BINDING_EXT        0x8CA6
+#define GL_RENDERBUFFER_BINDING_EXT       0x8CA7
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT 0x8CD0
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT 0x8CD1
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT 0x8CD2
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT 0x8CD3
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT 0x8CD4
+#define GL_FRAMEBUFFER_COMPLETE_EXT       0x8CD5
+#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT 0x8CD6
+#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT 0x8CD7
+#define GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT 0x8CD8
+#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT 0x8CD9
+#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT 0x8CDA
+#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT 0x8CDB
+#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT 0x8CDC
+#define GL_FRAMEBUFFER_UNSUPPORTED_EXT    0x8CDD
+#define GL_MAX_COLOR_ATTACHMENTS_EXT      0x8CDF
+#define GL_COLOR_ATTACHMENT0_EXT          0x8CE0
+#define GL_COLOR_ATTACHMENT1_EXT          0x8CE1
+#define GL_COLOR_ATTACHMENT2_EXT          0x8CE2
+#define GL_COLOR_ATTACHMENT3_EXT          0x8CE3
+#define GL_COLOR_ATTACHMENT4_EXT          0x8CE4
+#define GL_COLOR_ATTACHMENT5_EXT          0x8CE5
+#define GL_COLOR_ATTACHMENT6_EXT          0x8CE6
+#define GL_COLOR_ATTACHMENT7_EXT          0x8CE7
+#define GL_COLOR_ATTACHMENT8_EXT          0x8CE8
+#define GL_COLOR_ATTACHMENT9_EXT          0x8CE9
+#define GL_COLOR_ATTACHMENT10_EXT         0x8CEA
+#define GL_COLOR_ATTACHMENT11_EXT         0x8CEB
+#define GL_COLOR_ATTACHMENT12_EXT         0x8CEC
+#define GL_COLOR_ATTACHMENT13_EXT         0x8CED
+#define GL_COLOR_ATTACHMENT14_EXT         0x8CEE
+#define GL_COLOR_ATTACHMENT15_EXT         0x8CEF
+#define GL_DEPTH_ATTACHMENT_EXT           0x8D00
+#define GL_STENCIL_ATTACHMENT_EXT         0x8D20
+#define GL_FRAMEBUFFER_EXT                0x8D40
+#define GL_RENDERBUFFER_EXT               0x8D41
+#define GL_RENDERBUFFER_WIDTH_EXT         0x8D42
+#define GL_RENDERBUFFER_HEIGHT_EXT        0x8D43
+#define GL_RENDERBUFFER_INTERNAL_FORMAT_EXT 0x8D44
+#define GL_STENCIL_INDEX_EXT              0x8D45
+#define GL_STENCIL_INDEX1_EXT             0x8D46
+#define GL_STENCIL_INDEX4_EXT             0x8D47
+#define GL_STENCIL_INDEX8_EXT             0x8D48
+#define GL_STENCIL_INDEX16_EXT            0x8D49
+#define GL_RENDERBUFFER_RED_SIZE_EXT      0x8D50
+#define GL_RENDERBUFFER_GREEN_SIZE_EXT    0x8D51
+#define GL_RENDERBUFFER_BLUE_SIZE_EXT     0x8D52
+#define GL_RENDERBUFFER_ALPHA_SIZE_EXT    0x8D53
+#define GL_RENDERBUFFER_DEPTH_SIZE_EXT    0x8D54
+#define GL_RENDERBUFFER_STENCIL_SIZE_EXT  0x8D55
+#endif
+
+#ifndef GL_GREMEDY_string_marker
+#endif
+
+#ifndef GL_EXT_Cg_shader
+#define GL_CG_VERTEX_SHADER_EXT           0x890E
+#define GL_CG_FRAGMENT_SHADER_EXT         0x890F
+#endif
+
+#ifndef GL_EXT_timer_query
+#define GL_TIME_ELAPSED_EXT               0x88BF
+#endif
+
+#ifndef GL_EXT_texture_buffer_object
+#define GL_TEXTURE_BUFFER_EXT             0x8C2A
+#define GL_MAX_TEXTURE_BUFFER_SIZE_EXT    0x8C2B
+#define GL_TEXTURE_BINDING_BUFFER_EXT     0x8C2C
+#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT 0x8C2D
+#define GL_TEXTURE_BUFFER_FORMAT_EXT      0x8C2E
+#endif
+
+#ifndef GL_EXT_gpu_shader4
+#define GL_SAMPLER_1D_ARRAY_EXT           0x8DC0
+#define GL_SAMPLER_2D_ARRAY_EXT           0x8DC1
+#define GL_SAMPLER_BUFFER_EXT             0x8DC2
+#define GL_SAMPLER_1D_ARRAY_SHADOW_EXT    0x8DC3
+#define GL_SAMPLER_2D_ARRAY_SHADOW_EXT    0x8DC4
+#define GL_SAMPLER_CUBE_SHADOW_EXT        0x8DC5
+#define GL_UNSIGNED_INT_VEC2_EXT          0x8DC6
+#define GL_UNSIGNED_INT_VEC3_EXT          0x8DC7
+#define GL_UNSIGNED_INT_VEC4_EXT          0x8DC8
+#define GL_INT_SAMPLER_1D_EXT             0x8DC9
+#define GL_INT_SAMPLER_2D_EXT             0x8DCA
+#define GL_INT_SAMPLER_3D_EXT             0x8DCB
+#define GL_INT_SAMPLER_CUBE_EXT           0x8DCC
+#define GL_INT_SAMPLER_2D_RECT_EXT        0x8DCD
+#define GL_INT_SAMPLER_1D_ARRAY_EXT       0x8DCE
+#define GL_INT_SAMPLER_2D_ARRAY_EXT       0x8DCF
+#define GL_INT_SAMPLER_BUFFER_EXT         0x8DD0
+#define GL_UNSIGNED_INT_SAMPLER_1D_EXT    0x8DD1
+#define GL_UNSIGNED_INT_SAMPLER_2D_EXT    0x8DD2
+#define GL_UNSIGNED_INT_SAMPLER_3D_EXT    0x8DD3
+#define GL_UNSIGNED_INT_SAMPLER_CUBE_EXT  0x8DD4
+#define GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT 0x8DD5
+#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT 0x8DD6
+#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT 0x8DD7
+#define GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT 0x8DD8
+#define GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT 0x88FD
+#endif
+
+#ifndef GL_EXT_geometry_shader4
+#define GL_GEOMETRY_SHADER_EXT            0x8DD9
+#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT 0x8DDD
+#define GL_MAX_VERTEX_VARYING_COMPONENTS_EXT 0x8DDE
+#define GL_MAX_VARYING_COMPONENTS_EXT     0x8B4B
+#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT 0x8DDF
+#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT 0x8DE0
+#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT 0x8DE1
+#define GL_GEOMETRY_VERTICES_OUT_EXT      0x8DDA
+#define GL_GEOMETRY_INPUT_TYPE_EXT        0x8DDB
+#define GL_GEOMETRY_OUTPUT_TYPE_EXT       0x8DDC
+#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT 0x8C29
+#define GL_LINES_ADJACENCY_EXT            0xA
+#define GL_LINE_STRIP_ADJACENCY_EXT       0xB
+#define GL_TRIANGLES_ADJACENCY_EXT        0xC
+#define GL_TRIANGLE_STRIP_ADJACENCY_EXT   0xD
+#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT 0x8DA7
+#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT 0x8DA8
+#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT 0x8DA9
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT 0x8CD4
+#define GL_PROGRAM_POINT_SIZE_EXT         0x8642
+#endif
+
+#ifndef GL_EXT_bindable_uniform
+#define GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT 0x8DE2
+#define GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT 0x8DE3
+#define GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT 0x8DE4
+#define GL_MAX_BINDABLE_UNIFORM_SIZE_EXT  0x8DED
+#define GL_UNIFORM_BUFFER_EXT             0x8DEE
+#define GL_UNIFORM_BUFFER_BINDING_EXT     0x8DEF
+#endif
+
+#ifndef GL_EXT_framebuffer_sRGB
+#define GL_FRAMEBUFFER_SRGB_EXT           0x8DB9
+#define GL_FRAMEBUFFER_SRGB_CAPABLE_EXT   0x8DBA
+#endif
+
+#ifndef GL_EXT_texture_shared_exponent
+#define GL_RGB9_E5_EXT                    0x8C3D
+#define GL_UNSIGNED_INT_5_9_9_9_REV_EXT   0x8C3E
+#define GL_TEXTURE_SHARED_SIZE_EXT        0x8C3F
+#endif
+
+#ifndef GL_EXT_packed_float
+#define GL_R11F_G11F_B10F_EXT             0x8C3A
+#define GL_UNSIGNED_INT_10F_11F_11F_REV_EXT 0x8C3B
+#define GL_RGBA_SIGNED_COMPONENTS_EXT     0x8C3C
+#endif
+
+#ifndef GL_EXT_texture_array
+#define GL_TEXTURE_1D_ARRAY_EXT           0x8C18
+#define GL_PROXY_TEXTURE_1D_ARRAY_EXT     0x8C19
+#define GL_TEXTURE_2D_ARRAY_EXT           0x8C1A
+#define GL_PROXY_TEXTURE_2D_ARRAY_EXT     0x8C1B
+#define GL_TEXTURE_BINDING_1D_ARRAY_EXT   0x8C1C
+#define GL_TEXTURE_BINDING_2D_ARRAY_EXT   0x8C1D
+#define GL_MAX_ARRAY_TEXTURE_LAYERS_EXT   0x88FF
+#define GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT 0x884E
+    /*      GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT */
+#endif
+
+#ifndef GL_EXT_texture_integer
+#define GL_RGBA32UI_EXT                   0x8D70
+#define GL_RGB32UI_EXT                    0x8D71
+#define GL_ALPHA32UI_EXT                  0x8D72
+#define GL_INTENSITY32UI_EXT              0x8D73
+#define GL_LUMINANCE32UI_EXT              0x8D74
+#define GL_LUMINANCE_ALPHA32UI_EXT        0x8D75
+#define GL_RGBA16UI_EXT                   0x8D76
+#define GL_RGB16UI_EXT                    0x8D77
+#define GL_ALPHA16UI_EXT                  0x8D78
+#define GL_INTENSITY16UI_EXT              0x8D79
+#define GL_LUMINANCE16UI_EXT              0x8D7A
+#define GL_LUMINANCE_ALPHA16UI_EXT        0x8D7B
+#define GL_RGBA8UI_EXT                    0x8D7C
+#define GL_RGB8UI_EXT                     0x8D7D
+#define GL_ALPHA8UI_EXT                   0x8D7E
+#define GL_INTENSITY8UI_EXT               0x8D7F
+#define GL_LUMINANCE8UI_EXT               0x8D80
+#define GL_LUMINANCE_ALPHA8UI_EXT         0x8D81
+#define GL_RGBA32I_EXT                    0x8D82
+#define GL_RGB32I_EXT                     0x8D83
+#define GL_ALPHA32I_EXT                   0x8D84
+#define GL_INTENSITY32I_EXT               0x8D85
+#define GL_LUMINANCE32I_EXT               0x8D86
+#define GL_LUMINANCE_ALPHA32I_EXT         0x8D87
+#define GL_RGBA16I_EXT                    0x8D88
+#define GL_RGB16I_EXT                     0x8D89
+#define GL_ALPHA16I_EXT                   0x8D8A
+#define GL_INTENSITY16I_EXT               0x8D8B
+#define GL_LUMINANCE16I_EXT               0x8D8C
+#define GL_LUMINANCE_ALPHA16I_EXT         0x8D8D
+#define GL_RGBA8I_EXT                     0x8D8E
+#define GL_RGB8I_EXT                      0x8D8F
+#define GL_ALPHA8I_EXT                    0x8D90
+#define GL_INTENSITY8I_EXT                0x8D91
+#define GL_LUMINANCE8I_EXT                0x8D92
+#define GL_LUMINANCE_ALPHA8I_EXT          0x8D93
+#define GL_RED_INTEGER_EXT                0x8D94
+#define GL_GREEN_INTEGER_EXT              0x8D95
+#define GL_BLUE_INTEGER_EXT               0x8D96
+#define GL_ALPHA_INTEGER_EXT              0x8D97
+#define GL_RGB_INTEGER_EXT                0x8D98
+#define GL_RGBA_INTEGER_EXT               0x8D99
+#define GL_BGR_INTEGER_EXT                0x8D9A
+#define GL_BGRA_INTEGER_EXT               0x8D9B
+#define GL_LUMINANCE_INTEGER_EXT          0x8D9C
+#define GL_LUMINANCE_ALPHA_INTEGER_EXT    0x8D9D
+#define GL_RGBA_INTEGER_MODE_EXT          0x8D9E
+#endif
+
+#ifndef GL_NV_depth_buffer_float
+#define GL_DEPTH_COMPONENT32F_NV          0x8DAB
+#define GL_DEPTH32F_STENCIL8_NV           0x8DAC
+#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV 0x8DAD
+#define GL_DEPTH_BUFFER_FLOAT_MODE_NV     0x8DAF
+#endif
+
+#ifndef GL_EXT_texture_compression_latc
+#define GL_COMPRESSED_LUMINANCE_LATC1_EXT 0x8C70
+#define GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT 0x8C71
+#define GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT 0x8C72
+#define GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT 0x8C73
+#endif
+
+#ifndef GL_NV_transform_feedback
+#define GL_BACK_PRIMARY_COLOR_NV          0x8C77
+#define GL_BACK_SECONDARY_COLOR_NV        0x8C78
+#define GL_TEXTURE_COORD_NV               0x8C79
+#define GL_CLIP_DISTANCE_NV               0x8C7A
+#define GL_VERTEX_ID_NV                   0x8C7B
+#define GL_PRIMITIVE_ID_NV                0x8C7C
+#define GL_GENERIC_ATTRIB_NV              0x8C7D
+#define GL_TRANSFORM_FEEDBACK_ATTRIBS_NV  0x8C7E
+#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV 0x8C7F
+#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV 0x8C80
+#define GL_ACTIVE_VARYINGS_NV             0x8C81
+#define GL_ACTIVE_VARYING_MAX_LENGTH_NV   0x8C82
+#define GL_TRANSFORM_FEEDBACK_VARYINGS_NV 0x8C83
+#define GL_TRANSFORM_FEEDBACK_BUFFER_START_NV 0x8C84
+#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV 0x8C85
+#define GL_TRANSFORM_FEEDBACK_RECORD_NV   0x8C86
+#define GL_PRIMITIVES_GENERATED_NV        0x8C87
+#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV 0x8C88
+#define GL_RASTERIZER_DISCARD_NV          0x8C89
+#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_ATTRIBS_NV 0x8C8A
+#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV 0x8C8B
+#define GL_INTERLEAVED_ATTRIBS_NV         0x8C8C
+#define GL_SEPARATE_ATTRIBS_NV            0x8C8D
+#define GL_TRANSFORM_FEEDBACK_BUFFER_NV   0x8C8E
+#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV 0x8C8F
+#endif
+
+#ifndef GL_NV_geometry_program4
+#define GL_GEOMETRY_PROGRAM_NV            0x8C26
+#define GL_MAX_PROGRAM_OUTPUT_VERTICES_NV 0x8C27
+#define GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV 0x8C28
+#endif
+
+#ifndef GL_NV_gpu_program4
+#define GL_MIN_PROGRAM_TEXEL_OFFSET_NV    0x8904
+#define GL_MAX_PROGRAM_TEXEL_OFFSET_NV    0x8905
+#define GL_PROGRAM_ATTRIB_COMPONENTS_NV   0x8906
+#define GL_PROGRAM_RESULT_COMPONENTS_NV   0x8907
+#define GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV 0x8908
+#define GL_MAX_PROGRAM_RESULT_COMPONENTS_NV 0x8909
+#define GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV 0x8DA5
+#define GL_MAX_PROGRAM_GENERIC_RESULTS_NV 0x8DA6
+#endif
+
+#ifndef GL_NV_framebuffer_multisample_coverage
+#define GL_RENDERBUFFER_COVERAGE_SAMPLES_NV 0x8CAB
+#define GL_RENDERBUFFER_COLOR_SAMPLES_NV  0x8E10
+#define GL_MAX_RENDERBUFFER_COVERAGE_SAMPLES_NV 0x8D57
+#define GL_MAX_RENDERBUFFER_COLOR_SAMPLES_NV 0x8E11
+#define GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV 0x8E12
+#define GL_MULTISAMPLE_COVERAGE_MODES_NV  0x8E13
+#endif
+
+#ifndef GL_EXT_framebuffer_multisample
+#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT 0x8D56
+#define GL_MAX_SAMPLES_EXT                0x8D57
+#define GL_RENDERBUFFER_SAMPLES_EXT       0x8CAB
+#endif
+
+#ifndef GL_EXT_framebuffer_blit
+#define GL_READ_FRAMEBUFFER_EXT           0x8CA8
+#define GL_DRAW_FRAMEBUFFER_EXT           0x8CA9
+#define GL_DRAW_FRAMEBUFFER_BINDING_EXT   0x8CA6
+#define GL_READ_FRAMEBUFFER_BINDING_EXT   0x8CAA
+#endif
+
+#ifndef GL_EXT_texture_compression_rgtc
+#define GL_COMPRESSED_RED_RGTC1_EXT       0x8DBB
+#define GL_COMPRESSED_SIGNED_RED_RGTC1_EXT 0x8DBC
+#define GL_COMPRESSED_RED_GREEN_RGTC2_EXT 0x8DBD
+#define GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT 0x8DBE
+#endif
+
+    /*************************************************************/
+
+#include <stddef.h>
+#ifndef GL_VERSION_2_0
+    /* GL type for program/shader text */
+    typedef char GLchar;            /* native character */
+#endif
+
+#ifndef GL_VERSION_1_5
+    /* GL types for handling large vertex buffer objects */
+    typedef ptrdiff_t GLintptr;
+    typedef ptrdiff_t GLsizeiptr;
+#endif
+
+#ifndef GL_ARB_vertex_buffer_object
+    /* GL types for handling large vertex buffer objects */
+    typedef ptrdiff_t GLintptrARB;
+    typedef ptrdiff_t GLsizeiptrARB;
+#endif
+
+#ifndef GL_ARB_shader_objects
+    /* GL types for handling shader object handles and program/shader text */
+    typedef char GLcharARB;     /* native character */
+    typedef unsigned int GLhandleARB;   /* shader object handle */
+#endif
+
+    /* GL types for "half" precision (s10e5) float data in host memory */
+#ifndef GL_ARB_half_float_pixel
+    typedef unsigned short GLhalfARB;
+#endif
+
+#ifndef GL_NV_half_float
+    typedef unsigned short GLhalfNV;
+#endif
+
+#ifndef GL_EXT_timer_query
+    typedef signed long long GLint64EXT;
+    typedef unsigned long long GLuint64EXT;
+#endif
+
+#ifndef GL_VERSION_1_2
+#define GL_VERSION_1_2 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlendColor(GLclampf, GLclampf, GLclampf, GLclampf);
+    extern void APIENTRY glBlendEquation(GLenum);
+    extern void APIENTRY glDrawRangeElements(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *);
+    extern void APIENTRY glColorTable(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glColorTableParameterfv(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glColorTableParameteriv(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glCopyColorTable(GLenum, GLenum, GLint, GLint, GLsizei);
+    extern void APIENTRY glGetColorTable(GLenum, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetColorTableParameterfv(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetColorTableParameteriv(GLenum, GLenum, GLint *);
+    extern void APIENTRY glColorSubTable(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glCopyColorSubTable(GLenum, GLsizei, GLint, GLint, GLsizei);
+    extern void APIENTRY glConvolutionFilter1D(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glConvolutionFilter2D(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glConvolutionParameterf(GLenum, GLenum, GLfloat);
+    extern void APIENTRY glConvolutionParameterfv(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glConvolutionParameteri(GLenum, GLenum, GLint);
+    extern void APIENTRY glConvolutionParameteriv(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glCopyConvolutionFilter1D(GLenum, GLenum, GLint, GLint, GLsizei);
+    extern void APIENTRY glCopyConvolutionFilter2D(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
+    extern void APIENTRY glGetConvolutionFilter(GLenum, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetConvolutionParameterfv(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetConvolutionParameteriv(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetSeparableFilter(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
+    extern void APIENTRY glSeparableFilter2D(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
+    extern void APIENTRY glGetHistogram(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetHistogramParameterfv(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetHistogramParameteriv(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetMinmax(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetMinmaxParameterfv(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetMinmaxParameteriv(GLenum, GLenum, GLint *);
+    extern void APIENTRY glHistogram(GLenum, GLsizei, GLenum, GLboolean);
+    extern void APIENTRY glMinmax(GLenum, GLenum, GLboolean);
+    extern void APIENTRY glResetHistogram(GLenum);
+    extern void APIENTRY glResetMinmax(GLenum);
+    extern void APIENTRY glTexImage3D(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glTexSubImage3D(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glCopyTexSubImage3D(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLENDCOLORPROC)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+    typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC)(GLenum mode);
+    typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
+    typedef void (APIENTRYP PFNGLCOLORTABLEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+    typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLCOPYCOLORTABLEPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLEPROC)(GLenum target, GLenum format, GLenum type, GLvoid *table);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLCOLORSUBTABLEPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOPYCOLORSUBTABLEPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER1DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER2DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat params);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIPROC)(GLenum target, GLenum pname, GLint params);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER1DPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+    typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER2DPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (APIENTRYP PFNGLGETCONVOLUTIONFILTERPROC)(GLenum target, GLenum format, GLenum type, GLvoid *image);
+    typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETSEPARABLEFILTERPROC)(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
+    typedef void (APIENTRYP PFNGLSEPARABLEFILTER2DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
+    typedef void (APIENTRYP PFNGLGETHISTOGRAMPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+    typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETMINMAXPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+    typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLHISTOGRAMPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
+    typedef void (APIENTRYP PFNGLMINMAXPROC)(GLenum target, GLenum internalformat, GLboolean sink);
+    typedef void (APIENTRYP PFNGLRESETHISTOGRAMPROC)(GLenum target);
+    typedef void (APIENTRYP PFNGLRESETMINMAXPROC)(GLenum target);
+    typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+    typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+    typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+#endif
+
+#ifndef GL_VERSION_1_3
+#define GL_VERSION_1_3 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glActiveTexture(GLenum);
+    extern void APIENTRY glClientActiveTexture(GLenum);
+    extern void APIENTRY glMultiTexCoord1d(GLenum, GLdouble);
+    extern void APIENTRY glMultiTexCoord1dv(GLenum, const GLdouble *);
+    extern void APIENTRY glMultiTexCoord1f(GLenum, GLfloat);
+    extern void APIENTRY glMultiTexCoord1fv(GLenum, const GLfloat *);
+    extern void APIENTRY glMultiTexCoord1i(GLenum, GLint);
+    extern void APIENTRY glMultiTexCoord1iv(GLenum, const GLint *);
+    extern void APIENTRY glMultiTexCoord1s(GLenum, GLshort);
+    extern void APIENTRY glMultiTexCoord1sv(GLenum, const GLshort *);
+    extern void APIENTRY glMultiTexCoord2d(GLenum, GLdouble, GLdouble);
+    extern void APIENTRY glMultiTexCoord2dv(GLenum, const GLdouble *);
+    extern void APIENTRY glMultiTexCoord2f(GLenum, GLfloat, GLfloat);
+    extern void APIENTRY glMultiTexCoord2fv(GLenum, const GLfloat *);
+    extern void APIENTRY glMultiTexCoord2i(GLenum, GLint, GLint);
+    extern void APIENTRY glMultiTexCoord2iv(GLenum, const GLint *);
+    extern void APIENTRY glMultiTexCoord2s(GLenum, GLshort, GLshort);
+    extern void APIENTRY glMultiTexCoord2sv(GLenum, const GLshort *);
+    extern void APIENTRY glMultiTexCoord3d(GLenum, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glMultiTexCoord3dv(GLenum, const GLdouble *);
+    extern void APIENTRY glMultiTexCoord3f(GLenum, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glMultiTexCoord3fv(GLenum, const GLfloat *);
+    extern void APIENTRY glMultiTexCoord3i(GLenum, GLint, GLint, GLint);
+    extern void APIENTRY glMultiTexCoord3iv(GLenum, const GLint *);
+    extern void APIENTRY glMultiTexCoord3s(GLenum, GLshort, GLshort, GLshort);
+    extern void APIENTRY glMultiTexCoord3sv(GLenum, const GLshort *);
+    extern void APIENTRY glMultiTexCoord4d(GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glMultiTexCoord4dv(GLenum, const GLdouble *);
+    extern void APIENTRY glMultiTexCoord4f(GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glMultiTexCoord4fv(GLenum, const GLfloat *);
+    extern void APIENTRY glMultiTexCoord4i(GLenum, GLint, GLint, GLint, GLint);
+    extern void APIENTRY glMultiTexCoord4iv(GLenum, const GLint *);
+    extern void APIENTRY glMultiTexCoord4s(GLenum, GLshort, GLshort, GLshort, GLshort);
+    extern void APIENTRY glMultiTexCoord4sv(GLenum, const GLshort *);
+    extern void APIENTRY glLoadTransposeMatrixf(const GLfloat *);
+    extern void APIENTRY glLoadTransposeMatrixd(const GLdouble *);
+    extern void APIENTRY glMultTransposeMatrixf(const GLfloat *);
+    extern void APIENTRY glMultTransposeMatrixd(const GLdouble *);
+    extern void APIENTRY glSampleCoverage(GLclampf, GLboolean);
+    extern void APIENTRY glCompressedTexImage3D(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexImage2D(GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexImage1D(GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexSubImage3D(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexSubImage1D(GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glGetCompressedTexImage(GLenum, GLint, GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLACTIVETEXTUREPROC)(GLenum texture);
+    typedef void (APIENTRYP PFNGLCLIENTACTIVETEXTUREPROC)(GLenum texture);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1DPROC)(GLenum target, GLdouble s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1DVPROC)(GLenum target, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1FPROC)(GLenum target, GLfloat s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1FVPROC)(GLenum target, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1IPROC)(GLenum target, GLint s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1IVPROC)(GLenum target, const GLint *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1SPROC)(GLenum target, GLshort s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1SVPROC)(GLenum target, const GLshort *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2DPROC)(GLenum target, GLdouble s, GLdouble t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2DVPROC)(GLenum target, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2FPROC)(GLenum target, GLfloat s, GLfloat t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2FVPROC)(GLenum target, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2IPROC)(GLenum target, GLint s, GLint t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2IVPROC)(GLenum target, const GLint *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2SPROC)(GLenum target, GLshort s, GLshort t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2SVPROC)(GLenum target, const GLshort *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3DPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3DVPROC)(GLenum target, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3FPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3FVPROC)(GLenum target, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3IPROC)(GLenum target, GLint s, GLint t, GLint r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3IVPROC)(GLenum target, const GLint *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3SPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3SVPROC)(GLenum target, const GLshort *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4DPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4DVPROC)(GLenum target, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4FPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4FVPROC)(GLenum target, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4IPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4IVPROC)(GLenum target, const GLint *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4SPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4SVPROC)(GLenum target, const GLshort *v);
+    typedef void (APIENTRYP PFNGLLOADTRANSPOSEMATRIXFPROC)(const GLfloat *m);
+    typedef void (APIENTRYP PFNGLLOADTRANSPOSEMATRIXDPROC)(const GLdouble *m);
+    typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXFPROC)(const GLfloat *m);
+    typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXDPROC)(const GLdouble *m);
+    typedef void (APIENTRYP PFNGLSAMPLECOVERAGEPROC)(GLclampf value, GLboolean invert);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, GLvoid *img);
+#endif
+
+#ifndef GL_VERSION_1_4
+#define GL_VERSION_1_4 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlendFuncSeparate(GLenum, GLenum, GLenum, GLenum);
+    extern void APIENTRY glFogCoordf(GLfloat);
+    extern void APIENTRY glFogCoordfv(const GLfloat *);
+    extern void APIENTRY glFogCoordd(GLdouble);
+    extern void APIENTRY glFogCoorddv(const GLdouble *);
+    extern void APIENTRY glFogCoordPointer(GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glMultiDrawArrays(GLenum, GLint *, GLsizei *, GLsizei);
+    extern void APIENTRY glMultiDrawElements(GLenum, const GLsizei *, GLenum, const GLvoid* *, GLsizei);
+    extern void APIENTRY glPointParameterf(GLenum, GLfloat);
+    extern void APIENTRY glPointParameterfv(GLenum, const GLfloat *);
+    extern void APIENTRY glPointParameteri(GLenum, GLint);
+    extern void APIENTRY glPointParameteriv(GLenum, const GLint *);
+    extern void APIENTRY glSecondaryColor3b(GLbyte, GLbyte, GLbyte);
+    extern void APIENTRY glSecondaryColor3bv(const GLbyte *);
+    extern void APIENTRY glSecondaryColor3d(GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glSecondaryColor3dv(const GLdouble *);
+    extern void APIENTRY glSecondaryColor3f(GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glSecondaryColor3fv(const GLfloat *);
+    extern void APIENTRY glSecondaryColor3i(GLint, GLint, GLint);
+    extern void APIENTRY glSecondaryColor3iv(const GLint *);
+    extern void APIENTRY glSecondaryColor3s(GLshort, GLshort, GLshort);
+    extern void APIENTRY glSecondaryColor3sv(const GLshort *);
+    extern void APIENTRY glSecondaryColor3ub(GLubyte, GLubyte, GLubyte);
+    extern void APIENTRY glSecondaryColor3ubv(const GLubyte *);
+    extern void APIENTRY glSecondaryColor3ui(GLuint, GLuint, GLuint);
+    extern void APIENTRY glSecondaryColor3uiv(const GLuint *);
+    extern void APIENTRY glSecondaryColor3us(GLushort, GLushort, GLushort);
+    extern void APIENTRY glSecondaryColor3usv(const GLushort *);
+    extern void APIENTRY glSecondaryColorPointer(GLint, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glWindowPos2d(GLdouble, GLdouble);
+    extern void APIENTRY glWindowPos2dv(const GLdouble *);
+    extern void APIENTRY glWindowPos2f(GLfloat, GLfloat);
+    extern void APIENTRY glWindowPos2fv(const GLfloat *);
+    extern void APIENTRY glWindowPos2i(GLint, GLint);
+    extern void APIENTRY glWindowPos2iv(const GLint *);
+    extern void APIENTRY glWindowPos2s(GLshort, GLshort);
+    extern void APIENTRY glWindowPos2sv(const GLshort *);
+    extern void APIENTRY glWindowPos3d(GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glWindowPos3dv(const GLdouble *);
+    extern void APIENTRY glWindowPos3f(GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glWindowPos3fv(const GLfloat *);
+    extern void APIENTRY glWindowPos3i(GLint, GLint, GLint);
+    extern void APIENTRY glWindowPos3iv(const GLint *);
+    extern void APIENTRY glWindowPos3s(GLshort, GLshort, GLshort);
+    extern void APIENTRY glWindowPos3sv(const GLshort *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+    typedef void (APIENTRYP PFNGLFOGCOORDFPROC)(GLfloat coord);
+    typedef void (APIENTRYP PFNGLFOGCOORDFVPROC)(const GLfloat *coord);
+    typedef void (APIENTRYP PFNGLFOGCOORDDPROC)(GLdouble coord);
+    typedef void (APIENTRYP PFNGLFOGCOORDDVPROC)(const GLdouble *coord);
+    typedef void (APIENTRYP PFNGLFOGCOORDPOINTERPROC)(GLenum type, GLsizei stride, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
+    typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BPROC)(GLbyte red, GLbyte green, GLbyte blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BVPROC)(const GLbyte *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DPROC)(GLdouble red, GLdouble green, GLdouble blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DVPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3FPROC)(GLfloat red, GLfloat green, GLfloat blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3FVPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3IPROC)(GLint red, GLint green, GLint blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3IVPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3SPROC)(GLshort red, GLshort green, GLshort blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3SVPROC)(const GLshort *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UBPROC)(GLubyte red, GLubyte green, GLubyte blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UBVPROC)(const GLubyte *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIPROC)(GLuint red, GLuint green, GLuint blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIVPROC)(const GLuint *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USPROC)(GLushort red, GLushort green, GLushort blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USVPROC)(const GLushort *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTERPROC)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2DPROC)(GLdouble x, GLdouble y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2DVPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2FPROC)(GLfloat x, GLfloat y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2FVPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2IPROC)(GLint x, GLint y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2IVPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2SPROC)(GLshort x, GLshort y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2SVPROC)(const GLshort *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3DPROC)(GLdouble x, GLdouble y, GLdouble z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3DVPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3FPROC)(GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3FVPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3IPROC)(GLint x, GLint y, GLint z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3IVPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3SPROC)(GLshort x, GLshort y, GLshort z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3SVPROC)(const GLshort *v);
+#endif
+
+#ifndef GL_VERSION_1_5
+#define GL_VERSION_1_5 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGenQueries(GLsizei, GLuint *);
+    extern void APIENTRY glDeleteQueries(GLsizei, const GLuint *);
+    extern GLboolean APIENTRY glIsQuery(GLuint);
+    extern void APIENTRY glBeginQuery(GLenum, GLuint);
+    extern void APIENTRY glEndQuery(GLenum);
+    extern void APIENTRY glGetQueryiv(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetQueryObjectiv(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetQueryObjectuiv(GLuint, GLenum, GLuint *);
+    extern void APIENTRY glBindBuffer(GLenum, GLuint);
+    extern void APIENTRY glDeleteBuffers(GLsizei, const GLuint *);
+    extern void APIENTRY glGenBuffers(GLsizei, GLuint *);
+    extern GLboolean APIENTRY glIsBuffer(GLuint);
+    extern void APIENTRY glBufferData(GLenum, GLsizeiptr, const GLvoid *, GLenum);
+    extern void APIENTRY glBufferSubData(GLenum, GLintptr, GLsizeiptr, const GLvoid *);
+    extern void APIENTRY glGetBufferSubData(GLenum, GLintptr, GLsizeiptr, GLvoid *);
+    extern GLvoid *APIENTRY glMapBuffer(GLenum, GLenum);
+    extern GLboolean APIENTRY glUnmapBuffer(GLenum);
+    extern void APIENTRY glGetBufferParameteriv(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetBufferPointerv(GLenum, GLenum, GLvoid* *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGENQUERIESPROC)(GLsizei n, GLuint *ids);
+    typedef void (APIENTRYP PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint *ids);
+    typedef GLboolean(APIENTRYP PFNGLISQUERYPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
+    typedef void (APIENTRYP PFNGLENDQUERYPROC)(GLenum target);
+    typedef void (APIENTRYP PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint *params);
+    typedef void (APIENTRYP PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
+    typedef void (APIENTRYP PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint *buffers);
+    typedef void (APIENTRYP PFNGLGENBUFFERSPROC)(GLsizei n, GLuint *buffers);
+    typedef GLboolean(APIENTRYP PFNGLISBUFFERPROC)(GLuint buffer);
+    typedef void (APIENTRYP PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
+    typedef void (APIENTRYP PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
+    typedef GLvoid *(APIENTRYP PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
+    typedef GLboolean(APIENTRYP PFNGLUNMAPBUFFERPROC)(GLenum target);
+    typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, GLvoid* *params);
+#endif
+
+#ifndef GL_VERSION_2_0
+#define GL_VERSION_2_0 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlendEquationSeparate(GLenum, GLenum);
+    extern void APIENTRY glDrawBuffers(GLsizei, const GLenum *);
+    extern void APIENTRY glStencilOpSeparate(GLenum, GLenum, GLenum, GLenum);
+    extern void APIENTRY glStencilFuncSeparate(GLenum, GLenum, GLint, GLuint);
+    extern void APIENTRY glStencilMaskSeparate(GLenum, GLuint);
+    extern void APIENTRY glAttachShader(GLuint, GLuint);
+    extern void APIENTRY glBindAttribLocation(GLuint, GLuint, const GLchar *);
+    extern void APIENTRY glCompileShader(GLuint);
+    extern GLuint APIENTRY glCreateProgram(void);
+    extern GLuint APIENTRY glCreateShader(GLenum);
+    extern void APIENTRY glDeleteProgram(GLuint);
+    extern void APIENTRY glDeleteShader(GLuint);
+    extern void APIENTRY glDetachShader(GLuint, GLuint);
+    extern void APIENTRY glDisableVertexAttribArray(GLuint);
+    extern void APIENTRY glEnableVertexAttribArray(GLuint);
+    extern void APIENTRY glGetActiveAttrib(GLuint, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLchar *);
+    extern void APIENTRY glGetActiveUniform(GLuint, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLchar *);
+    extern void APIENTRY glGetAttachedShaders(GLuint, GLsizei, GLsizei *, GLuint *);
+    extern GLint APIENTRY glGetAttribLocation(GLuint, const GLchar *);
+    extern void APIENTRY glGetProgramiv(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetProgramInfoLog(GLuint, GLsizei, GLsizei *, GLchar *);
+    extern void APIENTRY glGetShaderiv(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetShaderInfoLog(GLuint, GLsizei, GLsizei *, GLchar *);
+    extern void APIENTRY glGetShaderSource(GLuint, GLsizei, GLsizei *, GLchar *);
+    extern GLint APIENTRY glGetUniformLocation(GLuint, const GLchar *);
+    extern void APIENTRY glGetUniformfv(GLuint, GLint, GLfloat *);
+    extern void APIENTRY glGetUniformiv(GLuint, GLint, GLint *);
+    extern void APIENTRY glGetVertexAttribdv(GLuint, GLenum, GLdouble *);
+    extern void APIENTRY glGetVertexAttribfv(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetVertexAttribiv(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetVertexAttribPointerv(GLuint, GLenum, GLvoid* *);
+    extern GLboolean APIENTRY glIsProgram(GLuint);
+    extern GLboolean APIENTRY glIsShader(GLuint);
+    extern void APIENTRY glLinkProgram(GLuint);
+    extern void APIENTRY glShaderSource(GLuint, GLsizei, const GLchar* *, const GLint *);
+    extern void APIENTRY glUseProgram(GLuint);
+    extern void APIENTRY glUniform1f(GLint, GLfloat);
+    extern void APIENTRY glUniform2f(GLint, GLfloat, GLfloat);
+    extern void APIENTRY glUniform3f(GLint, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glUniform4f(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glUniform1i(GLint, GLint);
+    extern void APIENTRY glUniform2i(GLint, GLint, GLint);
+    extern void APIENTRY glUniform3i(GLint, GLint, GLint, GLint);
+    extern void APIENTRY glUniform4i(GLint, GLint, GLint, GLint, GLint);
+    extern void APIENTRY glUniform1fv(GLint, GLsizei, const GLfloat *);
+    extern void APIENTRY glUniform2fv(GLint, GLsizei, const GLfloat *);
+    extern void APIENTRY glUniform3fv(GLint, GLsizei, const GLfloat *);
+    extern void APIENTRY glUniform4fv(GLint, GLsizei, const GLfloat *);
+    extern void APIENTRY glUniform1iv(GLint, GLsizei, const GLint *);
+    extern void APIENTRY glUniform2iv(GLint, GLsizei, const GLint *);
+    extern void APIENTRY glUniform3iv(GLint, GLsizei, const GLint *);
+    extern void APIENTRY glUniform4iv(GLint, GLsizei, const GLint *);
+    extern void APIENTRY glUniformMatrix2fv(GLint, GLsizei, GLboolean, const GLfloat *);
+    extern void APIENTRY glUniformMatrix3fv(GLint, GLsizei, GLboolean, const GLfloat *);
+    extern void APIENTRY glUniformMatrix4fv(GLint, GLsizei, GLboolean, const GLfloat *);
+    extern void APIENTRY glValidateProgram(GLuint);
+    extern void APIENTRY glVertexAttrib1d(GLuint, GLdouble);
+    extern void APIENTRY glVertexAttrib1dv(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib1f(GLuint, GLfloat);
+    extern void APIENTRY glVertexAttrib1fv(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib1s(GLuint, GLshort);
+    extern void APIENTRY glVertexAttrib1sv(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib2d(GLuint, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib2dv(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib2f(GLuint, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib2fv(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib2s(GLuint, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib2sv(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib3d(GLuint, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib3dv(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib3f(GLuint, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib3fv(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib3s(GLuint, GLshort, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib3sv(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib4Nbv(GLuint, const GLbyte *);
+    extern void APIENTRY glVertexAttrib4Niv(GLuint, const GLint *);
+    extern void APIENTRY glVertexAttrib4Nsv(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib4Nub(GLuint, GLubyte, GLubyte, GLubyte, GLubyte);
+    extern void APIENTRY glVertexAttrib4Nubv(GLuint, const GLubyte *);
+    extern void APIENTRY glVertexAttrib4Nuiv(GLuint, const GLuint *);
+    extern void APIENTRY glVertexAttrib4Nusv(GLuint, const GLushort *);
+    extern void APIENTRY glVertexAttrib4bv(GLuint, const GLbyte *);
+    extern void APIENTRY glVertexAttrib4d(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib4dv(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib4f(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib4fv(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib4iv(GLuint, const GLint *);
+    extern void APIENTRY glVertexAttrib4s(GLuint, GLshort, GLshort, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib4sv(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib4ubv(GLuint, const GLubyte *);
+    extern void APIENTRY glVertexAttrib4uiv(GLuint, const GLuint *);
+    extern void APIENTRY glVertexAttrib4usv(GLuint, const GLushort *);
+    extern void APIENTRY glVertexAttribPointer(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
+    typedef void (APIENTRYP PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum *bufs);
+    typedef void (APIENTRYP PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+    typedef void (APIENTRYP PFNGLSTENCILFUNCSEPARATEPROC)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
+    typedef void (APIENTRYP PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
+    typedef void (APIENTRYP PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
+    typedef void (APIENTRYP PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar *name);
+    typedef void (APIENTRYP PFNGLCOMPILESHADERPROC)(GLuint shader);
+    typedef GLuint(APIENTRYP PFNGLCREATEPROGRAMPROC)(void);
+    typedef GLuint(APIENTRYP PFNGLCREATESHADERPROC)(GLenum type);
+    typedef void (APIENTRYP PFNGLDELETEPROGRAMPROC)(GLuint program);
+    typedef void (APIENTRYP PFNGLDELETESHADERPROC)(GLuint shader);
+    typedef void (APIENTRYP PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
+    typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
+    typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
+    typedef void (APIENTRYP PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
+    typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
+    typedef void (APIENTRYP PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj);
+    typedef GLint(APIENTRYP PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar *name);
+    typedef void (APIENTRYP PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
+    typedef void (APIENTRYP PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
+    typedef void (APIENTRYP PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
+    typedef GLint(APIENTRYP PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar *name);
+    typedef void (APIENTRYP PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, GLvoid* *pointer);
+    typedef GLboolean(APIENTRYP PFNGLISPROGRAMPROC)(GLuint program);
+    typedef GLboolean(APIENTRYP PFNGLISSHADERPROC)(GLuint shader);
+    typedef void (APIENTRYP PFNGLLINKPROGRAMPROC)(GLuint program);
+    typedef void (APIENTRYP PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar* *string, const GLint *length);
+    typedef void (APIENTRYP PFNGLUSEPROGRAMPROC)(GLuint program);
+    typedef void (APIENTRYP PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
+    typedef void (APIENTRYP PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
+    typedef void (APIENTRYP PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+    typedef void (APIENTRYP PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+    typedef void (APIENTRYP PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
+    typedef void (APIENTRYP PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
+    typedef void (APIENTRYP PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
+    typedef void (APIENTRYP PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+    typedef void (APIENTRYP PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPROC)(GLuint program);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_VERSION_2_1
+#define GL_VERSION_2_1 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    extern void APIENTRY glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    extern void APIENTRY glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    extern void APIENTRY glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    extern void APIENTRY glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    extern void APIENTRY glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+#endif
+
+#ifndef GL_ARB_multitexture
+#define GL_ARB_multitexture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glActiveTextureARB(GLenum);
+    extern void APIENTRY glClientActiveTextureARB(GLenum);
+    extern void APIENTRY glMultiTexCoord1dARB(GLenum, GLdouble);
+    extern void APIENTRY glMultiTexCoord1dvARB(GLenum, const GLdouble *);
+    extern void APIENTRY glMultiTexCoord1fARB(GLenum, GLfloat);
+    extern void APIENTRY glMultiTexCoord1fvARB(GLenum, const GLfloat *);
+    extern void APIENTRY glMultiTexCoord1iARB(GLenum, GLint);
+    extern void APIENTRY glMultiTexCoord1ivARB(GLenum, const GLint *);
+    extern void APIENTRY glMultiTexCoord1sARB(GLenum, GLshort);
+    extern void APIENTRY glMultiTexCoord1svARB(GLenum, const GLshort *);
+    extern void APIENTRY glMultiTexCoord2dARB(GLenum, GLdouble, GLdouble);
+    extern void APIENTRY glMultiTexCoord2dvARB(GLenum, const GLdouble *);
+    extern void APIENTRY glMultiTexCoord2fARB(GLenum, GLfloat, GLfloat);
+    extern void APIENTRY glMultiTexCoord2fvARB(GLenum, const GLfloat *);
+    extern void APIENTRY glMultiTexCoord2iARB(GLenum, GLint, GLint);
+    extern void APIENTRY glMultiTexCoord2ivARB(GLenum, const GLint *);
+    extern void APIENTRY glMultiTexCoord2sARB(GLenum, GLshort, GLshort);
+    extern void APIENTRY glMultiTexCoord2svARB(GLenum, const GLshort *);
+    extern void APIENTRY glMultiTexCoord3dARB(GLenum, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glMultiTexCoord3dvARB(GLenum, const GLdouble *);
+    extern void APIENTRY glMultiTexCoord3fARB(GLenum, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glMultiTexCoord3fvARB(GLenum, const GLfloat *);
+    extern void APIENTRY glMultiTexCoord3iARB(GLenum, GLint, GLint, GLint);
+    extern void APIENTRY glMultiTexCoord3ivARB(GLenum, const GLint *);
+    extern void APIENTRY glMultiTexCoord3sARB(GLenum, GLshort, GLshort, GLshort);
+    extern void APIENTRY glMultiTexCoord3svARB(GLenum, const GLshort *);
+    extern void APIENTRY glMultiTexCoord4dARB(GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glMultiTexCoord4dvARB(GLenum, const GLdouble *);
+    extern void APIENTRY glMultiTexCoord4fARB(GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glMultiTexCoord4fvARB(GLenum, const GLfloat *);
+    extern void APIENTRY glMultiTexCoord4iARB(GLenum, GLint, GLint, GLint, GLint);
+    extern void APIENTRY glMultiTexCoord4ivARB(GLenum, const GLint *);
+    extern void APIENTRY glMultiTexCoord4sARB(GLenum, GLshort, GLshort, GLshort, GLshort);
+    extern void APIENTRY glMultiTexCoord4svARB(GLenum, const GLshort *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLACTIVETEXTUREARBPROC)(GLenum texture);
+    typedef void (APIENTRYP PFNGLCLIENTACTIVETEXTUREARBPROC)(GLenum texture);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1DARBPROC)(GLenum target, GLdouble s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1DVARBPROC)(GLenum target, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1FARBPROC)(GLenum target, GLfloat s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1FVARBPROC)(GLenum target, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1IARBPROC)(GLenum target, GLint s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1IVARBPROC)(GLenum target, const GLint *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1SARBPROC)(GLenum target, GLshort s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1SVARBPROC)(GLenum target, const GLshort *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2DARBPROC)(GLenum target, GLdouble s, GLdouble t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2DVARBPROC)(GLenum target, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2FARBPROC)(GLenum target, GLfloat s, GLfloat t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2FVARBPROC)(GLenum target, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2IARBPROC)(GLenum target, GLint s, GLint t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2IVARBPROC)(GLenum target, const GLint *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2SARBPROC)(GLenum target, GLshort s, GLshort t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2SVARBPROC)(GLenum target, const GLshort *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3DVARBPROC)(GLenum target, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3FVARBPROC)(GLenum target, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3IARBPROC)(GLenum target, GLint s, GLint t, GLint r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3IVARBPROC)(GLenum target, const GLint *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3SVARBPROC)(GLenum target, const GLshort *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4DVARBPROC)(GLenum target, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4FVARBPROC)(GLenum target, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4IARBPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4IVARBPROC)(GLenum target, const GLint *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4SVARBPROC)(GLenum target, const GLshort *v);
+#endif
+
+#ifndef GL_ARB_transpose_matrix
+#define GL_ARB_transpose_matrix 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glLoadTransposeMatrixfARB(const GLfloat *);
+    extern void APIENTRY glLoadTransposeMatrixdARB(const GLdouble *);
+    extern void APIENTRY glMultTransposeMatrixfARB(const GLfloat *);
+    extern void APIENTRY glMultTransposeMatrixdARB(const GLdouble *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLLOADTRANSPOSEMATRIXFARBPROC)(const GLfloat *m);
+    typedef void (APIENTRYP PFNGLLOADTRANSPOSEMATRIXDARBPROC)(const GLdouble *m);
+    typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXFARBPROC)(const GLfloat *m);
+    typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXDARBPROC)(const GLdouble *m);
+#endif
+
+#ifndef GL_ARB_multisample
+#define GL_ARB_multisample 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glSampleCoverageARB(GLclampf, GLboolean);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLSAMPLECOVERAGEARBPROC)(GLclampf value, GLboolean invert);
+#endif
+
+#ifndef GL_ARB_texture_env_add
+#define GL_ARB_texture_env_add 1
+#endif
+
+#ifndef GL_ARB_texture_cube_map
+#define GL_ARB_texture_cube_map 1
+#endif
+
+#ifndef GL_ARB_texture_compression
+#define GL_ARB_texture_compression 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glCompressedTexImage3DARB(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexImage2DARB(GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexImage1DARB(GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexSubImage3DARB(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexSubImage2DARB(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glCompressedTexSubImage1DARB(GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glGetCompressedTexImageARB(GLenum, GLint, GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint level, GLvoid *img);
+#endif
+
+#ifndef GL_ARB_texture_border_clamp
+#define GL_ARB_texture_border_clamp 1
+#endif
+
+#ifndef GL_ARB_point_parameters
+#define GL_ARB_point_parameters 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPointParameterfARB(GLenum, GLfloat);
+    extern void APIENTRY glPointParameterfvARB(GLenum, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERFARBPROC)(GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname, const GLfloat *params);
+#endif
+
+#ifndef GL_ARB_vertex_blend
+#define GL_ARB_vertex_blend 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glWeightbvARB(GLint, const GLbyte *);
+    extern void APIENTRY glWeightsvARB(GLint, const GLshort *);
+    extern void APIENTRY glWeightivARB(GLint, const GLint *);
+    extern void APIENTRY glWeightfvARB(GLint, const GLfloat *);
+    extern void APIENTRY glWeightdvARB(GLint, const GLdouble *);
+    extern void APIENTRY glWeightubvARB(GLint, const GLubyte *);
+    extern void APIENTRY glWeightusvARB(GLint, const GLushort *);
+    extern void APIENTRY glWeightuivARB(GLint, const GLuint *);
+    extern void APIENTRY glWeightPointerARB(GLint, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glVertexBlendARB(GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLWEIGHTBVARBPROC)(GLint size, const GLbyte *weights);
+    typedef void (APIENTRYP PFNGLWEIGHTSVARBPROC)(GLint size, const GLshort *weights);
+    typedef void (APIENTRYP PFNGLWEIGHTIVARBPROC)(GLint size, const GLint *weights);
+    typedef void (APIENTRYP PFNGLWEIGHTFVARBPROC)(GLint size, const GLfloat *weights);
+    typedef void (APIENTRYP PFNGLWEIGHTDVARBPROC)(GLint size, const GLdouble *weights);
+    typedef void (APIENTRYP PFNGLWEIGHTUBVARBPROC)(GLint size, const GLubyte *weights);
+    typedef void (APIENTRYP PFNGLWEIGHTUSVARBPROC)(GLint size, const GLushort *weights);
+    typedef void (APIENTRYP PFNGLWEIGHTUIVARBPROC)(GLint size, const GLuint *weights);
+    typedef void (APIENTRYP PFNGLWEIGHTPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLVERTEXBLENDARBPROC)(GLint count);
+#endif
+
+#ifndef GL_ARB_matrix_palette
+#define GL_ARB_matrix_palette 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glCurrentPaletteMatrixARB(GLint);
+    extern void APIENTRY glMatrixIndexubvARB(GLint, const GLubyte *);
+    extern void APIENTRY glMatrixIndexusvARB(GLint, const GLushort *);
+    extern void APIENTRY glMatrixIndexuivARB(GLint, const GLuint *);
+    extern void APIENTRY glMatrixIndexPointerARB(GLint, GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCURRENTPALETTEMATRIXARBPROC)(GLint index);
+    typedef void (APIENTRYP PFNGLMATRIXINDEXUBVARBPROC)(GLint size, const GLubyte *indices);
+    typedef void (APIENTRYP PFNGLMATRIXINDEXUSVARBPROC)(GLint size, const GLushort *indices);
+    typedef void (APIENTRYP PFNGLMATRIXINDEXUIVARBPROC)(GLint size, const GLuint *indices);
+    typedef void (APIENTRYP PFNGLMATRIXINDEXPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_ARB_texture_env_combine
+#define GL_ARB_texture_env_combine 1
+#endif
+
+#ifndef GL_ARB_texture_env_crossbar
+#define GL_ARB_texture_env_crossbar 1
+#endif
+
+#ifndef GL_ARB_texture_env_dot3
+#define GL_ARB_texture_env_dot3 1
+#endif
+
+#ifndef GL_ARB_texture_mirrored_repeat
+#define GL_ARB_texture_mirrored_repeat 1
+#endif
+
+#ifndef GL_ARB_depth_texture
+#define GL_ARB_depth_texture 1
+#endif
+
+#ifndef GL_ARB_shadow
+#define GL_ARB_shadow 1
+#endif
+
+#ifndef GL_ARB_shadow_ambient
+#define GL_ARB_shadow_ambient 1
+#endif
+
+#ifndef GL_ARB_window_pos
+#define GL_ARB_window_pos 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glWindowPos2dARB(GLdouble, GLdouble);
+    extern void APIENTRY glWindowPos2dvARB(const GLdouble *);
+    extern void APIENTRY glWindowPos2fARB(GLfloat, GLfloat);
+    extern void APIENTRY glWindowPos2fvARB(const GLfloat *);
+    extern void APIENTRY glWindowPos2iARB(GLint, GLint);
+    extern void APIENTRY glWindowPos2ivARB(const GLint *);
+    extern void APIENTRY glWindowPos2sARB(GLshort, GLshort);
+    extern void APIENTRY glWindowPos2svARB(const GLshort *);
+    extern void APIENTRY glWindowPos3dARB(GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glWindowPos3dvARB(const GLdouble *);
+    extern void APIENTRY glWindowPos3fARB(GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glWindowPos3fvARB(const GLfloat *);
+    extern void APIENTRY glWindowPos3iARB(GLint, GLint, GLint);
+    extern void APIENTRY glWindowPos3ivARB(const GLint *);
+    extern void APIENTRY glWindowPos3sARB(GLshort, GLshort, GLshort);
+    extern void APIENTRY glWindowPos3svARB(const GLshort *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLWINDOWPOS2DARBPROC)(GLdouble x, GLdouble y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2DVARBPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2FARBPROC)(GLfloat x, GLfloat y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2FVARBPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2IARBPROC)(GLint x, GLint y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2IVARBPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2SARBPROC)(GLshort x, GLshort y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2SVARBPROC)(const GLshort *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3DARBPROC)(GLdouble x, GLdouble y, GLdouble z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3DVARBPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3FARBPROC)(GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3FVARBPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3IARBPROC)(GLint x, GLint y, GLint z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3IVARBPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3SARBPROC)(GLshort x, GLshort y, GLshort z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3SVARBPROC)(const GLshort *v);
+#endif
+
+#ifndef GL_ARB_vertex_program
+#define GL_ARB_vertex_program 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glVertexAttrib1dARB(GLuint, GLdouble);
+    extern void APIENTRY glVertexAttrib1dvARB(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib1fARB(GLuint, GLfloat);
+    extern void APIENTRY glVertexAttrib1fvARB(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib1sARB(GLuint, GLshort);
+    extern void APIENTRY glVertexAttrib1svARB(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib2dARB(GLuint, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib2dvARB(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib2fARB(GLuint, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib2fvARB(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib2sARB(GLuint, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib2svARB(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib3dARB(GLuint, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib3dvARB(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib3fARB(GLuint, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib3fvARB(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib3sARB(GLuint, GLshort, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib3svARB(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib4NbvARB(GLuint, const GLbyte *);
+    extern void APIENTRY glVertexAttrib4NivARB(GLuint, const GLint *);
+    extern void APIENTRY glVertexAttrib4NsvARB(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib4NubARB(GLuint, GLubyte, GLubyte, GLubyte, GLubyte);
+    extern void APIENTRY glVertexAttrib4NubvARB(GLuint, const GLubyte *);
+    extern void APIENTRY glVertexAttrib4NuivARB(GLuint, const GLuint *);
+    extern void APIENTRY glVertexAttrib4NusvARB(GLuint, const GLushort *);
+    extern void APIENTRY glVertexAttrib4bvARB(GLuint, const GLbyte *);
+    extern void APIENTRY glVertexAttrib4dARB(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib4dvARB(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib4fARB(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib4fvARB(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib4ivARB(GLuint, const GLint *);
+    extern void APIENTRY glVertexAttrib4sARB(GLuint, GLshort, GLshort, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib4svARB(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib4ubvARB(GLuint, const GLubyte *);
+    extern void APIENTRY glVertexAttrib4uivARB(GLuint, const GLuint *);
+    extern void APIENTRY glVertexAttrib4usvARB(GLuint, const GLushort *);
+    extern void APIENTRY glVertexAttribPointerARB(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *);
+    extern void APIENTRY glEnableVertexAttribArrayARB(GLuint);
+    extern void APIENTRY glDisableVertexAttribArrayARB(GLuint);
+    extern void APIENTRY glProgramStringARB(GLenum, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glBindProgramARB(GLenum, GLuint);
+    extern void APIENTRY glDeleteProgramsARB(GLsizei, const GLuint *);
+    extern void APIENTRY glGenProgramsARB(GLsizei, GLuint *);
+    extern void APIENTRY glProgramEnvParameter4dARB(GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glProgramEnvParameter4dvARB(GLenum, GLuint, const GLdouble *);
+    extern void APIENTRY glProgramEnvParameter4fARB(GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glProgramEnvParameter4fvARB(GLenum, GLuint, const GLfloat *);
+    extern void APIENTRY glProgramLocalParameter4dARB(GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glProgramLocalParameter4dvARB(GLenum, GLuint, const GLdouble *);
+    extern void APIENTRY glProgramLocalParameter4fARB(GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glProgramLocalParameter4fvARB(GLenum, GLuint, const GLfloat *);
+    extern void APIENTRY glGetProgramEnvParameterdvARB(GLenum, GLuint, GLdouble *);
+    extern void APIENTRY glGetProgramEnvParameterfvARB(GLenum, GLuint, GLfloat *);
+    extern void APIENTRY glGetProgramLocalParameterdvARB(GLenum, GLuint, GLdouble *);
+    extern void APIENTRY glGetProgramLocalParameterfvARB(GLenum, GLuint, GLfloat *);
+    extern void APIENTRY glGetProgramivARB(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetProgramStringARB(GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetVertexAttribdvARB(GLuint, GLenum, GLdouble *);
+    extern void APIENTRY glGetVertexAttribfvARB(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetVertexAttribivARB(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetVertexAttribPointervARB(GLuint, GLenum, GLvoid* *);
+    extern GLboolean APIENTRY glIsProgramARB(GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1DARBPROC)(GLuint index, GLdouble x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVARBPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1FARBPROC)(GLuint index, GLfloat x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVARBPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1SARBPROC)(GLuint index, GLshort x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2DARBPROC)(GLuint index, GLdouble x, GLdouble y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVARBPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2FARBPROC)(GLuint index, GLfloat x, GLfloat y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVARBPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2SARBPROC)(GLuint index, GLshort x, GLshort y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVARBPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVARBPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NBVARBPROC)(GLuint index, const GLbyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NIVARBPROC)(GLuint index, const GLint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NSVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBARBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBVARBPROC)(GLuint index, const GLubyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUIVARBPROC)(GLuint index, const GLuint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUSVARBPROC)(GLuint index, const GLushort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4BVARBPROC)(GLuint index, const GLbyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVARBPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVARBPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4IVARBPROC)(GLuint index, const GLint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVARBPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVARBPROC)(GLuint index, const GLubyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVARBPROC)(GLuint index, const GLuint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVARBPROC)(GLuint index, const GLushort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERARBPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
+    typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
+    typedef void (APIENTRYP PFNGLPROGRAMSTRINGARBPROC)(GLenum target, GLenum format, GLsizei len, const GLvoid *string);
+    typedef void (APIENTRYP PFNGLBINDPROGRAMARBPROC)(GLenum target, GLuint program);
+    typedef void (APIENTRYP PFNGLDELETEPROGRAMSARBPROC)(GLsizei n, const GLuint *programs);
+    typedef void (APIENTRYP PFNGLGENPROGRAMSARBPROC)(GLsizei n, GLuint *programs);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble *params);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble *params);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMENVPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMENVPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMIVARBPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMSTRINGARBPROC)(GLenum target, GLenum pname, GLvoid *string);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVARBPROC)(GLuint index, GLenum pname, GLdouble *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVARBPROC)(GLuint index, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVARBPROC)(GLuint index, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVARBPROC)(GLuint index, GLenum pname, GLvoid* *pointer);
+    typedef GLboolean(APIENTRYP PFNGLISPROGRAMARBPROC)(GLuint program);
+#endif
+
+#ifndef GL_ARB_fragment_program
+#define GL_ARB_fragment_program 1
+    /* All ARB_fragment_program entry points are shared with ARB_vertex_program. */
+#endif
+
+#ifndef GL_ARB_vertex_buffer_object
+#define GL_ARB_vertex_buffer_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBindBufferARB(GLenum, GLuint);
+    extern void APIENTRY glDeleteBuffersARB(GLsizei, const GLuint *);
+    extern void APIENTRY glGenBuffersARB(GLsizei, GLuint *);
+    extern GLboolean APIENTRY glIsBufferARB(GLuint);
+    extern void APIENTRY glBufferDataARB(GLenum, GLsizeiptrARB, const GLvoid *, GLenum);
+    extern void APIENTRY glBufferSubDataARB(GLenum, GLintptrARB, GLsizeiptrARB, const GLvoid *);
+    extern void APIENTRY glGetBufferSubDataARB(GLenum, GLintptrARB, GLsizeiptrARB, GLvoid *);
+    extern GLvoid *APIENTRY glMapBufferARB(GLenum, GLenum);
+    extern GLboolean APIENTRY glUnmapBufferARB(GLenum);
+    extern void APIENTRY glGetBufferParameterivARB(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetBufferPointervARB(GLenum, GLenum, GLvoid* *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBINDBUFFERARBPROC)(GLenum target, GLuint buffer);
+    typedef void (APIENTRYP PFNGLDELETEBUFFERSARBPROC)(GLsizei n, const GLuint *buffers);
+    typedef void (APIENTRYP PFNGLGENBUFFERSARBPROC)(GLsizei n, GLuint *buffers);
+    typedef GLboolean(APIENTRYP PFNGLISBUFFERARBPROC)(GLuint buffer);
+    typedef void (APIENTRYP PFNGLBUFFERDATAARBPROC)(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+    typedef void (APIENTRYP PFNGLBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+    typedef GLvoid *(APIENTRYP PFNGLMAPBUFFERARBPROC)(GLenum target, GLenum access);
+    typedef GLboolean(APIENTRYP PFNGLUNMAPBUFFERARBPROC)(GLenum target);
+    typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVARBPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVARBPROC)(GLenum target, GLenum pname, GLvoid* *params);
+#endif
+
+#ifndef GL_ARB_occlusion_query
+#define GL_ARB_occlusion_query 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGenQueriesARB(GLsizei, GLuint *);
+    extern void APIENTRY glDeleteQueriesARB(GLsizei, const GLuint *);
+    extern GLboolean APIENTRY glIsQueryARB(GLuint);
+    extern void APIENTRY glBeginQueryARB(GLenum, GLuint);
+    extern void APIENTRY glEndQueryARB(GLenum);
+    extern void APIENTRY glGetQueryivARB(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetQueryObjectivARB(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetQueryObjectuivARB(GLuint, GLenum, GLuint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGENQUERIESARBPROC)(GLsizei n, GLuint *ids);
+    typedef void (APIENTRYP PFNGLDELETEQUERIESARBPROC)(GLsizei n, const GLuint *ids);
+    typedef GLboolean(APIENTRYP PFNGLISQUERYARBPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLBEGINQUERYARBPROC)(GLenum target, GLuint id);
+    typedef void (APIENTRYP PFNGLENDQUERYARBPROC)(GLenum target);
+    typedef void (APIENTRYP PFNGLGETQUERYIVARBPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETQUERYOBJECTIVARBPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETQUERYOBJECTUIVARBPROC)(GLuint id, GLenum pname, GLuint *params);
+#endif
+
+#ifndef GL_ARB_shader_objects
+#define GL_ARB_shader_objects 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDeleteObjectARB(GLhandleARB);
+    extern GLhandleARB APIENTRY glGetHandleARB(GLenum);
+    extern void APIENTRY glDetachObjectARB(GLhandleARB, GLhandleARB);
+    extern GLhandleARB APIENTRY glCreateShaderObjectARB(GLenum);
+    extern void APIENTRY glShaderSourceARB(GLhandleARB, GLsizei, const GLcharARB* *, const GLint *);
+    extern void APIENTRY glCompileShaderARB(GLhandleARB);
+    extern GLhandleARB APIENTRY glCreateProgramObjectARB(void);
+    extern void APIENTRY glAttachObjectARB(GLhandleARB, GLhandleARB);
+    extern void APIENTRY glLinkProgramARB(GLhandleARB);
+    extern void APIENTRY glUseProgramObjectARB(GLhandleARB);
+    extern void APIENTRY glValidateProgramARB(GLhandleARB);
+    extern void APIENTRY glUniform1fARB(GLint, GLfloat);
+    extern void APIENTRY glUniform2fARB(GLint, GLfloat, GLfloat);
+    extern void APIENTRY glUniform3fARB(GLint, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glUniform4fARB(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glUniform1iARB(GLint, GLint);
+    extern void APIENTRY glUniform2iARB(GLint, GLint, GLint);
+    extern void APIENTRY glUniform3iARB(GLint, GLint, GLint, GLint);
+    extern void APIENTRY glUniform4iARB(GLint, GLint, GLint, GLint, GLint);
+    extern void APIENTRY glUniform1fvARB(GLint, GLsizei, const GLfloat *);
+    extern void APIENTRY glUniform2fvARB(GLint, GLsizei, const GLfloat *);
+    extern void APIENTRY glUniform3fvARB(GLint, GLsizei, const GLfloat *);
+    extern void APIENTRY glUniform4fvARB(GLint, GLsizei, const GLfloat *);
+    extern void APIENTRY glUniform1ivARB(GLint, GLsizei, const GLint *);
+    extern void APIENTRY glUniform2ivARB(GLint, GLsizei, const GLint *);
+    extern void APIENTRY glUniform3ivARB(GLint, GLsizei, const GLint *);
+    extern void APIENTRY glUniform4ivARB(GLint, GLsizei, const GLint *);
+    extern void APIENTRY glUniformMatrix2fvARB(GLint, GLsizei, GLboolean, const GLfloat *);
+    extern void APIENTRY glUniformMatrix3fvARB(GLint, GLsizei, GLboolean, const GLfloat *);
+    extern void APIENTRY glUniformMatrix4fvARB(GLint, GLsizei, GLboolean, const GLfloat *);
+    extern void APIENTRY glGetObjectParameterfvARB(GLhandleARB, GLenum, GLfloat *);
+    extern void APIENTRY glGetObjectParameterivARB(GLhandleARB, GLenum, GLint *);
+    extern void APIENTRY glGetInfoLogARB(GLhandleARB, GLsizei, GLsizei *, GLcharARB *);
+    extern void APIENTRY glGetAttachedObjectsARB(GLhandleARB, GLsizei, GLsizei *, GLhandleARB *);
+    extern GLint APIENTRY glGetUniformLocationARB(GLhandleARB, const GLcharARB *);
+    extern void APIENTRY glGetActiveUniformARB(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *);
+    extern void APIENTRY glGetUniformfvARB(GLhandleARB, GLint, GLfloat *);
+    extern void APIENTRY glGetUniformivARB(GLhandleARB, GLint, GLint *);
+    extern void APIENTRY glGetShaderSourceARB(GLhandleARB, GLsizei, GLsizei *, GLcharARB *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDELETEOBJECTARBPROC)(GLhandleARB obj);
+    typedef GLhandleARB(APIENTRYP PFNGLGETHANDLEARBPROC)(GLenum pname);
+    typedef void (APIENTRYP PFNGLDETACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB attachedObj);
+    typedef GLhandleARB(APIENTRYP PFNGLCREATESHADEROBJECTARBPROC)(GLenum shaderType);
+    typedef void (APIENTRYP PFNGLSHADERSOURCEARBPROC)(GLhandleARB shaderObj, GLsizei count, const GLcharARB* *string, const GLint *length);
+    typedef void (APIENTRYP PFNGLCOMPILESHADERARBPROC)(GLhandleARB shaderObj);
+    typedef GLhandleARB(APIENTRYP PFNGLCREATEPROGRAMOBJECTARBPROC)(void);
+    typedef void (APIENTRYP PFNGLATTACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB obj);
+    typedef void (APIENTRYP PFNGLLINKPROGRAMARBPROC)(GLhandleARB programObj);
+    typedef void (APIENTRYP PFNGLUSEPROGRAMOBJECTARBPROC)(GLhandleARB programObj);
+    typedef void (APIENTRYP PFNGLVALIDATEPROGRAMARBPROC)(GLhandleARB programObj);
+    typedef void (APIENTRYP PFNGLUNIFORM1FARBPROC)(GLint location, GLfloat v0);
+    typedef void (APIENTRYP PFNGLUNIFORM2FARBPROC)(GLint location, GLfloat v0, GLfloat v1);
+    typedef void (APIENTRYP PFNGLUNIFORM3FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+    typedef void (APIENTRYP PFNGLUNIFORM4FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+    typedef void (APIENTRYP PFNGLUNIFORM1IARBPROC)(GLint location, GLint v0);
+    typedef void (APIENTRYP PFNGLUNIFORM2IARBPROC)(GLint location, GLint v0, GLint v1);
+    typedef void (APIENTRYP PFNGLUNIFORM3IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2);
+    typedef void (APIENTRYP PFNGLUNIFORM4IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+    typedef void (APIENTRYP PFNGLUNIFORM1FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORM2FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORM3FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORM4FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORM1IVARBPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM2IVARBPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM3IVARBPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM4IVARBPROC)(GLint location, GLsizei count, const GLint *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX2FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX3FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLUNIFORMMATRIX4FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+    typedef void (APIENTRYP PFNGLGETOBJECTPARAMETERFVARBPROC)(GLhandleARB obj, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETOBJECTPARAMETERIVARBPROC)(GLhandleARB obj, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETINFOLOGARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
+    typedef void (APIENTRYP PFNGLGETATTACHEDOBJECTSARBPROC)(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
+    typedef GLint(APIENTRYP PFNGLGETUNIFORMLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB *name);
+    typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+    typedef void (APIENTRYP PFNGLGETUNIFORMFVARBPROC)(GLhandleARB programObj, GLint location, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETUNIFORMIVARBPROC)(GLhandleARB programObj, GLint location, GLint *params);
+    typedef void (APIENTRYP PFNGLGETSHADERSOURCEARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
+#endif
+
+#ifndef GL_ARB_vertex_shader
+#define GL_ARB_vertex_shader 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBindAttribLocationARB(GLhandleARB, GLuint, const GLcharARB *);
+    extern void APIENTRY glGetActiveAttribARB(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *);
+    extern GLint APIENTRY glGetAttribLocationARB(GLhandleARB, const GLcharARB *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBINDATTRIBLOCATIONARBPROC)(GLhandleARB programObj, GLuint index, const GLcharARB *name);
+    typedef void (APIENTRYP PFNGLGETACTIVEATTRIBARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+    typedef GLint(APIENTRYP PFNGLGETATTRIBLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB *name);
+#endif
+
+#ifndef GL_ARB_fragment_shader
+#define GL_ARB_fragment_shader 1
+#endif
+
+#ifndef GL_ARB_shading_language_100
+#define GL_ARB_shading_language_100 1
+#endif
+
+#ifndef GL_ARB_texture_non_power_of_two
+#define GL_ARB_texture_non_power_of_two 1
+#endif
+
+#ifndef GL_ARB_point_sprite
+#define GL_ARB_point_sprite 1
+#endif
+
+#ifndef GL_ARB_fragment_program_shadow
+#define GL_ARB_fragment_program_shadow 1
+#endif
+
+#ifndef GL_ARB_draw_buffers
+#define GL_ARB_draw_buffers 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDrawBuffersARB(GLsizei, const GLenum *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDRAWBUFFERSARBPROC)(GLsizei n, const GLenum *bufs);
+#endif
+
+#ifndef GL_ARB_texture_rectangle
+#define GL_ARB_texture_rectangle 1
+#endif
+
+#ifndef GL_ARB_color_buffer_float
+#define GL_ARB_color_buffer_float 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glClampColorARB(GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCLAMPCOLORARBPROC)(GLenum target, GLenum clamp);
+#endif
+
+#ifndef GL_ARB_half_float_pixel
+#define GL_ARB_half_float_pixel 1
+#endif
+
+#ifndef GL_ARB_texture_float
+#define GL_ARB_texture_float 1
+#endif
+
+#ifndef GL_ARB_pixel_buffer_object
+#define GL_ARB_pixel_buffer_object 1
+#endif
+
+#ifndef GL_EXT_abgr
+#define GL_EXT_abgr 1
+#endif
+
+#ifndef GL_EXT_blend_color
+#define GL_EXT_blend_color 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlendColorEXT(GLclampf, GLclampf, GLclampf, GLclampf);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLENDCOLOREXTPROC)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+#endif
+
+#ifndef GL_EXT_polygon_offset
+#define GL_EXT_polygon_offset 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPolygonOffsetEXT(GLfloat, GLfloat);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPOLYGONOFFSETEXTPROC)(GLfloat factor, GLfloat bias);
+#endif
+
+#ifndef GL_EXT_texture
+#define GL_EXT_texture 1
+#endif
+
+#ifndef GL_EXT_texture3D
+#define GL_EXT_texture3D 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTexImage3DEXT(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glTexSubImage3DEXT(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTEXIMAGE3DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+    typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+#endif
+
+#ifndef GL_SGIS_texture_filter4
+#define GL_SGIS_texture_filter4 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGetTexFilterFuncSGIS(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glTexFilterFuncSGIS(GLenum, GLenum, GLsizei, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGETTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLfloat *weights);
+    typedef void (APIENTRYP PFNGLTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);
+#endif
+
+#ifndef GL_EXT_subtexture
+#define GL_EXT_subtexture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTexSubImage1DEXT(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glTexSubImage2DEXT(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
+    typedef void (APIENTRYP PFNGLTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+#endif
+
+#ifndef GL_EXT_copy_texture
+#define GL_EXT_copy_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glCopyTexImage1DEXT(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
+    extern void APIENTRY glCopyTexImage2DEXT(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
+    extern void APIENTRY glCopyTexSubImage1DEXT(GLenum, GLint, GLint, GLint, GLint, GLsizei);
+    extern void APIENTRY glCopyTexSubImage2DEXT(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+    extern void APIENTRY glCopyTexSubImage3DEXT(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOPYTEXIMAGE1DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
+    typedef void (APIENTRYP PFNGLCOPYTEXIMAGE2DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+    typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
+    typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+#endif
+
+#ifndef GL_EXT_histogram
+#define GL_EXT_histogram 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGetHistogramEXT(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetHistogramParameterfvEXT(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetHistogramParameterivEXT(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetMinmaxEXT(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetMinmaxParameterfvEXT(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetMinmaxParameterivEXT(GLenum, GLenum, GLint *);
+    extern void APIENTRY glHistogramEXT(GLenum, GLsizei, GLenum, GLboolean);
+    extern void APIENTRY glMinmaxEXT(GLenum, GLenum, GLboolean);
+    extern void APIENTRY glResetHistogramEXT(GLenum);
+    extern void APIENTRY glResetMinmaxEXT(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGETHISTOGRAMEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+    typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETMINMAXEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+    typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLHISTOGRAMEXTPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
+    typedef void (APIENTRYP PFNGLMINMAXEXTPROC)(GLenum target, GLenum internalformat, GLboolean sink);
+    typedef void (APIENTRYP PFNGLRESETHISTOGRAMEXTPROC)(GLenum target);
+    typedef void (APIENTRYP PFNGLRESETMINMAXEXTPROC)(GLenum target);
+#endif
+
+#ifndef GL_EXT_convolution
+#define GL_EXT_convolution 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glConvolutionFilter1DEXT(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glConvolutionFilter2DEXT(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glConvolutionParameterfEXT(GLenum, GLenum, GLfloat);
+    extern void APIENTRY glConvolutionParameterfvEXT(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glConvolutionParameteriEXT(GLenum, GLenum, GLint);
+    extern void APIENTRY glConvolutionParameterivEXT(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glCopyConvolutionFilter1DEXT(GLenum, GLenum, GLint, GLint, GLsizei);
+    extern void APIENTRY glCopyConvolutionFilter2DEXT(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
+    extern void APIENTRY glGetConvolutionFilterEXT(GLenum, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetConvolutionParameterfvEXT(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetConvolutionParameterivEXT(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetSeparableFilterEXT(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
+    extern void APIENTRY glSeparableFilter2DEXT(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat params);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint params);
+    typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+    typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
+    typedef void (APIENTRYP PFNGLGETCONVOLUTIONFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, GLvoid *image);
+    typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETSEPARABLEFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
+    typedef void (APIENTRYP PFNGLSEPARABLEFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
+#endif
+
+#ifndef GL_EXT_color_matrix
+#define GL_EXT_color_matrix 1
+#endif
+
+#ifndef GL_SGI_color_table
+#define GL_SGI_color_table 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glColorTableSGI(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glColorTableParameterfvSGI(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glColorTableParameterivSGI(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glCopyColorTableSGI(GLenum, GLenum, GLint, GLint, GLsizei);
+    extern void APIENTRY glGetColorTableSGI(GLenum, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetColorTableParameterfvSGI(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetColorTableParameterivSGI(GLenum, GLenum, GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOLORTABLESGIPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+    typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLCOPYCOLORTABLESGIPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLESGIPROC)(GLenum target, GLenum format, GLenum type, GLvoid *table);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname, GLint *params);
+#endif
+
+#ifndef GL_SGIX_pixel_texture
+#define GL_SGIX_pixel_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPixelTexGenSGIX(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPIXELTEXGENSGIXPROC)(GLenum mode);
+#endif
+
+#ifndef GL_SGIS_pixel_texture
+#define GL_SGIS_pixel_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPixelTexGenParameteriSGIS(GLenum, GLint);
+    extern void APIENTRY glPixelTexGenParameterivSGIS(GLenum, const GLint *);
+    extern void APIENTRY glPixelTexGenParameterfSGIS(GLenum, GLfloat);
+    extern void APIENTRY glPixelTexGenParameterfvSGIS(GLenum, const GLfloat *);
+    extern void APIENTRY glGetPixelTexGenParameterivSGIS(GLenum, GLint *);
+    extern void APIENTRY glGetPixelTexGenParameterfvSGIS(GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPIXELTEXGENPARAMETERISGISPROC)(GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLPIXELTEXGENPARAMETERIVSGISPROC)(GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLPIXELTEXGENPARAMETERFSGISPROC)(GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLPIXELTEXGENPARAMETERFVSGISPROC)(GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC)(GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC)(GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_SGIS_texture4D
+#define GL_SGIS_texture4D 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTexImage4DSGIS(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glTexSubImage4DSGIS(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTEXIMAGE4DSGISPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+    typedef void (APIENTRYP PFNGLTEXSUBIMAGE4DSGISPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
+#endif
+
+#ifndef GL_SGI_texture_color_table
+#define GL_SGI_texture_color_table 1
+#endif
+
+#ifndef GL_EXT_cmyka
+#define GL_EXT_cmyka 1
+#endif
+
+#ifndef GL_EXT_texture_object
+#define GL_EXT_texture_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern GLboolean APIENTRY glAreTexturesResidentEXT(GLsizei, const GLuint *, GLboolean *);
+    extern void APIENTRY glBindTextureEXT(GLenum, GLuint);
+    extern void APIENTRY glDeleteTexturesEXT(GLsizei, const GLuint *);
+    extern void APIENTRY glGenTexturesEXT(GLsizei, GLuint *);
+    extern GLboolean APIENTRY glIsTextureEXT(GLuint);
+    extern void APIENTRY glPrioritizeTexturesEXT(GLsizei, const GLuint *, const GLclampf *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef GLboolean(APIENTRYP PFNGLARETEXTURESRESIDENTEXTPROC)(GLsizei n, const GLuint *textures, GLboolean *residences);
+    typedef void (APIENTRYP PFNGLBINDTEXTUREEXTPROC)(GLenum target, GLuint texture);
+    typedef void (APIENTRYP PFNGLDELETETEXTURESEXTPROC)(GLsizei n, const GLuint *textures);
+    typedef void (APIENTRYP PFNGLGENTEXTURESEXTPROC)(GLsizei n, GLuint *textures);
+    typedef GLboolean(APIENTRYP PFNGLISTEXTUREEXTPROC)(GLuint texture);
+    typedef void (APIENTRYP PFNGLPRIORITIZETEXTURESEXTPROC)(GLsizei n, const GLuint *textures, const GLclampf *priorities);
+#endif
+
+#ifndef GL_SGIS_detail_texture
+#define GL_SGIS_detail_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDetailTexFuncSGIS(GLenum, GLsizei, const GLfloat *);
+    extern void APIENTRY glGetDetailTexFuncSGIS(GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDETAILTEXFUNCSGISPROC)(GLenum target, GLsizei n, const GLfloat *points);
+    typedef void (APIENTRYP PFNGLGETDETAILTEXFUNCSGISPROC)(GLenum target, GLfloat *points);
+#endif
+
+#ifndef GL_SGIS_sharpen_texture
+#define GL_SGIS_sharpen_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glSharpenTexFuncSGIS(GLenum, GLsizei, const GLfloat *);
+    extern void APIENTRY glGetSharpenTexFuncSGIS(GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLSHARPENTEXFUNCSGISPROC)(GLenum target, GLsizei n, const GLfloat *points);
+    typedef void (APIENTRYP PFNGLGETSHARPENTEXFUNCSGISPROC)(GLenum target, GLfloat *points);
+#endif
+
+#ifndef GL_EXT_packed_pixels
+#define GL_EXT_packed_pixels 1
+#endif
+
+#ifndef GL_SGIS_texture_lod
+#define GL_SGIS_texture_lod 1
+#endif
+
+#ifndef GL_SGIS_multisample
+#define GL_SGIS_multisample 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glSampleMaskSGIS(GLclampf, GLboolean);
+    extern void APIENTRY glSamplePatternSGIS(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLSAMPLEMASKSGISPROC)(GLclampf value, GLboolean invert);
+    typedef void (APIENTRYP PFNGLSAMPLEPATTERNSGISPROC)(GLenum pattern);
+#endif
+
+#ifndef GL_EXT_rescale_normal
+#define GL_EXT_rescale_normal 1
+#endif
+
+#ifndef GL_EXT_vertex_array
+#define GL_EXT_vertex_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glArrayElementEXT(GLint);
+    extern void APIENTRY glColorPointerEXT(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+    extern void APIENTRY glDrawArraysEXT(GLenum, GLint, GLsizei);
+    extern void APIENTRY glEdgeFlagPointerEXT(GLsizei, GLsizei, const GLboolean *);
+    extern void APIENTRY glGetPointervEXT(GLenum, GLvoid* *);
+    extern void APIENTRY glIndexPointerEXT(GLenum, GLsizei, GLsizei, const GLvoid *);
+    extern void APIENTRY glNormalPointerEXT(GLenum, GLsizei, GLsizei, const GLvoid *);
+    extern void APIENTRY glTexCoordPointerEXT(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+    extern void APIENTRY glVertexPointerEXT(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLARRAYELEMENTEXTPROC)(GLint i);
+    typedef void (APIENTRYP PFNGLCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLDRAWARRAYSEXTPROC)(GLenum mode, GLint first, GLsizei count);
+    typedef void (APIENTRYP PFNGLEDGEFLAGPOINTEREXTPROC)(GLsizei stride, GLsizei count, const GLboolean *pointer);
+    typedef void (APIENTRYP PFNGLGETPOINTERVEXTPROC)(GLenum pname, GLvoid* *params);
+    typedef void (APIENTRYP PFNGLINDEXPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLNORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLTEXCOORDPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLVERTEXPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+#endif
+
+#ifndef GL_EXT_misc_attribute
+#define GL_EXT_misc_attribute 1
+#endif
+
+#ifndef GL_SGIS_generate_mipmap
+#define GL_SGIS_generate_mipmap 1
+#endif
+
+#ifndef GL_SGIX_clipmap
+#define GL_SGIX_clipmap 1
+#endif
+
+#ifndef GL_SGIX_shadow
+#define GL_SGIX_shadow 1
+#endif
+
+#ifndef GL_SGIS_texture_edge_clamp
+#define GL_SGIS_texture_edge_clamp 1
+#endif
+
+#ifndef GL_SGIS_texture_border_clamp
+#define GL_SGIS_texture_border_clamp 1
+#endif
+
+#ifndef GL_EXT_blend_minmax
+#define GL_EXT_blend_minmax 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlendEquationEXT(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLENDEQUATIONEXTPROC)(GLenum mode);
+#endif
+
+#ifndef GL_EXT_blend_subtract
+#define GL_EXT_blend_subtract 1
+#endif
+
+#ifndef GL_EXT_blend_logic_op
+#define GL_EXT_blend_logic_op 1
+#endif
+
+#ifndef GL_SGIX_interlace
+#define GL_SGIX_interlace 1
+#endif
+
+#ifndef GL_SGIX_pixel_tiles
+#define GL_SGIX_pixel_tiles 1
+#endif
+
+#ifndef GL_SGIX_texture_select
+#define GL_SGIX_texture_select 1
+#endif
+
+#ifndef GL_SGIX_sprite
+#define GL_SGIX_sprite 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glSpriteParameterfSGIX(GLenum, GLfloat);
+    extern void APIENTRY glSpriteParameterfvSGIX(GLenum, const GLfloat *);
+    extern void APIENTRY glSpriteParameteriSGIX(GLenum, GLint);
+    extern void APIENTRY glSpriteParameterivSGIX(GLenum, const GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLSPRITEPARAMETERFSGIXPROC)(GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLSPRITEPARAMETERFVSGIXPROC)(GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLSPRITEPARAMETERISGIXPROC)(GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLSPRITEPARAMETERIVSGIXPROC)(GLenum pname, const GLint *params);
+#endif
+
+#ifndef GL_SGIX_texture_multi_buffer
+#define GL_SGIX_texture_multi_buffer 1
+#endif
+
+#ifndef GL_EXT_point_parameters
+#define GL_EXT_point_parameters 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPointParameterfEXT(GLenum, GLfloat);
+    extern void APIENTRY glPointParameterfvEXT(GLenum, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERFEXTPROC)(GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERFVEXTPROC)(GLenum pname, const GLfloat *params);
+#endif
+
+#ifndef GL_SGIS_point_parameters
+#define GL_SGIS_point_parameters 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPointParameterfSGIS(GLenum, GLfloat);
+    extern void APIENTRY glPointParameterfvSGIS(GLenum, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERFSGISPROC)(GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERFVSGISPROC)(GLenum pname, const GLfloat *params);
+#endif
+
+#ifndef GL_SGIX_instruments
+#define GL_SGIX_instruments 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern GLint APIENTRY glGetInstrumentsSGIX(void);
+    extern void APIENTRY glInstrumentsBufferSGIX(GLsizei, GLint *);
+    extern GLint APIENTRY glPollInstrumentsSGIX(GLint *);
+    extern void APIENTRY glReadInstrumentsSGIX(GLint);
+    extern void APIENTRY glStartInstrumentsSGIX(void);
+    extern void APIENTRY glStopInstrumentsSGIX(GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef GLint(APIENTRYP PFNGLGETINSTRUMENTSSGIXPROC)(void);
+    typedef void (APIENTRYP PFNGLINSTRUMENTSBUFFERSGIXPROC)(GLsizei size, GLint *buffer);
+    typedef GLint(APIENTRYP PFNGLPOLLINSTRUMENTSSGIXPROC)(GLint *marker_p);
+    typedef void (APIENTRYP PFNGLREADINSTRUMENTSSGIXPROC)(GLint marker);
+    typedef void (APIENTRYP PFNGLSTARTINSTRUMENTSSGIXPROC)(void);
+    typedef void (APIENTRYP PFNGLSTOPINSTRUMENTSSGIXPROC)(GLint marker);
+#endif
+
+#ifndef GL_SGIX_texture_scale_bias
+#define GL_SGIX_texture_scale_bias 1
+#endif
+
+#ifndef GL_SGIX_framezoom
+#define GL_SGIX_framezoom 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glFrameZoomSGIX(GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLFRAMEZOOMSGIXPROC)(GLint factor);
+#endif
+
+#ifndef GL_SGIX_tag_sample_buffer
+#define GL_SGIX_tag_sample_buffer 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTagSampleBufferSGIX(void);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTAGSAMPLEBUFFERSGIXPROC)(void);
+#endif
+
+#ifndef GL_SGIX_polynomial_ffd
+#define GL_SGIX_polynomial_ffd 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDeformationMap3dSGIX(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
+    extern void APIENTRY glDeformationMap3fSGIX(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
+    extern void APIENTRY glDeformSGIX(GLbitfield);
+    extern void APIENTRY glLoadIdentityDeformationMapSGIX(GLbitfield);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDEFORMATIONMAP3DSGIXPROC)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
+    typedef void (APIENTRYP PFNGLDEFORMATIONMAP3FSGIXPROC)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
+    typedef void (APIENTRYP PFNGLDEFORMSGIXPROC)(GLbitfield mask);
+    typedef void (APIENTRYP PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC)(GLbitfield mask);
+#endif
+
+#ifndef GL_SGIX_reference_plane
+#define GL_SGIX_reference_plane 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glReferencePlaneSGIX(const GLdouble *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLREFERENCEPLANESGIXPROC)(const GLdouble *equation);
+#endif
+
+#ifndef GL_SGIX_flush_raster
+#define GL_SGIX_flush_raster 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glFlushRasterSGIX(void);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLFLUSHRASTERSGIXPROC)(void);
+#endif
+
+#ifndef GL_SGIX_depth_texture
+#define GL_SGIX_depth_texture 1
+#endif
+
+#ifndef GL_SGIS_fog_function
+#define GL_SGIS_fog_function 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glFogFuncSGIS(GLsizei, const GLfloat *);
+    extern void APIENTRY glGetFogFuncSGIS(GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLFOGFUNCSGISPROC)(GLsizei n, const GLfloat *points);
+    typedef void (APIENTRYP PFNGLGETFOGFUNCSGISPROC)(GLfloat *points);
+#endif
+
+#ifndef GL_SGIX_fog_offset
+#define GL_SGIX_fog_offset 1
+#endif
+
+#ifndef GL_HP_image_transform
+#define GL_HP_image_transform 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glImageTransformParameteriHP(GLenum, GLenum, GLint);
+    extern void APIENTRY glImageTransformParameterfHP(GLenum, GLenum, GLfloat);
+    extern void APIENTRY glImageTransformParameterivHP(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glImageTransformParameterfvHP(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glGetImageTransformParameterivHP(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetImageTransformParameterfvHP(GLenum, GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLIMAGETRANSFORMPARAMETERIHPPROC)(GLenum target, GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLIMAGETRANSFORMPARAMETERFHPPROC)(GLenum target, GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_HP_convolution_border_modes
+#define GL_HP_convolution_border_modes 1
+#endif
+
+#ifndef GL_SGIX_texture_add_env
+#define GL_SGIX_texture_add_env 1
+#endif
+
+#ifndef GL_EXT_color_subtable
+#define GL_EXT_color_subtable 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glColorSubTableEXT(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glCopyColorSubTableEXT(GLenum, GLsizei, GLint, GLint, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+    typedef void (APIENTRYP PFNGLCOPYCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
+#endif
+
+#ifndef GL_PGI_vertex_hints
+#define GL_PGI_vertex_hints 1
+#endif
+
+#ifndef GL_PGI_misc_hints
+#define GL_PGI_misc_hints 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glHintPGI(GLenum, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLHINTPGIPROC)(GLenum target, GLint mode);
+#endif
+
+#ifndef GL_EXT_paletted_texture
+#define GL_EXT_paletted_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glColorTableEXT(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+    extern void APIENTRY glGetColorTableEXT(GLenum, GLenum, GLenum, GLvoid *);
+    extern void APIENTRY glGetColorTableParameterivEXT(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetColorTableParameterfvEXT(GLenum, GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOLORTABLEEXTPROC)(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLEEXTPROC)(GLenum target, GLenum format, GLenum type, GLvoid *data);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_EXT_clip_volume_hint
+#define GL_EXT_clip_volume_hint 1
+#endif
+
+#ifndef GL_SGIX_list_priority
+#define GL_SGIX_list_priority 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGetListParameterfvSGIX(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetListParameterivSGIX(GLuint, GLenum, GLint *);
+    extern void APIENTRY glListParameterfSGIX(GLuint, GLenum, GLfloat);
+    extern void APIENTRY glListParameterfvSGIX(GLuint, GLenum, const GLfloat *);
+    extern void APIENTRY glListParameteriSGIX(GLuint, GLenum, GLint);
+    extern void APIENTRY glListParameterivSGIX(GLuint, GLenum, const GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGETLISTPARAMETERFVSGIXPROC)(GLuint list, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETLISTPARAMETERIVSGIXPROC)(GLuint list, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLLISTPARAMETERFSGIXPROC)(GLuint list, GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLLISTPARAMETERFVSGIXPROC)(GLuint list, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLLISTPARAMETERISGIXPROC)(GLuint list, GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLLISTPARAMETERIVSGIXPROC)(GLuint list, GLenum pname, const GLint *params);
+#endif
+
+#ifndef GL_SGIX_ir_instrument1
+#define GL_SGIX_ir_instrument1 1
+#endif
+
+#ifndef GL_SGIX_calligraphic_fragment
+#define GL_SGIX_calligraphic_fragment 1
+#endif
+
+#ifndef GL_SGIX_texture_lod_bias
+#define GL_SGIX_texture_lod_bias 1
+#endif
+
+#ifndef GL_SGIX_shadow_ambient
+#define GL_SGIX_shadow_ambient 1
+#endif
+
+#ifndef GL_EXT_index_texture
+#define GL_EXT_index_texture 1
+#endif
+
+#ifndef GL_EXT_index_material
+#define GL_EXT_index_material 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glIndexMaterialEXT(GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLINDEXMATERIALEXTPROC)(GLenum face, GLenum mode);
+#endif
+
+#ifndef GL_EXT_index_func
+#define GL_EXT_index_func 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glIndexFuncEXT(GLenum, GLclampf);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLINDEXFUNCEXTPROC)(GLenum func, GLclampf ref);
+#endif
+
+#ifndef GL_EXT_index_array_formats
+#define GL_EXT_index_array_formats 1
+#endif
+
+#ifndef GL_EXT_compiled_vertex_array
+#define GL_EXT_compiled_vertex_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glLockArraysEXT(GLint, GLsizei);
+    extern void APIENTRY glUnlockArraysEXT(void);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLLOCKARRAYSEXTPROC)(GLint first, GLsizei count);
+    typedef void (APIENTRYP PFNGLUNLOCKARRAYSEXTPROC)(void);
+#endif
+
+#ifndef GL_EXT_cull_vertex
+#define GL_EXT_cull_vertex 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glCullParameterdvEXT(GLenum, GLdouble *);
+    extern void APIENTRY glCullParameterfvEXT(GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCULLPARAMETERDVEXTPROC)(GLenum pname, GLdouble *params);
+    typedef void (APIENTRYP PFNGLCULLPARAMETERFVEXTPROC)(GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_SGIX_ycrcb
+#define GL_SGIX_ycrcb 1
+#endif
+
+#ifndef GL_SGIX_fragment_lighting
+#define GL_SGIX_fragment_lighting 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glFragmentColorMaterialSGIX(GLenum, GLenum);
+    extern void APIENTRY glFragmentLightfSGIX(GLenum, GLenum, GLfloat);
+    extern void APIENTRY glFragmentLightfvSGIX(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glFragmentLightiSGIX(GLenum, GLenum, GLint);
+    extern void APIENTRY glFragmentLightivSGIX(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glFragmentLightModelfSGIX(GLenum, GLfloat);
+    extern void APIENTRY glFragmentLightModelfvSGIX(GLenum, const GLfloat *);
+    extern void APIENTRY glFragmentLightModeliSGIX(GLenum, GLint);
+    extern void APIENTRY glFragmentLightModelivSGIX(GLenum, const GLint *);
+    extern void APIENTRY glFragmentMaterialfSGIX(GLenum, GLenum, GLfloat);
+    extern void APIENTRY glFragmentMaterialfvSGIX(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glFragmentMaterialiSGIX(GLenum, GLenum, GLint);
+    extern void APIENTRY glFragmentMaterialivSGIX(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glGetFragmentLightfvSGIX(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetFragmentLightivSGIX(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetFragmentMaterialfvSGIX(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetFragmentMaterialivSGIX(GLenum, GLenum, GLint *);
+    extern void APIENTRY glLightEnviSGIX(GLenum, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLFRAGMENTCOLORMATERIALSGIXPROC)(GLenum face, GLenum mode);
+    typedef void (APIENTRYP PFNGLFRAGMENTLIGHTFSGIXPROC)(GLenum light, GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLFRAGMENTLIGHTISGIXPROC)(GLenum light, GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLFRAGMENTLIGHTMODELFSGIXPROC)(GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLFRAGMENTLIGHTMODELFVSGIXPROC)(GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLFRAGMENTLIGHTMODELISGIXPROC)(GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLFRAGMENTLIGHTMODELIVSGIXPROC)(GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLFRAGMENTMATERIALFSGIXPROC)(GLenum face, GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLFRAGMENTMATERIALISGIXPROC)(GLenum face, GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLGETFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLLIGHTENVISGIXPROC)(GLenum pname, GLint param);
+#endif
+
+#ifndef GL_IBM_rasterpos_clip
+#define GL_IBM_rasterpos_clip 1
+#endif
+
+#ifndef GL_HP_texture_lighting
+#define GL_HP_texture_lighting 1
+#endif
+
+#ifndef GL_EXT_draw_range_elements
+#define GL_EXT_draw_range_elements 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDrawRangeElementsEXT(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSEXTPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
+#endif
+
+#ifndef GL_WIN_phong_shading
+#define GL_WIN_phong_shading 1
+#endif
+
+#ifndef GL_WIN_specular_fog
+#define GL_WIN_specular_fog 1
+#endif
+
+#ifndef GL_EXT_light_texture
+#define GL_EXT_light_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glApplyTextureEXT(GLenum);
+    extern void APIENTRY glTextureLightEXT(GLenum);
+    extern void APIENTRY glTextureMaterialEXT(GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLAPPLYTEXTUREEXTPROC)(GLenum mode);
+    typedef void (APIENTRYP PFNGLTEXTURELIGHTEXTPROC)(GLenum pname);
+    typedef void (APIENTRYP PFNGLTEXTUREMATERIALEXTPROC)(GLenum face, GLenum mode);
+#endif
+
+#ifndef GL_SGIX_blend_alpha_minmax
+#define GL_SGIX_blend_alpha_minmax 1
+#endif
+
+#ifndef GL_EXT_bgra
+#define GL_EXT_bgra 1
+#endif
+
+#ifndef GL_SGIX_async
+#define GL_SGIX_async 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glAsyncMarkerSGIX(GLuint);
+    extern GLint APIENTRY glFinishAsyncSGIX(GLuint *);
+    extern GLint APIENTRY glPollAsyncSGIX(GLuint *);
+    extern GLuint APIENTRY glGenAsyncMarkersSGIX(GLsizei);
+    extern void APIENTRY glDeleteAsyncMarkersSGIX(GLuint, GLsizei);
+    extern GLboolean APIENTRY glIsAsyncMarkerSGIX(GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLASYNCMARKERSGIXPROC)(GLuint marker);
+    typedef GLint(APIENTRYP PFNGLFINISHASYNCSGIXPROC)(GLuint *markerp);
+    typedef GLint(APIENTRYP PFNGLPOLLASYNCSGIXPROC)(GLuint *markerp);
+    typedef GLuint(APIENTRYP PFNGLGENASYNCMARKERSSGIXPROC)(GLsizei range);
+    typedef void (APIENTRYP PFNGLDELETEASYNCMARKERSSGIXPROC)(GLuint marker, GLsizei range);
+    typedef GLboolean(APIENTRYP PFNGLISASYNCMARKERSGIXPROC)(GLuint marker);
+#endif
+
+#ifndef GL_SGIX_async_pixel
+#define GL_SGIX_async_pixel 1
+#endif
+
+#ifndef GL_SGIX_async_histogram
+#define GL_SGIX_async_histogram 1
+#endif
+
+#ifndef GL_INTEL_parallel_arrays
+#define GL_INTEL_parallel_arrays 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glVertexPointervINTEL(GLint, GLenum, const GLvoid* *);
+    extern void APIENTRY glNormalPointervINTEL(GLenum, const GLvoid* *);
+    extern void APIENTRY glColorPointervINTEL(GLint, GLenum, const GLvoid* *);
+    extern void APIENTRY glTexCoordPointervINTEL(GLint, GLenum, const GLvoid* *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLVERTEXPOINTERVINTELPROC)(GLint size, GLenum type, const GLvoid* *pointer);
+    typedef void (APIENTRYP PFNGLNORMALPOINTERVINTELPROC)(GLenum type, const GLvoid* *pointer);
+    typedef void (APIENTRYP PFNGLCOLORPOINTERVINTELPROC)(GLint size, GLenum type, const GLvoid* *pointer);
+    typedef void (APIENTRYP PFNGLTEXCOORDPOINTERVINTELPROC)(GLint size, GLenum type, const GLvoid* *pointer);
+#endif
+
+#ifndef GL_HP_occlusion_test
+#define GL_HP_occlusion_test 1
+#endif
+
+#ifndef GL_EXT_pixel_transform
+#define GL_EXT_pixel_transform 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPixelTransformParameteriEXT(GLenum, GLenum, GLint);
+    extern void APIENTRY glPixelTransformParameterfEXT(GLenum, GLenum, GLfloat);
+    extern void APIENTRY glPixelTransformParameterivEXT(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glPixelTransformParameterfvEXT(GLenum, GLenum, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat *params);
+#endif
+
+#ifndef GL_EXT_pixel_transform_color_table
+#define GL_EXT_pixel_transform_color_table 1
+#endif
+
+#ifndef GL_EXT_shared_texture_palette
+#define GL_EXT_shared_texture_palette 1
+#endif
+
+#ifndef GL_EXT_separate_specular_color
+#define GL_EXT_separate_specular_color 1
+#endif
+
+#ifndef GL_EXT_secondary_color
+#define GL_EXT_secondary_color 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glSecondaryColor3bEXT(GLbyte, GLbyte, GLbyte);
+    extern void APIENTRY glSecondaryColor3bvEXT(const GLbyte *);
+    extern void APIENTRY glSecondaryColor3dEXT(GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glSecondaryColor3dvEXT(const GLdouble *);
+    extern void APIENTRY glSecondaryColor3fEXT(GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glSecondaryColor3fvEXT(const GLfloat *);
+    extern void APIENTRY glSecondaryColor3iEXT(GLint, GLint, GLint);
+    extern void APIENTRY glSecondaryColor3ivEXT(const GLint *);
+    extern void APIENTRY glSecondaryColor3sEXT(GLshort, GLshort, GLshort);
+    extern void APIENTRY glSecondaryColor3svEXT(const GLshort *);
+    extern void APIENTRY glSecondaryColor3ubEXT(GLubyte, GLubyte, GLubyte);
+    extern void APIENTRY glSecondaryColor3ubvEXT(const GLubyte *);
+    extern void APIENTRY glSecondaryColor3uiEXT(GLuint, GLuint, GLuint);
+    extern void APIENTRY glSecondaryColor3uivEXT(const GLuint *);
+    extern void APIENTRY glSecondaryColor3usEXT(GLushort, GLushort, GLushort);
+    extern void APIENTRY glSecondaryColor3usvEXT(const GLushort *);
+    extern void APIENTRY glSecondaryColorPointerEXT(GLint, GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BEXTPROC)(GLbyte red, GLbyte green, GLbyte blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BVEXTPROC)(const GLbyte *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DEXTPROC)(GLdouble red, GLdouble green, GLdouble blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DVEXTPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3FEXTPROC)(GLfloat red, GLfloat green, GLfloat blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3FVEXTPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3IEXTPROC)(GLint red, GLint green, GLint blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3IVEXTPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3SEXTPROC)(GLshort red, GLshort green, GLshort blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3SVEXTPROC)(const GLshort *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UBEXTPROC)(GLubyte red, GLubyte green, GLubyte blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UBVEXTPROC)(const GLubyte *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIEXTPROC)(GLuint red, GLuint green, GLuint blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIVEXTPROC)(const GLuint *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USEXTPROC)(GLushort red, GLushort green, GLushort blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USVEXTPROC)(const GLushort *v);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_EXT_texture_perturb_normal
+#define GL_EXT_texture_perturb_normal 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTextureNormalEXT(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTEXTURENORMALEXTPROC)(GLenum mode);
+#endif
+
+#ifndef GL_EXT_multi_draw_arrays
+#define GL_EXT_multi_draw_arrays 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glMultiDrawArraysEXT(GLenum, GLint *, GLsizei *, GLsizei);
+    extern void APIENTRY glMultiDrawElementsEXT(GLenum, const GLsizei *, GLenum, const GLvoid* *, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSEXTPROC)(GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
+    typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSEXTPROC)(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
+#endif
+
+#ifndef GL_EXT_fog_coord
+#define GL_EXT_fog_coord 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glFogCoordfEXT(GLfloat);
+    extern void APIENTRY glFogCoordfvEXT(const GLfloat *);
+    extern void APIENTRY glFogCoorddEXT(GLdouble);
+    extern void APIENTRY glFogCoorddvEXT(const GLdouble *);
+    extern void APIENTRY glFogCoordPointerEXT(GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLFOGCOORDFEXTPROC)(GLfloat coord);
+    typedef void (APIENTRYP PFNGLFOGCOORDFVEXTPROC)(const GLfloat *coord);
+    typedef void (APIENTRYP PFNGLFOGCOORDDEXTPROC)(GLdouble coord);
+    typedef void (APIENTRYP PFNGLFOGCOORDDVEXTPROC)(const GLdouble *coord);
+    typedef void (APIENTRYP PFNGLFOGCOORDPOINTEREXTPROC)(GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_REND_screen_coordinates
+#define GL_REND_screen_coordinates 1
+#endif
+
+#ifndef GL_EXT_coordinate_frame
+#define GL_EXT_coordinate_frame 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTangent3bEXT(GLbyte, GLbyte, GLbyte);
+    extern void APIENTRY glTangent3bvEXT(const GLbyte *);
+    extern void APIENTRY glTangent3dEXT(GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glTangent3dvEXT(const GLdouble *);
+    extern void APIENTRY glTangent3fEXT(GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glTangent3fvEXT(const GLfloat *);
+    extern void APIENTRY glTangent3iEXT(GLint, GLint, GLint);
+    extern void APIENTRY glTangent3ivEXT(const GLint *);
+    extern void APIENTRY glTangent3sEXT(GLshort, GLshort, GLshort);
+    extern void APIENTRY glTangent3svEXT(const GLshort *);
+    extern void APIENTRY glBinormal3bEXT(GLbyte, GLbyte, GLbyte);
+    extern void APIENTRY glBinormal3bvEXT(const GLbyte *);
+    extern void APIENTRY glBinormal3dEXT(GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glBinormal3dvEXT(const GLdouble *);
+    extern void APIENTRY glBinormal3fEXT(GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glBinormal3fvEXT(const GLfloat *);
+    extern void APIENTRY glBinormal3iEXT(GLint, GLint, GLint);
+    extern void APIENTRY glBinormal3ivEXT(const GLint *);
+    extern void APIENTRY glBinormal3sEXT(GLshort, GLshort, GLshort);
+    extern void APIENTRY glBinormal3svEXT(const GLshort *);
+    extern void APIENTRY glTangentPointerEXT(GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glBinormalPointerEXT(GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTANGENT3BEXTPROC)(GLbyte tx, GLbyte ty, GLbyte tz);
+    typedef void (APIENTRYP PFNGLTANGENT3BVEXTPROC)(const GLbyte *v);
+    typedef void (APIENTRYP PFNGLTANGENT3DEXTPROC)(GLdouble tx, GLdouble ty, GLdouble tz);
+    typedef void (APIENTRYP PFNGLTANGENT3DVEXTPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLTANGENT3FEXTPROC)(GLfloat tx, GLfloat ty, GLfloat tz);
+    typedef void (APIENTRYP PFNGLTANGENT3FVEXTPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLTANGENT3IEXTPROC)(GLint tx, GLint ty, GLint tz);
+    typedef void (APIENTRYP PFNGLTANGENT3IVEXTPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLTANGENT3SEXTPROC)(GLshort tx, GLshort ty, GLshort tz);
+    typedef void (APIENTRYP PFNGLTANGENT3SVEXTPROC)(const GLshort *v);
+    typedef void (APIENTRYP PFNGLBINORMAL3BEXTPROC)(GLbyte bx, GLbyte by, GLbyte bz);
+    typedef void (APIENTRYP PFNGLBINORMAL3BVEXTPROC)(const GLbyte *v);
+    typedef void (APIENTRYP PFNGLBINORMAL3DEXTPROC)(GLdouble bx, GLdouble by, GLdouble bz);
+    typedef void (APIENTRYP PFNGLBINORMAL3DVEXTPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLBINORMAL3FEXTPROC)(GLfloat bx, GLfloat by, GLfloat bz);
+    typedef void (APIENTRYP PFNGLBINORMAL3FVEXTPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLBINORMAL3IEXTPROC)(GLint bx, GLint by, GLint bz);
+    typedef void (APIENTRYP PFNGLBINORMAL3IVEXTPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLBINORMAL3SEXTPROC)(GLshort bx, GLshort by, GLshort bz);
+    typedef void (APIENTRYP PFNGLBINORMAL3SVEXTPROC)(const GLshort *v);
+    typedef void (APIENTRYP PFNGLTANGENTPOINTEREXTPROC)(GLenum type, GLsizei stride, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLBINORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_EXT_texture_env_combine
+#define GL_EXT_texture_env_combine 1
+#endif
+
+#ifndef GL_APPLE_specular_vector
+#define GL_APPLE_specular_vector 1
+#endif
+
+#ifndef GL_APPLE_transform_hint
+#define GL_APPLE_transform_hint 1
+#endif
+
+#ifndef GL_SGIX_fog_scale
+#define GL_SGIX_fog_scale 1
+#endif
+
+#ifndef GL_SUNX_constant_data
+#define GL_SUNX_constant_data 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glFinishTextureSUNX(void);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLFINISHTEXTURESUNXPROC)(void);
+#endif
+
+#ifndef GL_SUN_global_alpha
+#define GL_SUN_global_alpha 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGlobalAlphaFactorbSUN(GLbyte);
+    extern void APIENTRY glGlobalAlphaFactorsSUN(GLshort);
+    extern void APIENTRY glGlobalAlphaFactoriSUN(GLint);
+    extern void APIENTRY glGlobalAlphaFactorfSUN(GLfloat);
+    extern void APIENTRY glGlobalAlphaFactordSUN(GLdouble);
+    extern void APIENTRY glGlobalAlphaFactorubSUN(GLubyte);
+    extern void APIENTRY glGlobalAlphaFactorusSUN(GLushort);
+    extern void APIENTRY glGlobalAlphaFactoruiSUN(GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORBSUNPROC)(GLbyte factor);
+    typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORSSUNPROC)(GLshort factor);
+    typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORISUNPROC)(GLint factor);
+    typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORFSUNPROC)(GLfloat factor);
+    typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORDSUNPROC)(GLdouble factor);
+    typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORUBSUNPROC)(GLubyte factor);
+    typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORUSSUNPROC)(GLushort factor);
+    typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORUISUNPROC)(GLuint factor);
+#endif
+
+#ifndef GL_SUN_triangle_list
+#define GL_SUN_triangle_list 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glReplacementCodeuiSUN(GLuint);
+    extern void APIENTRY glReplacementCodeusSUN(GLushort);
+    extern void APIENTRY glReplacementCodeubSUN(GLubyte);
+    extern void APIENTRY glReplacementCodeuivSUN(const GLuint *);
+    extern void APIENTRY glReplacementCodeusvSUN(const GLushort *);
+    extern void APIENTRY glReplacementCodeubvSUN(const GLubyte *);
+    extern void APIENTRY glReplacementCodePointerSUN(GLenum, GLsizei, const GLvoid* *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUISUNPROC)(GLuint code);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUSSUNPROC)(GLushort code);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUBSUNPROC)(GLubyte code);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUIVSUNPROC)(const GLuint *code);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUSVSUNPROC)(const GLushort *code);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUBVSUNPROC)(const GLubyte *code);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEPOINTERSUNPROC)(GLenum type, GLsizei stride, const GLvoid* *pointer);
+#endif
+
+#ifndef GL_SUN_vertex
+#define GL_SUN_vertex 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glColor4ubVertex2fSUN(GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat);
+    extern void APIENTRY glColor4ubVertex2fvSUN(const GLubyte *, const GLfloat *);
+    extern void APIENTRY glColor4ubVertex3fSUN(GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glColor4ubVertex3fvSUN(const GLubyte *, const GLfloat *);
+    extern void APIENTRY glColor3fVertex3fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glColor3fVertex3fvSUN(const GLfloat *, const GLfloat *);
+    extern void APIENTRY glNormal3fVertex3fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glNormal3fVertex3fvSUN(const GLfloat *, const GLfloat *);
+    extern void APIENTRY glColor4fNormal3fVertex3fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glColor4fNormal3fVertex3fvSUN(const GLfloat *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glTexCoord2fVertex3fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glTexCoord2fVertex3fvSUN(const GLfloat *, const GLfloat *);
+    extern void APIENTRY glTexCoord4fVertex4fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glTexCoord4fVertex4fvSUN(const GLfloat *, const GLfloat *);
+    extern void APIENTRY glTexCoord2fColor4ubVertex3fSUN(GLfloat, GLfloat, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *, const GLubyte *, const GLfloat *);
+    extern void APIENTRY glTexCoord2fColor3fVertex3fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glTexCoord2fColor3fVertex3fvSUN(const GLfloat *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glTexCoord2fNormal3fVertex3fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *, const GLfloat *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *, const GLfloat *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glReplacementCodeuiVertex3fSUN(GLuint, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glReplacementCodeuiVertex3fvSUN(const GLuint *, const GLfloat *);
+    extern void APIENTRY glReplacementCodeuiColor4ubVertex3fSUN(GLuint, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *, const GLubyte *, const GLfloat *);
+    extern void APIENTRY glReplacementCodeuiColor3fVertex3fSUN(GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glReplacementCodeuiNormal3fVertex3fSUN(GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *, const GLfloat *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *, const GLfloat *, const GLfloat *, const GLfloat *);
+    extern void APIENTRY glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *, const GLfloat *, const GLfloat *, const GLfloat *, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX2FSUNPROC)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
+    typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX2FVSUNPROC)(const GLubyte *c, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX3FSUNPROC)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX3FVSUNPROC)(const GLubyte *c, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLCOLOR3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLCOLOR3FVERTEX3FVSUNPROC)(const GLfloat *c, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLNORMAL3FVERTEX3FSUNPROC)(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *n, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD4FVERTEX4FSUNPROC)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLTEXCOORD4FVERTEX4FVSUNPROC)(const GLfloat *tc, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC)(const GLfloat *tc, const GLubyte *c, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *n, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC)(GLuint rc, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC)(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC)(const GLuint *rc, const GLubyte *c, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *c, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *n, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+#endif
+
+#ifndef GL_EXT_blend_func_separate
+#define GL_EXT_blend_func_separate 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlendFuncSeparateEXT(GLenum, GLenum, GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEEXTPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+#endif
+
+#ifndef GL_INGR_blend_func_separate
+#define GL_INGR_blend_func_separate 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlendFuncSeparateINGR(GLenum, GLenum, GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEINGRPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+#endif
+
+#ifndef GL_INGR_color_clamp
+#define GL_INGR_color_clamp 1
+#endif
+
+#ifndef GL_INGR_interlace_read
+#define GL_INGR_interlace_read 1
+#endif
+
+#ifndef GL_EXT_stencil_wrap
+#define GL_EXT_stencil_wrap 1
+#endif
+
+#ifndef GL_EXT_422_pixels
+#define GL_EXT_422_pixels 1
+#endif
+
+#ifndef GL_NV_texgen_reflection
+#define GL_NV_texgen_reflection 1
+#endif
+
+#ifndef GL_SUN_convolution_border_modes
+#define GL_SUN_convolution_border_modes 1
+#endif
+
+#ifndef GL_EXT_texture_env_add
+#define GL_EXT_texture_env_add 1
+#endif
+
+#ifndef GL_EXT_texture_lod_bias
+#define GL_EXT_texture_lod_bias 1
+#endif
+
+#ifndef GL_EXT_texture_filter_anisotropic
+#define GL_EXT_texture_filter_anisotropic 1
+#endif
+
+#ifndef GL_EXT_vertex_weighting
+#define GL_EXT_vertex_weighting 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glVertexWeightfEXT(GLfloat);
+    extern void APIENTRY glVertexWeightfvEXT(const GLfloat *);
+    extern void APIENTRY glVertexWeightPointerEXT(GLsizei, GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLVERTEXWEIGHTFEXTPROC)(GLfloat weight);
+    typedef void (APIENTRYP PFNGLVERTEXWEIGHTFVEXTPROC)(const GLfloat *weight);
+    typedef void (APIENTRYP PFNGLVERTEXWEIGHTPOINTEREXTPROC)(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_NV_light_max_exponent
+#define GL_NV_light_max_exponent 1
+#endif
+
+#ifndef GL_NV_vertex_array_range
+#define GL_NV_vertex_array_range 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glFlushVertexArrayRangeNV(void);
+    extern void APIENTRY glVertexArrayRangeNV(GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLFLUSHVERTEXARRAYRANGENVPROC)(void);
+    typedef void (APIENTRYP PFNGLVERTEXARRAYRANGENVPROC)(GLsizei length, const GLvoid *pointer);
+#endif
+
+#ifndef GL_NV_register_combiners
+#define GL_NV_register_combiners 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glCombinerParameterfvNV(GLenum, const GLfloat *);
+    extern void APIENTRY glCombinerParameterfNV(GLenum, GLfloat);
+    extern void APIENTRY glCombinerParameterivNV(GLenum, const GLint *);
+    extern void APIENTRY glCombinerParameteriNV(GLenum, GLint);
+    extern void APIENTRY glCombinerInputNV(GLenum, GLenum, GLenum, GLenum, GLenum, GLenum);
+    extern void APIENTRY glCombinerOutputNV(GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean);
+    extern void APIENTRY glFinalCombinerInputNV(GLenum, GLenum, GLenum, GLenum);
+    extern void APIENTRY glGetCombinerInputParameterfvNV(GLenum, GLenum, GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetCombinerInputParameterivNV(GLenum, GLenum, GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetCombinerOutputParameterfvNV(GLenum, GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetCombinerOutputParameterivNV(GLenum, GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetFinalCombinerInputParameterfvNV(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetFinalCombinerInputParameterivNV(GLenum, GLenum, GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOMBINERPARAMETERFVNVPROC)(GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLCOMBINERPARAMETERFNVPROC)(GLenum pname, GLfloat param);
+    typedef void (APIENTRYP PFNGLCOMBINERPARAMETERIVNVPROC)(GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLCOMBINERPARAMETERINVPROC)(GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLCOMBINERINPUTNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
+    typedef void (APIENTRYP PFNGLCOMBINEROUTPUTNVPROC)(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
+    typedef void (APIENTRYP PFNGLFINALCOMBINERINPUTNVPROC)(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
+    typedef void (APIENTRYP PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)(GLenum variable, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)(GLenum variable, GLenum pname, GLint *params);
+#endif
+
+#ifndef GL_NV_fog_distance
+#define GL_NV_fog_distance 1
+#endif
+
+#ifndef GL_NV_texgen_emboss
+#define GL_NV_texgen_emboss 1
+#endif
+
+#ifndef GL_NV_blend_square
+#define GL_NV_blend_square 1
+#endif
+
+#ifndef GL_NV_texture_env_combine4
+#define GL_NV_texture_env_combine4 1
+#endif
+
+#ifndef GL_MESA_resize_buffers
+#define GL_MESA_resize_buffers 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glResizeBuffersMESA(void);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLRESIZEBUFFERSMESAPROC)(void);
+#endif
+
+#ifndef GL_MESA_window_pos
+#define GL_MESA_window_pos 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glWindowPos2dMESA(GLdouble, GLdouble);
+    extern void APIENTRY glWindowPos2dvMESA(const GLdouble *);
+    extern void APIENTRY glWindowPos2fMESA(GLfloat, GLfloat);
+    extern void APIENTRY glWindowPos2fvMESA(const GLfloat *);
+    extern void APIENTRY glWindowPos2iMESA(GLint, GLint);
+    extern void APIENTRY glWindowPos2ivMESA(const GLint *);
+    extern void APIENTRY glWindowPos2sMESA(GLshort, GLshort);
+    extern void APIENTRY glWindowPos2svMESA(const GLshort *);
+    extern void APIENTRY glWindowPos3dMESA(GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glWindowPos3dvMESA(const GLdouble *);
+    extern void APIENTRY glWindowPos3fMESA(GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glWindowPos3fvMESA(const GLfloat *);
+    extern void APIENTRY glWindowPos3iMESA(GLint, GLint, GLint);
+    extern void APIENTRY glWindowPos3ivMESA(const GLint *);
+    extern void APIENTRY glWindowPos3sMESA(GLshort, GLshort, GLshort);
+    extern void APIENTRY glWindowPos3svMESA(const GLshort *);
+    extern void APIENTRY glWindowPos4dMESA(GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glWindowPos4dvMESA(const GLdouble *);
+    extern void APIENTRY glWindowPos4fMESA(GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glWindowPos4fvMESA(const GLfloat *);
+    extern void APIENTRY glWindowPos4iMESA(GLint, GLint, GLint, GLint);
+    extern void APIENTRY glWindowPos4ivMESA(const GLint *);
+    extern void APIENTRY glWindowPos4sMESA(GLshort, GLshort, GLshort, GLshort);
+    extern void APIENTRY glWindowPos4svMESA(const GLshort *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLWINDOWPOS2DMESAPROC)(GLdouble x, GLdouble y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2DVMESAPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2FMESAPROC)(GLfloat x, GLfloat y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2FVMESAPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2IMESAPROC)(GLint x, GLint y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2IVMESAPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2SMESAPROC)(GLshort x, GLshort y);
+    typedef void (APIENTRYP PFNGLWINDOWPOS2SVMESAPROC)(const GLshort *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3DMESAPROC)(GLdouble x, GLdouble y, GLdouble z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3DVMESAPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3FMESAPROC)(GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3FVMESAPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3IMESAPROC)(GLint x, GLint y, GLint z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3IVMESAPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3SMESAPROC)(GLshort x, GLshort y, GLshort z);
+    typedef void (APIENTRYP PFNGLWINDOWPOS3SVMESAPROC)(const GLshort *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS4DMESAPROC)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLWINDOWPOS4DVMESAPROC)(const GLdouble *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS4FMESAPROC)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLWINDOWPOS4FVMESAPROC)(const GLfloat *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS4IMESAPROC)(GLint x, GLint y, GLint z, GLint w);
+    typedef void (APIENTRYP PFNGLWINDOWPOS4IVMESAPROC)(const GLint *v);
+    typedef void (APIENTRYP PFNGLWINDOWPOS4SMESAPROC)(GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (APIENTRYP PFNGLWINDOWPOS4SVMESAPROC)(const GLshort *v);
+#endif
+
+#ifndef GL_EXT_texture_compression_s3tc
+#define GL_EXT_texture_compression_s3tc 1
+#endif
+
+#ifndef GL_IBM_cull_vertex
+#define GL_IBM_cull_vertex 1
+#endif
+
+#ifndef GL_IBM_multimode_draw_arrays
+#define GL_IBM_multimode_draw_arrays 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glMultiModeDrawArraysIBM(const GLenum *, const GLint *, const GLsizei *, GLsizei, GLint);
+    extern void APIENTRY glMultiModeDrawElementsIBM(const GLenum *, const GLsizei *, GLenum, const GLvoid *const *, GLsizei, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLMULTIMODEDRAWARRAYSIBMPROC)(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
+    typedef void (APIENTRYP PFNGLMULTIMODEDRAWELEMENTSIBMPROC)(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount, GLint modestride);
+#endif
+
+#ifndef GL_IBM_vertex_array_lists
+#define GL_IBM_vertex_array_lists 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glColorPointerListIBM(GLint, GLenum, GLint, const GLvoid* *, GLint);
+    extern void APIENTRY glSecondaryColorPointerListIBM(GLint, GLenum, GLint, const GLvoid* *, GLint);
+    extern void APIENTRY glEdgeFlagPointerListIBM(GLint, const GLboolean* *, GLint);
+    extern void APIENTRY glFogCoordPointerListIBM(GLenum, GLint, const GLvoid* *, GLint);
+    extern void APIENTRY glIndexPointerListIBM(GLenum, GLint, const GLvoid* *, GLint);
+    extern void APIENTRY glNormalPointerListIBM(GLenum, GLint, const GLvoid* *, GLint);
+    extern void APIENTRY glTexCoordPointerListIBM(GLint, GLenum, GLint, const GLvoid* *, GLint);
+    extern void APIENTRY glVertexPointerListIBM(GLint, GLenum, GLint, const GLvoid* *, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+    typedef void (APIENTRYP PFNGLEDGEFLAGPOINTERLISTIBMPROC)(GLint stride, const GLboolean* *pointer, GLint ptrstride);
+    typedef void (APIENTRYP PFNGLFOGCOORDPOINTERLISTIBMPROC)(GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+    typedef void (APIENTRYP PFNGLINDEXPOINTERLISTIBMPROC)(GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+    typedef void (APIENTRYP PFNGLNORMALPOINTERLISTIBMPROC)(GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+    typedef void (APIENTRYP PFNGLTEXCOORDPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+    typedef void (APIENTRYP PFNGLVERTEXPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+#endif
+
+#ifndef GL_SGIX_subsample
+#define GL_SGIX_subsample 1
+#endif
+
+#ifndef GL_SGIX_ycrcba
+#define GL_SGIX_ycrcba 1
+#endif
+
+#ifndef GL_SGIX_ycrcb_subsample
+#define GL_SGIX_ycrcb_subsample 1
+#endif
+
+#ifndef GL_SGIX_depth_pass_instrument
+#define GL_SGIX_depth_pass_instrument 1
+#endif
+
+#ifndef GL_3DFX_texture_compression_FXT1
+#define GL_3DFX_texture_compression_FXT1 1
+#endif
+
+#ifndef GL_3DFX_multisample
+#define GL_3DFX_multisample 1
+#endif
+
+#ifndef GL_3DFX_tbuffer
+#define GL_3DFX_tbuffer 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTbufferMask3DFX(GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTBUFFERMASK3DFXPROC)(GLuint mask);
+#endif
+
+#ifndef GL_EXT_multisample
+#define GL_EXT_multisample 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glSampleMaskEXT(GLclampf, GLboolean);
+    extern void APIENTRY glSamplePatternEXT(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLSAMPLEMASKEXTPROC)(GLclampf value, GLboolean invert);
+    typedef void (APIENTRYP PFNGLSAMPLEPATTERNEXTPROC)(GLenum pattern);
+#endif
+
+#ifndef GL_SGIX_vertex_preclip
+#define GL_SGIX_vertex_preclip 1
+#endif
+
+#ifndef GL_SGIX_convolution_accuracy
+#define GL_SGIX_convolution_accuracy 1
+#endif
+
+#ifndef GL_SGIX_resample
+#define GL_SGIX_resample 1
+#endif
+
+#ifndef GL_SGIS_point_line_texgen
+#define GL_SGIS_point_line_texgen 1
+#endif
+
+#ifndef GL_SGIS_texture_color_mask
+#define GL_SGIS_texture_color_mask 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTextureColorMaskSGIS(GLboolean, GLboolean, GLboolean, GLboolean);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTEXTURECOLORMASKSGISPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+#endif
+
+#ifndef GL_SGIX_igloo_interface
+#define GL_SGIX_igloo_interface 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glIglooInterfaceSGIX(GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLIGLOOINTERFACESGIXPROC)(GLenum pname, const GLvoid *params);
+#endif
+
+#ifndef GL_EXT_texture_env_dot3
+#define GL_EXT_texture_env_dot3 1
+#endif
+
+#ifndef GL_ATI_texture_mirror_once
+#define GL_ATI_texture_mirror_once 1
+#endif
+
+#ifndef GL_NV_fence
+#define GL_NV_fence 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDeleteFencesNV(GLsizei, const GLuint *);
+    extern void APIENTRY glGenFencesNV(GLsizei, GLuint *);
+    extern GLboolean APIENTRY glIsFenceNV(GLuint);
+    extern GLboolean APIENTRY glTestFenceNV(GLuint);
+    extern void APIENTRY glGetFenceivNV(GLuint, GLenum, GLint *);
+    extern void APIENTRY glFinishFenceNV(GLuint);
+    extern void APIENTRY glSetFenceNV(GLuint, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDELETEFENCESNVPROC)(GLsizei n, const GLuint *fences);
+    typedef void (APIENTRYP PFNGLGENFENCESNVPROC)(GLsizei n, GLuint *fences);
+    typedef GLboolean(APIENTRYP PFNGLISFENCENVPROC)(GLuint fence);
+    typedef GLboolean(APIENTRYP PFNGLTESTFENCENVPROC)(GLuint fence);
+    typedef void (APIENTRYP PFNGLGETFENCEIVNVPROC)(GLuint fence, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLFINISHFENCENVPROC)(GLuint fence);
+    typedef void (APIENTRYP PFNGLSETFENCENVPROC)(GLuint fence, GLenum condition);
+#endif
+
+#ifndef GL_NV_evaluators
+#define GL_NV_evaluators 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glMapControlPointsNV(GLenum, GLuint, GLenum, GLsizei, GLsizei, GLint, GLint, GLboolean, const GLvoid *);
+    extern void APIENTRY glMapParameterivNV(GLenum, GLenum, const GLint *);
+    extern void APIENTRY glMapParameterfvNV(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glGetMapControlPointsNV(GLenum, GLuint, GLenum, GLsizei, GLsizei, GLboolean, GLvoid *);
+    extern void APIENTRY glGetMapParameterivNV(GLenum, GLenum, GLint *);
+    extern void APIENTRY glGetMapParameterfvNV(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetMapAttribParameterivNV(GLenum, GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetMapAttribParameterfvNV(GLenum, GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glEvalMapsNV(GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
+    typedef void (APIENTRYP PFNGLMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
+    typedef void (APIENTRYP PFNGLGETMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETMAPATTRIBPARAMETERIVNVPROC)(GLenum target, GLuint index, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETMAPATTRIBPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLEVALMAPSNVPROC)(GLenum target, GLenum mode);
+#endif
+
+#ifndef GL_NV_packed_depth_stencil
+#define GL_NV_packed_depth_stencil 1
+#endif
+
+#ifndef GL_NV_register_combiners2
+#define GL_NV_register_combiners2 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glCombinerStageParameterfvNV(GLenum, GLenum, const GLfloat *);
+    extern void APIENTRY glGetCombinerStageParameterfvNV(GLenum, GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_NV_texture_compression_vtc
+#define GL_NV_texture_compression_vtc 1
+#endif
+
+#ifndef GL_NV_texture_rectangle
+#define GL_NV_texture_rectangle 1
+#endif
+
+#ifndef GL_NV_texture_shader
+#define GL_NV_texture_shader 1
+#endif
+
+#ifndef GL_NV_texture_shader2
+#define GL_NV_texture_shader2 1
+#endif
+
+#ifndef GL_NV_vertex_array_range2
+#define GL_NV_vertex_array_range2 1
+#endif
+
+#ifndef GL_NV_vertex_program
+#define GL_NV_vertex_program 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern GLboolean APIENTRY glAreProgramsResidentNV(GLsizei, const GLuint *, GLboolean *);
+    extern void APIENTRY glBindProgramNV(GLenum, GLuint);
+    extern void APIENTRY glDeleteProgramsNV(GLsizei, const GLuint *);
+    extern void APIENTRY glExecuteProgramNV(GLenum, GLuint, const GLfloat *);
+    extern void APIENTRY glGenProgramsNV(GLsizei, GLuint *);
+    extern void APIENTRY glGetProgramParameterdvNV(GLenum, GLuint, GLenum, GLdouble *);
+    extern void APIENTRY glGetProgramParameterfvNV(GLenum, GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetProgramivNV(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetProgramStringNV(GLuint, GLenum, GLubyte *);
+    extern void APIENTRY glGetTrackMatrixivNV(GLenum, GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetVertexAttribdvNV(GLuint, GLenum, GLdouble *);
+    extern void APIENTRY glGetVertexAttribfvNV(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetVertexAttribivNV(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetVertexAttribPointervNV(GLuint, GLenum, GLvoid* *);
+    extern GLboolean APIENTRY glIsProgramNV(GLuint);
+    extern void APIENTRY glLoadProgramNV(GLenum, GLuint, GLsizei, const GLubyte *);
+    extern void APIENTRY glProgramParameter4dNV(GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glProgramParameter4dvNV(GLenum, GLuint, const GLdouble *);
+    extern void APIENTRY glProgramParameter4fNV(GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glProgramParameter4fvNV(GLenum, GLuint, const GLfloat *);
+    extern void APIENTRY glProgramParameters4dvNV(GLenum, GLuint, GLuint, const GLdouble *);
+    extern void APIENTRY glProgramParameters4fvNV(GLenum, GLuint, GLuint, const GLfloat *);
+    extern void APIENTRY glRequestResidentProgramsNV(GLsizei, const GLuint *);
+    extern void APIENTRY glTrackMatrixNV(GLenum, GLuint, GLenum, GLenum);
+    extern void APIENTRY glVertexAttribPointerNV(GLuint, GLint, GLenum, GLsizei, const GLvoid *);
+    extern void APIENTRY glVertexAttrib1dNV(GLuint, GLdouble);
+    extern void APIENTRY glVertexAttrib1dvNV(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib1fNV(GLuint, GLfloat);
+    extern void APIENTRY glVertexAttrib1fvNV(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib1sNV(GLuint, GLshort);
+    extern void APIENTRY glVertexAttrib1svNV(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib2dNV(GLuint, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib2dvNV(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib2fNV(GLuint, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib2fvNV(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib2sNV(GLuint, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib2svNV(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib3dNV(GLuint, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib3dvNV(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib3fNV(GLuint, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib3fvNV(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib3sNV(GLuint, GLshort, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib3svNV(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib4dNV(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glVertexAttrib4dvNV(GLuint, const GLdouble *);
+    extern void APIENTRY glVertexAttrib4fNV(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glVertexAttrib4fvNV(GLuint, const GLfloat *);
+    extern void APIENTRY glVertexAttrib4sNV(GLuint, GLshort, GLshort, GLshort, GLshort);
+    extern void APIENTRY glVertexAttrib4svNV(GLuint, const GLshort *);
+    extern void APIENTRY glVertexAttrib4ubNV(GLuint, GLubyte, GLubyte, GLubyte, GLubyte);
+    extern void APIENTRY glVertexAttrib4ubvNV(GLuint, const GLubyte *);
+    extern void APIENTRY glVertexAttribs1dvNV(GLuint, GLsizei, const GLdouble *);
+    extern void APIENTRY glVertexAttribs1fvNV(GLuint, GLsizei, const GLfloat *);
+    extern void APIENTRY glVertexAttribs1svNV(GLuint, GLsizei, const GLshort *);
+    extern void APIENTRY glVertexAttribs2dvNV(GLuint, GLsizei, const GLdouble *);
+    extern void APIENTRY glVertexAttribs2fvNV(GLuint, GLsizei, const GLfloat *);
+    extern void APIENTRY glVertexAttribs2svNV(GLuint, GLsizei, const GLshort *);
+    extern void APIENTRY glVertexAttribs3dvNV(GLuint, GLsizei, const GLdouble *);
+    extern void APIENTRY glVertexAttribs3fvNV(GLuint, GLsizei, const GLfloat *);
+    extern void APIENTRY glVertexAttribs3svNV(GLuint, GLsizei, const GLshort *);
+    extern void APIENTRY glVertexAttribs4dvNV(GLuint, GLsizei, const GLdouble *);
+    extern void APIENTRY glVertexAttribs4fvNV(GLuint, GLsizei, const GLfloat *);
+    extern void APIENTRY glVertexAttribs4svNV(GLuint, GLsizei, const GLshort *);
+    extern void APIENTRY glVertexAttribs4ubvNV(GLuint, GLsizei, const GLubyte *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef GLboolean(APIENTRYP PFNGLAREPROGRAMSRESIDENTNVPROC)(GLsizei n, const GLuint *programs, GLboolean *residences);
+    typedef void (APIENTRYP PFNGLBINDPROGRAMNVPROC)(GLenum target, GLuint id);
+    typedef void (APIENTRYP PFNGLDELETEPROGRAMSNVPROC)(GLsizei n, const GLuint *programs);
+    typedef void (APIENTRYP PFNGLEXECUTEPROGRAMNVPROC)(GLenum target, GLuint id, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLGENPROGRAMSNVPROC)(GLsizei n, GLuint *programs);
+    typedef void (APIENTRYP PFNGLGETPROGRAMPARAMETERDVNVPROC)(GLenum target, GLuint index, GLenum pname, GLdouble *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMIVNVPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMSTRINGNVPROC)(GLuint id, GLenum pname, GLubyte *program);
+    typedef void (APIENTRYP PFNGLGETTRACKMATRIXIVNVPROC)(GLenum target, GLuint address, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVNVPROC)(GLuint index, GLenum pname, GLdouble *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVNVPROC)(GLuint index, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVNVPROC)(GLuint index, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVNVPROC)(GLuint index, GLenum pname, GLvoid* *pointer);
+    typedef GLboolean(APIENTRYP PFNGLISPROGRAMNVPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLLOADPROGRAMNVPROC)(GLenum target, GLuint id, GLsizei len, const GLubyte *program);
+    typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4DNVPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4DVNVPROC)(GLenum target, GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4FNVPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4FVNVPROC)(GLenum target, GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLPROGRAMPARAMETERS4DVNVPROC)(GLenum target, GLuint index, GLuint count, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLPROGRAMPARAMETERS4FVNVPROC)(GLenum target, GLuint index, GLuint count, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLREQUESTRESIDENTPROGRAMSNVPROC)(GLsizei n, const GLuint *programs);
+    typedef void (APIENTRYP PFNGLTRACKMATRIXNVPROC)(GLenum target, GLuint address, GLenum matrix, GLenum transform);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERNVPROC)(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1DNVPROC)(GLuint index, GLdouble x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVNVPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1FNVPROC)(GLuint index, GLfloat x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVNVPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1SNVPROC)(GLuint index, GLshort x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVNVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2DNVPROC)(GLuint index, GLdouble x, GLdouble y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVNVPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2FNVPROC)(GLuint index, GLfloat x, GLfloat y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVNVPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2SNVPROC)(GLuint index, GLshort x, GLshort y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVNVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVNVPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVNVPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVNVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVNVPROC)(GLuint index, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVNVPROC)(GLuint index, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVNVPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBNVPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVNVPROC)(GLuint index, const GLubyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS1DVNVPROC)(GLuint index, GLsizei count, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS1FVNVPROC)(GLuint index, GLsizei count, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS1SVNVPROC)(GLuint index, GLsizei count, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS2DVNVPROC)(GLuint index, GLsizei count, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS2FVNVPROC)(GLuint index, GLsizei count, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS2SVNVPROC)(GLuint index, GLsizei count, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS3DVNVPROC)(GLuint index, GLsizei count, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS3FVNVPROC)(GLuint index, GLsizei count, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS3SVNVPROC)(GLuint index, GLsizei count, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS4DVNVPROC)(GLuint index, GLsizei count, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS4FVNVPROC)(GLuint index, GLsizei count, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS4SVNVPROC)(GLuint index, GLsizei count, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS4UBVNVPROC)(GLuint index, GLsizei count, const GLubyte *v);
+#endif
+
+#ifndef GL_SGIX_texture_coordinate_clamp
+#define GL_SGIX_texture_coordinate_clamp 1
+#endif
+
+#ifndef GL_SGIX_scalebias_hint
+#define GL_SGIX_scalebias_hint 1
+#endif
+
+#ifndef GL_OML_interlace
+#define GL_OML_interlace 1
+#endif
+
+#ifndef GL_OML_subsample
+#define GL_OML_subsample 1
+#endif
+
+#ifndef GL_OML_resample
+#define GL_OML_resample 1
+#endif
+
+#ifndef GL_NV_copy_depth_to_color
+#define GL_NV_copy_depth_to_color 1
+#endif
+
+#ifndef GL_ATI_envmap_bumpmap
+#define GL_ATI_envmap_bumpmap 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTexBumpParameterivATI(GLenum, const GLint *);
+    extern void APIENTRY glTexBumpParameterfvATI(GLenum, const GLfloat *);
+    extern void APIENTRY glGetTexBumpParameterivATI(GLenum, GLint *);
+    extern void APIENTRY glGetTexBumpParameterfvATI(GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTEXBUMPPARAMETERIVATIPROC)(GLenum pname, const GLint *param);
+    typedef void (APIENTRYP PFNGLTEXBUMPPARAMETERFVATIPROC)(GLenum pname, const GLfloat *param);
+    typedef void (APIENTRYP PFNGLGETTEXBUMPPARAMETERIVATIPROC)(GLenum pname, GLint *param);
+    typedef void (APIENTRYP PFNGLGETTEXBUMPPARAMETERFVATIPROC)(GLenum pname, GLfloat *param);
+#endif
+
+#ifndef GL_ATI_fragment_shader
+#define GL_ATI_fragment_shader 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern GLuint APIENTRY glGenFragmentShadersATI(GLuint);
+    extern void APIENTRY glBindFragmentShaderATI(GLuint);
+    extern void APIENTRY glDeleteFragmentShaderATI(GLuint);
+    extern void APIENTRY glBeginFragmentShaderATI(void);
+    extern void APIENTRY glEndFragmentShaderATI(void);
+    extern void APIENTRY glPassTexCoordATI(GLuint, GLuint, GLenum);
+    extern void APIENTRY glSampleMapATI(GLuint, GLuint, GLenum);
+    extern void APIENTRY glColorFragmentOp1ATI(GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+    extern void APIENTRY glColorFragmentOp2ATI(GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+    extern void APIENTRY glColorFragmentOp3ATI(GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+    extern void APIENTRY glAlphaFragmentOp1ATI(GLenum, GLuint, GLuint, GLuint, GLuint, GLuint);
+    extern void APIENTRY glAlphaFragmentOp2ATI(GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+    extern void APIENTRY glAlphaFragmentOp3ATI(GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+    extern void APIENTRY glSetFragmentShaderConstantATI(GLuint, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef GLuint(APIENTRYP PFNGLGENFRAGMENTSHADERSATIPROC)(GLuint range);
+    typedef void (APIENTRYP PFNGLBINDFRAGMENTSHADERATIPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLDELETEFRAGMENTSHADERATIPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLBEGINFRAGMENTSHADERATIPROC)(void);
+    typedef void (APIENTRYP PFNGLENDFRAGMENTSHADERATIPROC)(void);
+    typedef void (APIENTRYP PFNGLPASSTEXCOORDATIPROC)(GLuint dst, GLuint coord, GLenum swizzle);
+    typedef void (APIENTRYP PFNGLSAMPLEMAPATIPROC)(GLuint dst, GLuint interp, GLenum swizzle);
+    typedef void (APIENTRYP PFNGLCOLORFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
+    typedef void (APIENTRYP PFNGLCOLORFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
+    typedef void (APIENTRYP PFNGLCOLORFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
+    typedef void (APIENTRYP PFNGLALPHAFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
+    typedef void (APIENTRYP PFNGLALPHAFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
+    typedef void (APIENTRYP PFNGLALPHAFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
+    typedef void (APIENTRYP PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)(GLuint dst, const GLfloat *value);
+#endif
+
+#ifndef GL_ATI_pn_triangles
+#define GL_ATI_pn_triangles 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPNTrianglesiATI(GLenum, GLint);
+    extern void APIENTRY glPNTrianglesfATI(GLenum, GLfloat);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPNTRIANGLESIATIPROC)(GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLPNTRIANGLESFATIPROC)(GLenum pname, GLfloat param);
+#endif
+
+#ifndef GL_ATI_vertex_array_object
+#define GL_ATI_vertex_array_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern GLuint APIENTRY glNewObjectBufferATI(GLsizei, const GLvoid *, GLenum);
+    extern GLboolean APIENTRY glIsObjectBufferATI(GLuint);
+    extern void APIENTRY glUpdateObjectBufferATI(GLuint, GLuint, GLsizei, const GLvoid *, GLenum);
+    extern void APIENTRY glGetObjectBufferfvATI(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetObjectBufferivATI(GLuint, GLenum, GLint *);
+    extern void APIENTRY glFreeObjectBufferATI(GLuint);
+    extern void APIENTRY glArrayObjectATI(GLenum, GLint, GLenum, GLsizei, GLuint, GLuint);
+    extern void APIENTRY glGetArrayObjectfvATI(GLenum, GLenum, GLfloat *);
+    extern void APIENTRY glGetArrayObjectivATI(GLenum, GLenum, GLint *);
+    extern void APIENTRY glVariantArrayObjectATI(GLuint, GLenum, GLsizei, GLuint, GLuint);
+    extern void APIENTRY glGetVariantArrayObjectfvATI(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetVariantArrayObjectivATI(GLuint, GLenum, GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef GLuint(APIENTRYP PFNGLNEWOBJECTBUFFERATIPROC)(GLsizei size, const GLvoid *pointer, GLenum usage);
+    typedef GLboolean(APIENTRYP PFNGLISOBJECTBUFFERATIPROC)(GLuint buffer);
+    typedef void (APIENTRYP PFNGLUPDATEOBJECTBUFFERATIPROC)(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
+    typedef void (APIENTRYP PFNGLGETOBJECTBUFFERFVATIPROC)(GLuint buffer, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETOBJECTBUFFERIVATIPROC)(GLuint buffer, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLFREEOBJECTBUFFERATIPROC)(GLuint buffer);
+    typedef void (APIENTRYP PFNGLARRAYOBJECTATIPROC)(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
+    typedef void (APIENTRYP PFNGLGETARRAYOBJECTFVATIPROC)(GLenum array, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETARRAYOBJECTIVATIPROC)(GLenum array, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLVARIANTARRAYOBJECTATIPROC)(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
+    typedef void (APIENTRYP PFNGLGETVARIANTARRAYOBJECTFVATIPROC)(GLuint id, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETVARIANTARRAYOBJECTIVATIPROC)(GLuint id, GLenum pname, GLint *params);
+#endif
+
+#ifndef GL_EXT_vertex_shader
+#define GL_EXT_vertex_shader 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBeginVertexShaderEXT(void);
+    extern void APIENTRY glEndVertexShaderEXT(void);
+    extern void APIENTRY glBindVertexShaderEXT(GLuint);
+    extern GLuint APIENTRY glGenVertexShadersEXT(GLuint);
+    extern void APIENTRY glDeleteVertexShaderEXT(GLuint);
+    extern void APIENTRY glShaderOp1EXT(GLenum, GLuint, GLuint);
+    extern void APIENTRY glShaderOp2EXT(GLenum, GLuint, GLuint, GLuint);
+    extern void APIENTRY glShaderOp3EXT(GLenum, GLuint, GLuint, GLuint, GLuint);
+    extern void APIENTRY glSwizzleEXT(GLuint, GLuint, GLenum, GLenum, GLenum, GLenum);
+    extern void APIENTRY glWriteMaskEXT(GLuint, GLuint, GLenum, GLenum, GLenum, GLenum);
+    extern void APIENTRY glInsertComponentEXT(GLuint, GLuint, GLuint);
+    extern void APIENTRY glExtractComponentEXT(GLuint, GLuint, GLuint);
+    extern GLuint APIENTRY glGenSymbolsEXT(GLenum, GLenum, GLenum, GLuint);
+    extern void APIENTRY glSetInvariantEXT(GLuint, GLenum, const GLvoid *);
+    extern void APIENTRY glSetLocalConstantEXT(GLuint, GLenum, const GLvoid *);
+    extern void APIENTRY glVariantbvEXT(GLuint, const GLbyte *);
+    extern void APIENTRY glVariantsvEXT(GLuint, const GLshort *);
+    extern void APIENTRY glVariantivEXT(GLuint, const GLint *);
+    extern void APIENTRY glVariantfvEXT(GLuint, const GLfloat *);
+    extern void APIENTRY glVariantdvEXT(GLuint, const GLdouble *);
+    extern void APIENTRY glVariantubvEXT(GLuint, const GLubyte *);
+    extern void APIENTRY glVariantusvEXT(GLuint, const GLushort *);
+    extern void APIENTRY glVariantuivEXT(GLuint, const GLuint *);
+    extern void APIENTRY glVariantPointerEXT(GLuint, GLenum, GLuint, const GLvoid *);
+    extern void APIENTRY glEnableVariantClientStateEXT(GLuint);
+    extern void APIENTRY glDisableVariantClientStateEXT(GLuint);
+    extern GLuint APIENTRY glBindLightParameterEXT(GLenum, GLenum);
+    extern GLuint APIENTRY glBindMaterialParameterEXT(GLenum, GLenum);
+    extern GLuint APIENTRY glBindTexGenParameterEXT(GLenum, GLenum, GLenum);
+    extern GLuint APIENTRY glBindTextureUnitParameterEXT(GLenum, GLenum);
+    extern GLuint APIENTRY glBindParameterEXT(GLenum);
+    extern GLboolean APIENTRY glIsVariantEnabledEXT(GLuint, GLenum);
+    extern void APIENTRY glGetVariantBooleanvEXT(GLuint, GLenum, GLboolean *);
+    extern void APIENTRY glGetVariantIntegervEXT(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetVariantFloatvEXT(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetVariantPointervEXT(GLuint, GLenum, GLvoid* *);
+    extern void APIENTRY glGetInvariantBooleanvEXT(GLuint, GLenum, GLboolean *);
+    extern void APIENTRY glGetInvariantIntegervEXT(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetInvariantFloatvEXT(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetLocalConstantBooleanvEXT(GLuint, GLenum, GLboolean *);
+    extern void APIENTRY glGetLocalConstantIntegervEXT(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetLocalConstantFloatvEXT(GLuint, GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBEGINVERTEXSHADEREXTPROC)(void);
+    typedef void (APIENTRYP PFNGLENDVERTEXSHADEREXTPROC)(void);
+    typedef void (APIENTRYP PFNGLBINDVERTEXSHADEREXTPROC)(GLuint id);
+    typedef GLuint(APIENTRYP PFNGLGENVERTEXSHADERSEXTPROC)(GLuint range);
+    typedef void (APIENTRYP PFNGLDELETEVERTEXSHADEREXTPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLSHADEROP1EXTPROC)(GLenum op, GLuint res, GLuint arg1);
+    typedef void (APIENTRYP PFNGLSHADEROP2EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2);
+    typedef void (APIENTRYP PFNGLSHADEROP3EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
+    typedef void (APIENTRYP PFNGLSWIZZLEEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
+    typedef void (APIENTRYP PFNGLWRITEMASKEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
+    typedef void (APIENTRYP PFNGLINSERTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
+    typedef void (APIENTRYP PFNGLEXTRACTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
+    typedef GLuint(APIENTRYP PFNGLGENSYMBOLSEXTPROC)(GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
+    typedef void (APIENTRYP PFNGLSETINVARIANTEXTPROC)(GLuint id, GLenum type, const GLvoid *addr);
+    typedef void (APIENTRYP PFNGLSETLOCALCONSTANTEXTPROC)(GLuint id, GLenum type, const GLvoid *addr);
+    typedef void (APIENTRYP PFNGLVARIANTBVEXTPROC)(GLuint id, const GLbyte *addr);
+    typedef void (APIENTRYP PFNGLVARIANTSVEXTPROC)(GLuint id, const GLshort *addr);
+    typedef void (APIENTRYP PFNGLVARIANTIVEXTPROC)(GLuint id, const GLint *addr);
+    typedef void (APIENTRYP PFNGLVARIANTFVEXTPROC)(GLuint id, const GLfloat *addr);
+    typedef void (APIENTRYP PFNGLVARIANTDVEXTPROC)(GLuint id, const GLdouble *addr);
+    typedef void (APIENTRYP PFNGLVARIANTUBVEXTPROC)(GLuint id, const GLubyte *addr);
+    typedef void (APIENTRYP PFNGLVARIANTUSVEXTPROC)(GLuint id, const GLushort *addr);
+    typedef void (APIENTRYP PFNGLVARIANTUIVEXTPROC)(GLuint id, const GLuint *addr);
+    typedef void (APIENTRYP PFNGLVARIANTPOINTEREXTPROC)(GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
+    typedef void (APIENTRYP PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
+    typedef GLuint(APIENTRYP PFNGLBINDLIGHTPARAMETEREXTPROC)(GLenum light, GLenum value);
+    typedef GLuint(APIENTRYP PFNGLBINDMATERIALPARAMETEREXTPROC)(GLenum face, GLenum value);
+    typedef GLuint(APIENTRYP PFNGLBINDTEXGENPARAMETEREXTPROC)(GLenum unit, GLenum coord, GLenum value);
+    typedef GLuint(APIENTRYP PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)(GLenum unit, GLenum value);
+    typedef GLuint(APIENTRYP PFNGLBINDPARAMETEREXTPROC)(GLenum value);
+    typedef GLboolean(APIENTRYP PFNGLISVARIANTENABLEDEXTPROC)(GLuint id, GLenum cap);
+    typedef void (APIENTRYP PFNGLGETVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
+    typedef void (APIENTRYP PFNGLGETVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
+    typedef void (APIENTRYP PFNGLGETVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
+    typedef void (APIENTRYP PFNGLGETVARIANTPOINTERVEXTPROC)(GLuint id, GLenum value, GLvoid* *data);
+    typedef void (APIENTRYP PFNGLGETINVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
+    typedef void (APIENTRYP PFNGLGETINVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
+    typedef void (APIENTRYP PFNGLGETINVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
+    typedef void (APIENTRYP PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
+    typedef void (APIENTRYP PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
+    typedef void (APIENTRYP PFNGLGETLOCALCONSTANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
+#endif
+
+#ifndef GL_ATI_vertex_streams
+#define GL_ATI_vertex_streams 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glVertexStream1sATI(GLenum, GLshort);
+    extern void APIENTRY glVertexStream1svATI(GLenum, const GLshort *);
+    extern void APIENTRY glVertexStream1iATI(GLenum, GLint);
+    extern void APIENTRY glVertexStream1ivATI(GLenum, const GLint *);
+    extern void APIENTRY glVertexStream1fATI(GLenum, GLfloat);
+    extern void APIENTRY glVertexStream1fvATI(GLenum, const GLfloat *);
+    extern void APIENTRY glVertexStream1dATI(GLenum, GLdouble);
+    extern void APIENTRY glVertexStream1dvATI(GLenum, const GLdouble *);
+    extern void APIENTRY glVertexStream2sATI(GLenum, GLshort, GLshort);
+    extern void APIENTRY glVertexStream2svATI(GLenum, const GLshort *);
+    extern void APIENTRY glVertexStream2iATI(GLenum, GLint, GLint);
+    extern void APIENTRY glVertexStream2ivATI(GLenum, const GLint *);
+    extern void APIENTRY glVertexStream2fATI(GLenum, GLfloat, GLfloat);
+    extern void APIENTRY glVertexStream2fvATI(GLenum, const GLfloat *);
+    extern void APIENTRY glVertexStream2dATI(GLenum, GLdouble, GLdouble);
+    extern void APIENTRY glVertexStream2dvATI(GLenum, const GLdouble *);
+    extern void APIENTRY glVertexStream3sATI(GLenum, GLshort, GLshort, GLshort);
+    extern void APIENTRY glVertexStream3svATI(GLenum, const GLshort *);
+    extern void APIENTRY glVertexStream3iATI(GLenum, GLint, GLint, GLint);
+    extern void APIENTRY glVertexStream3ivATI(GLenum, const GLint *);
+    extern void APIENTRY glVertexStream3fATI(GLenum, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glVertexStream3fvATI(GLenum, const GLfloat *);
+    extern void APIENTRY glVertexStream3dATI(GLenum, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glVertexStream3dvATI(GLenum, const GLdouble *);
+    extern void APIENTRY glVertexStream4sATI(GLenum, GLshort, GLshort, GLshort, GLshort);
+    extern void APIENTRY glVertexStream4svATI(GLenum, const GLshort *);
+    extern void APIENTRY glVertexStream4iATI(GLenum, GLint, GLint, GLint, GLint);
+    extern void APIENTRY glVertexStream4ivATI(GLenum, const GLint *);
+    extern void APIENTRY glVertexStream4fATI(GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glVertexStream4fvATI(GLenum, const GLfloat *);
+    extern void APIENTRY glVertexStream4dATI(GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glVertexStream4dvATI(GLenum, const GLdouble *);
+    extern void APIENTRY glNormalStream3bATI(GLenum, GLbyte, GLbyte, GLbyte);
+    extern void APIENTRY glNormalStream3bvATI(GLenum, const GLbyte *);
+    extern void APIENTRY glNormalStream3sATI(GLenum, GLshort, GLshort, GLshort);
+    extern void APIENTRY glNormalStream3svATI(GLenum, const GLshort *);
+    extern void APIENTRY glNormalStream3iATI(GLenum, GLint, GLint, GLint);
+    extern void APIENTRY glNormalStream3ivATI(GLenum, const GLint *);
+    extern void APIENTRY glNormalStream3fATI(GLenum, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glNormalStream3fvATI(GLenum, const GLfloat *);
+    extern void APIENTRY glNormalStream3dATI(GLenum, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glNormalStream3dvATI(GLenum, const GLdouble *);
+    extern void APIENTRY glClientActiveVertexStreamATI(GLenum);
+    extern void APIENTRY glVertexBlendEnviATI(GLenum, GLint);
+    extern void APIENTRY glVertexBlendEnvfATI(GLenum, GLfloat);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM1SATIPROC)(GLenum stream, GLshort x);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM1SVATIPROC)(GLenum stream, const GLshort *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM1IATIPROC)(GLenum stream, GLint x);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM1IVATIPROC)(GLenum stream, const GLint *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM1FATIPROC)(GLenum stream, GLfloat x);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM1FVATIPROC)(GLenum stream, const GLfloat *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM1DATIPROC)(GLenum stream, GLdouble x);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM1DVATIPROC)(GLenum stream, const GLdouble *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM2SATIPROC)(GLenum stream, GLshort x, GLshort y);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM2SVATIPROC)(GLenum stream, const GLshort *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM2IATIPROC)(GLenum stream, GLint x, GLint y);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM2IVATIPROC)(GLenum stream, const GLint *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM2FATIPROC)(GLenum stream, GLfloat x, GLfloat y);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM2FVATIPROC)(GLenum stream, const GLfloat *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM2DATIPROC)(GLenum stream, GLdouble x, GLdouble y);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM2DVATIPROC)(GLenum stream, const GLdouble *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM3SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM3SVATIPROC)(GLenum stream, const GLshort *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM3IATIPROC)(GLenum stream, GLint x, GLint y, GLint z);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM3IVATIPROC)(GLenum stream, const GLint *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM3FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM3FVATIPROC)(GLenum stream, const GLfloat *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM3DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM3DVATIPROC)(GLenum stream, const GLdouble *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM4SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM4SVATIPROC)(GLenum stream, const GLshort *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM4IATIPROC)(GLenum stream, GLint x, GLint y, GLint z, GLint w);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM4IVATIPROC)(GLenum stream, const GLint *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM4FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM4FVATIPROC)(GLenum stream, const GLfloat *coords);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM4DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLVERTEXSTREAM4DVATIPROC)(GLenum stream, const GLdouble *coords);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3BATIPROC)(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3BVATIPROC)(GLenum stream, const GLbyte *coords);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3SATIPROC)(GLenum stream, GLshort nx, GLshort ny, GLshort nz);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3SVATIPROC)(GLenum stream, const GLshort *coords);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3IATIPROC)(GLenum stream, GLint nx, GLint ny, GLint nz);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3IVATIPROC)(GLenum stream, const GLint *coords);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3FATIPROC)(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3FVATIPROC)(GLenum stream, const GLfloat *coords);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3DATIPROC)(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
+    typedef void (APIENTRYP PFNGLNORMALSTREAM3DVATIPROC)(GLenum stream, const GLdouble *coords);
+    typedef void (APIENTRYP PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)(GLenum stream);
+    typedef void (APIENTRYP PFNGLVERTEXBLENDENVIATIPROC)(GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLVERTEXBLENDENVFATIPROC)(GLenum pname, GLfloat param);
+#endif
+
+#ifndef GL_ATI_element_array
+#define GL_ATI_element_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glElementPointerATI(GLenum, const GLvoid *);
+    extern void APIENTRY glDrawElementArrayATI(GLenum, GLsizei);
+    extern void APIENTRY glDrawRangeElementArrayATI(GLenum, GLuint, GLuint, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLELEMENTPOINTERATIPROC)(GLenum type, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLDRAWELEMENTARRAYATIPROC)(GLenum mode, GLsizei count);
+    typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTARRAYATIPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count);
+#endif
+
+#ifndef GL_SUN_mesh_array
+#define GL_SUN_mesh_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDrawMeshArraysSUN(GLenum, GLint, GLsizei, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDRAWMESHARRAYSSUNPROC)(GLenum mode, GLint first, GLsizei count, GLsizei width);
+#endif
+
+#ifndef GL_SUN_slice_accum
+#define GL_SUN_slice_accum 1
+#endif
+
+#ifndef GL_NV_multisample_filter_hint
+#define GL_NV_multisample_filter_hint 1
+#endif
+
+#ifndef GL_NV_depth_clamp
+#define GL_NV_depth_clamp 1
+#endif
+
+#ifndef GL_NV_occlusion_query
+#define GL_NV_occlusion_query 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGenOcclusionQueriesNV(GLsizei, GLuint *);
+    extern void APIENTRY glDeleteOcclusionQueriesNV(GLsizei, const GLuint *);
+    extern GLboolean APIENTRY glIsOcclusionQueryNV(GLuint);
+    extern void APIENTRY glBeginOcclusionQueryNV(GLuint);
+    extern void APIENTRY glEndOcclusionQueryNV(void);
+    extern void APIENTRY glGetOcclusionQueryivNV(GLuint, GLenum, GLint *);
+    extern void APIENTRY glGetOcclusionQueryuivNV(GLuint, GLenum, GLuint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGENOCCLUSIONQUERIESNVPROC)(GLsizei n, GLuint *ids);
+    typedef void (APIENTRYP PFNGLDELETEOCCLUSIONQUERIESNVPROC)(GLsizei n, const GLuint *ids);
+    typedef GLboolean(APIENTRYP PFNGLISOCCLUSIONQUERYNVPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLBEGINOCCLUSIONQUERYNVPROC)(GLuint id);
+    typedef void (APIENTRYP PFNGLENDOCCLUSIONQUERYNVPROC)(void);
+    typedef void (APIENTRYP PFNGLGETOCCLUSIONQUERYIVNVPROC)(GLuint id, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETOCCLUSIONQUERYUIVNVPROC)(GLuint id, GLenum pname, GLuint *params);
+#endif
+
+#ifndef GL_NV_point_sprite
+#define GL_NV_point_sprite 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPointParameteriNV(GLenum, GLint);
+    extern void APIENTRY glPointParameterivNV(GLenum, const GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERINVPROC)(GLenum pname, GLint param);
+    typedef void (APIENTRYP PFNGLPOINTPARAMETERIVNVPROC)(GLenum pname, const GLint *params);
+#endif
+
+#ifndef GL_NV_texture_shader3
+#define GL_NV_texture_shader3 1
+#endif
+
+#ifndef GL_NV_vertex_program1_1
+#define GL_NV_vertex_program1_1 1
+#endif
+
+#ifndef GL_EXT_shadow_funcs
+#define GL_EXT_shadow_funcs 1
+#endif
+
+#ifndef GL_EXT_stencil_two_side
+#define GL_EXT_stencil_two_side 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glActiveStencilFaceEXT(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLACTIVESTENCILFACEEXTPROC)(GLenum face);
+#endif
+
+#ifndef GL_ATI_text_fragment_shader
+#define GL_ATI_text_fragment_shader 1
+#endif
+
+#ifndef GL_APPLE_client_storage
+#define GL_APPLE_client_storage 1
+#endif
+
+#ifndef GL_APPLE_element_array
+#define GL_APPLE_element_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glElementPointerAPPLE(GLenum, const GLvoid *);
+    extern void APIENTRY glDrawElementArrayAPPLE(GLenum, GLint, GLsizei);
+    extern void APIENTRY glDrawRangeElementArrayAPPLE(GLenum, GLuint, GLuint, GLint, GLsizei);
+    extern void APIENTRY glMultiDrawElementArrayAPPLE(GLenum, const GLint *, const GLsizei *, GLsizei);
+    extern void APIENTRY glMultiDrawRangeElementArrayAPPLE(GLenum, GLuint, GLuint, const GLint *, const GLsizei *, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLELEMENTPOINTERAPPLEPROC)(GLenum type, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, GLint first, GLsizei count);
+    typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
+    typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
+    typedef void (APIENTRYP PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
+#endif
+
+#ifndef GL_APPLE_fence
+#define GL_APPLE_fence 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGenFencesAPPLE(GLsizei, GLuint *);
+    extern void APIENTRY glDeleteFencesAPPLE(GLsizei, const GLuint *);
+    extern void APIENTRY glSetFenceAPPLE(GLuint);
+    extern GLboolean APIENTRY glIsFenceAPPLE(GLuint);
+    extern GLboolean APIENTRY glTestFenceAPPLE(GLuint);
+    extern void APIENTRY glFinishFenceAPPLE(GLuint);
+    extern GLboolean APIENTRY glTestObjectAPPLE(GLenum, GLuint);
+    extern void APIENTRY glFinishObjectAPPLE(GLenum, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGENFENCESAPPLEPROC)(GLsizei n, GLuint *fences);
+    typedef void (APIENTRYP PFNGLDELETEFENCESAPPLEPROC)(GLsizei n, const GLuint *fences);
+    typedef void (APIENTRYP PFNGLSETFENCEAPPLEPROC)(GLuint fence);
+    typedef GLboolean(APIENTRYP PFNGLISFENCEAPPLEPROC)(GLuint fence);
+    typedef GLboolean(APIENTRYP PFNGLTESTFENCEAPPLEPROC)(GLuint fence);
+    typedef void (APIENTRYP PFNGLFINISHFENCEAPPLEPROC)(GLuint fence);
+    typedef GLboolean(APIENTRYP PFNGLTESTOBJECTAPPLEPROC)(GLenum object, GLuint name);
+    typedef void (APIENTRYP PFNGLFINISHOBJECTAPPLEPROC)(GLenum object, GLint name);
+#endif
+
+#ifndef GL_APPLE_vertex_array_object
+#define GL_APPLE_vertex_array_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBindVertexArrayAPPLE(GLuint);
+    extern void APIENTRY glDeleteVertexArraysAPPLE(GLsizei, const GLuint *);
+    extern void APIENTRY glGenVertexArraysAPPLE(GLsizei, const GLuint *);
+    extern GLboolean APIENTRY glIsVertexArrayAPPLE(GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBINDVERTEXARRAYAPPLEPROC)(GLuint array);
+    typedef void (APIENTRYP PFNGLDELETEVERTEXARRAYSAPPLEPROC)(GLsizei n, const GLuint *arrays);
+    typedef void (APIENTRYP PFNGLGENVERTEXARRAYSAPPLEPROC)(GLsizei n, const GLuint *arrays);
+    typedef GLboolean(APIENTRYP PFNGLISVERTEXARRAYAPPLEPROC)(GLuint array);
+#endif
+
+#ifndef GL_APPLE_vertex_array_range
+#define GL_APPLE_vertex_array_range 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glVertexArrayRangeAPPLE(GLsizei, GLvoid *);
+    extern void APIENTRY glFlushVertexArrayRangeAPPLE(GLsizei, GLvoid *);
+    extern void APIENTRY glVertexArrayParameteriAPPLE(GLenum, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)(GLenum pname, GLint param);
+#endif
+
+#ifndef GL_APPLE_ycbcr_422
+#define GL_APPLE_ycbcr_422 1
+#endif
+
+#ifndef GL_S3_s3tc
+#define GL_S3_s3tc 1
+#endif
+
+#ifndef GL_ATI_draw_buffers
+#define GL_ATI_draw_buffers 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDrawBuffersATI(GLsizei, const GLenum *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDRAWBUFFERSATIPROC)(GLsizei n, const GLenum *bufs);
+#endif
+
+#ifndef GL_ATI_pixel_format_float
+#define GL_ATI_pixel_format_float 1
+    /* This is really a WGL extension, but defines some associated GL enums.
+     * ATI does not export "GL_ATI_pixel_format_float" in the GL_EXTENSIONS string.
+     */
+#endif
+
+#ifndef GL_ATI_texture_env_combine3
+#define GL_ATI_texture_env_combine3 1
+#endif
+
+#ifndef GL_ATI_texture_float
+#define GL_ATI_texture_float 1
+#endif
+
+#ifndef GL_NV_float_buffer
+#define GL_NV_float_buffer 1
+#endif
+
+#ifndef GL_NV_fragment_program
+#define GL_NV_fragment_program 1
+    /* Some NV_fragment_program entry points are shared with ARB_vertex_program. */
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glProgramNamedParameter4fNV(GLuint, GLsizei, const GLubyte *, GLfloat, GLfloat, GLfloat, GLfloat);
+    extern void APIENTRY glProgramNamedParameter4dNV(GLuint, GLsizei, const GLubyte *, GLdouble, GLdouble, GLdouble, GLdouble);
+    extern void APIENTRY glProgramNamedParameter4fvNV(GLuint, GLsizei, const GLubyte *, const GLfloat *);
+    extern void APIENTRY glProgramNamedParameter4dvNV(GLuint, GLsizei, const GLubyte *, const GLdouble *);
+    extern void APIENTRY glGetProgramNamedParameterfvNV(GLuint, GLsizei, const GLubyte *, GLfloat *);
+    extern void APIENTRY glGetProgramNamedParameterdvNV(GLuint, GLsizei, const GLubyte *, GLdouble *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+    typedef void (APIENTRYP PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+    typedef void (APIENTRYP PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v);
+    typedef void (APIENTRYP PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v);
+    typedef void (APIENTRYP PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
+#endif
+
+#ifndef GL_NV_half_float
+#define GL_NV_half_float 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glVertex2hNV(GLhalfNV, GLhalfNV);
+    extern void APIENTRY glVertex2hvNV(const GLhalfNV *);
+    extern void APIENTRY glVertex3hNV(GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glVertex3hvNV(const GLhalfNV *);
+    extern void APIENTRY glVertex4hNV(GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glVertex4hvNV(const GLhalfNV *);
+    extern void APIENTRY glNormal3hNV(GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glNormal3hvNV(const GLhalfNV *);
+    extern void APIENTRY glColor3hNV(GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glColor3hvNV(const GLhalfNV *);
+    extern void APIENTRY glColor4hNV(GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glColor4hvNV(const GLhalfNV *);
+    extern void APIENTRY glTexCoord1hNV(GLhalfNV);
+    extern void APIENTRY glTexCoord1hvNV(const GLhalfNV *);
+    extern void APIENTRY glTexCoord2hNV(GLhalfNV, GLhalfNV);
+    extern void APIENTRY glTexCoord2hvNV(const GLhalfNV *);
+    extern void APIENTRY glTexCoord3hNV(GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glTexCoord3hvNV(const GLhalfNV *);
+    extern void APIENTRY glTexCoord4hNV(GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glTexCoord4hvNV(const GLhalfNV *);
+    extern void APIENTRY glMultiTexCoord1hNV(GLenum, GLhalfNV);
+    extern void APIENTRY glMultiTexCoord1hvNV(GLenum, const GLhalfNV *);
+    extern void APIENTRY glMultiTexCoord2hNV(GLenum, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glMultiTexCoord2hvNV(GLenum, const GLhalfNV *);
+    extern void APIENTRY glMultiTexCoord3hNV(GLenum, GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glMultiTexCoord3hvNV(GLenum, const GLhalfNV *);
+    extern void APIENTRY glMultiTexCoord4hNV(GLenum, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glMultiTexCoord4hvNV(GLenum, const GLhalfNV *);
+    extern void APIENTRY glFogCoordhNV(GLhalfNV);
+    extern void APIENTRY glFogCoordhvNV(const GLhalfNV *);
+    extern void APIENTRY glSecondaryColor3hNV(GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glSecondaryColor3hvNV(const GLhalfNV *);
+    extern void APIENTRY glVertexWeighthNV(GLhalfNV);
+    extern void APIENTRY glVertexWeighthvNV(const GLhalfNV *);
+    extern void APIENTRY glVertexAttrib1hNV(GLuint, GLhalfNV);
+    extern void APIENTRY glVertexAttrib1hvNV(GLuint, const GLhalfNV *);
+    extern void APIENTRY glVertexAttrib2hNV(GLuint, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glVertexAttrib2hvNV(GLuint, const GLhalfNV *);
+    extern void APIENTRY glVertexAttrib3hNV(GLuint, GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glVertexAttrib3hvNV(GLuint, const GLhalfNV *);
+    extern void APIENTRY glVertexAttrib4hNV(GLuint, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+    extern void APIENTRY glVertexAttrib4hvNV(GLuint, const GLhalfNV *);
+    extern void APIENTRY glVertexAttribs1hvNV(GLuint, GLsizei, const GLhalfNV *);
+    extern void APIENTRY glVertexAttribs2hvNV(GLuint, GLsizei, const GLhalfNV *);
+    extern void APIENTRY glVertexAttribs3hvNV(GLuint, GLsizei, const GLhalfNV *);
+    extern void APIENTRY glVertexAttribs4hvNV(GLuint, GLsizei, const GLhalfNV *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLVERTEX2HNVPROC)(GLhalfNV x, GLhalfNV y);
+    typedef void (APIENTRYP PFNGLVERTEX2HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEX3HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z);
+    typedef void (APIENTRYP PFNGLVERTEX3HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEX4HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
+    typedef void (APIENTRYP PFNGLVERTEX4HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLNORMAL3HNVPROC)(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
+    typedef void (APIENTRYP PFNGLNORMAL3HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
+    typedef void (APIENTRYP PFNGLCOLOR3HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLCOLOR4HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
+    typedef void (APIENTRYP PFNGLCOLOR4HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD1HNVPROC)(GLhalfNV s);
+    typedef void (APIENTRYP PFNGLTEXCOORD1HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD2HNVPROC)(GLhalfNV s, GLhalfNV t);
+    typedef void (APIENTRYP PFNGLTEXCOORD2HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD3HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r);
+    typedef void (APIENTRYP PFNGLTEXCOORD3HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLTEXCOORD4HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
+    typedef void (APIENTRYP PFNGLTEXCOORD4HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1HNVPROC)(GLenum target, GLhalfNV s);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD1HVNVPROC)(GLenum target, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD2HVNVPROC)(GLenum target, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD3HVNVPROC)(GLenum target, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
+    typedef void (APIENTRYP PFNGLMULTITEXCOORD4HVNVPROC)(GLenum target, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLFOGCOORDHNVPROC)(GLhalfNV fog);
+    typedef void (APIENTRYP PFNGLFOGCOORDHVNVPROC)(const GLhalfNV *fog);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
+    typedef void (APIENTRYP PFNGLSECONDARYCOLOR3HVNVPROC)(const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEXWEIGHTHNVPROC)(GLhalfNV weight);
+    typedef void (APIENTRYP PFNGLVERTEXWEIGHTHVNVPROC)(const GLhalfNV *weight);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1HNVPROC)(GLuint index, GLhalfNV x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB1HVNVPROC)(GLuint index, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB2HVNVPROC)(GLuint index, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB3HVNVPROC)(GLuint index, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIB4HVNVPROC)(GLuint index, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS1HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS2HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS3HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBS4HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV *v);
+#endif
+
+#ifndef GL_NV_pixel_data_range
+#define GL_NV_pixel_data_range 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPixelDataRangeNV(GLenum, GLsizei, GLvoid *);
+    extern void APIENTRY glFlushPixelDataRangeNV(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPIXELDATARANGENVPROC)(GLenum target, GLsizei length, GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLFLUSHPIXELDATARANGENVPROC)(GLenum target);
+#endif
+
+#ifndef GL_NV_primitive_restart
+#define GL_NV_primitive_restart 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glPrimitiveRestartNV(void);
+    extern void APIENTRY glPrimitiveRestartIndexNV(GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPRIMITIVERESTARTNVPROC)(void);
+    typedef void (APIENTRYP PFNGLPRIMITIVERESTARTINDEXNVPROC)(GLuint index);
+#endif
+
+#ifndef GL_NV_texture_expand_normal
+#define GL_NV_texture_expand_normal 1
+#endif
+
+#ifndef GL_NV_vertex_program2
+#define GL_NV_vertex_program2 1
+#endif
+
+#ifndef GL_ATI_map_object_buffer
+#define GL_ATI_map_object_buffer 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern GLvoid *APIENTRY glMapObjectBufferATI(GLuint);
+    extern void APIENTRY glUnmapObjectBufferATI(GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef GLvoid *(APIENTRYP PFNGLMAPOBJECTBUFFERATIPROC)(GLuint buffer);
+    typedef void (APIENTRYP PFNGLUNMAPOBJECTBUFFERATIPROC)(GLuint buffer);
+#endif
+
+#ifndef GL_ATI_separate_stencil
+#define GL_ATI_separate_stencil 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glStencilOpSeparateATI(GLenum, GLenum, GLenum, GLenum);
+    extern void APIENTRY glStencilFuncSeparateATI(GLenum, GLenum, GLint, GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLSTENCILOPSEPARATEATIPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+    typedef void (APIENTRYP PFNGLSTENCILFUNCSEPARATEATIPROC)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
+#endif
+
+#ifndef GL_ATI_vertex_attrib_array_object
+#define GL_ATI_vertex_attrib_array_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glVertexAttribArrayObjectATI(GLuint, GLint, GLenum, GLboolean, GLsizei, GLuint, GLuint);
+    extern void APIENTRY glGetVertexAttribArrayObjectfvATI(GLuint, GLenum, GLfloat *);
+    extern void APIENTRY glGetVertexAttribArrayObjectivATI(GLuint, GLenum, GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)(GLuint index, GLenum pname, GLfloat *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)(GLuint index, GLenum pname, GLint *params);
+#endif
+
+#ifndef GL_OES_read_format
+#define GL_OES_read_format 1
+#endif
+
+#ifndef GL_EXT_depth_bounds_test
+#define GL_EXT_depth_bounds_test 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDepthBoundsEXT(GLclampd, GLclampd);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDEPTHBOUNDSEXTPROC)(GLclampd zmin, GLclampd zmax);
+#endif
+
+#ifndef GL_EXT_texture_mirror_clamp
+#define GL_EXT_texture_mirror_clamp 1
+#endif
+
+#ifndef GL_EXT_blend_equation_separate
+#define GL_EXT_blend_equation_separate 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlendEquationSeparateEXT(GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEEXTPROC)(GLenum modeRGB, GLenum modeAlpha);
+#endif
+
+#ifndef GL_MESA_pack_invert
+#define GL_MESA_pack_invert 1
+#endif
+
+#ifndef GL_MESA_ycbcr_texture
+#define GL_MESA_ycbcr_texture 1
+#endif
+
+#ifndef GL_EXT_pixel_buffer_object
+#define GL_EXT_pixel_buffer_object 1
+#endif
+
+#ifndef GL_NV_fragment_program_option
+#define GL_NV_fragment_program_option 1
+#endif
+
+#ifndef GL_NV_fragment_program2
+#define GL_NV_fragment_program2 1
+#endif
+
+#ifndef GL_NV_vertex_program2_option
+#define GL_NV_vertex_program2_option 1
+#endif
+
+#ifndef GL_NV_vertex_program3
+#define GL_NV_vertex_program3 1
+#endif
+
+#ifndef GL_EXT_framebuffer_object
+#define GL_EXT_framebuffer_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern GLboolean APIENTRY glIsRenderbufferEXT(GLuint);
+    extern void APIENTRY glBindRenderbufferEXT(GLenum, GLuint);
+    extern void APIENTRY glDeleteRenderbuffersEXT(GLsizei, const GLuint *);
+    extern void APIENTRY glGenRenderbuffersEXT(GLsizei, GLuint *);
+    extern void APIENTRY glRenderbufferStorageEXT(GLenum, GLenum, GLsizei, GLsizei);
+    extern void APIENTRY glGetRenderbufferParameterivEXT(GLenum, GLenum, GLint *);
+    extern GLboolean APIENTRY glIsFramebufferEXT(GLuint);
+    extern void APIENTRY glBindFramebufferEXT(GLenum, GLuint);
+    extern void APIENTRY glDeleteFramebuffersEXT(GLsizei, const GLuint *);
+    extern void APIENTRY glGenFramebuffersEXT(GLsizei, GLuint *);
+    extern GLenum APIENTRY glCheckFramebufferStatusEXT(GLenum);
+    extern void APIENTRY glFramebufferTexture1DEXT(GLenum, GLenum, GLenum, GLuint, GLint);
+    extern void APIENTRY glFramebufferTexture2DEXT(GLenum, GLenum, GLenum, GLuint, GLint);
+    extern void APIENTRY glFramebufferTexture3DEXT(GLenum, GLenum, GLenum, GLuint, GLint, GLint);
+    extern void APIENTRY glFramebufferRenderbufferEXT(GLenum, GLenum, GLenum, GLuint);
+    extern void APIENTRY glGetFramebufferAttachmentParameterivEXT(GLenum, GLenum, GLenum, GLint *);
+    extern void APIENTRY glGenerateMipmapEXT(GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef GLboolean(APIENTRYP PFNGLISRENDERBUFFEREXTPROC)(GLuint renderbuffer);
+    typedef void (APIENTRYP PFNGLBINDRENDERBUFFEREXTPROC)(GLenum target, GLuint renderbuffer);
+    typedef void (APIENTRYP PFNGLDELETERENDERBUFFERSEXTPROC)(GLsizei n, const GLuint *renderbuffers);
+    typedef void (APIENTRYP PFNGLGENRENDERBUFFERSEXTPROC)(GLsizei n, GLuint *renderbuffers);
+    typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
+    typedef void (APIENTRYP PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef GLboolean(APIENTRYP PFNGLISFRAMEBUFFEREXTPROC)(GLuint framebuffer);
+    typedef void (APIENTRYP PFNGLBINDFRAMEBUFFEREXTPROC)(GLenum target, GLuint framebuffer);
+    typedef void (APIENTRYP PFNGLDELETEFRAMEBUFFERSEXTPROC)(GLsizei n, const GLuint *framebuffers);
+    typedef void (APIENTRYP PFNGLGENFRAMEBUFFERSEXTPROC)(GLsizei n, GLuint *framebuffers);
+    typedef GLenum(APIENTRYP PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)(GLenum target);
+    typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
+    typedef void (APIENTRYP PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+    typedef void (APIENTRYP PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGENERATEMIPMAPEXTPROC)(GLenum target);
+#endif
+
+#ifndef GL_GREMEDY_string_marker
+#define GL_GREMEDY_string_marker 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glStringMarkerGREMEDY(GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLSTRINGMARKERGREMEDYPROC)(GLsizei len, const GLvoid *string);
+#endif
+
+#ifndef GL_EXT_Cg_shader
+#define GL_EXT_Cg_shader 1
+#endif
+
+#ifndef GL_EXT_timer_query
+#define GL_EXT_timer_query 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params);
+    extern void APIENTRY glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGETQUERYOBJECTI64VEXTPROC)(GLuint id, GLenum pname, GLint64EXT *params);
+    typedef void (APIENTRYP PFNGLGETQUERYOBJECTUI64VEXTPROC)(GLuint id, GLenum pname, GLuint64EXT *params);
+#endif
+
+#ifndef GL_EXT_texture_buffer_object
+#define GL_EXT_texture_buffer_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTEXBUFFEREXTPROC)(GLenum target, GLenum internalformat, GLuint buffer);
+#endif
+
+#ifndef GL_NV_transform_feedback
+#define GL_NV_transform_feedback 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBeginTransformFeedbackNV(GLenum primitiveMode);
+    extern void APIENTRY glEndTransformFeedbackNV(void);
+    extern void APIENTRY glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode);
+    extern void APIENTRY glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
+    extern void APIENTRY glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
+    extern void APIENTRY glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer);
+    extern void APIENTRY glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
+    extern void APIENTRY glActiveVaryingNV(GLuint program, const GLchar *name);
+    extern GLint APIENTRY glGetVaryingLocationNV(GLuint program, const GLchar *name);
+    extern void APIENTRY glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
+    extern void APIENTRY glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBEGINTRANSFORMFEEDBACKNVPROC)(GLenum primitiveMode);
+    typedef void (APIENTRYP PFNGLENDTRANSFORMFEEDBACKNVPROC)(void);
+    typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)(GLuint count, const GLint *attribs, GLenum bufferMode);
+    typedef void (APIENTRYP PFNGLBINDBUFFERRANGENVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
+    typedef void (APIENTRYP PFNGLBINDBUFFEROFFSETNVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
+    typedef void (APIENTRYP PFNGLBINDBUFFERBASENVPROC)(GLenum target, GLuint index, GLuint buffer);
+    typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
+    typedef void (APIENTRYP PFNGLACTIVEVARYINGNVPROC)(GLuint program, const GLchar *name);
+    typedef GLint(APIENTRYP PFNGLGETVARYINGLOCATIONNVPROC)(GLuint program, const GLchar *name);
+    typedef void (APIENTRYP PFNGLGETACTIVEVARYINGNVPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
+    typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)(GLuint program, GLuint index, GLint *location);
+#endif
+
+
+#ifndef GL_NV_depth_buffer_float
+#define GL_NV_depth_buffer_float 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDepthRangedNV(GLdouble zNear, GLdouble zFar);
+    extern void APIENTRY glClearDepthdNV(GLdouble depth);
+    extern void APIENTRY glDepthBoundsdNV(GLdouble zmin, GLdouble zmax);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDEPTHRANGEDNVPROC)(GLdouble zNear, GLdouble zFar);
+    typedef void (APIENTRYP PFNGLCLEARDEPTHDNVPROC)(GLdouble depth);
+    typedef void (APIENTRYP PFNGLDEPTHBOUNDSDNVPROC)(GLdouble zmin, GLdouble zmax);
+#endif
+
+#ifndef GL_EXT_texture_compression_latc
+#define GL_EXT_texture_compression_latc 1
+#endif
+
+#ifndef GL_EXT_framebuffer_sRGB
+#define GL_EXT_framebuffer_sRGB 1
+#endif
+
+#ifndef GL_EXT_texture_shared_exponent
+#define GL_EXT_texture_shared_exponent 1
+#endif
+
+#ifndef GL_EXT_packed_float
+#define GL_EXT_packed_float 1
+#endif
+
+#ifndef GL_EXT_texture_array
+#define GL_EXT_texture_array 1
+#endif
+
+#ifndef GL_EXT_draw_buffers2
+#define GL_EXT_draw_buffers2 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
+    extern void APIENTRY glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean *data);
+    extern void APIENTRY glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint *data);
+    extern void APIENTRY glEnableIndexedEXT(GLenum target, GLuint index);
+    extern void APIENTRY glDisableIndexedEXT(GLenum target, GLuint index);
+    extern GLboolean APIENTRY glIsEnabledIndexedEXT(GLenum target, GLuint index);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLCOLORMASKINDEXEDEXTPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
+    typedef void (APIENTRYP PFNGLGETBOOLEANINDEXEDVEXTPROC)(GLenum target, GLuint index, GLboolean *data);
+    typedef void (APIENTRYP PFNGLGETINTEGERINDEXEDVEXTPROC)(GLenum target, GLuint index, GLint *data);
+    typedef void (APIENTRYP PFNGLENABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
+    typedef void (APIENTRYP PFNGLDISABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
+    typedef GLboolean(APIENTRYP PFNGLISENABLEDINDEXEDEXTPROC)(GLenum target, GLuint index);
+#endif
+
+#ifndef GL_EXT_texture_integer
+#define GL_EXT_texture_integer 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params);
+    extern void APIENTRY glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params);
+    extern void APIENTRY glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params);
+    extern void APIENTRY glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params);
+    extern void APIENTRY glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha);
+    extern void APIENTRY glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
+    typedef void (APIENTRYP PFNGLTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, const GLuint *params);
+    typedef void (APIENTRYP PFNGLGETTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, GLuint *params);
+    typedef void (APIENTRYP PFNGLCLEARCOLORIIEXTPROC)(GLint red, GLint green, GLint blue, GLint alpha);
+    typedef void (APIENTRYP PFNGLCLEARCOLORIUIEXTPROC)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
+#endif
+
+#ifndef GL_EXT_bindable_uniform
+#define GL_EXT_bindable_uniform 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);
+    extern GLint APIENTRY glGetUniformBufferSizeEXT(GLuint program, GLint location);
+    extern GLintptr APIENTRY glGetUniformOffsetEXT(GLuint program, GLint location);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLUNIFORMBUFFEREXTPROC)(GLuint program, GLint location, GLuint buffer);
+    typedef GLint(APIENTRYP PFNGLGETUNIFORMBUFFERSIZEEXTPROC)(GLuint program, GLint location);
+    typedef GLintptr(APIENTRYP PFNGLGETUNIFORMOFFSETEXTPROC)(GLuint program, GLint location);
+#endif
+
+#ifndef GL_EXT_gpu_shader4
+#define GL_EXT_gpu_shader4 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glGetUniformuivEXT(GLuint program, GLint location, GLuint *params);
+    extern void APIENTRY glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name);
+    extern GLint APIENTRY glGetFragDataLocationEXT(GLuint program, const GLchar *name);
+    extern void APIENTRY glUniform1uiEXT(GLint location, GLuint v0);
+    extern void APIENTRY glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);
+    extern void APIENTRY glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);
+    extern void APIENTRY glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
+    extern void APIENTRY glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value);
+    extern void APIENTRY glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value);
+    extern void APIENTRY glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value);
+    extern void APIENTRY glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value);
+    extern void APIENTRY glVertexAttribI1iEXT(GLuint index, GLint x);
+    extern void APIENTRY glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
+    extern void APIENTRY glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
+    extern void APIENTRY glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
+    extern void APIENTRY glVertexAttribI1uiEXT(GLuint index, GLuint x);
+    extern void APIENTRY glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
+    extern void APIENTRY glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
+    extern void APIENTRY glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    extern void APIENTRY glVertexAttribI1ivEXT(GLuint index, const GLint *v);
+    extern void APIENTRY glVertexAttribI2ivEXT(GLuint index, const GLint *v);
+    extern void APIENTRY glVertexAttribI3ivEXT(GLuint index, const GLint *v);
+    extern void APIENTRY glVertexAttribI4ivEXT(GLuint index, const GLint *v);
+    extern void APIENTRY glVertexAttribI1uivEXT(GLuint index, const GLuint *v);
+    extern void APIENTRY glVertexAttribI2uivEXT(GLuint index, const GLuint *v);
+    extern void APIENTRY glVertexAttribI3uivEXT(GLuint index, const GLuint *v);
+    extern void APIENTRY glVertexAttribI4uivEXT(GLuint index, const GLuint *v);
+    extern void APIENTRY glVertexAttribI4bvEXT(GLuint index, const GLbyte *v);
+    extern void APIENTRY glVertexAttribI4svEXT(GLuint index, const GLshort *v);
+    extern void APIENTRY glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v);
+    extern void APIENTRY glVertexAttribI4usvEXT(GLuint index, const GLushort *v);
+    extern void APIENTRY glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    extern void APIENTRY glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params);
+    extern void APIENTRY glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLGETUNIFORMUIVEXTPROC)(GLuint program, GLint location, GLuint *params);
+    typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONEXTPROC)(GLuint program, GLuint color, const GLchar *name);
+    typedef GLint(APIENTRYP PFNGLGETFRAGDATALOCATIONEXTPROC)(GLuint program, const GLchar *name);
+    typedef void (APIENTRYP PFNGLUNIFORM1UIEXTPROC)(GLint location, GLuint v0);
+    typedef void (APIENTRYP PFNGLUNIFORM2UIEXTPROC)(GLint location, GLuint v0, GLuint v1);
+    typedef void (APIENTRYP PFNGLUNIFORM3UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
+    typedef void (APIENTRYP PFNGLUNIFORM4UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
+    typedef void (APIENTRYP PFNGLUNIFORM1UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM2UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM3UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
+    typedef void (APIENTRYP PFNGLUNIFORM4UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IEXTPROC)(GLuint index, GLint x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IEXTPROC)(GLuint index, GLint x, GLint y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IEXTPROC)(GLuint index, GLint x, GLint y, GLint z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IEXTPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIEXTPROC)(GLuint index, GLuint x);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIEXTPROC)(GLuint index, GLuint x, GLuint y);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IVEXTPROC)(GLuint index, const GLint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IVEXTPROC)(GLuint index, const GLint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IVEXTPROC)(GLuint index, const GLint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IVEXTPROC)(GLuint index, const GLint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIVEXTPROC)(GLuint index, const GLuint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIVEXTPROC)(GLuint index, const GLuint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIVEXTPROC)(GLuint index, const GLuint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIVEXTPROC)(GLuint index, const GLuint *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI4BVEXTPROC)(GLuint index, const GLbyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI4SVEXTPROC)(GLuint index, const GLshort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UBVEXTPROC)(GLuint index, const GLubyte *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBI4USVEXTPROC)(GLuint index, const GLushort *v);
+    typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIIVEXTPROC)(GLuint index, GLenum pname, GLint *params);
+    typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIUIVEXTPROC)(GLuint index, GLenum pname, GLuint *params);
+#endif
+
+
+#ifndef GL_EXT_geometry_shader4
+#define GL_EXT_geometry_shader4 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
+    extern void APIENTRY glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);
+    extern void APIENTRY glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
+    extern void APIENTRY glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPROGRAMPARAMETERIEXTPROC)(GLuint program, GLenum pname, GLint value);
+    typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
+    typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
+    typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
+#endif
+
+#ifndef GL_NV_geometry_program4
+#define GL_NV_geometry_program4 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glProgramVertexLimitNV(GLenum target, GLint limit);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPROGRAMVERTEXLIMITNVPROC)(GLenum target, GLint limit);
+#endif
+
+#ifndef GL_NV_gpu_program4
+#define GL_NV_gpu_program4 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
+    extern void APIENTRY glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params);
+    extern void APIENTRY glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params);
+    extern void APIENTRY glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    extern void APIENTRY glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params);
+    extern void APIENTRY glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params);
+    extern void APIENTRY glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
+    extern void APIENTRY glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params);
+    extern void APIENTRY glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params);
+    extern void APIENTRY glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    extern void APIENTRY glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params);
+    extern void APIENTRY glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params);
+    extern void APIENTRY glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params);
+    extern void APIENTRY glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params);
+    extern void APIENTRY glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params);
+    extern void APIENTRY glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint *params);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint *params);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint *params);
+    typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint *params);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint *params);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint *params);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint *params);
+    typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC)(GLenum target, GLuint index, GLint *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC)(GLenum target, GLuint index, GLuint *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMENVPARAMETERIIVNVPROC)(GLenum target, GLuint index, GLint *params);
+    typedef void (APIENTRYP PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC)(GLenum target, GLuint index, GLuint *params);
+#endif
+
+#ifndef GL_NV_parameter_buffer_object
+#define GL_NV_parameter_buffer_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
+    extern void APIENTRY glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
+    extern void APIENTRY glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
+    typedef void (APIENTRYP PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
+    typedef void (APIENTRYP PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
+#endif
+
+#ifndef GL_EXT_framebuffer_multisample
+#define GL_EXT_framebuffer_multisample 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
+#endif
+
+#ifndef GL_NV_framebuffer_multisample_coverage
+#define GL_NV_framebuffer_multisample_coverage 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
+#endif
+
+#ifndef GL_EXT_framebuffer_blit
+#define GL_EXT_framebuffer_blit 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLBLITFRAMEBUFFEREXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+#endif
+
+#ifndef GL_EXT_draw_instanced
+#define GL_EXT_draw_instanced 1
+#ifdef GL_GLEXT_PROTOTYPES
+    extern void APIENTRY glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
+    extern void APIENTRY glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
+#endif /* GL_GLEXT_PROTOTYPES */
+    typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDEXTPROC)(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
+    typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDEXTPROC)(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
+#endif
+
+#ifndef GL_EXT_texture_compression_rgtc
+#define GL_EXT_texture_compression_rgtc 1
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/glut.h gpu-rodinia_new/cuda/cfd/common/inc/GL/glut.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/glut.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/glut.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,597 @@
+#ifndef __glut_h__
+#define __glut_h__
+
+/* Copyright (c) Mark J. Kilgard, 1994, 1995, 1996, 1998. */
+
+/* This program is freely distributable without licensing fees  and is
+   provided without guarantee or warrantee expressed or  implied. This
+   program is -not- in the public domain. */
+
+#if defined(_WIN32)
+
+/* GLUT 3.7 now tries to avoid including <windows.h>
+   to avoid name space pollution, but Win32's <GL/gl.h>
+   needs APIENTRY and WINGDIAPI defined properly. */
+# if 0
+#  define  WIN32_LEAN_AND_MEAN
+#  include <windows.h>
+# else
+/* XXX This is from Win32's <windef.h> */
+#  ifndef APIENTRY
+#   define GLUT_APIENTRY_DEFINED
+#   if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
+#    define APIENTRY    __stdcall
+#   else
+#    define APIENTRY
+#   endif
+#  endif
+/* XXX This is from Win32's <winnt.h> */
+#  ifndef CALLBACK
+#   if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
+#    define CALLBACK __stdcall
+#   else
+#    define CALLBACK
+#   endif
+#  endif
+/* XXX This is from Win32's <wingdi.h> and <winnt.h> */
+#  ifndef WINGDIAPI
+#   define GLUT_WINGDIAPI_DEFINED
+#   define WINGDIAPI __declspec(dllimport)
+#  endif
+/* XXX This is from Win32's <ctype.h> */
+#  ifndef _WCHAR_T_DEFINED
+typedef unsigned short wchar_t;
+#   define _WCHAR_T_DEFINED
+#  endif
+# endif
+
+#pragma comment (lib, "winmm.lib")     /* link with Windows MultiMedia lib */
+#pragma comment (lib, "opengl32.lib")  /* link with Microsoft OpenGL lib */
+#pragma comment (lib, "glu32.lib")     /* link with OpenGL Utility lib */
+#pragma message("Note: including lib: glut32.lib\n")
+#pragma comment (lib, "glut32.lib")    /* link with Win32 GLUT lib */
+
+#pragma warning (disable:4244)  /* Disable bogus conversion warnings. */
+#pragma warning (disable:4305)  /* VC++ 5.0 version of above warning. */
+
+#endif
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+
+/* define APIENTRY and CALLBACK to null string if we aren't on Win32 */
+#if !defined(_WIN32)
+#define APIENTRY
+#define GLUT_APIENTRY_DEFINED
+#define CALLBACK
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     GLUT API revision history:
+
+     GLUT_API_VERSION is updated to reflect incompatible GLUT
+     API changes (interface changes, semantic changes, deletions,
+     or additions).
+
+     GLUT_API_VERSION=1  First public release of GLUT.  11/29/94
+
+     GLUT_API_VERSION=2  Added support for OpenGL/GLX multisampling,
+     extension.  Supports new input devices like tablet, dial and button
+     box, and Spaceball.  Easy to query OpenGL extensions.
+
+     GLUT_API_VERSION=3  glutMenuStatus added.
+
+     GLUT_API_VERSION=4  glutInitDisplayString, glutWarpPointer,
+     glutBitmapLength, glutStrokeLength, glutWindowStatusFunc, dynamic
+     video resize subAPI, glutPostWindowRedisplay, glutKeyboardUpFunc,
+     glutSpecialUpFunc, glutIgnoreKeyRepeat, glutSetKeyRepeat,
+     glutJoystickFunc, glutForceJoystickFunc (NOT FINALIZED!).
+    **/
+#ifndef GLUT_API_VERSION  /* allow this to be overriden */
+#define GLUT_API_VERSION        3
+#endif
+
+    /**
+     GLUT implementation revision history:
+
+     GLUT_XLIB_IMPLEMENTATION is updated to reflect both GLUT
+     API revisions and implementation revisions (ie, bug fixes).
+
+     GLUT_XLIB_IMPLEMENTATION=1  mjk's first public release of
+     GLUT Xlib-based implementation.  11/29/94
+
+     GLUT_XLIB_IMPLEMENTATION=2  mjk's second public release of
+     GLUT Xlib-based implementation providing GLUT version 2
+     interfaces.
+
+     GLUT_XLIB_IMPLEMENTATION=3  mjk's GLUT 2.2 images. 4/17/95
+
+     GLUT_XLIB_IMPLEMENTATION=4  mjk's GLUT 2.3 images. 6/?/95
+
+     GLUT_XLIB_IMPLEMENTATION=5  mjk's GLUT 3.0 images. 10/?/95
+
+     GLUT_XLIB_IMPLEMENTATION=7  mjk's GLUT 3.1+ with glutWarpPoitner.  7/24/96
+
+     GLUT_XLIB_IMPLEMENTATION=8  mjk's GLUT 3.1+ with glutWarpPoitner
+     and video resize.  1/3/97
+
+     GLUT_XLIB_IMPLEMENTATION=9 mjk's GLUT 3.4 release with early GLUT 4 routines.
+
+     GLUT_XLIB_IMPLEMENTATION=11 Mesa 2.5's GLUT 3.6 release.
+
+     GLUT_XLIB_IMPLEMENTATION=12 mjk's GLUT 3.6 release with early GLUT 4 routines + signal handling.
+
+     GLUT_XLIB_IMPLEMENTATION=13 mjk's GLUT 3.7 release with GameGLUT support.
+    **/
+#ifndef GLUT_XLIB_IMPLEMENTATION  /* Allow this to be overriden. */
+#define GLUT_XLIB_IMPLEMENTATION    13
+#endif
+
+    /* Display mode bit masks. */
+#define GLUT_RGB            0
+#define GLUT_RGBA           GLUT_RGB
+#define GLUT_INDEX          1
+#define GLUT_SINGLE         0
+#define GLUT_DOUBLE         2
+#define GLUT_ACCUM          4
+#define GLUT_ALPHA          8
+#define GLUT_DEPTH          16
+#define GLUT_STENCIL            32
+#if (GLUT_API_VERSION >= 2)
+#define GLUT_MULTISAMPLE        128
+#define GLUT_STEREO         256
+#endif
+#if (GLUT_API_VERSION >= 3)
+#define GLUT_LUMINANCE          512
+#endif
+
+    /* Mouse buttons. */
+#define GLUT_LEFT_BUTTON        0
+#define GLUT_MIDDLE_BUTTON      1
+#define GLUT_RIGHT_BUTTON       2
+
+    /* Mouse button  state. */
+#define GLUT_DOWN           0
+#define GLUT_UP             1
+
+#if (GLUT_API_VERSION >= 2)
+    /* function keys */
+#define GLUT_KEY_F1         1
+#define GLUT_KEY_F2         2
+#define GLUT_KEY_F3         3
+#define GLUT_KEY_F4         4
+#define GLUT_KEY_F5         5
+#define GLUT_KEY_F6         6
+#define GLUT_KEY_F7         7
+#define GLUT_KEY_F8         8
+#define GLUT_KEY_F9         9
+#define GLUT_KEY_F10            10
+#define GLUT_KEY_F11            11
+#define GLUT_KEY_F12            12
+    /* directional keys */
+#define GLUT_KEY_LEFT           100
+#define GLUT_KEY_UP         101
+#define GLUT_KEY_RIGHT          102
+#define GLUT_KEY_DOWN           103
+#define GLUT_KEY_PAGE_UP        104
+#define GLUT_KEY_PAGE_DOWN      105
+#define GLUT_KEY_HOME           106
+#define GLUT_KEY_END            107
+#define GLUT_KEY_INSERT         108
+#endif
+
+    /* Entry/exit  state. */
+#define GLUT_LEFT           0
+#define GLUT_ENTERED            1
+
+    /* Menu usage  state. */
+#define GLUT_MENU_NOT_IN_USE        0
+#define GLUT_MENU_IN_USE        1
+
+    /* Visibility  state. */
+#define GLUT_NOT_VISIBLE        0
+#define GLUT_VISIBLE            1
+
+    /* Window status  state. */
+#define GLUT_HIDDEN         0
+#define GLUT_FULLY_RETAINED     1
+#define GLUT_PARTIALLY_RETAINED     2
+#define GLUT_FULLY_COVERED      3
+
+    /* Color index component selection values. */
+#define GLUT_RED            0
+#define GLUT_GREEN          1
+#define GLUT_BLUE           2
+
+    /* Layers for use. */
+#define GLUT_NORMAL         0
+#define GLUT_OVERLAY            1
+
+#if defined(_WIN32)
+    /* Stroke font constants (use these in GLUT program). */
+#define GLUT_STROKE_ROMAN       ((void*)0)
+#define GLUT_STROKE_MONO_ROMAN      ((void*)1)
+
+    /* Bitmap font constants (use these in GLUT program). */
+#define GLUT_BITMAP_9_BY_15     ((void*)2)
+#define GLUT_BITMAP_8_BY_13     ((void*)3)
+#define GLUT_BITMAP_TIMES_ROMAN_10  ((void*)4)
+#define GLUT_BITMAP_TIMES_ROMAN_24  ((void*)5)
+#if (GLUT_API_VERSION >= 3)
+#define GLUT_BITMAP_HELVETICA_10    ((void*)6)
+#define GLUT_BITMAP_HELVETICA_12    ((void*)7)
+#define GLUT_BITMAP_HELVETICA_18    ((void*)8)
+#endif
+#else
+    /* Stroke font opaque addresses (use constants instead in source code). */
+    extern void *glutStrokeRoman;
+    extern void *glutStrokeMonoRoman;
+
+    /* Stroke font constants (use these in GLUT program). */
+#define GLUT_STROKE_ROMAN       (&glutStrokeRoman)
+#define GLUT_STROKE_MONO_ROMAN      (&glutStrokeMonoRoman)
+
+    /* Bitmap font opaque addresses (use constants instead in source code). */
+    extern void *glutBitmap9By15;
+    extern void *glutBitmap8By13;
+    extern void *glutBitmapTimesRoman10;
+    extern void *glutBitmapTimesRoman24;
+    extern void *glutBitmapHelvetica10;
+    extern void *glutBitmapHelvetica12;
+    extern void *glutBitmapHelvetica18;
+
+    /* Bitmap font constants (use these in GLUT program). */
+#define GLUT_BITMAP_9_BY_15     (&glutBitmap9By15)
+#define GLUT_BITMAP_8_BY_13     (&glutBitmap8By13)
+#define GLUT_BITMAP_TIMES_ROMAN_10  (&glutBitmapTimesRoman10)
+#define GLUT_BITMAP_TIMES_ROMAN_24  (&glutBitmapTimesRoman24)
+#if (GLUT_API_VERSION >= 3)
+#define GLUT_BITMAP_HELVETICA_10    (&glutBitmapHelvetica10)
+#define GLUT_BITMAP_HELVETICA_12    (&glutBitmapHelvetica12)
+#define GLUT_BITMAP_HELVETICA_18    (&glutBitmapHelvetica18)
+#endif
+#endif
+
+    /* glutGet parameters. */
+#define GLUT_WINDOW_X           100
+#define GLUT_WINDOW_Y           101
+#define GLUT_WINDOW_WIDTH       102
+#define GLUT_WINDOW_HEIGHT      103
+#define GLUT_WINDOW_BUFFER_SIZE     104
+#define GLUT_WINDOW_STENCIL_SIZE    105
+#define GLUT_WINDOW_DEPTH_SIZE      106
+#define GLUT_WINDOW_RED_SIZE        107
+#define GLUT_WINDOW_GREEN_SIZE      108
+#define GLUT_WINDOW_BLUE_SIZE       109
+#define GLUT_WINDOW_ALPHA_SIZE      110
+#define GLUT_WINDOW_ACCUM_RED_SIZE  111
+#define GLUT_WINDOW_ACCUM_GREEN_SIZE    112
+#define GLUT_WINDOW_ACCUM_BLUE_SIZE 113
+#define GLUT_WINDOW_ACCUM_ALPHA_SIZE    114
+#define GLUT_WINDOW_DOUBLEBUFFER    115
+#define GLUT_WINDOW_RGBA        116
+#define GLUT_WINDOW_PARENT      117
+#define GLUT_WINDOW_NUM_CHILDREN    118
+#define GLUT_WINDOW_COLORMAP_SIZE   119
+#if (GLUT_API_VERSION >= 2)
+#define GLUT_WINDOW_NUM_SAMPLES     120
+#define GLUT_WINDOW_STEREO      121
+#endif
+#if (GLUT_API_VERSION >= 3)
+#define GLUT_WINDOW_CURSOR      122
+#endif
+#define GLUT_SCREEN_WIDTH       200
+#define GLUT_SCREEN_HEIGHT      201
+#define GLUT_SCREEN_WIDTH_MM        202
+#define GLUT_SCREEN_HEIGHT_MM       203
+#define GLUT_MENU_NUM_ITEMS     300
+#define GLUT_DISPLAY_MODE_POSSIBLE  400
+#define GLUT_INIT_WINDOW_X      500
+#define GLUT_INIT_WINDOW_Y      501
+#define GLUT_INIT_WINDOW_WIDTH      502
+#define GLUT_INIT_WINDOW_HEIGHT     503
+#define GLUT_INIT_DISPLAY_MODE      504
+#if (GLUT_API_VERSION >= 2)
+#define GLUT_ELAPSED_TIME       700
+#endif
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 13)
+#define GLUT_WINDOW_FORMAT_ID       123
+#endif
+
+#if (GLUT_API_VERSION >= 2)
+    /* glutDeviceGet parameters. */
+#define GLUT_HAS_KEYBOARD       600
+#define GLUT_HAS_MOUSE          601
+#define GLUT_HAS_SPACEBALL      602
+#define GLUT_HAS_DIAL_AND_BUTTON_BOX    603
+#define GLUT_HAS_TABLET         604
+#define GLUT_NUM_MOUSE_BUTTONS      605
+#define GLUT_NUM_SPACEBALL_BUTTONS  606
+#define GLUT_NUM_BUTTON_BOX_BUTTONS 607
+#define GLUT_NUM_DIALS          608
+#define GLUT_NUM_TABLET_BUTTONS     609
+#endif
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 13)
+#define GLUT_DEVICE_IGNORE_KEY_REPEAT   610
+#define GLUT_DEVICE_KEY_REPEAT          611
+#define GLUT_HAS_JOYSTICK       612
+#define GLUT_OWNS_JOYSTICK      613
+#define GLUT_JOYSTICK_BUTTONS       614
+#define GLUT_JOYSTICK_AXES      615
+#define GLUT_JOYSTICK_POLL_RATE     616
+#endif
+
+#if (GLUT_API_VERSION >= 3)
+    /* glutLayerGet parameters. */
+#define GLUT_OVERLAY_POSSIBLE           800
+#define GLUT_LAYER_IN_USE       801
+#define GLUT_HAS_OVERLAY        802
+#define GLUT_TRANSPARENT_INDEX      803
+#define GLUT_NORMAL_DAMAGED     804
+#define GLUT_OVERLAY_DAMAGED        805
+
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 9)
+    /* glutVideoResizeGet parameters. */
+#define GLUT_VIDEO_RESIZE_POSSIBLE  900
+#define GLUT_VIDEO_RESIZE_IN_USE    901
+#define GLUT_VIDEO_RESIZE_X_DELTA   902
+#define GLUT_VIDEO_RESIZE_Y_DELTA   903
+#define GLUT_VIDEO_RESIZE_WIDTH_DELTA   904
+#define GLUT_VIDEO_RESIZE_HEIGHT_DELTA  905
+#define GLUT_VIDEO_RESIZE_X     906
+#define GLUT_VIDEO_RESIZE_Y     907
+#define GLUT_VIDEO_RESIZE_WIDTH     908
+#define GLUT_VIDEO_RESIZE_HEIGHT    909
+#endif
+
+    /* glutUseLayer parameters. */
+#define GLUT_NORMAL         0
+#define GLUT_OVERLAY            1
+
+    /* glutGetModifiers return mask. */
+#define GLUT_ACTIVE_SHIFT               1
+#define GLUT_ACTIVE_CTRL                2
+#define GLUT_ACTIVE_ALT                 4
+
+    /* glutSetCursor parameters. */
+    /* Basic arrows. */
+#define GLUT_CURSOR_RIGHT_ARROW     0
+#define GLUT_CURSOR_LEFT_ARROW      1
+    /* Symbolic cursor shapes. */
+#define GLUT_CURSOR_INFO        2
+#define GLUT_CURSOR_DESTROY     3
+#define GLUT_CURSOR_HELP        4
+#define GLUT_CURSOR_CYCLE       5
+#define GLUT_CURSOR_SPRAY       6
+#define GLUT_CURSOR_WAIT        7
+#define GLUT_CURSOR_TEXT        8
+#define GLUT_CURSOR_CROSSHAIR       9
+    /* Directional cursors. */
+#define GLUT_CURSOR_UP_DOWN     10
+#define GLUT_CURSOR_LEFT_RIGHT      11
+    /* Sizing cursors. */
+#define GLUT_CURSOR_TOP_SIDE        12
+#define GLUT_CURSOR_BOTTOM_SIDE     13
+#define GLUT_CURSOR_LEFT_SIDE       14
+#define GLUT_CURSOR_RIGHT_SIDE      15
+#define GLUT_CURSOR_TOP_LEFT_CORNER 16
+#define GLUT_CURSOR_TOP_RIGHT_CORNER    17
+#define GLUT_CURSOR_BOTTOM_RIGHT_CORNER 18
+#define GLUT_CURSOR_BOTTOM_LEFT_CORNER  19
+    /* Inherit from parent window. */
+#define GLUT_CURSOR_INHERIT     100
+    /* Blank cursor. */
+#define GLUT_CURSOR_NONE        101
+    /* Fullscreen crosshair (if available). */
+#define GLUT_CURSOR_FULL_CROSSHAIR  102
+#endif
+
+    /* GLUT initialization sub-API. */
+    extern void APIENTRY glutInit(int *argcp, char **argv);
+    extern void APIENTRY glutInitDisplayMode(unsigned int mode);
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 9)
+    extern void APIENTRY glutInitDisplayString(const char *string);
+#endif
+    extern void APIENTRY glutInitWindowPosition(int x, int y);
+    extern void APIENTRY glutInitWindowSize(int width, int height);
+    extern void APIENTRY glutMainLoop(void);
+
+    /* GLUT window sub-API. */
+    extern int APIENTRY glutCreateWindow(const char *title);
+    extern int APIENTRY glutCreateSubWindow(int win, int x, int y, int width, int height);
+    extern void APIENTRY glutDestroyWindow(int win);
+    extern void APIENTRY glutPostRedisplay(void);
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 11)
+    extern void APIENTRY glutPostWindowRedisplay(int win);
+#endif
+    extern void APIENTRY glutSwapBuffers(void);
+    extern int APIENTRY glutGetWindow(void);
+    extern void APIENTRY glutSetWindow(int win);
+    extern void APIENTRY glutSetWindowTitle(const char *title);
+    extern void APIENTRY glutSetIconTitle(const char *title);
+    extern void APIENTRY glutPositionWindow(int x, int y);
+    extern void APIENTRY glutReshapeWindow(int width, int height);
+    extern void APIENTRY glutPopWindow(void);
+    extern void APIENTRY glutPushWindow(void);
+    extern void APIENTRY glutIconifyWindow(void);
+    extern void APIENTRY glutShowWindow(void);
+    extern void APIENTRY glutHideWindow(void);
+#if (GLUT_API_VERSION >= 3)
+    extern void APIENTRY glutFullScreen(void);
+    extern void APIENTRY glutSetCursor(int cursor);
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 9)
+    extern void APIENTRY glutWarpPointer(int x, int y);
+#endif
+
+    /* GLUT overlay sub-API. */
+    extern void APIENTRY glutEstablishOverlay(void);
+    extern void APIENTRY glutRemoveOverlay(void);
+    extern void APIENTRY glutUseLayer(GLenum layer);
+    extern void APIENTRY glutPostOverlayRedisplay(void);
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 11)
+    extern void APIENTRY glutPostWindowOverlayRedisplay(int win);
+#endif
+    extern void APIENTRY glutShowOverlay(void);
+    extern void APIENTRY glutHideOverlay(void);
+#endif
+
+    /* GLUT menu sub-API. */
+    extern int APIENTRY glutCreateMenu(void ( *)(int));
+    extern void APIENTRY glutDestroyMenu(int menu);
+    extern int APIENTRY glutGetMenu(void);
+    extern void APIENTRY glutSetMenu(int menu);
+    extern void APIENTRY glutAddMenuEntry(const char *label, int value);
+    extern void APIENTRY glutAddSubMenu(const char *label, int submenu);
+    extern void APIENTRY glutChangeToMenuEntry(int item, const char *label, int value);
+    extern void APIENTRY glutChangeToSubMenu(int item, const char *label, int submenu);
+    extern void APIENTRY glutRemoveMenuItem(int item);
+    extern void APIENTRY glutAttachMenu(int button);
+    extern void APIENTRY glutDetachMenu(int button);
+
+    /* GLUT window callback sub-API. */
+    extern void APIENTRY glutDisplayFunc(void (*func)(void));
+    extern void APIENTRY glutReshapeFunc(void (*func)(int width, int height));
+    extern void APIENTRY glutKeyboardFunc(void (*func)(unsigned char key, int x, int y));
+    extern void APIENTRY glutMouseFunc(void (*func)(int button, int state, int x, int y));
+    extern void APIENTRY glutMotionFunc(void (*func)(int x, int y));
+    extern void APIENTRY glutPassiveMotionFunc(void (*func)(int x, int y));
+    extern void APIENTRY glutEntryFunc(void (*func)(int state));
+    extern void APIENTRY glutVisibilityFunc(void (*func)(int state));
+    extern void APIENTRY glutIdleFunc(void (*func)(void));
+    extern void APIENTRY glutTimerFunc(unsigned int millis, void (*func)(int value), int value);
+    extern void APIENTRY glutMenuStateFunc(void (*func)(int state));
+#if (GLUT_API_VERSION >= 2)
+    extern void APIENTRY glutSpecialFunc(void (*func)(int key, int x, int y));
+    extern void APIENTRY glutSpaceballMotionFunc(void (*func)(int x, int y, int z));
+    extern void APIENTRY glutSpaceballRotateFunc(void (*func)(int x, int y, int z));
+    extern void APIENTRY glutSpaceballButtonFunc(void (*func)(int button, int state));
+    extern void APIENTRY glutButtonBoxFunc(void (*func)(int button, int state));
+    extern void APIENTRY glutDialsFunc(void (*func)(int dial, int value));
+    extern void APIENTRY glutTabletMotionFunc(void (*func)(int x, int y));
+    extern void APIENTRY glutTabletButtonFunc(void (*func)(int button, int state, int x, int y));
+#if (GLUT_API_VERSION >= 3)
+    extern void APIENTRY glutMenuStatusFunc(void (*func)(int status, int x, int y));
+    extern void APIENTRY glutOverlayDisplayFunc(void (*func)(void));
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 9)
+    extern void APIENTRY glutWindowStatusFunc(void (*func)(int state));
+#endif
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 13)
+    extern void APIENTRY glutKeyboardUpFunc(void (*func)(unsigned char key, int x, int y));
+    extern void APIENTRY glutSpecialUpFunc(void (*func)(int key, int x, int y));
+    extern void APIENTRY glutJoystickFunc(void (*func)(unsigned int buttonMask, int x, int y, int z), int pollInterval);
+#endif
+#endif
+#endif
+
+    /* GLUT color index sub-API. */
+    extern void APIENTRY glutSetColor(int, GLfloat red, GLfloat green, GLfloat blue);
+    extern GLfloat APIENTRY glutGetColor(int ndx, int component);
+    extern void APIENTRY glutCopyColormap(int win);
+
+    /* GLUT state retrieval sub-API. */
+    extern int APIENTRY glutGet(GLenum type);
+    extern int APIENTRY glutDeviceGet(GLenum type);
+#if (GLUT_API_VERSION >= 2)
+    /* GLUT extension support sub-API */
+    extern int APIENTRY glutExtensionSupported(const char *name);
+#endif
+#if (GLUT_API_VERSION >= 3)
+    extern int APIENTRY glutGetModifiers(void);
+    extern int APIENTRY glutLayerGet(GLenum type);
+#endif
+
+    /* GLUT font sub-API */
+    extern void APIENTRY glutBitmapCharacter(void *font, int character);
+    extern int APIENTRY glutBitmapWidth(void *font, int character);
+    extern void APIENTRY glutStrokeCharacter(void *font, int character);
+    extern int APIENTRY glutStrokeWidth(void *font, int character);
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 9)
+    extern int APIENTRY glutBitmapLength(void *font, const unsigned char *string);
+    extern int APIENTRY glutStrokeLength(void *font, const unsigned char *string);
+#endif
+
+    /* GLUT pre-built models sub-API */
+    extern void APIENTRY glutWireSphere(GLdouble radius, GLint slices, GLint stacks);
+    extern void APIENTRY glutSolidSphere(GLdouble radius, GLint slices, GLint stacks);
+    extern void APIENTRY glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);
+    extern void APIENTRY glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);
+    extern void APIENTRY glutWireCube(GLdouble size);
+    extern void APIENTRY glutSolidCube(GLdouble size);
+    extern void APIENTRY glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings);
+    extern void APIENTRY glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings);
+    extern void APIENTRY glutWireDodecahedron(void);
+    extern void APIENTRY glutSolidDodecahedron(void);
+    extern void APIENTRY glutWireTeapot(GLdouble size);
+    extern void APIENTRY glutSolidTeapot(GLdouble size);
+    extern void APIENTRY glutWireOctahedron(void);
+    extern void APIENTRY glutSolidOctahedron(void);
+    extern void APIENTRY glutWireTetrahedron(void);
+    extern void APIENTRY glutSolidTetrahedron(void);
+    extern void APIENTRY glutWireIcosahedron(void);
+    extern void APIENTRY glutSolidIcosahedron(void);
+
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 9)
+    /* GLUT video resize sub-API. */
+    extern int APIENTRY glutVideoResizeGet(GLenum param);
+    extern void APIENTRY glutSetupVideoResizing(void);
+    extern void APIENTRY glutStopVideoResizing(void);
+    extern void APIENTRY glutVideoResize(int x, int y, int width, int height);
+    extern void APIENTRY glutVideoPan(int x, int y, int width, int height);
+
+    /* GLUT debugging sub-API. */
+    extern void APIENTRY glutReportErrors(void);
+#endif
+
+#if (GLUT_API_VERSION >= 4 || GLUT_XLIB_IMPLEMENTATION >= 13)
+    /* GLUT device control sub-API. */
+    /* glutSetKeyRepeat modes. */
+#define GLUT_KEY_REPEAT_OFF     0
+#define GLUT_KEY_REPEAT_ON      1
+#define GLUT_KEY_REPEAT_DEFAULT     2
+
+    /* Joystick button masks. */
+#define GLUT_JOYSTICK_BUTTON_A      1
+#define GLUT_JOYSTICK_BUTTON_B      2
+#define GLUT_JOYSTICK_BUTTON_C      4
+#define GLUT_JOYSTICK_BUTTON_D      8
+
+    extern void APIENTRY glutIgnoreKeyRepeat(int ignore);
+    extern void APIENTRY glutSetKeyRepeat(int repeatMode);
+    extern void APIENTRY glutForceJoystickFunc(void);
+
+    /* GLUT game mode sub-API. */
+    /* glutGameModeGet. */
+#define GLUT_GAME_MODE_ACTIVE           0
+#define GLUT_GAME_MODE_POSSIBLE         1
+#define GLUT_GAME_MODE_WIDTH            2
+#define GLUT_GAME_MODE_HEIGHT           3
+#define GLUT_GAME_MODE_PIXEL_DEPTH      4
+#define GLUT_GAME_MODE_REFRESH_RATE     5
+#define GLUT_GAME_MODE_DISPLAY_CHANGED  6
+
+    extern void APIENTRY glutGameModeString(const char *string);
+    extern int APIENTRY glutEnterGameMode(void);
+    extern void APIENTRY glutLeaveGameMode(void);
+    extern int APIENTRY glutGameModeGet(GLenum mode);
+#endif
+
+#ifdef __cplusplus
+}
+
+#endif
+
+#ifdef GLUT_APIENTRY_DEFINED
+# undef GLUT_APIENTRY_DEFINED
+# undef APIENTRY
+#endif
+
+#ifdef GLUT_WINGDIAPI_DEFINED
+# undef GLUT_WINGDIAPI_DEFINED
+# undef WINGDIAPI
+#endif
+
+#endif                  /* __glut_h__ */
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/glxew.h gpu-rodinia_new/cuda/cfd/common/inc/GL/glxew.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/glxew.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/glxew.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,1121 @@
+/*
+** The OpenGL Extension Wrangler Library
+** Copyright (C) 2002-2006, Milan Ikits <milan ikits[]ieee org>
+** Copyright (C) 2002-2006, Marcelo E. Magallon <mmagallo[]debian org>
+** Copyright (C) 2002, Lev Povalahev
+** All rights reserved.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**
+** * Redistributions of source code must retain the above copyright notice,
+**   this list of conditions and the following disclaimer.
+** * Redistributions in binary form must reproduce the above copyright notice,
+**   this list of conditions and the following disclaimer in the documentation
+**   and/or other materials provided with the distribution.
+** * The name of the author may be used to endorse or promote products
+**   derived from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+** THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/*
+** The contents of this file are subject to the GLX Public License Version 1.0
+** (the "License"). You may not use this file except in compliance with the
+** License. You may obtain a copy of the License at Silicon Graphics, Inc.,
+** attn: Legal Services, 2011 N. Shoreline Blvd., Mountain View, CA 94043
+** or at http://www.sgi.com/software/opensource/glx/license.html.
+**
+** Software distributed under the License is distributed on an "AS IS"
+** basis. ALL WARRANTIES ARE DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY
+** IMPLIED WARRANTIES OF MERCHANTABILITY, OF FITNESS FOR A PARTICULAR
+** PURPOSE OR OF NON- INFRINGEMENT. See the License for the specific
+** language governing rights and limitations under the License.
+**
+** The Original Software is GLX version 1.2 source code, released February,
+** 1999. The developer of the Original Software is Silicon Graphics, Inc.
+** Those portions of the Subject Software created by Silicon Graphics, Inc.
+** are Copyright (c) 1991-9 Silicon Graphics, Inc. All Rights Reserved.
+*/
+
+#ifndef __glxew_h__
+#define __glxew_h__
+#define __GLXEW_H__
+
+#ifdef __glxext_h_
+#error glxext.h included before glxew.h
+#endif
+
+#define __glxext_h_
+#define __GLX_glx_h__
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xmd.h>
+#include <GL/glew.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /* ---------------------------- GLX_VERSION_1_0 --------------------------- */
+
+#ifndef GLX_VERSION_1_0
+#define GLX_VERSION_1_0 1
+
+#define GLX_USE_GL 1
+#define GLX_BUFFER_SIZE 2
+#define GLX_LEVEL 3
+#define GLX_RGBA 4
+#define GLX_DOUBLEBUFFER 5
+#define GLX_STEREO 6
+#define GLX_AUX_BUFFERS 7
+#define GLX_RED_SIZE 8
+#define GLX_GREEN_SIZE 9
+#define GLX_BLUE_SIZE 10
+#define GLX_ALPHA_SIZE 11
+#define GLX_DEPTH_SIZE 12
+#define GLX_STENCIL_SIZE 13
+#define GLX_ACCUM_RED_SIZE 14
+#define GLX_ACCUM_GREEN_SIZE 15
+#define GLX_ACCUM_BLUE_SIZE 16
+#define GLX_ACCUM_ALPHA_SIZE 17
+#define GLX_BAD_SCREEN 1
+#define GLX_BAD_ATTRIBUTE 2
+#define GLX_NO_EXTENSION 3
+#define GLX_BAD_VISUAL 4
+#define GLX_BAD_CONTEXT 5
+#define GLX_BAD_VALUE 6
+#define GLX_BAD_ENUM 7
+
+    typedef XID GLXDrawable;
+    typedef XID GLXPixmap;
+#ifdef __sun
+    typedef struct __glXcontextRec *GLXContext;
+#else
+    typedef struct __GLXcontextRec *GLXContext;
+#endif
+
+    extern Bool glXQueryExtension(Display *dpy, int *errorBase, int *eventBase);
+    extern Bool glXQueryVersion(Display *dpy, int *major, int *minor);
+    extern int glXGetConfig(Display *dpy, XVisualInfo *vis, int attrib, int *value);
+    extern XVisualInfo *glXChooseVisual(Display *dpy, int screen, int *attribList);
+    extern GLXPixmap glXCreateGLXPixmap(Display *dpy, XVisualInfo *vis, Pixmap pixmap);
+    extern void glXDestroyGLXPixmap(Display *dpy, GLXPixmap pix);
+    extern GLXContext glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct);
+    extern void glXDestroyContext(Display *dpy, GLXContext ctx);
+    extern Bool glXIsDirect(Display *dpy, GLXContext ctx);
+    extern void glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, GLuint mask);
+    extern Bool glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx);
+    extern GLXContext glXGetCurrentContext(void);
+    extern GLXDrawable glXGetCurrentDrawable(void);
+    extern void glXWaitGL(void);
+    extern void glXWaitX(void);
+    extern void glXSwapBuffers(Display *dpy, GLXDrawable drawable);
+    extern void glXUseXFont(Font font, int first, int count, int listBase);
+
+#define GLXEW_VERSION_1_0 GLXEW_GET_VAR(__GLXEW_VERSION_1_0)
+
+#endif /* GLX_VERSION_1_0 */
+
+    /* ---------------------------- GLX_VERSION_1_1 --------------------------- */
+
+#ifndef GLX_VERSION_1_1
+#define GLX_VERSION_1_1
+
+#define GLX_VENDOR 0x1
+#define GLX_VERSION 0x2
+#define GLX_EXTENSIONS 0x3
+
+    extern const char *glXQueryExtensionsString(Display *dpy, int screen);
+    extern const char *glXGetClientString(Display *dpy, int name);
+    extern const char *glXQueryServerString(Display *dpy, int screen, int name);
+
+#define GLXEW_VERSION_1_1 GLXEW_GET_VAR(__GLXEW_VERSION_1_1)
+
+#endif /* GLX_VERSION_1_1 */
+
+    /* ---------------------------- GLX_VERSION_1_2 ---------------------------- */
+
+#ifndef GLX_VERSION_1_2
+#define GLX_VERSION_1_2 1
+
+    typedef Display *(* PFNGLXGETCURRENTDISPLAYPROC)(void);
+
+#define glXGetCurrentDisplay GLXEW_GET_FUN(__glewXGetCurrentDisplay)
+
+#define GLXEW_VERSION_1_2 GLXEW_GET_VAR(__GLXEW_VERSION_1_2)
+
+#endif /* GLX_VERSION_1_2 */
+
+    /* ---------------------------- GLX_VERSION_1_3 ---------------------------- */
+
+#ifndef GLX_VERSION_1_3
+#define GLX_VERSION_1_3 1
+
+#define GLX_RGBA_BIT 0x00000001
+#define GLX_FRONT_LEFT_BUFFER_BIT 0x00000001
+#define GLX_WINDOW_BIT 0x00000001
+#define GLX_COLOR_INDEX_BIT 0x00000002
+#define GLX_PIXMAP_BIT 0x00000002
+#define GLX_FRONT_RIGHT_BUFFER_BIT 0x00000002
+#define GLX_BACK_LEFT_BUFFER_BIT 0x00000004
+#define GLX_PBUFFER_BIT 0x00000004
+#define GLX_BACK_RIGHT_BUFFER_BIT 0x00000008
+#define GLX_AUX_BUFFERS_BIT 0x00000010
+#define GLX_CONFIG_CAVEAT 0x20
+#define GLX_DEPTH_BUFFER_BIT 0x00000020
+#define GLX_X_VISUAL_TYPE 0x22
+#define GLX_TRANSPARENT_TYPE 0x23
+#define GLX_TRANSPARENT_INDEX_VALUE 0x24
+#define GLX_TRANSPARENT_RED_VALUE 0x25
+#define GLX_TRANSPARENT_GREEN_VALUE 0x26
+#define GLX_TRANSPARENT_BLUE_VALUE 0x27
+#define GLX_TRANSPARENT_ALPHA_VALUE 0x28
+#define GLX_STENCIL_BUFFER_BIT 0x00000040
+#define GLX_ACCUM_BUFFER_BIT 0x00000080
+#define GLX_NONE 0x8000
+#define GLX_SLOW_CONFIG 0x8001
+#define GLX_TRUE_COLOR 0x8002
+#define GLX_DIRECT_COLOR 0x8003
+#define GLX_PSEUDO_COLOR 0x8004
+#define GLX_STATIC_COLOR 0x8005
+#define GLX_GRAY_SCALE 0x8006
+#define GLX_STATIC_GRAY 0x8007
+#define GLX_TRANSPARENT_RGB 0x8008
+#define GLX_TRANSPARENT_INDEX 0x8009
+#define GLX_VISUAL_ID 0x800B
+#define GLX_SCREEN 0x800C
+#define GLX_NON_CONFORMANT_CONFIG 0x800D
+#define GLX_DRAWABLE_TYPE 0x8010
+#define GLX_RENDER_TYPE 0x8011
+#define GLX_X_RENDERABLE 0x8012
+#define GLX_FBCONFIG_ID 0x8013
+#define GLX_RGBA_TYPE 0x8014
+#define GLX_COLOR_INDEX_TYPE 0x8015
+#define GLX_MAX_PBUFFER_WIDTH 0x8016
+#define GLX_MAX_PBUFFER_HEIGHT 0x8017
+#define GLX_MAX_PBUFFER_PIXELS 0x8018
+#define GLX_PRESERVED_CONTENTS 0x801B
+#define GLX_LARGEST_PBUFFER 0x801C
+#define GLX_WIDTH 0x801D
+#define GLX_HEIGHT 0x801E
+#define GLX_EVENT_MASK 0x801F
+#define GLX_DAMAGED 0x8020
+#define GLX_SAVED 0x8021
+#define GLX_WINDOW 0x8022
+#define GLX_PBUFFER 0x8023
+#define GLX_PBUFFER_HEIGHT 0x8040
+#define GLX_PBUFFER_WIDTH 0x8041
+#define GLX_PBUFFER_CLOBBER_MASK 0x08000000
+#define GLX_DONT_CARE 0xFFFFFFFF
+
+    typedef XID GLXFBConfigID;
+    typedef XID GLXWindow;
+    typedef XID GLXPbuffer;
+    typedef struct __GLXFBConfigRec *GLXFBConfig;
+    typedef struct
+    {
+        int event_type;
+        int draw_type;
+        unsigned long serial;
+        Bool send_event;
+        Display *display;
+        GLXDrawable drawable;
+        unsigned int buffer_mask;
+        unsigned int aux_buffer;
+        int x, y;
+        int width, height;
+        int count;
+    } GLXPbufferClobberEvent;
+    typedef union __GLXEvent
+    {
+        GLXPbufferClobberEvent glxpbufferclobber;
+        long pad[24];
+    } GLXEvent;
+
+    typedef GLXFBConfig *(* PFNGLXCHOOSEFBCONFIGPROC)(Display *dpy, int screen, const int *attrib_list, int *nelements);
+    typedef GLXContext(* PFNGLXCREATENEWCONTEXTPROC)(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
+    typedef GLXPbuffer(* PFNGLXCREATEPBUFFERPROC)(Display *dpy, GLXFBConfig config, const int *attrib_list);
+    typedef GLXPixmap(* PFNGLXCREATEPIXMAPPROC)(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
+    typedef GLXWindow(* PFNGLXCREATEWINDOWPROC)(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
+    typedef void (* PFNGLXDESTROYPBUFFERPROC)(Display *dpy, GLXPbuffer pbuf);
+    typedef void (* PFNGLXDESTROYPIXMAPPROC)(Display *dpy, GLXPixmap pixmap);
+    typedef void (* PFNGLXDESTROYWINDOWPROC)(Display *dpy, GLXWindow win);
+    typedef GLXDrawable(* PFNGLXGETCURRENTREADDRAWABLEPROC)(void);
+    typedef int (* PFNGLXGETFBCONFIGATTRIBPROC)(Display *dpy, GLXFBConfig config, int attribute, int *value);
+    typedef GLXFBConfig *(* PFNGLXGETFBCONFIGSPROC)(Display *dpy, int screen, int *nelements);
+    typedef void (* PFNGLXGETSELECTEDEVENTPROC)(Display *dpy, GLXDrawable draw, unsigned long *event_mask);
+    typedef XVisualInfo *(* PFNGLXGETVISUALFROMFBCONFIGPROC)(Display *dpy, GLXFBConfig config);
+    typedef Bool(* PFNGLXMAKECONTEXTCURRENTPROC)(Display *display, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+    typedef int (* PFNGLXQUERYCONTEXTPROC)(Display *dpy, GLXContext ctx, int attribute, int *value);
+    typedef void (* PFNGLXQUERYDRAWABLEPROC)(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
+    typedef void (* PFNGLXSELECTEVENTPROC)(Display *dpy, GLXDrawable draw, unsigned long event_mask);
+
+#define glXChooseFBConfig GLXEW_GET_FUN(__glewXChooseFBConfig)
+#define glXCreateNewContext GLXEW_GET_FUN(__glewXCreateNewContext)
+#define glXCreatePbuffer GLXEW_GET_FUN(__glewXCreatePbuffer)
+#define glXCreatePixmap GLXEW_GET_FUN(__glewXCreatePixmap)
+#define glXCreateWindow GLXEW_GET_FUN(__glewXCreateWindow)
+#define glXDestroyPbuffer GLXEW_GET_FUN(__glewXDestroyPbuffer)
+#define glXDestroyPixmap GLXEW_GET_FUN(__glewXDestroyPixmap)
+#define glXDestroyWindow GLXEW_GET_FUN(__glewXDestroyWindow)
+#define glXGetCurrentReadDrawable GLXEW_GET_FUN(__glewXGetCurrentReadDrawable)
+#define glXGetFBConfigAttrib GLXEW_GET_FUN(__glewXGetFBConfigAttrib)
+#define glXGetFBConfigs GLXEW_GET_FUN(__glewXGetFBConfigs)
+#define glXGetSelectedEvent GLXEW_GET_FUN(__glewXGetSelectedEvent)
+#define glXGetVisualFromFBConfig GLXEW_GET_FUN(__glewXGetVisualFromFBConfig)
+#define glXMakeContextCurrent GLXEW_GET_FUN(__glewXMakeContextCurrent)
+#define glXQueryContext GLXEW_GET_FUN(__glewXQueryContext)
+#define glXQueryDrawable GLXEW_GET_FUN(__glewXQueryDrawable)
+#define glXSelectEvent GLXEW_GET_FUN(__glewXSelectEvent)
+
+#define GLXEW_VERSION_1_3 GLXEW_GET_VAR(__GLXEW_VERSION_1_3)
+
+#endif /* GLX_VERSION_1_3 */
+
+    /* ---------------------------- GLX_VERSION_1_4 ---------------------------- */
+
+#ifndef GLX_VERSION_1_4
+#define GLX_VERSION_1_4 1
+
+#define GLX_SAMPLE_BUFFERS 100000
+#define GLX_SAMPLES 100001
+
+    extern void (* glXGetProcAddress(const GLubyte *procName))(void);
+
+#define GLXEW_VERSION_1_4 GLXEW_GET_VAR(__GLXEW_VERSION_1_4)
+
+#endif /* GLX_VERSION_1_4 */
+
+    /* -------------------------- GLX_3DFX_multisample ------------------------- */
+
+#ifndef GLX_3DFX_multisample
+#define GLX_3DFX_multisample 1
+
+#define GLX_SAMPLE_BUFFERS_3DFX 0x8050
+#define GLX_SAMPLES_3DFX 0x8051
+
+#define GLXEW_3DFX_multisample GLXEW_GET_VAR(__GLXEW_3DFX_multisample)
+
+#endif /* GLX_3DFX_multisample */
+
+    /* ------------------------- GLX_ARB_fbconfig_float ------------------------ */
+
+#ifndef GLX_ARB_fbconfig_float
+#define GLX_ARB_fbconfig_float 1
+
+#define GLX_RGBA_FLOAT_BIT 0x00000004
+#define GLX_RGBA_FLOAT_TYPE 0x20B9
+
+#define GLXEW_ARB_fbconfig_float GLXEW_GET_VAR(__GLXEW_ARB_fbconfig_float)
+
+#endif /* GLX_ARB_fbconfig_float */
+
+    /* ------------------------ GLX_ARB_get_proc_address ----------------------- */
+
+#ifndef GLX_ARB_get_proc_address
+#define GLX_ARB_get_proc_address 1
+
+    extern void (* glXGetProcAddressARB(const GLubyte *procName))(void);
+
+#define GLXEW_ARB_get_proc_address GLXEW_GET_VAR(__GLXEW_ARB_get_proc_address)
+
+#endif /* GLX_ARB_get_proc_address */
+
+    /* -------------------------- GLX_ARB_multisample -------------------------- */
+
+#ifndef GLX_ARB_multisample
+#define GLX_ARB_multisample 1
+
+#define GLX_SAMPLE_BUFFERS_ARB 100000
+#define GLX_SAMPLES_ARB 100001
+
+#define GLXEW_ARB_multisample GLXEW_GET_VAR(__GLXEW_ARB_multisample)
+
+#endif /* GLX_ARB_multisample */
+
+    /* ----------------------- GLX_ATI_pixel_format_float ---------------------- */
+
+#ifndef GLX_ATI_pixel_format_float
+#define GLX_ATI_pixel_format_float 1
+
+#define GLX_RGBA_FLOAT_ATI_BIT 0x00000100
+
+#define GLXEW_ATI_pixel_format_float GLXEW_GET_VAR(__GLXEW_ATI_pixel_format_float)
+
+#endif /* GLX_ATI_pixel_format_float */
+
+    /* ------------------------- GLX_ATI_render_texture ------------------------ */
+
+#ifndef GLX_ATI_render_texture
+#define GLX_ATI_render_texture 1
+
+#define GLX_BIND_TO_TEXTURE_RGB_ATI 0x9800
+#define GLX_BIND_TO_TEXTURE_RGBA_ATI 0x9801
+#define GLX_TEXTURE_FORMAT_ATI 0x9802
+#define GLX_TEXTURE_TARGET_ATI 0x9803
+#define GLX_MIPMAP_TEXTURE_ATI 0x9804
+#define GLX_TEXTURE_RGB_ATI 0x9805
+#define GLX_TEXTURE_RGBA_ATI 0x9806
+#define GLX_NO_TEXTURE_ATI 0x9807
+#define GLX_TEXTURE_CUBE_MAP_ATI 0x9808
+#define GLX_TEXTURE_1D_ATI 0x9809
+#define GLX_TEXTURE_2D_ATI 0x980A
+#define GLX_MIPMAP_LEVEL_ATI 0x980B
+#define GLX_CUBE_MAP_FACE_ATI 0x980C
+#define GLX_TEXTURE_CUBE_MAP_POSITIVE_X_ATI 0x980D
+#define GLX_TEXTURE_CUBE_MAP_NEGATIVE_X_ATI 0x980E
+#define GLX_TEXTURE_CUBE_MAP_POSITIVE_Y_ATI 0x980F
+#define GLX_TEXTURE_CUBE_MAP_NEGATIVE_Y_ATI 0x9810
+#define GLX_TEXTURE_CUBE_MAP_POSITIVE_Z_ATI 0x9811
+#define GLX_TEXTURE_CUBE_MAP_NEGATIVE_Z_ATI 0x9812
+#define GLX_FRONT_LEFT_ATI 0x9813
+#define GLX_FRONT_RIGHT_ATI 0x9814
+#define GLX_BACK_LEFT_ATI 0x9815
+#define GLX_BACK_RIGHT_ATI 0x9816
+#define GLX_AUX0_ATI 0x9817
+#define GLX_AUX1_ATI 0x9818
+#define GLX_AUX2_ATI 0x9819
+#define GLX_AUX3_ATI 0x981A
+#define GLX_AUX4_ATI 0x981B
+#define GLX_AUX5_ATI 0x981C
+#define GLX_AUX6_ATI 0x981D
+#define GLX_AUX7_ATI 0x981E
+#define GLX_AUX8_ATI 0x981F
+#define GLX_AUX9_ATI 0x9820
+#define GLX_BIND_TO_TEXTURE_LUMINANCE_ATI 0x9821
+#define GLX_BIND_TO_TEXTURE_INTENSITY_ATI 0x9822
+
+    typedef void (* PFNGLXBINDTEXIMAGEATIPROC)(Display *dpy, GLXPbuffer pbuf, int buffer);
+    typedef void (* PFNGLXDRAWABLEATTRIBATIPROC)(Display *dpy, GLXDrawable draw, const int *attrib_list);
+    typedef void (* PFNGLXRELEASETEXIMAGEATIPROC)(Display *dpy, GLXPbuffer pbuf, int buffer);
+
+#define glXBindTexImageATI GLXEW_GET_FUN(__glewXBindTexImageATI)
+#define glXDrawableAttribATI GLXEW_GET_FUN(__glewXDrawableAttribATI)
+#define glXReleaseTexImageATI GLXEW_GET_FUN(__glewXReleaseTexImageATI)
+
+#define GLXEW_ATI_render_texture GLXEW_GET_VAR(__GLXEW_ATI_render_texture)
+
+#endif /* GLX_ATI_render_texture */
+
+    /* --------------------- GLX_EXT_fbconfig_packed_float --------------------- */
+
+#ifndef GLX_EXT_fbconfig_packed_float
+#define GLX_EXT_fbconfig_packed_float 1
+
+#define GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT 0x00000008
+#define GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT 0x20B1
+
+#define GLXEW_EXT_fbconfig_packed_float GLXEW_GET_VAR(__GLXEW_EXT_fbconfig_packed_float)
+
+#endif /* GLX_EXT_fbconfig_packed_float */
+
+    /* ------------------------ GLX_EXT_framebuffer_sRGB ----------------------- */
+
+#ifndef GLX_EXT_framebuffer_sRGB
+#define GLX_EXT_framebuffer_sRGB 1
+
+#define GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT 0x20B2
+
+#define GLXEW_EXT_framebuffer_sRGB GLXEW_GET_VAR(__GLXEW_EXT_framebuffer_sRGB)
+
+#endif /* GLX_EXT_framebuffer_sRGB */
+
+    /* ------------------------- GLX_EXT_import_context ------------------------ */
+
+#ifndef GLX_EXT_import_context
+#define GLX_EXT_import_context 1
+
+#define GLX_SHARE_CONTEXT_EXT 0x800A
+#define GLX_VISUAL_ID_EXT 0x800B
+#define GLX_SCREEN_EXT 0x800C
+
+    typedef XID GLXContextID;
+
+    typedef void (* PFNGLXFREECONTEXTEXTPROC)(Display *dpy, GLXContext context);
+    typedef GLXContextID(* PFNGLXGETCONTEXTIDEXTPROC)(const GLXContext context);
+    typedef GLXContext(* PFNGLXIMPORTCONTEXTEXTPROC)(Display *dpy, GLXContextID contextID);
+    typedef int (* PFNGLXQUERYCONTEXTINFOEXTPROC)(Display *dpy, GLXContext context, int attribute,int *value);
+
+#define glXFreeContextEXT GLXEW_GET_FUN(__glewXFreeContextEXT)
+#define glXGetContextIDEXT GLXEW_GET_FUN(__glewXGetContextIDEXT)
+#define glXImportContextEXT GLXEW_GET_FUN(__glewXImportContextEXT)
+#define glXQueryContextInfoEXT GLXEW_GET_FUN(__glewXQueryContextInfoEXT)
+
+#define GLXEW_EXT_import_context GLXEW_GET_VAR(__GLXEW_EXT_import_context)
+
+#endif /* GLX_EXT_import_context */
+
+    /* -------------------------- GLX_EXT_scene_marker ------------------------- */
+
+#ifndef GLX_EXT_scene_marker
+#define GLX_EXT_scene_marker 1
+
+#define GLXEW_EXT_scene_marker GLXEW_GET_VAR(__GLXEW_EXT_scene_marker)
+
+#endif /* GLX_EXT_scene_marker */
+
+    /* -------------------------- GLX_EXT_visual_info -------------------------- */
+
+#ifndef GLX_EXT_visual_info
+#define GLX_EXT_visual_info 1
+
+#define GLX_X_VISUAL_TYPE_EXT 0x22
+#define GLX_TRANSPARENT_TYPE_EXT 0x23
+#define GLX_TRANSPARENT_INDEX_VALUE_EXT 0x24
+#define GLX_TRANSPARENT_RED_VALUE_EXT 0x25
+#define GLX_TRANSPARENT_GREEN_VALUE_EXT 0x26
+#define GLX_TRANSPARENT_BLUE_VALUE_EXT 0x27
+#define GLX_TRANSPARENT_ALPHA_VALUE_EXT 0x28
+#define GLX_NONE_EXT 0x8000
+#define GLX_TRUE_COLOR_EXT 0x8002
+#define GLX_DIRECT_COLOR_EXT 0x8003
+#define GLX_PSEUDO_COLOR_EXT 0x8004
+#define GLX_STATIC_COLOR_EXT 0x8005
+#define GLX_GRAY_SCALE_EXT 0x8006
+#define GLX_STATIC_GRAY_EXT 0x8007
+#define GLX_TRANSPARENT_RGB_EXT 0x8008
+#define GLX_TRANSPARENT_INDEX_EXT 0x8009
+
+#define GLXEW_EXT_visual_info GLXEW_GET_VAR(__GLXEW_EXT_visual_info)
+
+#endif /* GLX_EXT_visual_info */
+
+    /* ------------------------- GLX_EXT_visual_rating ------------------------- */
+
+#ifndef GLX_EXT_visual_rating
+#define GLX_EXT_visual_rating 1
+
+#define GLX_VISUAL_CAVEAT_EXT 0x20
+#define GLX_SLOW_VISUAL_EXT 0x8001
+#define GLX_NON_CONFORMANT_VISUAL_EXT 0x800D
+
+#define GLXEW_EXT_visual_rating GLXEW_GET_VAR(__GLXEW_EXT_visual_rating)
+
+#endif /* GLX_EXT_visual_rating */
+
+    /* -------------------------- GLX_MESA_agp_offset -------------------------- */
+
+#ifndef GLX_MESA_agp_offset
+#define GLX_MESA_agp_offset 1
+
+    typedef unsigned int (* PFNGLXGETAGPOFFSETMESAPROC)(const void *pointer);
+
+#define glXGetAGPOffsetMESA GLXEW_GET_FUN(__glewXGetAGPOffsetMESA)
+
+#define GLXEW_MESA_agp_offset GLXEW_GET_VAR(__GLXEW_MESA_agp_offset)
+
+#endif /* GLX_MESA_agp_offset */
+
+    /* ------------------------ GLX_MESA_copy_sub_buffer ----------------------- */
+
+#ifndef GLX_MESA_copy_sub_buffer
+#define GLX_MESA_copy_sub_buffer 1
+
+    typedef void (* PFNGLXCOPYSUBBUFFERMESAPROC)(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
+
+#define glXCopySubBufferMESA GLXEW_GET_FUN(__glewXCopySubBufferMESA)
+
+#define GLXEW_MESA_copy_sub_buffer GLXEW_GET_VAR(__GLXEW_MESA_copy_sub_buffer)
+
+#endif /* GLX_MESA_copy_sub_buffer */
+
+    /* ------------------------ GLX_MESA_pixmap_colormap ----------------------- */
+
+#ifndef GLX_MESA_pixmap_colormap
+#define GLX_MESA_pixmap_colormap 1
+
+    typedef GLXPixmap(* PFNGLXCREATEGLXPIXMAPMESAPROC)(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
+
+#define glXCreateGLXPixmapMESA GLXEW_GET_FUN(__glewXCreateGLXPixmapMESA)
+
+#define GLXEW_MESA_pixmap_colormap GLXEW_GET_VAR(__GLXEW_MESA_pixmap_colormap)
+
+#endif /* GLX_MESA_pixmap_colormap */
+
+    /* ------------------------ GLX_MESA_release_buffers ----------------------- */
+
+#ifndef GLX_MESA_release_buffers
+#define GLX_MESA_release_buffers 1
+
+    typedef Bool(* PFNGLXRELEASEBUFFERSMESAPROC)(Display *dpy, GLXDrawable d);
+
+#define glXReleaseBuffersMESA GLXEW_GET_FUN(__glewXReleaseBuffersMESA)
+
+#define GLXEW_MESA_release_buffers GLXEW_GET_VAR(__GLXEW_MESA_release_buffers)
+
+#endif /* GLX_MESA_release_buffers */
+
+    /* ------------------------- GLX_MESA_set_3dfx_mode ------------------------ */
+
+#ifndef GLX_MESA_set_3dfx_mode
+#define GLX_MESA_set_3dfx_mode 1
+
+#define GLX_3DFX_WINDOW_MODE_MESA 0x1
+#define GLX_3DFX_FULLSCREEN_MODE_MESA 0x2
+
+    typedef GLboolean(* PFNGLXSET3DFXMODEMESAPROC)(GLint mode);
+
+#define glXSet3DfxModeMESA GLXEW_GET_FUN(__glewXSet3DfxModeMESA)
+
+#define GLXEW_MESA_set_3dfx_mode GLXEW_GET_VAR(__GLXEW_MESA_set_3dfx_mode)
+
+#endif /* GLX_MESA_set_3dfx_mode */
+
+    /* -------------------------- GLX_NV_float_buffer -------------------------- */
+
+#ifndef GLX_NV_float_buffer
+#define GLX_NV_float_buffer 1
+
+#define GLX_FLOAT_COMPONENTS_NV 0x20B0
+
+#define GLXEW_NV_float_buffer GLXEW_GET_VAR(__GLXEW_NV_float_buffer)
+
+#endif /* GLX_NV_float_buffer */
+
+    /* ----------------------- GLX_NV_vertex_array_range ----------------------- */
+
+#ifndef GLX_NV_vertex_array_range
+#define GLX_NV_vertex_array_range 1
+
+    typedef void *(* PFNGLXALLOCATEMEMORYNVPROC)(GLsizei size, GLfloat readFrequency, GLfloat writeFrequency, GLfloat priority);
+    typedef void (* PFNGLXFREEMEMORYNVPROC)(void *pointer);
+
+#define glXAllocateMemoryNV GLXEW_GET_FUN(__glewXAllocateMemoryNV)
+#define glXFreeMemoryNV GLXEW_GET_FUN(__glewXFreeMemoryNV)
+
+#define GLXEW_NV_vertex_array_range GLXEW_GET_VAR(__GLXEW_NV_vertex_array_range)
+
+#endif /* GLX_NV_vertex_array_range */
+
+    /* -------------------------- GLX_OML_swap_method -------------------------- */
+
+#ifndef GLX_OML_swap_method
+#define GLX_OML_swap_method 1
+
+#define GLX_SWAP_METHOD_OML 0x8060
+#define GLX_SWAP_EXCHANGE_OML 0x8061
+#define GLX_SWAP_COPY_OML 0x8062
+#define GLX_SWAP_UNDEFINED_OML 0x8063
+
+#define GLXEW_OML_swap_method GLXEW_GET_VAR(__GLXEW_OML_swap_method)
+
+#endif /* GLX_OML_swap_method */
+
+    /* -------------------------- GLX_OML_sync_control ------------------------- */
+
+#if !defined(GLX_OML_sync_control) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+#include <inttypes.h>
+#define GLX_OML_sync_control 1
+
+    typedef Bool(* PFNGLXGETMSCRATEOMLPROC)(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
+    typedef Bool(* PFNGLXGETSYNCVALUESOMLPROC)(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
+    typedef int64_t (* PFNGLXSWAPBUFFERSMSCOMLPROC)(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
+    typedef Bool(* PFNGLXWAITFORMSCOMLPROC)(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
+    typedef Bool(* PFNGLXWAITFORSBCOMLPROC)(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
+
+#define glXGetMscRateOML GLXEW_GET_FUN(__glewXGetMscRateOML)
+#define glXGetSyncValuesOML GLXEW_GET_FUN(__glewXGetSyncValuesOML)
+#define glXSwapBuffersMscOML GLXEW_GET_FUN(__glewXSwapBuffersMscOML)
+#define glXWaitForMscOML GLXEW_GET_FUN(__glewXWaitForMscOML)
+#define glXWaitForSbcOML GLXEW_GET_FUN(__glewXWaitForSbcOML)
+
+#define GLXEW_OML_sync_control GLXEW_GET_VAR(__GLXEW_OML_sync_control)
+
+#endif /* GLX_OML_sync_control */
+
+    /* ------------------------ GLX_SGIS_blended_overlay ----------------------- */
+
+#ifndef GLX_SGIS_blended_overlay
+#define GLX_SGIS_blended_overlay 1
+
+#define GLX_BLENDED_RGBA_SGIS 0x8025
+
+#define GLXEW_SGIS_blended_overlay GLXEW_GET_VAR(__GLXEW_SGIS_blended_overlay)
+
+#endif /* GLX_SGIS_blended_overlay */
+
+    /* -------------------------- GLX_SGIS_color_range ------------------------- */
+
+#ifndef GLX_SGIS_color_range
+#define GLX_SGIS_color_range 1
+
+#define GLX_MIN_RED_SGIS 0
+#define GLX_MAX_GREEN_SGIS 0
+#define GLX_MIN_BLUE_SGIS 0
+#define GLX_MAX_ALPHA_SGIS 0
+#define GLX_MIN_GREEN_SGIS 0
+#define GLX_MIN_ALPHA_SGIS 0
+#define GLX_MAX_RED_SGIS 0
+#define GLX_EXTENDED_RANGE_SGIS 0
+#define GLX_MAX_BLUE_SGIS 0
+
+#define GLXEW_SGIS_color_range GLXEW_GET_VAR(__GLXEW_SGIS_color_range)
+
+#endif /* GLX_SGIS_color_range */
+
+    /* -------------------------- GLX_SGIS_multisample ------------------------- */
+
+#ifndef GLX_SGIS_multisample
+#define GLX_SGIS_multisample 1
+
+#define GLX_SAMPLE_BUFFERS_SGIS 100000
+#define GLX_SAMPLES_SGIS 100001
+
+#define GLXEW_SGIS_multisample GLXEW_GET_VAR(__GLXEW_SGIS_multisample)
+
+#endif /* GLX_SGIS_multisample */
+
+    /* ---------------------- GLX_SGIS_shared_multisample ---------------------- */
+
+#ifndef GLX_SGIS_shared_multisample
+#define GLX_SGIS_shared_multisample 1
+
+#define GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS 0x8026
+#define GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS 0x8027
+
+#define GLXEW_SGIS_shared_multisample GLXEW_GET_VAR(__GLXEW_SGIS_shared_multisample)
+
+#endif /* GLX_SGIS_shared_multisample */
+
+    /* --------------------------- GLX_SGIX_fbconfig --------------------------- */
+
+#ifndef GLX_SGIX_fbconfig
+#define GLX_SGIX_fbconfig 1
+
+#define GLX_WINDOW_BIT_SGIX 0x00000001
+#define GLX_RGBA_BIT_SGIX 0x00000001
+#define GLX_PIXMAP_BIT_SGIX 0x00000002
+#define GLX_COLOR_INDEX_BIT_SGIX 0x00000002
+#define GLX_SCREEN_EXT 0x800C
+#define GLX_DRAWABLE_TYPE_SGIX 0x8010
+#define GLX_RENDER_TYPE_SGIX 0x8011
+#define GLX_X_RENDERABLE_SGIX 0x8012
+#define GLX_FBCONFIG_ID_SGIX 0x8013
+#define GLX_RGBA_TYPE_SGIX 0x8014
+#define GLX_COLOR_INDEX_TYPE_SGIX 0x8015
+
+    typedef XID GLXFBConfigIDSGIX;
+    typedef struct __GLXFBConfigRec *GLXFBConfigSGIX;
+
+    typedef GLXFBConfigSGIX *(* PFNGLXCHOOSEFBCONFIGSGIXPROC)(Display *dpy, int screen, const int *attrib_list, int *nelements);
+    typedef GLXContext(* PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC)(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
+    typedef GLXPixmap(* PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC)(Display *dpy, GLXFBConfig config, Pixmap pixmap);
+    typedef int (* PFNGLXGETFBCONFIGATTRIBSGIXPROC)(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
+    typedef GLXFBConfigSGIX(* PFNGLXGETFBCONFIGFROMVISUALSGIXPROC)(Display *dpy, XVisualInfo *vis);
+    typedef XVisualInfo *(* PFNGLXGETVISUALFROMFBCONFIGSGIXPROC)(Display *dpy, GLXFBConfig config);
+
+#define glXChooseFBConfigSGIX GLXEW_GET_FUN(__glewXChooseFBConfigSGIX)
+#define glXCreateContextWithConfigSGIX GLXEW_GET_FUN(__glewXCreateContextWithConfigSGIX)
+#define glXCreateGLXPixmapWithConfigSGIX GLXEW_GET_FUN(__glewXCreateGLXPixmapWithConfigSGIX)
+#define glXGetFBConfigAttribSGIX GLXEW_GET_FUN(__glewXGetFBConfigAttribSGIX)
+#define glXGetFBConfigFromVisualSGIX GLXEW_GET_FUN(__glewXGetFBConfigFromVisualSGIX)
+#define glXGetVisualFromFBConfigSGIX GLXEW_GET_FUN(__glewXGetVisualFromFBConfigSGIX)
+
+#define GLXEW_SGIX_fbconfig GLXEW_GET_VAR(__GLXEW_SGIX_fbconfig)
+
+#endif /* GLX_SGIX_fbconfig */
+
+    /* ---------------------------- GLX_SGIX_pbuffer --------------------------- */
+
+#ifndef GLX_SGIX_pbuffer
+#define GLX_SGIX_pbuffer 1
+
+#define GLX_FRONT_LEFT_BUFFER_BIT_SGIX 0x00000001
+#define GLX_FRONT_RIGHT_BUFFER_BIT_SGIX 0x00000002
+#define GLX_PBUFFER_BIT_SGIX 0x00000004
+#define GLX_BACK_LEFT_BUFFER_BIT_SGIX 0x00000004
+#define GLX_BACK_RIGHT_BUFFER_BIT_SGIX 0x00000008
+#define GLX_AUX_BUFFERS_BIT_SGIX 0x00000010
+#define GLX_DEPTH_BUFFER_BIT_SGIX 0x00000020
+#define GLX_STENCIL_BUFFER_BIT_SGIX 0x00000040
+#define GLX_ACCUM_BUFFER_BIT_SGIX 0x00000080
+#define GLX_SAMPLE_BUFFERS_BIT_SGIX 0x00000100
+#define GLX_MAX_PBUFFER_WIDTH_SGIX 0x8016
+#define GLX_MAX_PBUFFER_HEIGHT_SGIX 0x8017
+#define GLX_MAX_PBUFFER_PIXELS_SGIX 0x8018
+#define GLX_OPTIMAL_PBUFFER_WIDTH_SGIX 0x8019
+#define GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX 0x801A
+#define GLX_PRESERVED_CONTENTS_SGIX 0x801B
+#define GLX_LARGEST_PBUFFER_SGIX 0x801C
+#define GLX_WIDTH_SGIX 0x801D
+#define GLX_HEIGHT_SGIX 0x801E
+#define GLX_EVENT_MASK_SGIX 0x801F
+#define GLX_DAMAGED_SGIX 0x8020
+#define GLX_SAVED_SGIX 0x8021
+#define GLX_WINDOW_SGIX 0x8022
+#define GLX_PBUFFER_SGIX 0x8023
+#define GLX_BUFFER_CLOBBER_MASK_SGIX 0x08000000
+
+    typedef XID GLXPbufferSGIX;
+    typedef struct
+    {
+        int type;
+        unsigned long serial;
+        Bool send_event;
+        Display *display;
+        GLXDrawable drawable;
+        int event_type;
+        int draw_type;
+        unsigned int mask;
+        int x, y;
+        int width, height;
+        int count;
+    } GLXBufferClobberEventSGIX;
+
+    typedef GLXPbuffer(* PFNGLXCREATEGLXPBUFFERSGIXPROC)(Display *dpy, GLXFBConfig config, unsigned int width, unsigned int height, int *attrib_list);
+    typedef void (* PFNGLXDESTROYGLXPBUFFERSGIXPROC)(Display *dpy, GLXPbuffer pbuf);
+    typedef void (* PFNGLXGETSELECTEDEVENTSGIXPROC)(Display *dpy, GLXDrawable drawable, unsigned long *mask);
+    typedef void (* PFNGLXQUERYGLXPBUFFERSGIXPROC)(Display *dpy, GLXPbuffer pbuf, int attribute, unsigned int *value);
+    typedef void (* PFNGLXSELECTEVENTSGIXPROC)(Display *dpy, GLXDrawable drawable, unsigned long mask);
+
+#define glXCreateGLXPbufferSGIX GLXEW_GET_FUN(__glewXCreateGLXPbufferSGIX)
+#define glXDestroyGLXPbufferSGIX GLXEW_GET_FUN(__glewXDestroyGLXPbufferSGIX)
+#define glXGetSelectedEventSGIX GLXEW_GET_FUN(__glewXGetSelectedEventSGIX)
+#define glXQueryGLXPbufferSGIX GLXEW_GET_FUN(__glewXQueryGLXPbufferSGIX)
+#define glXSelectEventSGIX GLXEW_GET_FUN(__glewXSelectEventSGIX)
+
+#define GLXEW_SGIX_pbuffer GLXEW_GET_VAR(__GLXEW_SGIX_pbuffer)
+
+#endif /* GLX_SGIX_pbuffer */
+
+    /* ------------------------- GLX_SGIX_swap_barrier ------------------------- */
+
+#ifndef GLX_SGIX_swap_barrier
+#define GLX_SGIX_swap_barrier 1
+
+    typedef void (* PFNGLXBINDSWAPBARRIERSGIXPROC)(Display *dpy, GLXDrawable drawable, int barrier);
+    typedef Bool(* PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC)(Display *dpy, int screen, int *max);
+
+#define glXBindSwapBarrierSGIX GLXEW_GET_FUN(__glewXBindSwapBarrierSGIX)
+#define glXQueryMaxSwapBarriersSGIX GLXEW_GET_FUN(__glewXQueryMaxSwapBarriersSGIX)
+
+#define GLXEW_SGIX_swap_barrier GLXEW_GET_VAR(__GLXEW_SGIX_swap_barrier)
+
+#endif /* GLX_SGIX_swap_barrier */
+
+    /* -------------------------- GLX_SGIX_swap_group -------------------------- */
+
+#ifndef GLX_SGIX_swap_group
+#define GLX_SGIX_swap_group 1
+
+    typedef void (* PFNGLXJOINSWAPGROUPSGIXPROC)(Display *dpy, GLXDrawable drawable, GLXDrawable member);
+
+#define glXJoinSwapGroupSGIX GLXEW_GET_FUN(__glewXJoinSwapGroupSGIX)
+
+#define GLXEW_SGIX_swap_group GLXEW_GET_VAR(__GLXEW_SGIX_swap_group)
+
+#endif /* GLX_SGIX_swap_group */
+
+    /* ------------------------- GLX_SGIX_video_resize ------------------------- */
+
+#ifndef GLX_SGIX_video_resize
+#define GLX_SGIX_video_resize 1
+
+#define GLX_SYNC_FRAME_SGIX 0x00000000
+#define GLX_SYNC_SWAP_SGIX 0x00000001
+
+    typedef int (* PFNGLXBINDCHANNELTOWINDOWSGIXPROC)(Display *display, int screen, int channel, Window window);
+    typedef int (* PFNGLXCHANNELRECTSGIXPROC)(Display *display, int screen, int channel, int x, int y, int w, int h);
+    typedef int (* PFNGLXCHANNELRECTSYNCSGIXPROC)(Display *display, int screen, int channel, GLenum synctype);
+    typedef int (* PFNGLXQUERYCHANNELDELTASSGIXPROC)(Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
+    typedef int (* PFNGLXQUERYCHANNELRECTSGIXPROC)(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
+
+#define glXBindChannelToWindowSGIX GLXEW_GET_FUN(__glewXBindChannelToWindowSGIX)
+#define glXChannelRectSGIX GLXEW_GET_FUN(__glewXChannelRectSGIX)
+#define glXChannelRectSyncSGIX GLXEW_GET_FUN(__glewXChannelRectSyncSGIX)
+#define glXQueryChannelDeltasSGIX GLXEW_GET_FUN(__glewXQueryChannelDeltasSGIX)
+#define glXQueryChannelRectSGIX GLXEW_GET_FUN(__glewXQueryChannelRectSGIX)
+
+#define GLXEW_SGIX_video_resize GLXEW_GET_VAR(__GLXEW_SGIX_video_resize)
+
+#endif /* GLX_SGIX_video_resize */
+
+    /* ---------------------- GLX_SGIX_visual_select_group --------------------- */
+
+#ifndef GLX_SGIX_visual_select_group
+#define GLX_SGIX_visual_select_group 1
+
+#define GLX_VISUAL_SELECT_GROUP_SGIX 0x8028
+
+#define GLXEW_SGIX_visual_select_group GLXEW_GET_VAR(__GLXEW_SGIX_visual_select_group)
+
+#endif /* GLX_SGIX_visual_select_group */
+
+    /* ---------------------------- GLX_SGI_cushion ---------------------------- */
+
+#ifndef GLX_SGI_cushion
+#define GLX_SGI_cushion 1
+
+    typedef void (* PFNGLXCUSHIONSGIPROC)(Display *dpy, Window window, float cushion);
+
+#define glXCushionSGI GLXEW_GET_FUN(__glewXCushionSGI)
+
+#define GLXEW_SGI_cushion GLXEW_GET_VAR(__GLXEW_SGI_cushion)
+
+#endif /* GLX_SGI_cushion */
+
+    /* ----------------------- GLX_SGI_make_current_read ----------------------- */
+
+#ifndef GLX_SGI_make_current_read
+#define GLX_SGI_make_current_read 1
+
+    typedef GLXDrawable(* PFNGLXGETCURRENTREADDRAWABLESGIPROC)(void);
+    typedef Bool(* PFNGLXMAKECURRENTREADSGIPROC)(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+
+#define glXGetCurrentReadDrawableSGI GLXEW_GET_FUN(__glewXGetCurrentReadDrawableSGI)
+#define glXMakeCurrentReadSGI GLXEW_GET_FUN(__glewXMakeCurrentReadSGI)
+
+#define GLXEW_SGI_make_current_read GLXEW_GET_VAR(__GLXEW_SGI_make_current_read)
+
+#endif /* GLX_SGI_make_current_read */
+
+    /* -------------------------- GLX_SGI_swap_control ------------------------- */
+
+#ifndef GLX_SGI_swap_control
+#define GLX_SGI_swap_control 1
+
+    typedef int (* PFNGLXSWAPINTERVALSGIPROC)(int interval);
+
+#define glXSwapIntervalSGI GLXEW_GET_FUN(__glewXSwapIntervalSGI)
+
+#define GLXEW_SGI_swap_control GLXEW_GET_VAR(__GLXEW_SGI_swap_control)
+
+#endif /* GLX_SGI_swap_control */
+
+    /* --------------------------- GLX_SGI_video_sync -------------------------- */
+
+#ifndef GLX_SGI_video_sync
+#define GLX_SGI_video_sync 1
+
+    typedef int (* PFNGLXGETVIDEOSYNCSGIPROC)(uint *count);
+    typedef int (* PFNGLXWAITVIDEOSYNCSGIPROC)(int divisor, int remainder, unsigned int *count);
+
+#define glXGetVideoSyncSGI GLXEW_GET_FUN(__glewXGetVideoSyncSGI)
+#define glXWaitVideoSyncSGI GLXEW_GET_FUN(__glewXWaitVideoSyncSGI)
+
+#define GLXEW_SGI_video_sync GLXEW_GET_VAR(__GLXEW_SGI_video_sync)
+
+#endif /* GLX_SGI_video_sync */
+
+    /* --------------------- GLX_SUN_get_transparent_index --------------------- */
+
+#ifndef GLX_SUN_get_transparent_index
+#define GLX_SUN_get_transparent_index 1
+
+    typedef Status(* PFNGLXGETTRANSPARENTINDEXSUNPROC)(Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex);
+
+#define glXGetTransparentIndexSUN GLXEW_GET_FUN(__glewXGetTransparentIndexSUN)
+
+#define GLXEW_SUN_get_transparent_index GLXEW_GET_VAR(__GLXEW_SUN_get_transparent_index)
+
+#endif /* GLX_SUN_get_transparent_index */
+
+    /* -------------------------- GLX_SUN_video_resize ------------------------- */
+
+#ifndef GLX_SUN_video_resize
+#define GLX_SUN_video_resize 1
+
+#define GLX_VIDEO_RESIZE_SUN 0x8171
+#define GL_VIDEO_RESIZE_COMPENSATION_SUN 0x85CD
+
+    typedef int (* PFNGLXGETVIDEORESIZESUNPROC)(Display *display, GLXDrawable window, float *factor);
+    typedef int (* PFNGLXVIDEORESIZESUNPROC)(Display *display, GLXDrawable window, float factor);
+
+#define glXGetVideoResizeSUN GLXEW_GET_FUN(__glewXGetVideoResizeSUN)
+#define glXVideoResizeSUN GLXEW_GET_FUN(__glewXVideoResizeSUN)
+
+#define GLXEW_SUN_video_resize GLXEW_GET_VAR(__GLXEW_SUN_video_resize)
+
+#endif /* GLX_SUN_video_resize */
+
+    /* ------------------------------------------------------------------------- */
+
+#ifdef GLEW_MX
+#define GLXEW_EXPORT
+#else
+#define GLXEW_EXPORT extern
+#endif /* GLEW_MX */
+
+    extern PFNGLXGETCURRENTDISPLAYPROC __glewXGetCurrentDisplay;
+
+    extern PFNGLXCHOOSEFBCONFIGPROC __glewXChooseFBConfig;
+    extern PFNGLXCREATENEWCONTEXTPROC __glewXCreateNewContext;
+    extern PFNGLXCREATEPBUFFERPROC __glewXCreatePbuffer;
+    extern PFNGLXCREATEPIXMAPPROC __glewXCreatePixmap;
+    extern PFNGLXCREATEWINDOWPROC __glewXCreateWindow;
+    extern PFNGLXDESTROYPBUFFERPROC __glewXDestroyPbuffer;
+    extern PFNGLXDESTROYPIXMAPPROC __glewXDestroyPixmap;
+    extern PFNGLXDESTROYWINDOWPROC __glewXDestroyWindow;
+    extern PFNGLXGETCURRENTREADDRAWABLEPROC __glewXGetCurrentReadDrawable;
+    extern PFNGLXGETFBCONFIGATTRIBPROC __glewXGetFBConfigAttrib;
+    extern PFNGLXGETFBCONFIGSPROC __glewXGetFBConfigs;
+    extern PFNGLXGETSELECTEDEVENTPROC __glewXGetSelectedEvent;
+    extern PFNGLXGETVISUALFROMFBCONFIGPROC __glewXGetVisualFromFBConfig;
+    extern PFNGLXMAKECONTEXTCURRENTPROC __glewXMakeContextCurrent;
+    extern PFNGLXQUERYCONTEXTPROC __glewXQueryContext;
+    extern PFNGLXQUERYDRAWABLEPROC __glewXQueryDrawable;
+    extern PFNGLXSELECTEVENTPROC __glewXSelectEvent;
+
+    extern PFNGLXBINDTEXIMAGEATIPROC __glewXBindTexImageATI;
+    extern PFNGLXDRAWABLEATTRIBATIPROC __glewXDrawableAttribATI;
+    extern PFNGLXRELEASETEXIMAGEATIPROC __glewXReleaseTexImageATI;
+
+    extern PFNGLXFREECONTEXTEXTPROC __glewXFreeContextEXT;
+    extern PFNGLXGETCONTEXTIDEXTPROC __glewXGetContextIDEXT;
+    extern PFNGLXIMPORTCONTEXTEXTPROC __glewXImportContextEXT;
+    extern PFNGLXQUERYCONTEXTINFOEXTPROC __glewXQueryContextInfoEXT;
+
+    extern PFNGLXGETAGPOFFSETMESAPROC __glewXGetAGPOffsetMESA;
+
+    extern PFNGLXCOPYSUBBUFFERMESAPROC __glewXCopySubBufferMESA;
+
+    extern PFNGLXCREATEGLXPIXMAPMESAPROC __glewXCreateGLXPixmapMESA;
+
+    extern PFNGLXRELEASEBUFFERSMESAPROC __glewXReleaseBuffersMESA;
+
+    extern PFNGLXSET3DFXMODEMESAPROC __glewXSet3DfxModeMESA;
+
+    extern PFNGLXALLOCATEMEMORYNVPROC __glewXAllocateMemoryNV;
+    extern PFNGLXFREEMEMORYNVPROC __glewXFreeMemoryNV;
+
+#ifdef GLX_OML_sync_control
+    extern PFNGLXGETMSCRATEOMLPROC __glewXGetMscRateOML;
+    extern PFNGLXGETSYNCVALUESOMLPROC __glewXGetSyncValuesOML;
+    extern PFNGLXSWAPBUFFERSMSCOMLPROC __glewXSwapBuffersMscOML;
+    extern PFNGLXWAITFORMSCOMLPROC __glewXWaitForMscOML;
+    extern PFNGLXWAITFORSBCOMLPROC __glewXWaitForSbcOML;
+#endif
+
+    extern PFNGLXCHOOSEFBCONFIGSGIXPROC __glewXChooseFBConfigSGIX;
+    extern PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC __glewXCreateContextWithConfigSGIX;
+    extern PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC __glewXCreateGLXPixmapWithConfigSGIX;
+    extern PFNGLXGETFBCONFIGATTRIBSGIXPROC __glewXGetFBConfigAttribSGIX;
+    extern PFNGLXGETFBCONFIGFROMVISUALSGIXPROC __glewXGetFBConfigFromVisualSGIX;
+    extern PFNGLXGETVISUALFROMFBCONFIGSGIXPROC __glewXGetVisualFromFBConfigSGIX;
+
+    extern PFNGLXCREATEGLXPBUFFERSGIXPROC __glewXCreateGLXPbufferSGIX;
+    extern PFNGLXDESTROYGLXPBUFFERSGIXPROC __glewXDestroyGLXPbufferSGIX;
+    extern PFNGLXGETSELECTEDEVENTSGIXPROC __glewXGetSelectedEventSGIX;
+    extern PFNGLXQUERYGLXPBUFFERSGIXPROC __glewXQueryGLXPbufferSGIX;
+    extern PFNGLXSELECTEVENTSGIXPROC __glewXSelectEventSGIX;
+
+    extern PFNGLXBINDSWAPBARRIERSGIXPROC __glewXBindSwapBarrierSGIX;
+    extern PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC __glewXQueryMaxSwapBarriersSGIX;
+
+    extern PFNGLXJOINSWAPGROUPSGIXPROC __glewXJoinSwapGroupSGIX;
+
+    extern PFNGLXBINDCHANNELTOWINDOWSGIXPROC __glewXBindChannelToWindowSGIX;
+    extern PFNGLXCHANNELRECTSGIXPROC __glewXChannelRectSGIX;
+    extern PFNGLXCHANNELRECTSYNCSGIXPROC __glewXChannelRectSyncSGIX;
+    extern PFNGLXQUERYCHANNELDELTASSGIXPROC __glewXQueryChannelDeltasSGIX;
+    extern PFNGLXQUERYCHANNELRECTSGIXPROC __glewXQueryChannelRectSGIX;
+
+    extern PFNGLXCUSHIONSGIPROC __glewXCushionSGI;
+
+    extern PFNGLXGETCURRENTREADDRAWABLESGIPROC __glewXGetCurrentReadDrawableSGI;
+    extern PFNGLXMAKECURRENTREADSGIPROC __glewXMakeCurrentReadSGI;
+
+    extern PFNGLXSWAPINTERVALSGIPROC __glewXSwapIntervalSGI;
+
+    extern PFNGLXGETVIDEOSYNCSGIPROC __glewXGetVideoSyncSGI;
+    extern PFNGLXWAITVIDEOSYNCSGIPROC __glewXWaitVideoSyncSGI;
+
+    extern PFNGLXGETTRANSPARENTINDEXSUNPROC __glewXGetTransparentIndexSUN;
+
+    extern PFNGLXGETVIDEORESIZESUNPROC __glewXGetVideoResizeSUN;
+    extern PFNGLXVIDEORESIZESUNPROC __glewXVideoResizeSUN;
+
+#if defined(GLEW_MX)
+    struct GLXEWContextStruct
+    {
+#endif /* GLEW_MX */
+
+        GLXEW_EXPORT GLboolean __GLXEW_VERSION_1_0;
+        GLXEW_EXPORT GLboolean __GLXEW_VERSION_1_1;
+        GLXEW_EXPORT GLboolean __GLXEW_VERSION_1_2;
+        GLXEW_EXPORT GLboolean __GLXEW_VERSION_1_3;
+        GLXEW_EXPORT GLboolean __GLXEW_VERSION_1_4;
+        GLXEW_EXPORT GLboolean __GLXEW_3DFX_multisample;
+        GLXEW_EXPORT GLboolean __GLXEW_ARB_fbconfig_float;
+        GLXEW_EXPORT GLboolean __GLXEW_ARB_get_proc_address;
+        GLXEW_EXPORT GLboolean __GLXEW_ARB_multisample;
+        GLXEW_EXPORT GLboolean __GLXEW_ATI_pixel_format_float;
+        GLXEW_EXPORT GLboolean __GLXEW_ATI_render_texture;
+        GLXEW_EXPORT GLboolean __GLXEW_EXT_fbconfig_packed_float;
+        GLXEW_EXPORT GLboolean __GLXEW_EXT_framebuffer_sRGB;
+        GLXEW_EXPORT GLboolean __GLXEW_EXT_import_context;
+        GLXEW_EXPORT GLboolean __GLXEW_EXT_scene_marker;
+        GLXEW_EXPORT GLboolean __GLXEW_EXT_visual_info;
+        GLXEW_EXPORT GLboolean __GLXEW_EXT_visual_rating;
+        GLXEW_EXPORT GLboolean __GLXEW_MESA_agp_offset;
+        GLXEW_EXPORT GLboolean __GLXEW_MESA_copy_sub_buffer;
+        GLXEW_EXPORT GLboolean __GLXEW_MESA_pixmap_colormap;
+        GLXEW_EXPORT GLboolean __GLXEW_MESA_release_buffers;
+        GLXEW_EXPORT GLboolean __GLXEW_MESA_set_3dfx_mode;
+        GLXEW_EXPORT GLboolean __GLXEW_NV_float_buffer;
+        GLXEW_EXPORT GLboolean __GLXEW_NV_vertex_array_range;
+        GLXEW_EXPORT GLboolean __GLXEW_OML_swap_method;
+        GLXEW_EXPORT GLboolean __GLXEW_OML_sync_control;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIS_blended_overlay;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIS_color_range;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIS_multisample;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIS_shared_multisample;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIX_fbconfig;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIX_pbuffer;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIX_swap_barrier;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIX_swap_group;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIX_video_resize;
+        GLXEW_EXPORT GLboolean __GLXEW_SGIX_visual_select_group;
+        GLXEW_EXPORT GLboolean __GLXEW_SGI_cushion;
+        GLXEW_EXPORT GLboolean __GLXEW_SGI_make_current_read;
+        GLXEW_EXPORT GLboolean __GLXEW_SGI_swap_control;
+        GLXEW_EXPORT GLboolean __GLXEW_SGI_video_sync;
+        GLXEW_EXPORT GLboolean __GLXEW_SUN_get_transparent_index;
+        GLXEW_EXPORT GLboolean __GLXEW_SUN_video_resize;
+
+#ifdef GLEW_MX
+    }; /* GLXEWContextStruct */
+#endif /* GLEW_MX */
+
+    /* ------------------------------------------------------------------------ */
+
+#ifdef GLEW_MX
+
+    typedef struct GLXEWContextStruct GLXEWContext;
+    extern GLenum glxewContextInit(GLXEWContext *ctx);
+    extern GLboolean glxewContextIsSupported(GLXEWContext *ctx, const char *name);
+
+#define glxewInit() glxewContextInit(glxewGetContext())
+#define glxewIsSupported(x) glxewContextIsSupported(glxewGetContext(), x)
+
+#define GLXEW_GET_VAR(x) glxewGetContext()->x
+#define GLXEW_GET_FUN(x) x
+
+#else /* GLEW_MX */
+
+#define GLXEW_GET_VAR(x) x
+#define GLXEW_GET_FUN(x) x
+
+    extern GLboolean glxewIsSupported(const char *name);
+
+#endif /* GLEW_MX */
+
+    extern GLboolean glxewGetExtension(const char *name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __glxew_h__ */
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/glxext.h gpu-rodinia_new/cuda/cfd/common/inc/GL/glxext.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/glxext.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/glxext.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,805 @@
+#ifndef __glxext_h_
+#define __glxext_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /*
+    ** License Applicability. Except to the extent portions of this file are
+    ** made subject to an alternative license as permitted in the SGI Free
+    ** Software License B, Version 1.1 (the "License"), the contents of this
+    ** file are subject only to the provisions of the License. You may not use
+    ** this file except in compliance with the License. You may obtain a copy
+    ** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
+    ** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
+    **
+    ** http://oss.sgi.com/projects/FreeB
+    **
+    ** Note that, as provided in the License, the Software is distributed on an
+    ** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
+    ** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
+    ** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
+    ** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
+    **
+    ** Original Code. The Original Code is: OpenGL Sample Implementation,
+    ** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
+    ** Inc. The Original Code is Copyright (c) 1991-2004 Silicon Graphics, Inc.
+    ** Copyright in any portions created by third parties is as indicated
+    ** elsewhere herein. All Rights Reserved.
+    **
+    ** Additional Notice Provisions: This software was created using the
+    ** OpenGL(R) version 1.2.1 Sample Implementation published by SGI, but has
+    ** not been independently verified as being compliant with the OpenGL(R)
+    ** version 1.2.1 Specification.
+    */
+
+#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
+#define WIN32_LEAN_AND_MEAN 1
+#include <windows.h>
+#endif
+
+#ifndef APIENTRY
+#define APIENTRY
+#endif
+#ifndef APIENTRYP
+#define APIENTRYP APIENTRY *
+#endif
+#ifndef GLAPI
+#define GLAPI extern
+#endif
+
+    /*************************************************************/
+
+    /* Header file version number, required by OpenGL ABI for Linux */
+    /* glxext.h last updated 2005/01/20 */
+    /* Current version at http://oss.sgi.com/projects/ogl-sample/registry/ */
+#define GLX_GLXEXT_VERSION 10
+
+#ifndef GLX_ARB_get_proc_address
+#endif
+
+#ifndef GLX_ARB_multisample
+#define GLX_SAMPLE_BUFFERS_ARB             100000
+#define GLX_SAMPLES_ARB                    100001
+#endif
+
+#ifndef GLX_ARB_fbconfig_float
+#define GLX_RGBA_FLOAT_TYPE_ARB            0x20B9
+#define GLX_RGBA_FLOAT_BIT_ARB             0x00000004
+#endif
+
+#ifndef GLX_SGIS_multisample
+#define GLX_SAMPLE_BUFFERS_SGIS            100000
+#define GLX_SAMPLES_SGIS                   100001
+#endif
+
+#ifndef GLX_EXT_visual_info
+#define GLX_X_VISUAL_TYPE_EXT              0x22
+#define GLX_TRANSPARENT_TYPE_EXT           0x23
+#define GLX_TRANSPARENT_INDEX_VALUE_EXT    0x24
+#define GLX_TRANSPARENT_RED_VALUE_EXT      0x25
+#define GLX_TRANSPARENT_GREEN_VALUE_EXT    0x26
+#define GLX_TRANSPARENT_BLUE_VALUE_EXT     0x27
+#define GLX_TRANSPARENT_ALPHA_VALUE_EXT    0x28
+#define GLX_NONE_EXT                       0x8000
+#define GLX_TRUE_COLOR_EXT                 0x8002
+#define GLX_DIRECT_COLOR_EXT               0x8003
+#define GLX_PSEUDO_COLOR_EXT               0x8004
+#define GLX_STATIC_COLOR_EXT               0x8005
+#define GLX_GRAY_SCALE_EXT                 0x8006
+#define GLX_STATIC_GRAY_EXT                0x8007
+#define GLX_TRANSPARENT_RGB_EXT            0x8008
+#define GLX_TRANSPARENT_INDEX_EXT          0x8009
+#endif
+
+#ifndef GLX_SGI_swap_control
+#endif
+
+#ifndef GLX_SGI_video_sync
+#endif
+
+#ifndef GLX_SGI_make_current_read
+#endif
+
+#ifndef GLX_SGIX_video_source
+#endif
+
+#ifndef GLX_EXT_visual_rating
+#define GLX_VISUAL_CAVEAT_EXT              0x20
+#define GLX_SLOW_VISUAL_EXT                0x8001
+#define GLX_NON_CONFORMANT_VISUAL_EXT      0x800D
+    /* reuse GLX_NONE_EXT */
+#endif
+
+#ifndef GLX_EXT_import_context
+#define GLX_SHARE_CONTEXT_EXT              0x800A
+#define GLX_VISUAL_ID_EXT                  0x800B
+#define GLX_SCREEN_EXT                     0x800C
+#endif
+
+#ifndef GLX_SGIX_fbconfig
+#define GLX_WINDOW_BIT_SGIX                0x00000001
+#define GLX_PIXMAP_BIT_SGIX                0x00000002
+#define GLX_RGBA_BIT_SGIX                  0x00000001
+#define GLX_COLOR_INDEX_BIT_SGIX           0x00000002
+#define GLX_DRAWABLE_TYPE_SGIX             0x8010
+#define GLX_RENDER_TYPE_SGIX               0x8011
+#define GLX_X_RENDERABLE_SGIX              0x8012
+#define GLX_FBCONFIG_ID_SGIX               0x8013
+#define GLX_RGBA_TYPE_SGIX                 0x8014
+#define GLX_COLOR_INDEX_TYPE_SGIX          0x8015
+    /* reuse GLX_SCREEN_EXT */
+#endif
+
+#ifndef GLX_SGIX_pbuffer
+#define GLX_PBUFFER_BIT_SGIX               0x00000004
+#define GLX_BUFFER_CLOBBER_MASK_SGIX       0x08000000
+#define GLX_FRONT_LEFT_BUFFER_BIT_SGIX     0x00000001
+#define GLX_FRONT_RIGHT_BUFFER_BIT_SGIX    0x00000002
+#define GLX_BACK_LEFT_BUFFER_BIT_SGIX      0x00000004
+#define GLX_BACK_RIGHT_BUFFER_BIT_SGIX     0x00000008
+#define GLX_AUX_BUFFERS_BIT_SGIX           0x00000010
+#define GLX_DEPTH_BUFFER_BIT_SGIX          0x00000020
+#define GLX_STENCIL_BUFFER_BIT_SGIX        0x00000040
+#define GLX_ACCUM_BUFFER_BIT_SGIX          0x00000080
+#define GLX_SAMPLE_BUFFERS_BIT_SGIX        0x00000100
+#define GLX_MAX_PBUFFER_WIDTH_SGIX         0x8016
+#define GLX_MAX_PBUFFER_HEIGHT_SGIX        0x8017
+#define GLX_MAX_PBUFFER_PIXELS_SGIX        0x8018
+#define GLX_OPTIMAL_PBUFFER_WIDTH_SGIX     0x8019
+#define GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX    0x801A
+#define GLX_PRESERVED_CONTENTS_SGIX        0x801B
+#define GLX_LARGEST_PBUFFER_SGIX           0x801C
+#define GLX_WIDTH_SGIX                     0x801D
+#define GLX_HEIGHT_SGIX                    0x801E
+#define GLX_EVENT_MASK_SGIX                0x801F
+#define GLX_DAMAGED_SGIX                   0x8020
+#define GLX_SAVED_SGIX                     0x8021
+#define GLX_WINDOW_SGIX                    0x8022
+#define GLX_PBUFFER_SGIX                   0x8023
+#endif
+
+#ifndef GLX_SGI_cushion
+#endif
+
+#ifndef GLX_SGIX_video_resize
+#define GLX_SYNC_FRAME_SGIX                0x00000000
+#define GLX_SYNC_SWAP_SGIX                 0x00000001
+#endif
+
+#ifndef GLX_SGIX_dmbuffer
+#define GLX_DIGITAL_MEDIA_PBUFFER_SGIX     0x8024
+#endif
+
+#ifndef GLX_SGIX_swap_group
+#endif
+
+#ifndef GLX_SGIX_swap_barrier
+#endif
+
+#ifndef GLX_SGIS_blended_overlay
+#define GLX_BLENDED_RGBA_SGIS              0x8025
+#endif
+
+#ifndef GLX_SGIS_shared_multisample
+#define GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS 0x8026
+#define GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS 0x8027
+#endif
+
+#ifndef GLX_SUN_get_transparent_index
+#endif
+
+#ifndef GLX_3DFX_multisample
+#define GLX_SAMPLE_BUFFERS_3DFX            0x8050
+#define GLX_SAMPLES_3DFX                   0x8051
+#endif
+
+#ifndef GLX_MESA_copy_sub_buffer
+#endif
+
+#ifndef GLX_MESA_pixmap_colormap
+#endif
+
+#ifndef GLX_MESA_release_buffers
+#endif
+
+#ifndef GLX_MESA_set_3dfx_mode
+#define GLX_3DFX_WINDOW_MODE_MESA          0x1
+#define GLX_3DFX_FULLSCREEN_MODE_MESA      0x2
+#endif
+
+#ifndef GLX_SGIX_visual_select_group
+#define GLX_VISUAL_SELECT_GROUP_SGIX       0x8028
+#endif
+
+#ifndef GLX_OML_swap_method
+#define GLX_SWAP_METHOD_OML                0x8060
+#define GLX_SWAP_EXCHANGE_OML              0x8061
+#define GLX_SWAP_COPY_OML                  0x8062
+#define GLX_SWAP_UNDEFINED_OML             0x8063
+#endif
+
+#ifndef GLX_OML_sync_control
+#endif
+
+#ifndef GLX_NV_float_buffer
+#define GLX_FLOAT_COMPONENTS_NV            0x20B0
+#endif
+
+#ifndef GLX_SGIX_hyperpipe
+#define GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX 80
+#define GLX_BAD_HYPERPIPE_CONFIG_SGIX      91
+#define GLX_BAD_HYPERPIPE_SGIX             92
+#define GLX_HYPERPIPE_DISPLAY_PIPE_SGIX    0x00000001
+#define GLX_HYPERPIPE_RENDER_PIPE_SGIX     0x00000002
+#define GLX_PIPE_RECT_SGIX                 0x00000001
+#define GLX_PIPE_RECT_LIMITS_SGIX          0x00000002
+#define GLX_HYPERPIPE_STEREO_SGIX          0x00000003
+#define GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX   0x00000004
+#define GLX_HYPERPIPE_ID_SGIX              0x8030
+#endif
+
+#ifndef GLX_MESA_agp_offset
+#endif
+
+
+    /*************************************************************/
+
+#ifndef GLX_ARB_get_proc_address
+    /*
+     * Linux OpenGL ABI specifies glXGetProcAddressARB should be
+     * in glx.h moving related defines there as well.
+     */
+#endif
+
+#ifndef GLX_SGIX_video_source
+    typedef XID GLXVideoSourceSGIX;
+#endif
+
+#ifndef GLX_SGIX_fbconfig
+    typedef XID GLXFBConfigIDSGIX;
+    typedef struct __GLXFBConfigRec *GLXFBConfigSGIX;
+#endif
+
+#ifndef GLX_SGIX_pbuffer
+    typedef XID GLXPbufferSGIX;
+    typedef struct
+    {
+        int type;
+        unsigned long serial;     /* # of last request processed by server */
+        Bool send_event;          /* true if this came for SendEvent request */
+        Display *display;         /* display the event was read from */
+        GLXDrawable drawable;     /* i.d. of Drawable */
+        int event_type;       /* GLX_DAMAGED_SGIX or GLX_SAVED_SGIX */
+        int draw_type;        /* GLX_WINDOW_SGIX or GLX_PBUFFER_SGIX */
+        unsigned int mask;    /* mask indicating which buffers are affected*/
+        int x, y;
+        int width, height;
+        int count;        /* if nonzero, at least this many more */
+    } GLXBufferClobberEventSGIX;
+#endif
+
+#ifndef GLX_NV_swap_group
+#endif
+
+#ifndef GLX_NV_video_out
+    /*
+     * GLXVideoDeviceNV is an opaque handle to a video device (part of the
+     * GLX_NV_video_out extension).
+     */
+    typedef unsigned int GLXVideoDeviceNV;
+
+    /* glXBindVideoImageNV iVideoBuffer values (NV_video_out) */
+#define GLX_VIDEO_OUT_COLOR_NV           0x20C3
+#define GLX_VIDEO_OUT_ALPHA_NV           0x20C4
+#define GLX_VIDEO_OUT_DEPTH_NV           0x20C5
+#define GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV 0x20C6
+#define GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV 0x20C7
+
+    /* glXSendPbufferToVideoNV iBufferType values (NV_video_out) */
+#define GLX_VIDEO_OUT_FRAME_NV           0x20C8
+#define GLX_VIDEO_OUT_FIELD_1_NV         0x20C9
+#define GLX_VIDEO_OUT_FIELD_2_NV         0x20CA
+#endif
+
+#ifndef GLX_EXT_texture_from_pixmap
+    /* New glXGetFBConfigAttrib <attrib_list> tokens */
+#define GLX_BIND_TO_TEXTURE_RGB_EXT      0x20D0
+#define GLX_BIND_TO_TEXTURE_RGBA_EXT     0x20D1
+#define GLX_BIND_TO_MIPMAP_TEXTURE_EXT   0x20D2
+#define GLX_BIND_TO_TEXTURE_TARGETS_EXT  0x20D3
+#define GLX_Y_INVERTED_EXT               0x20D4
+
+    /* New glXCreatePixmap attributes and glXQueryDrawable attributes */
+#define GLX_TEXTURE_FORMAT_EXT           0x20D5
+#define GLX_TEXTURE_TARGET_EXT           0x20D6
+#define GLX_MIPMAP_TEXTURE_EXT           0x20D7
+
+    /* Values for GLX_TEXTURE_FORMAT_EXT */
+#define GLX_TEXTURE_FORMAT_NONE_EXT      0x20D8
+#define GLX_TEXTURE_FORMAT_RGB_EXT       0x20D9
+#define GLX_TEXTURE_FORMAT_RGBA_EXT      0x20DA
+
+    /* Bits for GLX_BIND_TO_TEXTURE_TARGETS_EXT mask */
+#define GLX_TEXTURE_1D_BIT_EXT           0x00000001
+#define GLX_TEXTURE_2D_BIT_EXT           0x00000002
+#define GLX_TEXTURE_RECTANGLE_BIT_EXT    0x00000004
+
+    /* Values for GLX_TEXTURE_TARGET_EXT */
+#define GLX_TEXTURE_1D_EXT               0x20DB
+#define GLX_TEXTURE_2D_EXT               0x20DC
+#define GLX_TEXTURE_RECTANGLE_EXT        0x20DD
+
+    /*
+     * Values for the buffer parameter of glXBindTexImageEXT and
+     * glXReleaseTexImageEXT
+     */
+#define GLX_FRONT_LEFT_EXT               0x20DE
+#define GLX_FRONT_RIGHT_EXT              0x20DF
+#define GLX_BACK_LEFT_EXT                0x20E0
+#define GLX_BACK_RIGHT_EXT               0x20E1
+#define GLX_FRONT_EXT                    GLX_FRONT_LEFT_EXT
+#define GLX_BACK_EXT                     GLX_BACK_LEFT_EXT
+#define GLX_AUX0_EXT                     0x20E2
+#define GLX_AUX1_EXT                     0x20E3
+#define GLX_AUX2_EXT                     0x20E4
+#define GLX_AUX3_EXT                     0x20E5
+#define GLX_AUX4_EXT                     0x20E6
+#define GLX_AUX5_EXT                     0x20E7
+#define GLX_AUX6_EXT                     0x20E8
+#define GLX_AUX7_EXT                     0x20E9
+#define GLX_AUX8_EXT                     0x20EA
+#define GLX_AUX9_EXT                     0x20EB
+
+#endif
+
+    /* Define int32_t and int64_t types for UST/MSC */
+    /* (as used in the GLX_OML_sync_control extension). */
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#include <inttypes.h>
+#elif defined( __VMS ) || defined(__FreeBSD__)
+#include <inttypes.h>
+#elif (defined(__sun__) && defined(__svr4__)) || (defined(__sun) && defined(__SVR4))
+#include <inttypes.h>
+#elif defined(__SCO__) || defined(__USLC__) || defined(__linux__)
+#include <stdint.h>
+#elif defined(__UNIXOS2__) || defined(__SOL64__)
+    typedef long int int32_t;
+    typedef long long int int64_t;
+#else
+#error "int32_t and int64_t are undefined!"
+#endif
+
+#ifndef GLX_ARB_get_proc_address
+    /* Moved to glx.h */
+#endif
+
+#ifndef GLX_ARB_multisample
+#define GLX_ARB_multisample 1
+#endif
+
+#ifndef GLX_ARB_fbconfig_float
+#define GLX_ARB_fbconfig_float 1
+#endif
+
+#ifndef GLX_SGIS_multisample
+#define GLX_SGIS_multisample 1
+#endif
+
+#ifndef GLX_EXT_visual_info
+#define GLX_EXT_visual_info 1
+#endif
+
+#ifndef GLX_SGI_swap_control
+#define GLX_SGI_swap_control 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern int glXSwapIntervalSGI(int);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef int (* PFNGLXSWAPINTERVALSGIPROC)(int interval);
+#endif
+
+#ifndef GLX_SGI_video_sync
+#define GLX_SGI_video_sync 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern int glXGetVideoSyncSGI(unsigned int *);
+    extern int glXWaitVideoSyncSGI(int, int, unsigned int *);
+    extern int glXGetRefreshRateSGI(unsigned int *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef int (* PFNGLXGETVIDEOSYNCSGIPROC)(unsigned int *count);
+    typedef int (* PFNGLXWAITVIDEOSYNCSGIPROC)(int divisor, int remainder, unsigned int *count);
+    typedef int (* PFNGLXGETREFRESHRATESGIPROC)(unsigned int *);
+#endif
+
+#ifndef GLX_SGI_make_current_read
+#define GLX_SGI_make_current_read 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern Bool glXMakeCurrentReadSGI(Display *, GLXDrawable, GLXDrawable, GLXContext);
+    extern GLXDrawable glXGetCurrentReadDrawableSGI(void);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef Bool(* PFNGLXMAKECURRENTREADSGIPROC)(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+    typedef GLXDrawable(* PFNGLXGETCURRENTREADDRAWABLESGIPROC)(void);
+#endif
+
+#ifndef GLX_SGIX_video_source
+#define GLX_SGIX_video_source 1
+#ifdef _VL_H
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX(Display *, int, VLServer, VLPath, int, VLNode);
+    extern void glXDestroyGLXVideoSourceSGIX(Display *, GLXVideoSourceSGIX);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef GLXVideoSourceSGIX(* PFNGLXCREATEGLXVIDEOSOURCESGIXPROC)(Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
+    typedef void (* PFNGLXDESTROYGLXVIDEOSOURCESGIXPROC)(Display *dpy, GLXVideoSourceSGIX glxvideosource);
+#endif /* _VL_H */
+#endif
+
+#ifndef GLX_EXT_visual_rating
+#define GLX_EXT_visual_rating 1
+#endif
+
+#ifndef GLX_EXT_import_context
+#define GLX_EXT_import_context 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern Display *glXGetCurrentDisplayEXT(void);
+    extern int glXQueryContextInfoEXT(Display *, GLXContext, int, int *);
+    extern GLXContextID glXGetContextIDEXT(const GLXContext);
+    extern GLXContext glXImportContextEXT(Display *, GLXContextID);
+    extern void glXFreeContextEXT(Display *, GLXContext);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef Display *(* PFNGLXGETCURRENTDISPLAYEXTPROC)(void);
+    typedef int (* PFNGLXQUERYCONTEXTINFOEXTPROC)(Display *dpy, GLXContext context, int attribute, int *value);
+    typedef GLXContextID(* PFNGLXGETCONTEXTIDEXTPROC)(const GLXContext context);
+    typedef GLXContext(* PFNGLXIMPORTCONTEXTEXTPROC)(Display *dpy, GLXContextID contextID);
+    typedef void (* PFNGLXFREECONTEXTEXTPROC)(Display *dpy, GLXContext context);
+#endif
+
+#ifndef GLX_SGIX_fbconfig
+#define GLX_SGIX_fbconfig 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern int glXGetFBConfigAttribSGIX(Display *, GLXFBConfigSGIX, int, int *);
+    extern GLXFBConfigSGIX *glXChooseFBConfigSGIX(Display *, int, int *, int *);
+    extern GLXPixmap glXCreateGLXPixmapWithConfigSGIX(Display *, GLXFBConfigSGIX, Pixmap);
+    extern GLXContext glXCreateContextWithConfigSGIX(Display *, GLXFBConfigSGIX, int, GLXContext, Bool);
+    extern XVisualInfo *glXGetVisualFromFBConfigSGIX(Display *, GLXFBConfigSGIX);
+    extern GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX(Display *, XVisualInfo *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef int (* PFNGLXGETFBCONFIGATTRIBSGIXPROC)(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
+    typedef GLXFBConfigSGIX *(* PFNGLXCHOOSEFBCONFIGSGIXPROC)(Display *dpy, int screen, int *attrib_list, int *nelements);
+    typedef GLXPixmap(* PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC)(Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
+    typedef GLXContext(* PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC)(Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
+    typedef XVisualInfo *(* PFNGLXGETVISUALFROMFBCONFIGSGIXPROC)(Display *dpy, GLXFBConfigSGIX config);
+    typedef GLXFBConfigSGIX(* PFNGLXGETFBCONFIGFROMVISUALSGIXPROC)(Display *dpy, XVisualInfo *vis);
+#endif
+
+#ifndef GLX_SGIX_pbuffer
+#define GLX_SGIX_pbuffer 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern GLXPbufferSGIX glXCreateGLXPbufferSGIX(Display *, GLXFBConfigSGIX, unsigned int, unsigned int, int *);
+    extern void glXDestroyGLXPbufferSGIX(Display *, GLXPbufferSGIX);
+    extern int glXQueryGLXPbufferSGIX(Display *, GLXPbufferSGIX, int, unsigned int *);
+    extern void glXSelectEventSGIX(Display *, GLXDrawable, unsigned long);
+    extern void glXGetSelectedEventSGIX(Display *, GLXDrawable, unsigned long *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef GLXPbufferSGIX(* PFNGLXCREATEGLXPBUFFERSGIXPROC)(Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
+    typedef void (* PFNGLXDESTROYGLXPBUFFERSGIXPROC)(Display *dpy, GLXPbufferSGIX pbuf);
+    typedef int (* PFNGLXQUERYGLXPBUFFERSGIXPROC)(Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
+    typedef void (* PFNGLXSELECTEVENTSGIXPROC)(Display *dpy, GLXDrawable drawable, unsigned long mask);
+    typedef void (* PFNGLXGETSELECTEDEVENTSGIXPROC)(Display *dpy, GLXDrawable drawable, unsigned long *mask);
+#endif
+
+#ifndef GLX_SGI_cushion
+#define GLX_SGI_cushion 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern void glXCushionSGI(Display *, Window, float);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef void (* PFNGLXCUSHIONSGIPROC)(Display *dpy, Window window, float cushion);
+#endif
+
+#ifndef GLX_SGIX_video_resize
+#define GLX_SGIX_video_resize 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern int glXBindChannelToWindowSGIX(Display *, int, int, Window);
+    extern int glXChannelRectSGIX(Display *, int, int, int, int, int, int);
+    extern int glXQueryChannelRectSGIX(Display *, int, int, int *, int *, int *, int *);
+    extern int glXQueryChannelDeltasSGIX(Display *, int, int, int *, int *, int *, int *);
+    extern int glXChannelRectSyncSGIX(Display *, int, int, GLenum);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef int (* PFNGLXBINDCHANNELTOWINDOWSGIXPROC)(Display *display, int screen, int channel, Window window);
+    typedef int (* PFNGLXCHANNELRECTSGIXPROC)(Display *display, int screen, int channel, int x, int y, int w, int h);
+    typedef int (* PFNGLXQUERYCHANNELRECTSGIXPROC)(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
+    typedef int (* PFNGLXQUERYCHANNELDELTASSGIXPROC)(Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
+    typedef int (* PFNGLXCHANNELRECTSYNCSGIXPROC)(Display *display, int screen, int channel, GLenum synctype);
+#endif
+
+#ifndef GLX_SGIX_dmbuffer
+#define GLX_SGIX_dmbuffer 1
+#ifdef _DM_BUFFER_H_
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern Bool glXAssociateDMPbufferSGIX(Display *, GLXPbufferSGIX, DMparams *, DMbuffer);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef Bool(* PFNGLXASSOCIATEDMPBUFFERSGIXPROC)(Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
+#endif /* _DM_BUFFER_H_ */
+#endif
+
+#ifndef GLX_SGIX_swap_group
+#define GLX_SGIX_swap_group 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern void glXJoinSwapGroupSGIX(Display *, GLXDrawable, GLXDrawable);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef void (* PFNGLXJOINSWAPGROUPSGIXPROC)(Display *dpy, GLXDrawable drawable, GLXDrawable member);
+#endif
+
+#ifndef GLX_SGIX_swap_barrier
+#define GLX_SGIX_swap_barrier 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern void glXBindSwapBarrierSGIX(Display *, GLXDrawable, int);
+    extern Bool glXQueryMaxSwapBarriersSGIX(Display *, int, int *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef void (* PFNGLXBINDSWAPBARRIERSGIXPROC)(Display *dpy, GLXDrawable drawable, int barrier);
+    typedef Bool(* PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC)(Display *dpy, int screen, int *max);
+#endif
+
+#ifndef GLX_SUN_get_transparent_index
+#define GLX_SUN_get_transparent_index 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern Status glXGetTransparentIndexSUN(Display *, Window, Window, long *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef Status(* PFNGLXGETTRANSPARENTINDEXSUNPROC)(Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
+#endif
+
+#ifndef GLX_MESA_copy_sub_buffer
+#define GLX_MESA_copy_sub_buffer 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern void glXCopySubBufferMESA(Display *, GLXDrawable, int, int, int, int);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef void (* PFNGLXCOPYSUBBUFFERMESAPROC)(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
+#endif
+
+#ifndef GLX_MESA_pixmap_colormap
+#define GLX_MESA_pixmap_colormap 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern GLXPixmap glXCreateGLXPixmapMESA(Display *, XVisualInfo *, Pixmap, Colormap);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef GLXPixmap(* PFNGLXCREATEGLXPIXMAPMESAPROC)(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
+#endif
+
+#ifndef GLX_MESA_release_buffers
+#define GLX_MESA_release_buffers 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern Bool glXReleaseBuffersMESA(Display *, GLXDrawable);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef Bool(* PFNGLXRELEASEBUFFERSMESAPROC)(Display *dpy, GLXDrawable drawable);
+#endif
+
+#ifndef GLX_MESA_set_3dfx_mode
+#define GLX_MESA_set_3dfx_mode 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern Bool glXSet3DfxModeMESA(int);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef Bool(* PFNGLXSET3DFXMODEMESAPROC)(int mode);
+#endif
+
+#ifndef GLX_SGIX_visual_select_group
+#define GLX_SGIX_visual_select_group 1
+#endif
+
+#ifndef GLX_OML_swap_method
+#define GLX_OML_swap_method 1
+#endif
+
+#ifndef GLX_OML_sync_control
+#define GLX_OML_sync_control 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern Bool glXGetSyncValuesOML(Display *, GLXDrawable, int64_t *, int64_t *, int64_t *);
+    extern Bool glXGetMscRateOML(Display *, GLXDrawable, int32_t *, int32_t *);
+    extern int64_t glXSwapBuffersMscOML(Display *, GLXDrawable, int64_t, int64_t, int64_t);
+    extern Bool glXWaitForMscOML(Display *, GLXDrawable, int64_t, int64_t, int64_t, int64_t *, int64_t *, int64_t *);
+    extern Bool glXWaitForSbcOML(Display *, GLXDrawable, int64_t, int64_t *, int64_t *, int64_t *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef Bool(* PFNGLXGETSYNCVALUESOMLPROC)(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
+    typedef Bool(* PFNGLXGETMSCRATEOMLPROC)(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
+    typedef int64_t (* PFNGLXSWAPBUFFERSMSCOMLPROC)(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
+    typedef Bool(* PFNGLXWAITFORMSCOMLPROC)(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
+    typedef Bool(* PFNGLXWAITFORSBCOMLPROC)(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
+#endif
+
+#ifndef GLX_NV_float_buffer
+#define GLX_NV_float_buffer 1
+#endif
+
+#ifndef GLX_SGIX_hyperpipe
+#define GLX_SGIX_hyperpipe 1
+
+    typedef struct
+    {
+        char    pipeName[GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX];
+        int     networkId;
+    } GLXHyperpipeNetworkSGIX;
+
+    typedef struct
+    {
+        char    pipeName[GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX];
+        int     channel;
+        unsigned int
+        participationType;
+        int     timeSlice;
+    } GLXHyperpipeConfigSGIX;
+
+    typedef struct
+    {
+        char pipeName[GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX];
+        int srcXOrigin, srcYOrigin, srcWidth, srcHeight;
+        int destXOrigin, destYOrigin, destWidth, destHeight;
+    } GLXPipeRect;
+
+    typedef struct
+    {
+        char pipeName[GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX];
+        int XOrigin, YOrigin, maxHeight, maxWidth;
+    } GLXPipeRectLimits;
+
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern GLXHyperpipeNetworkSGIX *glXQueryHyperpipeNetworkSGIX(Display *, int *);
+    extern int glXHyperpipeConfigSGIX(Display *, int, int, GLXHyperpipeConfigSGIX *, int *);
+    extern GLXHyperpipeConfigSGIX *glXQueryHyperpipeConfigSGIX(Display *, int, int *);
+    extern int glXDestroyHyperpipeConfigSGIX(Display *, int);
+    extern int glXBindHyperpipeSGIX(Display *, int);
+    extern int glXQueryHyperpipeBestAttribSGIX(Display *, int, int, int, void *, void *);
+    extern int glXHyperpipeAttribSGIX(Display *, int, int, int, void *);
+    extern int glXQueryHyperpipeAttribSGIX(Display *, int, int, int, void *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef GLXHyperpipeNetworkSGIX *(* PFNGLXQUERYHYPERPIPENETWORKSGIXPROC)(Display *dpy, int *npipes);
+    typedef int (* PFNGLXHYPERPIPECONFIGSGIXPROC)(Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
+    typedef GLXHyperpipeConfigSGIX *(* PFNGLXQUERYHYPERPIPECONFIGSGIXPROC)(Display *dpy, int hpId, int *npipes);
+    typedef int (* PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC)(Display *dpy, int hpId);
+    typedef int (* PFNGLXBINDHYPERPIPESGIXPROC)(Display *dpy, int hpId);
+    typedef int (* PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC)(Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
+    typedef int (* PFNGLXHYPERPIPEATTRIBSGIXPROC)(Display *dpy, int timeSlice, int attrib, int size, void *attribList);
+    typedef int (* PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC)(Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
+#endif
+
+#ifndef GLX_MESA_agp_offset
+#define GLX_MESA_agp_offset 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern unsigned int glXGetAGPOffsetMESA(const void *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+    typedef unsigned int (* PFNGLXGETAGPOFFSETMESAPROC)(const void *pointer);
+#endif
+
+    /*
+     * GLX_NV_vertex_array_range is not a real extension name...
+     */
+#ifndef GLX_NV_vertex_array_range
+#define GLX_NV_vertex_array_range 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern void *glXAllocateMemoryNV(GLsizei size, GLfloat readfreq,
+                                     GLfloat writefreq, GLfloat priority);
+
+    extern void glXFreeMemoryNV(GLvoid *pointer);
+#endif
+    typedef void *(* PFNGLXALLOCATEMEMORYNVPROC)(GLsizei size,
+                                                 GLfloat readfreq,
+                                                 GLfloat writefreq,
+                                                 GLfloat priority);
+
+    typedef void (* PFNGLXFREEMEMORYNVPROC)(GLvoid *pointer);
+#endif
+
+#ifndef GLX_NV_swap_group
+#define GLX_NV_swap_group 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern Bool glXJoinSwapGroupNV(Display *dpy, GLXDrawable drawable,
+                                   GLuint group);
+
+    extern Bool glXBindSwapBarrierNV(Display *dpy, GLuint group, GLuint barrier);
+
+    extern Bool glXQuerySwapGroupNV(Display *dpy, GLXDrawable drawable,
+                                    GLuint *group, GLuint *barrier);
+
+    extern Bool glXQueryMaxSwapGroupsNV(Display *dpy, int screen,
+                                        GLuint *maxGroups, GLuint *maxBarriers);
+
+    extern Bool glXQueryFrameCountNV(Display *dpy, int screen, GLuint *count);
+
+    extern Bool glXResetFrameCountNV(Display *dpy, int screen);
+#endif
+    typedef Bool(* PFNGLXJOINSWAPGROUPNVPROC)(Display *dpy,
+                                              GLXDrawable drawable,
+                                              GLuint group);
+
+    typedef Bool(* PFNGLXBINDSWAPBARRIERNVPROC)(Display *dpy,
+                                                GLuint group,
+                                                GLuint barrier);
+
+    typedef Bool(* PFNGLXQUERYSWAPGROUPNVPROC)(Display *dpy,
+                                               GLXDrawable drawable,
+                                               GLuint *group,
+                                               GLuint *barrier);
+
+    typedef Bool(* PFNGLXQUERYMAXSWAPGROUPSNVPROC)(Display *dpy,
+                                                   int screen,
+                                                   GLuint *maxGroups,
+                                                   GLuint *maxBarriers);
+
+    typedef Bool(* PFNGLXQUERYFRAMECOUNTNVPROC)(Display *dpy,
+                                                int screen,
+                                                GLuint *count);
+
+    typedef Bool(* PFNGLXRESETFRAMECOUNTNVPROC)(Display *dpy, int screen);
+#endif
+
+#ifndef GLX_NV_video_out
+#define GLX_NV_video_out 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern int glXGetVideoDeviceNV(Display *dpy, int screen, int numVideoDevices,
+                                   GLXVideoDeviceNV *pVideoDevice);
+
+    extern int glXReleaseVideoDeviceNV(Display *dpy, int screen,
+                                       GLXVideoDeviceNV VideoDevice);
+
+    extern int glXBindVideoImageNV(Display *dpy, GLXVideoDeviceNV VideoDevice,
+                                   GLXPbuffer pbuf, int iVideoBuffer);
+
+    extern int glXReleaseVideoImageNV(Display *dpy, GLXPbuffer pbuf);
+
+    extern int glXSendPbufferToVideoNV(Display *dpy, GLXPbuffer pbuf,
+                                       int iBufferType,
+                                       unsigned long *pulCounterPbuffer,
+                                       GLboolean bBlock);
+
+    extern int glXGetVideoInfoNV(Display *dpy, int screen,
+                                 GLXVideoDeviceNV VideoDevice,
+                                 unsigned long *pulCounterOutputVideo,
+                                 unsigned long *pulCounterOutputPbuffer);
+#endif
+    typedef int (* PFNGLXGETVIDEODEVICENVPROC)(Display *dpy,
+                                               int screen,
+                                               int numVideoDevices,
+                                               GLXVideoDeviceNV *pVideoDevice);
+
+    typedef int (* PFNGLXRELEASEVIDEODEVICENVPROC)(Display *dpy,
+                                                   int screen,
+                                                   GLXVideoDeviceNV VideoDevice);
+
+    typedef int (* PFNGLXBINDVIDEOIMAGENVPROC)(Display *dpy,
+                                               GLXVideoDeviceNV VideoDevice,
+                                               GLXPbuffer pbuf,
+                                               int iVideoBuffer);
+
+    typedef int (* PFNGLXRELEASEVIDEOIMAGENVPROC)(Display *dpy,
+                                                  GLXPbuffer pbuf);
+
+    typedef int (* PFNGLXSENDPBUFFERTOVIDEONVPROC)(Display *dpy,
+                                                   GLXPbuffer pbuf,
+                                                   int iBufferType,
+                                                   unsigned long *pulCounterPbuffer,
+                                                   GLboolean bBlock);
+
+    typedef int (* PFNGLXGETVIDEOINFONVPROC)(Display *dpy, int screen,
+                                             GLXVideoDeviceNV VideoDevice,
+                                             unsigned long *pulCounterOutputVideo,
+                                             unsigned long *pulCounterOutputPbuffer);
+#endif
+
+#ifndef GLX_EXT_texture_from_pixmap
+#define GLX_EXT_texture_from_pixmap
+#ifdef GLX_GLXEXT_PROTOTYPES
+    extern void glXBindTexImageEXT(Display *dpy, GLXDrawable drawable,
+                                   int buffer, const int *attrib_list);
+    extern void glXReleaseTexImageEXT(Display *dpy, GLXDrawable drawable,
+                                      int buffer);
+#endif
+    typedef void (* PFNGLXBINDTEXIMAGEEXTPROC)(Display *dpy,
+                                               GLXDrawable drawable,
+                                               int buffer,
+                                               const int *attrib_list);
+    typedef void (* PFNGLXRELEASETEXIMAGEEXTPROC)(Display *dpy,
+                                                  GLXDrawable drawable,
+                                                  int buffer);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/GL/wglew.h gpu-rodinia_new/cuda/cfd/common/inc/GL/wglew.h
--- gpu-rodinia/cuda/cfd/common/inc/GL/wglew.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/GL/wglew.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,958 @@
+/*
+** The OpenGL Extension Wrangler Library
+** Copyright (C) 2002-2006, Milan Ikits <milan ikits[]ieee org>
+** Copyright (C) 2002-2006, Marcelo E. Magallon <mmagallo[]debian org>
+** Copyright (C) 2002, Lev Povalahev
+** All rights reserved.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**
+** * Redistributions of source code must retain the above copyright notice,
+**   this list of conditions and the following disclaimer.
+** * Redistributions in binary form must reproduce the above copyright notice,
+**   this list of conditions and the following disclaimer in the documentation
+**   and/or other materials provided with the distribution.
+** * The name of the author may be used to endorse or promote products
+**   derived from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+** THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef __wglew_h__
+#define __wglew_h__
+#define __WGLEW_H__
+
+#ifdef __wglext_h_
+#error wglext.h included before wglew.h
+#endif
+
+#define __wglext_h_
+
+#if !defined(APIENTRY) && !defined(__CYGWIN__)
+#  ifndef WIN32_LEAN_AND_MEAN
+#    define WIN32_LEAN_AND_MEAN 1
+#  endif
+#include <windows.h>
+#endif
+
+/*
+ * GLEW_STATIC needs to be set when using the static version.
+ * GLEW_BUILD is set when building the DLL version.
+ */
+#ifdef GLEW_STATIC
+#  define GLEWAPI extern
+#else
+#  ifdef GLEW_BUILD
+#    define GLEWAPI extern __declspec(dllexport)
+#  else
+#    define GLEWAPI extern __declspec(dllimport)
+#  endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /* -------------------------- WGL_3DFX_multisample ------------------------- */
+
+#ifndef WGL_3DFX_multisample
+#define WGL_3DFX_multisample 1
+
+#define WGL_SAMPLE_BUFFERS_3DFX 0x2060
+#define WGL_SAMPLES_3DFX 0x2061
+
+#define WGLEW_3DFX_multisample WGLEW_GET_VAR(__WGLEW_3DFX_multisample)
+
+#endif /* WGL_3DFX_multisample */
+
+    /* ------------------------- WGL_3DL_stereo_control ------------------------ */
+
+#ifndef WGL_3DL_stereo_control
+#define WGL_3DL_stereo_control 1
+
+#define WGL_STEREO_EMITTER_ENABLE_3DL 0x2055
+#define WGL_STEREO_EMITTER_DISABLE_3DL 0x2056
+#define WGL_STEREO_POLARITY_NORMAL_3DL 0x2057
+#define WGL_STEREO_POLARITY_INVERT_3DL 0x2058
+
+    typedef BOOL (WINAPI *PFNWGLSETSTEREOEMITTERSTATE3DLPROC)(HDC hDC, UINT uState);
+
+#define wglSetStereoEmitterState3DL WGLEW_GET_FUN(__wglewSetStereoEmitterState3DL)
+
+#define WGLEW_3DL_stereo_control WGLEW_GET_VAR(__WGLEW_3DL_stereo_control)
+
+#endif /* WGL_3DL_stereo_control */
+
+    /* ------------------------- WGL_ARB_buffer_region ------------------------- */
+
+#ifndef WGL_ARB_buffer_region
+#define WGL_ARB_buffer_region 1
+
+#define WGL_FRONT_COLOR_BUFFER_BIT_ARB 0x00000001
+#define WGL_BACK_COLOR_BUFFER_BIT_ARB 0x00000002
+#define WGL_DEPTH_BUFFER_BIT_ARB 0x00000004
+#define WGL_STENCIL_BUFFER_BIT_ARB 0x00000008
+
+    typedef HANDLE(WINAPI *PFNWGLCREATEBUFFERREGIONARBPROC)(HDC hDC, int iLayerPlane, UINT uType);
+    typedef VOID (WINAPI *PFNWGLDELETEBUFFERREGIONARBPROC)(HANDLE hRegion);
+    typedef BOOL (WINAPI *PFNWGLRESTOREBUFFERREGIONARBPROC)(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc);
+    typedef BOOL (WINAPI *PFNWGLSAVEBUFFERREGIONARBPROC)(HANDLE hRegion, int x, int y, int width, int height);
+
+#define wglCreateBufferRegionARB WGLEW_GET_FUN(__wglewCreateBufferRegionARB)
+#define wglDeleteBufferRegionARB WGLEW_GET_FUN(__wglewDeleteBufferRegionARB)
+#define wglRestoreBufferRegionARB WGLEW_GET_FUN(__wglewRestoreBufferRegionARB)
+#define wglSaveBufferRegionARB WGLEW_GET_FUN(__wglewSaveBufferRegionARB)
+
+#define WGLEW_ARB_buffer_region WGLEW_GET_VAR(__WGLEW_ARB_buffer_region)
+
+#endif /* WGL_ARB_buffer_region */
+
+    /* ----------------------- WGL_ARB_extensions_string ----------------------- */
+
+#ifndef WGL_ARB_extensions_string
+#define WGL_ARB_extensions_string 1
+
+    typedef const char *(WINAPI *PFNWGLGETEXTENSIONSSTRINGARBPROC)(HDC hdc);
+
+#define wglGetExtensionsStringARB WGLEW_GET_FUN(__wglewGetExtensionsStringARB)
+
+#define WGLEW_ARB_extensions_string WGLEW_GET_VAR(__WGLEW_ARB_extensions_string)
+
+#endif /* WGL_ARB_extensions_string */
+
+    /* ----------------------- WGL_ARB_make_current_read ----------------------- */
+
+#ifndef WGL_ARB_make_current_read
+#define WGL_ARB_make_current_read 1
+
+    typedef HDC(WINAPI *PFNWGLGETCURRENTREADDCARBPROC)(VOID);
+    typedef BOOL (WINAPI *PFNWGLMAKECONTEXTCURRENTARBPROC)(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
+
+#define wglGetCurrentReadDCARB WGLEW_GET_FUN(__wglewGetCurrentReadDCARB)
+#define wglMakeContextCurrentARB WGLEW_GET_FUN(__wglewMakeContextCurrentARB)
+
+#define WGLEW_ARB_make_current_read WGLEW_GET_VAR(__WGLEW_ARB_make_current_read)
+
+#endif /* WGL_ARB_make_current_read */
+
+    /* -------------------------- WGL_ARB_multisample -------------------------- */
+
+#ifndef WGL_ARB_multisample
+#define WGL_ARB_multisample 1
+
+#define WGL_SAMPLE_BUFFERS_ARB 0x2041
+#define WGL_SAMPLES_ARB 0x2042
+
+#define WGLEW_ARB_multisample WGLEW_GET_VAR(__WGLEW_ARB_multisample)
+
+#endif /* WGL_ARB_multisample */
+
+    /* ---------------------------- WGL_ARB_pbuffer ---------------------------- */
+
+#ifndef WGL_ARB_pbuffer
+#define WGL_ARB_pbuffer 1
+
+#define WGL_DRAW_TO_PBUFFER_ARB 0x202D
+#define WGL_MAX_PBUFFER_PIXELS_ARB 0x202E
+#define WGL_MAX_PBUFFER_WIDTH_ARB 0x202F
+#define WGL_MAX_PBUFFER_HEIGHT_ARB 0x2030
+#define WGL_PBUFFER_LARGEST_ARB 0x2033
+#define WGL_PBUFFER_WIDTH_ARB 0x2034
+#define WGL_PBUFFER_HEIGHT_ARB 0x2035
+#define WGL_PBUFFER_LOST_ARB 0x2036
+
+    DECLARE_HANDLE(HPBUFFERARB);
+
+    typedef HPBUFFERARB(WINAPI *PFNWGLCREATEPBUFFERARBPROC)(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
+    typedef BOOL (WINAPI *PFNWGLDESTROYPBUFFERARBPROC)(HPBUFFERARB hPbuffer);
+    typedef HDC(WINAPI *PFNWGLGETPBUFFERDCARBPROC)(HPBUFFERARB hPbuffer);
+    typedef BOOL (WINAPI *PFNWGLQUERYPBUFFERARBPROC)(HPBUFFERARB hPbuffer, int iAttribute, int *piValue);
+    typedef int (WINAPI *PFNWGLRELEASEPBUFFERDCARBPROC)(HPBUFFERARB hPbuffer, HDC hDC);
+
+#define wglCreatePbufferARB WGLEW_GET_FUN(__wglewCreatePbufferARB)
+#define wglDestroyPbufferARB WGLEW_GET_FUN(__wglewDestroyPbufferARB)
+#define wglGetPbufferDCARB WGLEW_GET_FUN(__wglewGetPbufferDCARB)
+#define wglQueryPbufferARB WGLEW_GET_FUN(__wglewQueryPbufferARB)
+#define wglReleasePbufferDCARB WGLEW_GET_FUN(__wglewReleasePbufferDCARB)
+
+#define WGLEW_ARB_pbuffer WGLEW_GET_VAR(__WGLEW_ARB_pbuffer)
+
+#endif /* WGL_ARB_pbuffer */
+
+    /* -------------------------- WGL_ARB_pixel_format ------------------------- */
+
+#ifndef WGL_ARB_pixel_format
+#define WGL_ARB_pixel_format 1
+
+#define WGL_NUMBER_PIXEL_FORMATS_ARB 0x2000
+#define WGL_DRAW_TO_WINDOW_ARB 0x2001
+#define WGL_DRAW_TO_BITMAP_ARB 0x2002
+#define WGL_ACCELERATION_ARB 0x2003
+#define WGL_NEED_PALETTE_ARB 0x2004
+#define WGL_NEED_SYSTEM_PALETTE_ARB 0x2005
+#define WGL_SWAP_LAYER_BUFFERS_ARB 0x2006
+#define WGL_SWAP_METHOD_ARB 0x2007
+#define WGL_NUMBER_OVERLAYS_ARB 0x2008
+#define WGL_NUMBER_UNDERLAYS_ARB 0x2009
+#define WGL_TRANSPARENT_ARB 0x200A
+#define WGL_SHARE_DEPTH_ARB 0x200C
+#define WGL_SHARE_STENCIL_ARB 0x200D
+#define WGL_SHARE_ACCUM_ARB 0x200E
+#define WGL_SUPPORT_GDI_ARB 0x200F
+#define WGL_SUPPORT_OPENGL_ARB 0x2010
+#define WGL_DOUBLE_BUFFER_ARB 0x2011
+#define WGL_STEREO_ARB 0x2012
+#define WGL_PIXEL_TYPE_ARB 0x2013
+#define WGL_COLOR_BITS_ARB 0x2014
+#define WGL_RED_BITS_ARB 0x2015
+#define WGL_RED_SHIFT_ARB 0x2016
+#define WGL_GREEN_BITS_ARB 0x2017
+#define WGL_GREEN_SHIFT_ARB 0x2018
+#define WGL_BLUE_BITS_ARB 0x2019
+#define WGL_BLUE_SHIFT_ARB 0x201A
+#define WGL_ALPHA_BITS_ARB 0x201B
+#define WGL_ALPHA_SHIFT_ARB 0x201C
+#define WGL_ACCUM_BITS_ARB 0x201D
+#define WGL_ACCUM_RED_BITS_ARB 0x201E
+#define WGL_ACCUM_GREEN_BITS_ARB 0x201F
+#define WGL_ACCUM_BLUE_BITS_ARB 0x2020
+#define WGL_ACCUM_ALPHA_BITS_ARB 0x2021
+#define WGL_DEPTH_BITS_ARB 0x2022
+#define WGL_STENCIL_BITS_ARB 0x2023
+#define WGL_AUX_BUFFERS_ARB 0x2024
+#define WGL_NO_ACCELERATION_ARB 0x2025
+#define WGL_GENERIC_ACCELERATION_ARB 0x2026
+#define WGL_FULL_ACCELERATION_ARB 0x2027
+#define WGL_SWAP_EXCHANGE_ARB 0x2028
+#define WGL_SWAP_COPY_ARB 0x2029
+#define WGL_SWAP_UNDEFINED_ARB 0x202A
+#define WGL_TYPE_RGBA_ARB 0x202B
+#define WGL_TYPE_COLORINDEX_ARB 0x202C
+#define WGL_TRANSPARENT_RED_VALUE_ARB 0x2037
+#define WGL_TRANSPARENT_GREEN_VALUE_ARB 0x2038
+#define WGL_TRANSPARENT_BLUE_VALUE_ARB 0x2039
+#define WGL_TRANSPARENT_ALPHA_VALUE_ARB 0x203A
+#define WGL_TRANSPARENT_INDEX_VALUE_ARB 0x203B
+
+    typedef BOOL (WINAPI *PFNWGLCHOOSEPIXELFORMATARBPROC)(HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
+    typedef BOOL (WINAPI *PFNWGLGETPIXELFORMATATTRIBFVARBPROC)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues);
+    typedef BOOL (WINAPI *PFNWGLGETPIXELFORMATATTRIBIVARBPROC)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues);
+
+#define wglChoosePixelFormatARB WGLEW_GET_FUN(__wglewChoosePixelFormatARB)
+#define wglGetPixelFormatAttribfvARB WGLEW_GET_FUN(__wglewGetPixelFormatAttribfvARB)
+#define wglGetPixelFormatAttribivARB WGLEW_GET_FUN(__wglewGetPixelFormatAttribivARB)
+
+#define WGLEW_ARB_pixel_format WGLEW_GET_VAR(__WGLEW_ARB_pixel_format)
+
+#endif /* WGL_ARB_pixel_format */
+
+    /* ----------------------- WGL_ARB_pixel_format_float ---------------------- */
+
+#ifndef WGL_ARB_pixel_format_float
+#define WGL_ARB_pixel_format_float 1
+
+#define WGL_TYPE_RGBA_FLOAT_ARB 0x21A0
+
+#define WGLEW_ARB_pixel_format_float WGLEW_GET_VAR(__WGLEW_ARB_pixel_format_float)
+
+#endif /* WGL_ARB_pixel_format_float */
+
+    /* ------------------------- WGL_ARB_render_texture ------------------------ */
+
+#ifndef WGL_ARB_render_texture
+#define WGL_ARB_render_texture 1
+
+#define WGL_BIND_TO_TEXTURE_RGB_ARB 0x2070
+#define WGL_BIND_TO_TEXTURE_RGBA_ARB 0x2071
+#define WGL_TEXTURE_FORMAT_ARB 0x2072
+#define WGL_TEXTURE_TARGET_ARB 0x2073
+#define WGL_MIPMAP_TEXTURE_ARB 0x2074
+#define WGL_TEXTURE_RGB_ARB 0x2075
+#define WGL_TEXTURE_RGBA_ARB 0x2076
+#define WGL_NO_TEXTURE_ARB 0x2077
+#define WGL_TEXTURE_CUBE_MAP_ARB 0x2078
+#define WGL_TEXTURE_1D_ARB 0x2079
+#define WGL_TEXTURE_2D_ARB 0x207A
+#define WGL_MIPMAP_LEVEL_ARB 0x207B
+#define WGL_CUBE_MAP_FACE_ARB 0x207C
+#define WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x207D
+#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x207E
+#define WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x207F
+#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x2080
+#define WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x2081
+#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x2082
+#define WGL_FRONT_LEFT_ARB 0x2083
+#define WGL_FRONT_RIGHT_ARB 0x2084
+#define WGL_BACK_LEFT_ARB 0x2085
+#define WGL_BACK_RIGHT_ARB 0x2086
+#define WGL_AUX0_ARB 0x2087
+#define WGL_AUX1_ARB 0x2088
+#define WGL_AUX2_ARB 0x2089
+#define WGL_AUX3_ARB 0x208A
+#define WGL_AUX4_ARB 0x208B
+#define WGL_AUX5_ARB 0x208C
+#define WGL_AUX6_ARB 0x208D
+#define WGL_AUX7_ARB 0x208E
+#define WGL_AUX8_ARB 0x208F
+#define WGL_AUX9_ARB 0x2090
+
+    typedef BOOL (WINAPI *PFNWGLBINDTEXIMAGEARBPROC)(HPBUFFERARB hPbuffer, int iBuffer);
+    typedef BOOL (WINAPI *PFNWGLRELEASETEXIMAGEARBPROC)(HPBUFFERARB hPbuffer, int iBuffer);
+    typedef BOOL (WINAPI *PFNWGLSETPBUFFERATTRIBARBPROC)(HPBUFFERARB hPbuffer, const int *piAttribList);
+
+#define wglBindTexImageARB WGLEW_GET_FUN(__wglewBindTexImageARB)
+#define wglReleaseTexImageARB WGLEW_GET_FUN(__wglewReleaseTexImageARB)
+#define wglSetPbufferAttribARB WGLEW_GET_FUN(__wglewSetPbufferAttribARB)
+
+#define WGLEW_ARB_render_texture WGLEW_GET_VAR(__WGLEW_ARB_render_texture)
+
+#endif /* WGL_ARB_render_texture */
+
+    /* ----------------------- WGL_ATI_pixel_format_float ---------------------- */
+
+#ifndef WGL_ATI_pixel_format_float
+#define WGL_ATI_pixel_format_float 1
+
+#define WGL_TYPE_RGBA_FLOAT_ATI 0x21A0
+#define GL_RGBA_FLOAT_MODE_ATI 0x8820
+#define GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI 0x8835
+
+#define WGLEW_ATI_pixel_format_float WGLEW_GET_VAR(__WGLEW_ATI_pixel_format_float)
+
+#endif /* WGL_ATI_pixel_format_float */
+
+    /* -------------------- WGL_ATI_render_texture_rectangle ------------------- */
+
+#ifndef WGL_ATI_render_texture_rectangle
+#define WGL_ATI_render_texture_rectangle 1
+
+#define WGL_TEXTURE_RECTANGLE_ATI 0x21A5
+
+#define WGLEW_ATI_render_texture_rectangle WGLEW_GET_VAR(__WGLEW_ATI_render_texture_rectangle)
+
+#endif /* WGL_ATI_render_texture_rectangle */
+
+    /* -------------------------- WGL_EXT_depth_float -------------------------- */
+
+#ifndef WGL_EXT_depth_float
+#define WGL_EXT_depth_float 1
+
+#define WGL_DEPTH_FLOAT_EXT 0x2040
+
+#define WGLEW_EXT_depth_float WGLEW_GET_VAR(__WGLEW_EXT_depth_float)
+
+#endif /* WGL_EXT_depth_float */
+
+    /* ---------------------- WGL_EXT_display_color_table ---------------------- */
+
+#ifndef WGL_EXT_display_color_table
+#define WGL_EXT_display_color_table 1
+
+    typedef GLboolean(WINAPI *PFNWGLBINDDISPLAYCOLORTABLEEXTPROC)(GLushort id);
+    typedef GLboolean(WINAPI *PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC)(GLushort id);
+    typedef void (WINAPI *PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC)(GLushort id);
+    typedef GLboolean(WINAPI *PFNWGLLOADDISPLAYCOLORTABLEEXTPROC)(GLushort *table, GLuint length);
+
+#define wglBindDisplayColorTableEXT WGLEW_GET_FUN(__wglewBindDisplayColorTableEXT)
+#define wglCreateDisplayColorTableEXT WGLEW_GET_FUN(__wglewCreateDisplayColorTableEXT)
+#define wglDestroyDisplayColorTableEXT WGLEW_GET_FUN(__wglewDestroyDisplayColorTableEXT)
+#define wglLoadDisplayColorTableEXT WGLEW_GET_FUN(__wglewLoadDisplayColorTableEXT)
+
+#define WGLEW_EXT_display_color_table WGLEW_GET_VAR(__WGLEW_EXT_display_color_table)
+
+#endif /* WGL_EXT_display_color_table */
+
+    /* ----------------------- WGL_EXT_extensions_string ----------------------- */
+
+#ifndef WGL_EXT_extensions_string
+#define WGL_EXT_extensions_string 1
+
+    typedef const char *(WINAPI *PFNWGLGETEXTENSIONSSTRINGEXTPROC)(void);
+
+#define wglGetExtensionsStringEXT WGLEW_GET_FUN(__wglewGetExtensionsStringEXT)
+
+#define WGLEW_EXT_extensions_string WGLEW_GET_VAR(__WGLEW_EXT_extensions_string)
+
+#endif /* WGL_EXT_extensions_string */
+
+    /* ------------------------ WGL_EXT_framebuffer_sRGB ----------------------- */
+
+#ifndef WGL_EXT_framebuffer_sRGB
+#define WGL_EXT_framebuffer_sRGB 1
+
+#define WGL_FRAMEBUFFER_SRGB_CAPABLE_EXT 0x20A9
+
+#define WGLEW_EXT_framebuffer_sRGB WGLEW_GET_VAR(__WGLEW_EXT_framebuffer_sRGB)
+
+#endif /* WGL_EXT_framebuffer_sRGB */
+
+    /* ----------------------- WGL_EXT_make_current_read ----------------------- */
+
+#ifndef WGL_EXT_make_current_read
+#define WGL_EXT_make_current_read 1
+
+    typedef HDC(WINAPI *PFNWGLGETCURRENTREADDCEXTPROC)(VOID);
+    typedef BOOL (WINAPI *PFNWGLMAKECONTEXTCURRENTEXTPROC)(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
+
+#define wglGetCurrentReadDCEXT WGLEW_GET_FUN(__wglewGetCurrentReadDCEXT)
+#define wglMakeContextCurrentEXT WGLEW_GET_FUN(__wglewMakeContextCurrentEXT)
+
+#define WGLEW_EXT_make_current_read WGLEW_GET_VAR(__WGLEW_EXT_make_current_read)
+
+#endif /* WGL_EXT_make_current_read */
+
+    /* -------------------------- WGL_EXT_multisample -------------------------- */
+
+#ifndef WGL_EXT_multisample
+#define WGL_EXT_multisample 1
+
+#define WGL_SAMPLE_BUFFERS_EXT 0x2041
+#define WGL_SAMPLES_EXT 0x2042
+
+#define WGLEW_EXT_multisample WGLEW_GET_VAR(__WGLEW_EXT_multisample)
+
+#endif /* WGL_EXT_multisample */
+
+    /* ---------------------------- WGL_EXT_pbuffer ---------------------------- */
+
+#ifndef WGL_EXT_pbuffer
+#define WGL_EXT_pbuffer 1
+
+#define WGL_DRAW_TO_PBUFFER_EXT 0x202D
+#define WGL_MAX_PBUFFER_PIXELS_EXT 0x202E
+#define WGL_MAX_PBUFFER_WIDTH_EXT 0x202F
+#define WGL_MAX_PBUFFER_HEIGHT_EXT 0x2030
+#define WGL_OPTIMAL_PBUFFER_WIDTH_EXT 0x2031
+#define WGL_OPTIMAL_PBUFFER_HEIGHT_EXT 0x2032
+#define WGL_PBUFFER_LARGEST_EXT 0x2033
+#define WGL_PBUFFER_WIDTH_EXT 0x2034
+#define WGL_PBUFFER_HEIGHT_EXT 0x2035
+
+    DECLARE_HANDLE(HPBUFFEREXT);
+
+    typedef HPBUFFEREXT(WINAPI *PFNWGLCREATEPBUFFEREXTPROC)(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
+    typedef BOOL (WINAPI *PFNWGLDESTROYPBUFFEREXTPROC)(HPBUFFEREXT hPbuffer);
+    typedef HDC(WINAPI *PFNWGLGETPBUFFERDCEXTPROC)(HPBUFFEREXT hPbuffer);
+    typedef BOOL (WINAPI *PFNWGLQUERYPBUFFEREXTPROC)(HPBUFFEREXT hPbuffer, int iAttribute, int *piValue);
+    typedef int (WINAPI *PFNWGLRELEASEPBUFFERDCEXTPROC)(HPBUFFEREXT hPbuffer, HDC hDC);
+
+#define wglCreatePbufferEXT WGLEW_GET_FUN(__wglewCreatePbufferEXT)
+#define wglDestroyPbufferEXT WGLEW_GET_FUN(__wglewDestroyPbufferEXT)
+#define wglGetPbufferDCEXT WGLEW_GET_FUN(__wglewGetPbufferDCEXT)
+#define wglQueryPbufferEXT WGLEW_GET_FUN(__wglewQueryPbufferEXT)
+#define wglReleasePbufferDCEXT WGLEW_GET_FUN(__wglewReleasePbufferDCEXT)
+
+#define WGLEW_EXT_pbuffer WGLEW_GET_VAR(__WGLEW_EXT_pbuffer)
+
+#endif /* WGL_EXT_pbuffer */
+
+    /* -------------------------- WGL_EXT_pixel_format ------------------------- */
+
+#ifndef WGL_EXT_pixel_format
+#define WGL_EXT_pixel_format 1
+
+#define WGL_NUMBER_PIXEL_FORMATS_EXT 0x2000
+#define WGL_DRAW_TO_WINDOW_EXT 0x2001
+#define WGL_DRAW_TO_BITMAP_EXT 0x2002
+#define WGL_ACCELERATION_EXT 0x2003
+#define WGL_NEED_PALETTE_EXT 0x2004
+#define WGL_NEED_SYSTEM_PALETTE_EXT 0x2005
+#define WGL_SWAP_LAYER_BUFFERS_EXT 0x2006
+#define WGL_SWAP_METHOD_EXT 0x2007
+#define WGL_NUMBER_OVERLAYS_EXT 0x2008
+#define WGL_NUMBER_UNDERLAYS_EXT 0x2009
+#define WGL_TRANSPARENT_EXT 0x200A
+#define WGL_TRANSPARENT_VALUE_EXT 0x200B
+#define WGL_SHARE_DEPTH_EXT 0x200C
+#define WGL_SHARE_STENCIL_EXT 0x200D
+#define WGL_SHARE_ACCUM_EXT 0x200E
+#define WGL_SUPPORT_GDI_EXT 0x200F
+#define WGL_SUPPORT_OPENGL_EXT 0x2010
+#define WGL_DOUBLE_BUFFER_EXT 0x2011
+#define WGL_STEREO_EXT 0x2012
+#define WGL_PIXEL_TYPE_EXT 0x2013
+#define WGL_COLOR_BITS_EXT 0x2014
+#define WGL_RED_BITS_EXT 0x2015
+#define WGL_RED_SHIFT_EXT 0x2016
+#define WGL_GREEN_BITS_EXT 0x2017
+#define WGL_GREEN_SHIFT_EXT 0x2018
+#define WGL_BLUE_BITS_EXT 0x2019
+#define WGL_BLUE_SHIFT_EXT 0x201A
+#define WGL_ALPHA_BITS_EXT 0x201B
+#define WGL_ALPHA_SHIFT_EXT 0x201C
+#define WGL_ACCUM_BITS_EXT 0x201D
+#define WGL_ACCUM_RED_BITS_EXT 0x201E
+#define WGL_ACCUM_GREEN_BITS_EXT 0x201F
+#define WGL_ACCUM_BLUE_BITS_EXT 0x2020
+#define WGL_ACCUM_ALPHA_BITS_EXT 0x2021
+#define WGL_DEPTH_BITS_EXT 0x2022
+#define WGL_STENCIL_BITS_EXT 0x2023
+#define WGL_AUX_BUFFERS_EXT 0x2024
+#define WGL_NO_ACCELERATION_EXT 0x2025
+#define WGL_GENERIC_ACCELERATION_EXT 0x2026
+#define WGL_FULL_ACCELERATION_EXT 0x2027
+#define WGL_SWAP_EXCHANGE_EXT 0x2028
+#define WGL_SWAP_COPY_EXT 0x2029
+#define WGL_SWAP_UNDEFINED_EXT 0x202A
+#define WGL_TYPE_RGBA_EXT 0x202B
+#define WGL_TYPE_COLORINDEX_EXT 0x202C
+
+    typedef BOOL (WINAPI *PFNWGLCHOOSEPIXELFORMATEXTPROC)(HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
+    typedef BOOL (WINAPI *PFNWGLGETPIXELFORMATATTRIBFVEXTPROC)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, FLOAT *pfValues);
+    typedef BOOL (WINAPI *PFNWGLGETPIXELFORMATATTRIBIVEXTPROC)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, int *piValues);
+
+#define wglChoosePixelFormatEXT WGLEW_GET_FUN(__wglewChoosePixelFormatEXT)
+#define wglGetPixelFormatAttribfvEXT WGLEW_GET_FUN(__wglewGetPixelFormatAttribfvEXT)
+#define wglGetPixelFormatAttribivEXT WGLEW_GET_FUN(__wglewGetPixelFormatAttribivEXT)
+
+#define WGLEW_EXT_pixel_format WGLEW_GET_VAR(__WGLEW_EXT_pixel_format)
+
+#endif /* WGL_EXT_pixel_format */
+
+    /* ------------------- WGL_EXT_pixel_format_packed_float ------------------- */
+
+#ifndef WGL_EXT_pixel_format_packed_float
+#define WGL_EXT_pixel_format_packed_float 1
+
+#define WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT 0x20A8
+
+#define WGLEW_EXT_pixel_format_packed_float WGLEW_GET_VAR(__WGLEW_EXT_pixel_format_packed_float)
+
+#endif /* WGL_EXT_pixel_format_packed_float */
+
+    /* -------------------------- WGL_EXT_swap_control ------------------------- */
+
+#ifndef WGL_EXT_swap_control
+#define WGL_EXT_swap_control 1
+
+    typedef int (WINAPI *PFNWGLGETSWAPINTERVALEXTPROC)(void);
+    typedef BOOL (WINAPI *PFNWGLSWAPINTERVALEXTPROC)(int interval);
+
+#define wglGetSwapIntervalEXT WGLEW_GET_FUN(__wglewGetSwapIntervalEXT)
+#define wglSwapIntervalEXT WGLEW_GET_FUN(__wglewSwapIntervalEXT)
+
+#define WGLEW_EXT_swap_control WGLEW_GET_VAR(__WGLEW_EXT_swap_control)
+
+#endif /* WGL_EXT_swap_control */
+
+    /* --------------------- WGL_I3D_digital_video_control --------------------- */
+
+#ifndef WGL_I3D_digital_video_control
+#define WGL_I3D_digital_video_control 1
+
+#define WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D 0x2050
+#define WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D 0x2051
+#define WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D 0x2052
+#define WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D 0x2053
+
+    typedef BOOL (WINAPI *PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC)(HDC hDC, int iAttribute, int *piValue);
+    typedef BOOL (WINAPI *PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC)(HDC hDC, int iAttribute, const int *piValue);
+
+#define wglGetDigitalVideoParametersI3D WGLEW_GET_FUN(__wglewGetDigitalVideoParametersI3D)
+#define wglSetDigitalVideoParametersI3D WGLEW_GET_FUN(__wglewSetDigitalVideoParametersI3D)
+
+#define WGLEW_I3D_digital_video_control WGLEW_GET_VAR(__WGLEW_I3D_digital_video_control)
+
+#endif /* WGL_I3D_digital_video_control */
+
+    /* ----------------------------- WGL_I3D_gamma ----------------------------- */
+
+#ifndef WGL_I3D_gamma
+#define WGL_I3D_gamma 1
+
+#define WGL_GAMMA_TABLE_SIZE_I3D 0x204E
+#define WGL_GAMMA_EXCLUDE_DESKTOP_I3D 0x204F
+
+    typedef BOOL (WINAPI *PFNWGLGETGAMMATABLEI3DPROC)(HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue);
+    typedef BOOL (WINAPI *PFNWGLGETGAMMATABLEPARAMETERSI3DPROC)(HDC hDC, int iAttribute, int *piValue);
+    typedef BOOL (WINAPI *PFNWGLSETGAMMATABLEI3DPROC)(HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue);
+    typedef BOOL (WINAPI *PFNWGLSETGAMMATABLEPARAMETERSI3DPROC)(HDC hDC, int iAttribute, const int *piValue);
+
+#define wglGetGammaTableI3D WGLEW_GET_FUN(__wglewGetGammaTableI3D)
+#define wglGetGammaTableParametersI3D WGLEW_GET_FUN(__wglewGetGammaTableParametersI3D)
+#define wglSetGammaTableI3D WGLEW_GET_FUN(__wglewSetGammaTableI3D)
+#define wglSetGammaTableParametersI3D WGLEW_GET_FUN(__wglewSetGammaTableParametersI3D)
+
+#define WGLEW_I3D_gamma WGLEW_GET_VAR(__WGLEW_I3D_gamma)
+
+#endif /* WGL_I3D_gamma */
+
+    /* ---------------------------- WGL_I3D_genlock ---------------------------- */
+
+#ifndef WGL_I3D_genlock
+#define WGL_I3D_genlock 1
+
+#define WGL_GENLOCK_SOURCE_MULTIVIEW_I3D 0x2044
+#define WGL_GENLOCK_SOURCE_EXTERNAL_SYNC_I3D 0x2045
+#define WGL_GENLOCK_SOURCE_EXTERNAL_FIELD_I3D 0x2046
+#define WGL_GENLOCK_SOURCE_EXTERNAL_TTL_I3D 0x2047
+#define WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D 0x2048
+#define WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D 0x2049
+#define WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D 0x204A
+#define WGL_GENLOCK_SOURCE_EDGE_RISING_I3D 0x204B
+#define WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D 0x204C
+
+    typedef BOOL (WINAPI *PFNWGLDISABLEGENLOCKI3DPROC)(HDC hDC);
+    typedef BOOL (WINAPI *PFNWGLENABLEGENLOCKI3DPROC)(HDC hDC);
+    typedef BOOL (WINAPI *PFNWGLGENLOCKSAMPLERATEI3DPROC)(HDC hDC, UINT uRate);
+    typedef BOOL (WINAPI *PFNWGLGENLOCKSOURCEDELAYI3DPROC)(HDC hDC, UINT uDelay);
+    typedef BOOL (WINAPI *PFNWGLGENLOCKSOURCEEDGEI3DPROC)(HDC hDC, UINT uEdge);
+    typedef BOOL (WINAPI *PFNWGLGENLOCKSOURCEI3DPROC)(HDC hDC, UINT uSource);
+    typedef BOOL (WINAPI *PFNWGLGETGENLOCKSAMPLERATEI3DPROC)(HDC hDC, UINT *uRate);
+    typedef BOOL (WINAPI *PFNWGLGETGENLOCKSOURCEDELAYI3DPROC)(HDC hDC, UINT *uDelay);
+    typedef BOOL (WINAPI *PFNWGLGETGENLOCKSOURCEEDGEI3DPROC)(HDC hDC, UINT *uEdge);
+    typedef BOOL (WINAPI *PFNWGLGETGENLOCKSOURCEI3DPROC)(HDC hDC, UINT *uSource);
+    typedef BOOL (WINAPI *PFNWGLISENABLEDGENLOCKI3DPROC)(HDC hDC, BOOL *pFlag);
+    typedef BOOL (WINAPI *PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC)(HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay);
+
+#define wglDisableGenlockI3D WGLEW_GET_FUN(__wglewDisableGenlockI3D)
+#define wglEnableGenlockI3D WGLEW_GET_FUN(__wglewEnableGenlockI3D)
+#define wglGenlockSampleRateI3D WGLEW_GET_FUN(__wglewGenlockSampleRateI3D)
+#define wglGenlockSourceDelayI3D WGLEW_GET_FUN(__wglewGenlockSourceDelayI3D)
+#define wglGenlockSourceEdgeI3D WGLEW_GET_FUN(__wglewGenlockSourceEdgeI3D)
+#define wglGenlockSourceI3D WGLEW_GET_FUN(__wglewGenlockSourceI3D)
+#define wglGetGenlockSampleRateI3D WGLEW_GET_FUN(__wglewGetGenlockSampleRateI3D)
+#define wglGetGenlockSourceDelayI3D WGLEW_GET_FUN(__wglewGetGenlockSourceDelayI3D)
+#define wglGetGenlockSourceEdgeI3D WGLEW_GET_FUN(__wglewGetGenlockSourceEdgeI3D)
+#define wglGetGenlockSourceI3D WGLEW_GET_FUN(__wglewGetGenlockSourceI3D)
+#define wglIsEnabledGenlockI3D WGLEW_GET_FUN(__wglewIsEnabledGenlockI3D)
+#define wglQueryGenlockMaxSourceDelayI3D WGLEW_GET_FUN(__wglewQueryGenlockMaxSourceDelayI3D)
+
+#define WGLEW_I3D_genlock WGLEW_GET_VAR(__WGLEW_I3D_genlock)
+
+#endif /* WGL_I3D_genlock */
+
+    /* -------------------------- WGL_I3D_image_buffer ------------------------- */
+
+#ifndef WGL_I3D_image_buffer
+#define WGL_I3D_image_buffer 1
+
+#define WGL_IMAGE_BUFFER_MIN_ACCESS_I3D 0x00000001
+#define WGL_IMAGE_BUFFER_LOCK_I3D 0x00000002
+
+    typedef BOOL (WINAPI *PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC)(HDC hdc, HANDLE *pEvent, LPVOID *pAddress, DWORD *pSize, UINT count);
+    typedef LPVOID (WINAPI *PFNWGLCREATEIMAGEBUFFERI3DPROC)(HDC hDC, DWORD dwSize, UINT uFlags);
+    typedef BOOL (WINAPI *PFNWGLDESTROYIMAGEBUFFERI3DPROC)(HDC hDC, LPVOID pAddress);
+    typedef BOOL (WINAPI *PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC)(HDC hdc, LPVOID *pAddress, UINT count);
+
+#define wglAssociateImageBufferEventsI3D WGLEW_GET_FUN(__wglewAssociateImageBufferEventsI3D)
+#define wglCreateImageBufferI3D WGLEW_GET_FUN(__wglewCreateImageBufferI3D)
+#define wglDestroyImageBufferI3D WGLEW_GET_FUN(__wglewDestroyImageBufferI3D)
+#define wglReleaseImageBufferEventsI3D WGLEW_GET_FUN(__wglewReleaseImageBufferEventsI3D)
+
+#define WGLEW_I3D_image_buffer WGLEW_GET_VAR(__WGLEW_I3D_image_buffer)
+
+#endif /* WGL_I3D_image_buffer */
+
+    /* ------------------------ WGL_I3D_swap_frame_lock ------------------------ */
+
+#ifndef WGL_I3D_swap_frame_lock
+#define WGL_I3D_swap_frame_lock 1
+
+    typedef BOOL (WINAPI *PFNWGLDISABLEFRAMELOCKI3DPROC)(VOID);
+    typedef BOOL (WINAPI *PFNWGLENABLEFRAMELOCKI3DPROC)(VOID);
+    typedef BOOL (WINAPI *PFNWGLISENABLEDFRAMELOCKI3DPROC)(BOOL *pFlag);
+    typedef BOOL (WINAPI *PFNWGLQUERYFRAMELOCKMASTERI3DPROC)(BOOL *pFlag);
+
+#define wglDisableFrameLockI3D WGLEW_GET_FUN(__wglewDisableFrameLockI3D)
+#define wglEnableFrameLockI3D WGLEW_GET_FUN(__wglewEnableFrameLockI3D)
+#define wglIsEnabledFrameLockI3D WGLEW_GET_FUN(__wglewIsEnabledFrameLockI3D)
+#define wglQueryFrameLockMasterI3D WGLEW_GET_FUN(__wglewQueryFrameLockMasterI3D)
+
+#define WGLEW_I3D_swap_frame_lock WGLEW_GET_VAR(__WGLEW_I3D_swap_frame_lock)
+
+#endif /* WGL_I3D_swap_frame_lock */
+
+    /* ------------------------ WGL_I3D_swap_frame_usage ----------------------- */
+
+#ifndef WGL_I3D_swap_frame_usage
+#define WGL_I3D_swap_frame_usage 1
+
+    typedef BOOL (WINAPI *PFNWGLBEGINFRAMETRACKINGI3DPROC)(void);
+    typedef BOOL (WINAPI *PFNWGLENDFRAMETRACKINGI3DPROC)(void);
+    typedef BOOL (WINAPI *PFNWGLGETFRAMEUSAGEI3DPROC)(float *pUsage);
+    typedef BOOL (WINAPI *PFNWGLQUERYFRAMETRACKINGI3DPROC)(DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage);
+
+#define wglBeginFrameTrackingI3D WGLEW_GET_FUN(__wglewBeginFrameTrackingI3D)
+#define wglEndFrameTrackingI3D WGLEW_GET_FUN(__wglewEndFrameTrackingI3D)
+#define wglGetFrameUsageI3D WGLEW_GET_FUN(__wglewGetFrameUsageI3D)
+#define wglQueryFrameTrackingI3D WGLEW_GET_FUN(__wglewQueryFrameTrackingI3D)
+
+#define WGLEW_I3D_swap_frame_usage WGLEW_GET_VAR(__WGLEW_I3D_swap_frame_usage)
+
+#endif /* WGL_I3D_swap_frame_usage */
+
+    /* -------------------------- WGL_NV_float_buffer -------------------------- */
+
+#ifndef WGL_NV_float_buffer
+#define WGL_NV_float_buffer 1
+
+#define WGL_FLOAT_COMPONENTS_NV 0x20B0
+#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV 0x20B1
+#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV 0x20B2
+#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV 0x20B3
+#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV 0x20B4
+#define WGL_TEXTURE_FLOAT_R_NV 0x20B5
+#define WGL_TEXTURE_FLOAT_RG_NV 0x20B6
+#define WGL_TEXTURE_FLOAT_RGB_NV 0x20B7
+#define WGL_TEXTURE_FLOAT_RGBA_NV 0x20B8
+
+#define WGLEW_NV_float_buffer WGLEW_GET_VAR(__WGLEW_NV_float_buffer)
+
+#endif /* WGL_NV_float_buffer */
+
+    /* ---------------------- WGL_NV_render_depth_texture ---------------------- */
+
+#ifndef WGL_NV_render_depth_texture
+#define WGL_NV_render_depth_texture 1
+
+#define WGL_NO_TEXTURE_ARB 0x2077
+#define WGL_BIND_TO_TEXTURE_DEPTH_NV 0x20A3
+#define WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV 0x20A4
+#define WGL_DEPTH_TEXTURE_FORMAT_NV 0x20A5
+#define WGL_TEXTURE_DEPTH_COMPONENT_NV 0x20A6
+#define WGL_DEPTH_COMPONENT_NV 0x20A7
+
+#define WGLEW_NV_render_depth_texture WGLEW_GET_VAR(__WGLEW_NV_render_depth_texture)
+
+#endif /* WGL_NV_render_depth_texture */
+
+    /* -------------------- WGL_NV_render_texture_rectangle -------------------- */
+
+#ifndef WGL_NV_render_texture_rectangle
+#define WGL_NV_render_texture_rectangle 1
+
+#define WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV 0x20A0
+#define WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV 0x20A1
+#define WGL_TEXTURE_RECTANGLE_NV 0x20A2
+
+#define WGLEW_NV_render_texture_rectangle WGLEW_GET_VAR(__WGLEW_NV_render_texture_rectangle)
+
+#endif /* WGL_NV_render_texture_rectangle */
+
+    /* ----------------------- WGL_NV_vertex_array_range ----------------------- */
+
+#ifndef WGL_NV_vertex_array_range
+#define WGL_NV_vertex_array_range 1
+
+    typedef void *(WINAPI *PFNWGLALLOCATEMEMORYNVPROC)(GLsizei size, GLfloat readFrequency, GLfloat writeFrequency, GLfloat priority);
+    typedef void (WINAPI *PFNWGLFREEMEMORYNVPROC)(void *pointer);
+
+#define wglAllocateMemoryNV WGLEW_GET_FUN(__wglewAllocateMemoryNV)
+#define wglFreeMemoryNV WGLEW_GET_FUN(__wglewFreeMemoryNV)
+
+#define WGLEW_NV_vertex_array_range WGLEW_GET_VAR(__WGLEW_NV_vertex_array_range)
+
+#endif /* WGL_NV_vertex_array_range */
+
+    /* -------------------------- WGL_OML_sync_control ------------------------- */
+
+#ifndef WGL_OML_sync_control
+#define WGL_OML_sync_control 1
+
+    typedef BOOL (WINAPI *PFNWGLGETMSCRATEOMLPROC)(HDC hdc, INT32 *numerator, INT32 *denominator);
+    typedef BOOL (WINAPI *PFNWGLGETSYNCVALUESOMLPROC)(HDC hdc, INT64 *ust, INT64 *msc, INT64 *sbc);
+    typedef INT64(WINAPI *PFNWGLSWAPBUFFERSMSCOMLPROC)(HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder);
+    typedef INT64(WINAPI *PFNWGLSWAPLAYERBUFFERSMSCOMLPROC)(HDC hdc, INT fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);
+    typedef BOOL (WINAPI *PFNWGLWAITFORMSCOMLPROC)(HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc);
+    typedef BOOL (WINAPI *PFNWGLWAITFORSBCOMLPROC)(HDC hdc, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc);
+
+#define wglGetMscRateOML WGLEW_GET_FUN(__wglewGetMscRateOML)
+#define wglGetSyncValuesOML WGLEW_GET_FUN(__wglewGetSyncValuesOML)
+#define wglSwapBuffersMscOML WGLEW_GET_FUN(__wglewSwapBuffersMscOML)
+#define wglSwapLayerBuffersMscOML WGLEW_GET_FUN(__wglewSwapLayerBuffersMscOML)
+#define wglWaitForMscOML WGLEW_GET_FUN(__wglewWaitForMscOML)
+#define wglWaitForSbcOML WGLEW_GET_FUN(__wglewWaitForSbcOML)
+
+#define WGLEW_OML_sync_control WGLEW_GET_VAR(__WGLEW_OML_sync_control)
+
+#endif /* WGL_OML_sync_control */
+
+    /* ------------------------------------------------------------------------- */
+
+#ifdef GLEW_MX
+#define WGLEW_EXPORT
+#else
+#define WGLEW_EXPORT GLEWAPI
+#endif /* GLEW_MX */
+
+#ifdef GLEW_MX
+    struct WGLEWContextStruct
+    {
+#endif /* GLEW_MX */
+
+        WGLEW_EXPORT PFNWGLSETSTEREOEMITTERSTATE3DLPROC __wglewSetStereoEmitterState3DL;
+
+        WGLEW_EXPORT PFNWGLCREATEBUFFERREGIONARBPROC __wglewCreateBufferRegionARB;
+        WGLEW_EXPORT PFNWGLDELETEBUFFERREGIONARBPROC __wglewDeleteBufferRegionARB;
+        WGLEW_EXPORT PFNWGLRESTOREBUFFERREGIONARBPROC __wglewRestoreBufferRegionARB;
+        WGLEW_EXPORT PFNWGLSAVEBUFFERREGIONARBPROC __wglewSaveBufferRegionARB;
+
+        WGLEW_EXPORT PFNWGLGETEXTENSIONSSTRINGARBPROC __wglewGetExtensionsStringARB;
+
+        WGLEW_EXPORT PFNWGLGETCURRENTREADDCARBPROC __wglewGetCurrentReadDCARB;
+        WGLEW_EXPORT PFNWGLMAKECONTEXTCURRENTARBPROC __wglewMakeContextCurrentARB;
+
+        WGLEW_EXPORT PFNWGLCREATEPBUFFERARBPROC __wglewCreatePbufferARB;
+        WGLEW_EXPORT PFNWGLDESTROYPBUFFERARBPROC __wglewDestroyPbufferARB;
+        WGLEW_EXPORT PFNWGLGETPBUFFERDCARBPROC __wglewGetPbufferDCARB;
+        WGLEW_EXPORT PFNWGLQUERYPBUFFERARBPROC __wglewQueryPbufferARB;
+        WGLEW_EXPORT PFNWGLRELEASEPBUFFERDCARBPROC __wglewReleasePbufferDCARB;
+
+        WGLEW_EXPORT PFNWGLCHOOSEPIXELFORMATARBPROC __wglewChoosePixelFormatARB;
+        WGLEW_EXPORT PFNWGLGETPIXELFORMATATTRIBFVARBPROC __wglewGetPixelFormatAttribfvARB;
+        WGLEW_EXPORT PFNWGLGETPIXELFORMATATTRIBIVARBPROC __wglewGetPixelFormatAttribivARB;
+
+        WGLEW_EXPORT PFNWGLBINDTEXIMAGEARBPROC __wglewBindTexImageARB;
+        WGLEW_EXPORT PFNWGLRELEASETEXIMAGEARBPROC __wglewReleaseTexImageARB;
+        WGLEW_EXPORT PFNWGLSETPBUFFERATTRIBARBPROC __wglewSetPbufferAttribARB;
+
+        WGLEW_EXPORT PFNWGLBINDDISPLAYCOLORTABLEEXTPROC __wglewBindDisplayColorTableEXT;
+        WGLEW_EXPORT PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC __wglewCreateDisplayColorTableEXT;
+        WGLEW_EXPORT PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC __wglewDestroyDisplayColorTableEXT;
+        WGLEW_EXPORT PFNWGLLOADDISPLAYCOLORTABLEEXTPROC __wglewLoadDisplayColorTableEXT;
+
+        WGLEW_EXPORT PFNWGLGETEXTENSIONSSTRINGEXTPROC __wglewGetExtensionsStringEXT;
+
+        WGLEW_EXPORT PFNWGLGETCURRENTREADDCEXTPROC __wglewGetCurrentReadDCEXT;
+        WGLEW_EXPORT PFNWGLMAKECONTEXTCURRENTEXTPROC __wglewMakeContextCurrentEXT;
+
+        WGLEW_EXPORT PFNWGLCREATEPBUFFEREXTPROC __wglewCreatePbufferEXT;
+        WGLEW_EXPORT PFNWGLDESTROYPBUFFEREXTPROC __wglewDestroyPbufferEXT;
+        WGLEW_EXPORT PFNWGLGETPBUFFERDCEXTPROC __wglewGetPbufferDCEXT;
+        WGLEW_EXPORT PFNWGLQUERYPBUFFEREXTPROC __wglewQueryPbufferEXT;
+        WGLEW_EXPORT PFNWGLRELEASEPBUFFERDCEXTPROC __wglewReleasePbufferDCEXT;
+
+        WGLEW_EXPORT PFNWGLCHOOSEPIXELFORMATEXTPROC __wglewChoosePixelFormatEXT;
+        WGLEW_EXPORT PFNWGLGETPIXELFORMATATTRIBFVEXTPROC __wglewGetPixelFormatAttribfvEXT;
+        WGLEW_EXPORT PFNWGLGETPIXELFORMATATTRIBIVEXTPROC __wglewGetPixelFormatAttribivEXT;
+
+        WGLEW_EXPORT PFNWGLGETSWAPINTERVALEXTPROC __wglewGetSwapIntervalEXT;
+        WGLEW_EXPORT PFNWGLSWAPINTERVALEXTPROC __wglewSwapIntervalEXT;
+
+        WGLEW_EXPORT PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC __wglewGetDigitalVideoParametersI3D;
+        WGLEW_EXPORT PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC __wglewSetDigitalVideoParametersI3D;
+
+        WGLEW_EXPORT PFNWGLGETGAMMATABLEI3DPROC __wglewGetGammaTableI3D;
+        WGLEW_EXPORT PFNWGLGETGAMMATABLEPARAMETERSI3DPROC __wglewGetGammaTableParametersI3D;
+        WGLEW_EXPORT PFNWGLSETGAMMATABLEI3DPROC __wglewSetGammaTableI3D;
+        WGLEW_EXPORT PFNWGLSETGAMMATABLEPARAMETERSI3DPROC __wglewSetGammaTableParametersI3D;
+
+        WGLEW_EXPORT PFNWGLDISABLEGENLOCKI3DPROC __wglewDisableGenlockI3D;
+        WGLEW_EXPORT PFNWGLENABLEGENLOCKI3DPROC __wglewEnableGenlockI3D;
+        WGLEW_EXPORT PFNWGLGENLOCKSAMPLERATEI3DPROC __wglewGenlockSampleRateI3D;
+        WGLEW_EXPORT PFNWGLGENLOCKSOURCEDELAYI3DPROC __wglewGenlockSourceDelayI3D;
+        WGLEW_EXPORT PFNWGLGENLOCKSOURCEEDGEI3DPROC __wglewGenlockSourceEdgeI3D;
+        WGLEW_EXPORT PFNWGLGENLOCKSOURCEI3DPROC __wglewGenlockSourceI3D;
+        WGLEW_EXPORT PFNWGLGETGENLOCKSAMPLERATEI3DPROC __wglewGetGenlockSampleRateI3D;
+        WGLEW_EXPORT PFNWGLGETGENLOCKSOURCEDELAYI3DPROC __wglewGetGenlockSourceDelayI3D;
+        WGLEW_EXPORT PFNWGLGETGENLOCKSOURCEEDGEI3DPROC __wglewGetGenlockSourceEdgeI3D;
+        WGLEW_EXPORT PFNWGLGETGENLOCKSOURCEI3DPROC __wglewGetGenlockSourceI3D;
+        WGLEW_EXPORT PFNWGLISENABLEDGENLOCKI3DPROC __wglewIsEnabledGenlockI3D;
+        WGLEW_EXPORT PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC __wglewQueryGenlockMaxSourceDelayI3D;
+
+        WGLEW_EXPORT PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC __wglewAssociateImageBufferEventsI3D;
+        WGLEW_EXPORT PFNWGLCREATEIMAGEBUFFERI3DPROC __wglewCreateImageBufferI3D;
+        WGLEW_EXPORT PFNWGLDESTROYIMAGEBUFFERI3DPROC __wglewDestroyImageBufferI3D;
+        WGLEW_EXPORT PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC __wglewReleaseImageBufferEventsI3D;
+
+        WGLEW_EXPORT PFNWGLDISABLEFRAMELOCKI3DPROC __wglewDisableFrameLockI3D;
+        WGLEW_EXPORT PFNWGLENABLEFRAMELOCKI3DPROC __wglewEnableFrameLockI3D;
+        WGLEW_EXPORT PFNWGLISENABLEDFRAMELOCKI3DPROC __wglewIsEnabledFrameLockI3D;
+        WGLEW_EXPORT PFNWGLQUERYFRAMELOCKMASTERI3DPROC __wglewQueryFrameLockMasterI3D;
+
+        WGLEW_EXPORT PFNWGLBEGINFRAMETRACKINGI3DPROC __wglewBeginFrameTrackingI3D;
+        WGLEW_EXPORT PFNWGLENDFRAMETRACKINGI3DPROC __wglewEndFrameTrackingI3D;
+        WGLEW_EXPORT PFNWGLGETFRAMEUSAGEI3DPROC __wglewGetFrameUsageI3D;
+        WGLEW_EXPORT PFNWGLQUERYFRAMETRACKINGI3DPROC __wglewQueryFrameTrackingI3D;
+
+        WGLEW_EXPORT PFNWGLALLOCATEMEMORYNVPROC __wglewAllocateMemoryNV;
+        WGLEW_EXPORT PFNWGLFREEMEMORYNVPROC __wglewFreeMemoryNV;
+
+        WGLEW_EXPORT PFNWGLGETMSCRATEOMLPROC __wglewGetMscRateOML;
+        WGLEW_EXPORT PFNWGLGETSYNCVALUESOMLPROC __wglewGetSyncValuesOML;
+        WGLEW_EXPORT PFNWGLSWAPBUFFERSMSCOMLPROC __wglewSwapBuffersMscOML;
+        WGLEW_EXPORT PFNWGLSWAPLAYERBUFFERSMSCOMLPROC __wglewSwapLayerBuffersMscOML;
+        WGLEW_EXPORT PFNWGLWAITFORMSCOMLPROC __wglewWaitForMscOML;
+        WGLEW_EXPORT PFNWGLWAITFORSBCOMLPROC __wglewWaitForSbcOML;
+        WGLEW_EXPORT GLboolean __WGLEW_3DFX_multisample;
+        WGLEW_EXPORT GLboolean __WGLEW_3DL_stereo_control;
+        WGLEW_EXPORT GLboolean __WGLEW_ARB_buffer_region;
+        WGLEW_EXPORT GLboolean __WGLEW_ARB_extensions_string;
+        WGLEW_EXPORT GLboolean __WGLEW_ARB_make_current_read;
+        WGLEW_EXPORT GLboolean __WGLEW_ARB_multisample;
+        WGLEW_EXPORT GLboolean __WGLEW_ARB_pbuffer;
+        WGLEW_EXPORT GLboolean __WGLEW_ARB_pixel_format;
+        WGLEW_EXPORT GLboolean __WGLEW_ARB_pixel_format_float;
+        WGLEW_EXPORT GLboolean __WGLEW_ARB_render_texture;
+        WGLEW_EXPORT GLboolean __WGLEW_ATI_pixel_format_float;
+        WGLEW_EXPORT GLboolean __WGLEW_ATI_render_texture_rectangle;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_depth_float;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_display_color_table;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_extensions_string;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_framebuffer_sRGB;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_make_current_read;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_multisample;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_pbuffer;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_pixel_format;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_pixel_format_packed_float;
+        WGLEW_EXPORT GLboolean __WGLEW_EXT_swap_control;
+        WGLEW_EXPORT GLboolean __WGLEW_I3D_digital_video_control;
+        WGLEW_EXPORT GLboolean __WGLEW_I3D_gamma;
+        WGLEW_EXPORT GLboolean __WGLEW_I3D_genlock;
+        WGLEW_EXPORT GLboolean __WGLEW_I3D_image_buffer;
+        WGLEW_EXPORT GLboolean __WGLEW_I3D_swap_frame_lock;
+        WGLEW_EXPORT GLboolean __WGLEW_I3D_swap_frame_usage;
+        WGLEW_EXPORT GLboolean __WGLEW_NV_float_buffer;
+        WGLEW_EXPORT GLboolean __WGLEW_NV_render_depth_texture;
+        WGLEW_EXPORT GLboolean __WGLEW_NV_render_texture_rectangle;
+        WGLEW_EXPORT GLboolean __WGLEW_NV_vertex_array_range;
+        WGLEW_EXPORT GLboolean __WGLEW_OML_sync_control;
+
+#ifdef GLEW_MX
+    }; /* WGLEWContextStruct */
+#endif /* GLEW_MX */
+
+    /* ------------------------------------------------------------------------- */
+
+#ifdef GLEW_MX
+
+    typedef struct WGLEWContextStruct WGLEWContext;
+    GLEWAPI GLenum wglewContextInit(WGLEWContext *ctx);
+    GLEWAPI GLboolean wglewContextIsSupported(WGLEWContext *ctx, const char *name);
+
+#define wglewInit() wglewContextInit(wglewGetContext())
+#define wglewIsSupported(x) wglewContextIsSupported(wglewGetContext(), x)
+
+#define WGLEW_GET_VAR(x) wglewGetContext()->x
+#define WGLEW_GET_FUN(x) wglewGetContext()->x
+
+#else /* GLEW_MX */
+
+#define WGLEW_GET_VAR(x) x
+#define WGLEW_GET_FUN(x) x
+
+    GLEWAPI GLboolean wglewIsSupported(const char *name);
+
+#endif /* GLEW_MX */
+
+    GLEWAPI GLboolean wglewGetExtension(const char *name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#undef GLEWAPI
+
+#endif /* __wglew_h__ */
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/helper_cuda_drvapi.h gpu-rodinia_new/cuda/cfd/common/inc/helper_cuda_drvapi.h
--- gpu-rodinia/cuda/cfd/common/inc/helper_cuda_drvapi.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/helper_cuda_drvapi.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,466 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+// Helper functions for CUDA Driver API error handling (make sure that CUDA_H is included in your projects)
+#ifndef HELPER_CUDA_DRVAPI_H
+#define HELPER_CUDA_DRVAPI_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <helper_string.h>
+#include <drvapi_error_string.h>
+
+#ifndef MAX
+#define MAX(a,b) (a > b ? a : b)
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// These are CUDA Helper functions
+
+// add a level of protection to the CUDA SDK samples, let's force samples to explicitly include CUDA.H
+#ifdef  __cuda_cuda_h__
+// This will output the proper CUDA error strings in the event that a CUDA host call returns an error
+#ifndef checkCudaErrors
+#define checkCudaErrors(err)  __checkCudaErrors (err, __FILE__, __LINE__)
+
+// These are the inline versions for all of the SDK helper functions
+inline void __checkCudaErrors(CUresult err, const char *file, const int line)
+{
+    if (CUDA_SUCCESS != err)
+    {
+        fprintf(stderr, "checkCudaErrors() Driver API error = %04d \"%s\" from file <%s>, line %i.\n",
+                err, getCudaDrvErrorString(err), file, line);
+        exit(EXIT_FAILURE);
+    }
+}
+#endif
+
+#ifdef getLastCudaDrvErrorMsg
+#undef getLastCudaDrvErrorMsg
+#endif
+
+#define getLastCudaDrvErrorMsg(msg)           __getLastCudaDrvErrorMsg  (msg, __FILE__, __LINE__)
+
+inline void __getLastCudaDrvErrorMsg(const char *msg, const char *file, const int line)
+{
+    CUresult err = cuCtxSynchronize();
+
+    if (CUDA_SUCCESS != err)
+    {
+        fprintf(stderr, "getLastCudaDrvErrorMsg -> %s", msg);
+        fprintf(stderr, "getLastCudaDrvErrorMsg -> cuCtxSynchronize API error = %04d \"%s\" in file <%s>, line %i.\n",
+                err, getCudaDrvErrorString(err), file, line);
+        exit(EXIT_FAILURE);
+    }
+}
+
+// This function wraps the CUDA Driver API into a template function
+template <class T>
+inline void getCudaAttribute(T *attribute, CUdevice_attribute device_attribute, int device)
+{
+    CUresult error_result = cuDeviceGetAttribute(attribute, device_attribute, device);
+
+    if (error_result != CUDA_SUCCESS)
+    {
+        printf("cuDeviceGetAttribute returned %d\n-> %s\n", (int)error_result, getCudaDrvErrorString(error_result));
+        exit(EXIT_SUCCESS);
+    }
+}
+#endif
+
+// Beginning of GPU Architecture definitions
+inline int _ConvertSMVer2CoresDRV(int major, int minor)
+{
+    // Defines for GPU Architecture types (using the SM version to determine the # of cores per SM
+    typedef struct
+    {
+        int SM; // 0xMm (hexidecimal notation), M = SM Major version, and m = SM minor version
+        int Cores;
+    } sSMtoCores;
+
+    sSMtoCores nGpuArchCoresPerSM[] =
+    {
+        { 0x10,  8 }, // Tesla Generation (SM 1.0) G80 class
+        { 0x11,  8 }, // Tesla Generation (SM 1.1) G8x class
+        { 0x12,  8 }, // Tesla Generation (SM 1.2) G9x class
+        { 0x13,  8 }, // Tesla Generation (SM 1.3) GT200 class
+        { 0x20, 32 }, // Fermi Generation (SM 2.0) GF100 class
+        { 0x21, 48 }, // Fermi Generation (SM 2.1) GF10x class
+        { 0x30, 192}, // Kepler Generation (SM 3.0) GK10x class
+        { 0x35, 192}, // Kepler Generation (SM 3.5) GK11x class
+        {   -1, -1 }
+    };
+
+    int index = 0;
+
+    while (nGpuArchCoresPerSM[index].SM != -1)
+    {
+        if (nGpuArchCoresPerSM[index].SM == ((major << 4) + minor))
+        {
+            return nGpuArchCoresPerSM[index].Cores;
+        }
+
+        index++;
+    }
+
+    // If we don't find the values, we default use the previous one to run properly
+    printf("MapSMtoCores for SM %d.%d is undefined.  Default to use %d Cores/SM\n", major, minor, nGpuArchCoresPerSM[7].Cores);
+    return nGpuArchCoresPerSM[7].Cores;
+}
+// end of GPU Architecture definitions
+
+#ifdef __cuda_cuda_h__
+// General GPU Device CUDA Initialization
+inline int gpuDeviceInitDRV(int ARGC, const char **ARGV)
+{
+    int cuDevice = 0;
+    int deviceCount = 0;
+    CUresult err = cuInit(0);
+
+    if (CUDA_SUCCESS == err)
+    {
+        checkCudaErrors(cuDeviceGetCount(&deviceCount));
+    }
+
+    if (deviceCount == 0)
+    {
+        fprintf(stderr, "cudaDeviceInit error: no devices supporting CUDA\n");
+        exit(EXIT_FAILURE);
+    }
+
+    int dev = 0;
+    dev = getCmdLineArgumentInt(ARGC, (const char **) ARGV, "device=");
+
+    if (dev < 0)
+    {
+        dev = 0;
+    }
+
+    if (dev > deviceCount-1)
+    {
+        fprintf(stderr, "\n");
+        fprintf(stderr, ">> %d CUDA capable GPU device(s) detected. <<\n", deviceCount);
+        fprintf(stderr, ">> cudaDeviceInit (-device=%d) is not a valid GPU device. <<\n", dev);
+        fprintf(stderr, "\n");
+        return -dev;
+    }
+
+    checkCudaErrors(cuDeviceGet(&cuDevice, dev));
+    char name[100];
+    cuDeviceGetName(name, 100, cuDevice);
+
+    int computeMode;
+    getCudaAttribute<int>(&computeMode, CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, dev);
+
+    if (computeMode == CU_COMPUTEMODE_PROHIBITED)
+    {
+        fprintf(stderr, "Error: device is running in <CU_COMPUTEMODE_PROHIBITED>, no threads can use this CUDA Device.\n");
+        return -1;
+    }
+
+    if (checkCmdLineFlag(ARGC, (const char **) ARGV, "quiet") == false)
+    {
+        printf("gpuDeviceInitDRV() Using CUDA Device [%d]: %s\n", dev, name);
+    }
+
+    return dev;
+}
+
+// This function returns the best GPU based on performance
+inline int gpuGetMaxGflopsDeviceIdDRV()
+{
+    CUdevice current_device = 0, max_perf_device = 0;
+    int device_count        = 0, sm_per_multiproc = 0;
+    int max_compute_perf    = 0, best_SM_arch     = 0;
+    int major = 0, minor = 0   , multiProcessorCount, clockRate;
+
+    cuInit(0);
+    checkCudaErrors(cuDeviceGetCount(&device_count));
+
+    // Find the best major SM Architecture GPU device
+    while (current_device < device_count)
+    {
+        checkCudaErrors(cuDeviceComputeCapability(&major, &minor, current_device));
+
+        if (major > 0 && major < 9999)
+        {
+            best_SM_arch = MAX(best_SM_arch, major);
+        }
+
+        current_device++;
+    }
+
+    // Find the best CUDA capable GPU device
+    current_device = 0;
+
+    while (current_device < device_count)
+    {
+        checkCudaErrors(cuDeviceGetAttribute(&multiProcessorCount,
+                                             CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT,
+                                             current_device));
+        checkCudaErrors(cuDeviceGetAttribute(&clockRate,
+                                             CU_DEVICE_ATTRIBUTE_CLOCK_RATE,
+                                             current_device));
+        checkCudaErrors(cuDeviceComputeCapability(&major, &minor, current_device));
+
+        int computeMode;
+        getCudaAttribute<int>(&computeMode, CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, current_device);
+
+        if (computeMode != CU_COMPUTEMODE_PROHIBITED)
+        {
+            if (major == 9999 && minor == 9999)
+            {
+                sm_per_multiproc = 1;
+            }
+            else
+            {
+                sm_per_multiproc = _ConvertSMVer2CoresDRV(major, minor);
+            }
+
+            int compute_perf  = multiProcessorCount * sm_per_multiproc * clockRate;
+
+            if (compute_perf  > max_compute_perf)
+            {
+                // If we find GPU with SM major > 2, search only these
+                if (best_SM_arch > 2)
+                {
+                    // If our device==dest_SM_arch, choose this, or else pass
+                    if (major == best_SM_arch)
+                    {
+                        max_compute_perf  = compute_perf;
+                        max_perf_device   = current_device;
+                    }
+                }
+                else
+                {
+                    max_compute_perf  = compute_perf;
+                    max_perf_device   = current_device;
+                }
+            }
+        }
+
+        ++current_device;
+    }
+
+    return max_perf_device;
+}
+
+// This function returns the best Graphics GPU based on performance
+inline int gpuGetMaxGflopsGLDeviceIdDRV()
+{
+    CUdevice current_device = 0, max_perf_device = 0;
+    int device_count     = 0, sm_per_multiproc = 0;
+    int max_compute_perf = 0, best_SM_arch     = 0;
+    int major = 0, minor = 0, multiProcessorCount, clockRate;
+    int bTCC = 0;
+    char deviceName[256];
+
+    cuInit(0);
+    checkCudaErrors(cuDeviceGetCount(&device_count));
+
+    // Find the best major SM Architecture GPU device that are graphics devices
+    while (current_device < device_count)
+    {
+        checkCudaErrors(cuDeviceGetName(deviceName, 256, current_device));
+        checkCudaErrors(cuDeviceComputeCapability(&major, &minor, current_device));
+
+#if CUDA_VERSION >= 3020
+        checkCudaErrors(cuDeviceGetAttribute(&bTCC,  CU_DEVICE_ATTRIBUTE_TCC_DRIVER, current_device));
+#else
+
+        // Assume a Tesla GPU is running in TCC if we are running CUDA 3.1
+        if (deviceName[0] == 'T')
+        {
+            bTCC = 1;
+        }
+
+#endif
+
+        int computeMode;
+        getCudaAttribute<int>(&computeMode, CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, current_device);
+
+        if (computeMode != CU_COMPUTEMODE_PROHIBITED)
+        {
+            if (!bTCC)
+            {
+                if (major > 0 && major < 9999)
+                {
+                    best_SM_arch = MAX(best_SM_arch, major);
+                }
+            }
+        }
+
+        current_device++;
+    }
+
+    // Find the best CUDA capable GPU device
+    current_device = 0;
+
+    while (current_device < device_count)
+    {
+        checkCudaErrors(cuDeviceGetAttribute(&multiProcessorCount,
+                                             CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT,
+                                             current_device));
+        checkCudaErrors(cuDeviceGetAttribute(&clockRate,
+                                             CU_DEVICE_ATTRIBUTE_CLOCK_RATE,
+                                             current_device));
+        checkCudaErrors(cuDeviceComputeCapability(&major, &minor, current_device));
+
+#if CUDA_VERSION >= 3020
+        checkCudaErrors(cuDeviceGetAttribute(&bTCC,  CU_DEVICE_ATTRIBUTE_TCC_DRIVER, current_device));
+#else
+
+        // Assume a Tesla GPU is running in TCC if we are running CUDA 3.1
+        if (deviceName[0] == 'T')
+        {
+            bTCC = 1;
+        }
+
+#endif
+
+        int computeMode;
+        getCudaAttribute<int>(&computeMode, CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, current_device);
+
+        if (computeMode != CU_COMPUTEMODE_PROHIBITED)
+        {
+            if (major == 9999 && minor == 9999)
+            {
+                sm_per_multiproc = 1;
+            }
+            else
+            {
+                sm_per_multiproc = _ConvertSMVer2CoresDRV(major, minor);
+            }
+
+            // If this is a Tesla based GPU and SM 2.0, and TCC is disabled, this is a contendor
+            if (!bTCC)   // Is this GPU running the TCC driver?  If so we pass on this
+            {
+                int compute_perf  = multiProcessorCount * sm_per_multiproc * clockRate;
+
+                if (compute_perf  > max_compute_perf)
+                {
+                    // If we find GPU with SM major > 2, search only these
+                    if (best_SM_arch > 2)
+                    {
+                        // If our device = dest_SM_arch, then we pick this one
+                        if (major == best_SM_arch)
+                        {
+                            max_compute_perf  = compute_perf;
+                            max_perf_device   = current_device;
+                        }
+                    }
+                    else
+                    {
+                        max_compute_perf  = compute_perf;
+                        max_perf_device   = current_device;
+                    }
+                }
+            }
+        }
+
+        ++current_device;
+    }
+
+    return max_perf_device;
+}
+
+// General initialization call to pick the best CUDA Device
+inline CUdevice findCudaDeviceDRV(int argc, const char **argv)
+{
+    CUdevice cuDevice;
+    int devID = 0;
+
+    // If the command-line has a device number specified, use it
+    if (checkCmdLineFlag(argc, (const char **)argv, "device"))
+    {
+        devID = gpuDeviceInitDRV(argc, argv);
+
+        if (devID < 0)
+        {
+            printf("exiting...\n");
+            exit(EXIT_SUCCESS);
+        }
+    }
+    else
+    {
+        // Otherwise pick the device with highest Gflops/s
+        char name[100];
+        devID = gpuGetMaxGflopsDeviceIdDRV();
+        checkCudaErrors(cuDeviceGet(&cuDevice, devID));
+        cuDeviceGetName(name, 100, cuDevice);
+        printf("> Using CUDA Device [%d]: %s\n", devID, name);
+    }
+
+    cuDeviceGet(&cuDevice, devID);
+
+    return cuDevice;
+}
+
+// This function will pick the best CUDA device available with OpenGL interop
+inline CUdevice findCudaGLDeviceDRV(int argc, const char **argv)
+{
+    CUdevice cuDevice;
+    int devID = 0;
+
+    // If the command-line has a device number specified, use it
+    if (checkCmdLineFlag(argc, (const char **)argv, "device"))
+    {
+        devID = gpuDeviceInitDRV(argc, (const char **)argv);
+
+        if (devID < 0)
+        {
+            printf("no CUDA capable devices found, exiting...\n");
+            exit(EXIT_SUCCESS);
+        }
+    }
+    else
+    {
+        char name[100];
+        // Otherwise pick the device with highest Gflops/s
+        devID = gpuGetMaxGflopsGLDeviceIdDRV();
+        checkCudaErrors(cuDeviceGet(&cuDevice, devID));
+        cuDeviceGetName(name, 100, cuDevice);
+        printf("> Using CUDA/GL Device [%d]: %s\n", devID, name);
+    }
+
+    return devID;
+}
+
+// General check for CUDA GPU SM Capabilities
+inline bool checkCudaCapabilitiesDRV(int major_version, int minor_version, int devID)
+{
+    CUdevice cuDevice;
+    char name[256];
+    int major = 0, minor = 0;
+
+    checkCudaErrors(cuDeviceGet(&cuDevice, devID));
+    checkCudaErrors(cuDeviceGetName(name, 100, cuDevice));
+    checkCudaErrors(cuDeviceComputeCapability(&major, &minor, devID));
+
+    if ((major > major_version) ||
+        (major == major_version && minor >= minor_version))
+    {
+        printf("> Device %d: <%16s >, Compute SM %d.%d detected\n", devID, name, major, minor);
+        return true;
+    }
+    else
+    {
+        printf("No GPU device was found that can support CUDA compute capability %d.%d.\n", major_version, minor_version);
+        return false;
+    }
+}
+#endif
+
+// end of CUDA Helper Functions
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/helper_cuda_gl.h gpu-rodinia_new/cuda/cfd/common/inc/helper_cuda_gl.h
--- gpu-rodinia/cuda/cfd/common/inc/helper_cuda_gl.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/helper_cuda_gl.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,151 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+#ifndef HELPER_CUDA_GL_H
+#define HELPER_CUDA_GL_H
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+// includes, graphics
+#if defined (__APPLE__) || defined(MACOSX)
+#include <OpenGL/gl.h>
+#include <OpenGL/glu.h>
+#else
+#include <GL/gl.h>
+#include <GL/glu.h>
+#endif
+
+#ifdef __CUDA_GL_INTEROP_H__
+////////////////////////////////////////////////////////////////////////////////
+// These are CUDA OpenGL Helper functions
+
+inline int gpuGLDeviceInit(int ARGC, const char **ARGV)
+{
+    int deviceCount;
+    checkCudaErrors(cudaGetDeviceCount(&deviceCount));
+
+    if (deviceCount == 0)
+    {
+        fprintf(stderr, "CUDA error: no devices supporting CUDA.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    int dev = 0;
+    dev = getCmdLineArgumentInt(ARGC, ARGV, "device=");
+
+    if (dev < 0)
+    {
+        dev = 0;
+    }
+
+    if (dev > deviceCount-1)
+    {
+        fprintf(stderr, "\n");
+        fprintf(stderr, ">> %d CUDA capable GPU device(s) detected. <<\n", deviceCount);
+        fprintf(stderr, ">> gpuGLDeviceInit (-device=%d) is not a valid GPU device. <<\n", dev);
+        fprintf(stderr, "\n");
+        return -dev;
+    }
+
+    cudaDeviceProp deviceProp;
+    checkCudaErrors(cudaGetDeviceProperties(&deviceProp, dev));
+
+    if (deviceProp.computeMode == cudaComputeModeProhibited)
+    {
+        fprintf(stderr, "Error: device is running in <Compute Mode Prohibited>, no threads can use ::cudaSetDevice().\n");
+        return -1;
+    }
+
+    if (deviceProp.major < 1)
+    {
+        fprintf(stderr, "Error: device does not support CUDA.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    if (checkCmdLineFlag(ARGC, ARGV, "quiet") == false)
+    {
+        fprintf(stderr, "Using device %d: %s\n", dev, deviceProp.name);
+    }
+
+    checkCudaErrors(cudaGLSetGLDevice(dev));
+    return dev;
+}
+
+// This function will pick the best CUDA device available with OpenGL interop
+inline int findCudaGLDevice(int argc, const char **argv)
+{
+    int devID = 0;
+
+    // If the command-line has a device number specified, use it
+    if (checkCmdLineFlag(argc, (const char **)argv, "device"))
+    {
+        devID = gpuGLDeviceInit(argc, (const char **)argv);
+
+        if (devID < 0)
+        {
+            printf("no CUDA capable devices found, exiting...\n");
+            cudaDeviceReset();
+            exit(EXIT_SUCCESS);
+        }
+    }
+    else
+    {
+        // Otherwise pick the device with highest Gflops/s
+        devID = gpuGetMaxGflopsDeviceId();
+        cudaGLSetGLDevice(devID);
+    }
+
+    return devID;
+}
+
+////////////////////////////////////////////////////////////////////////////
+//! Check for OpenGL error
+//! @return bool if no GL error has been encountered, otherwise 0
+//! @param file  __FILE__ macro
+//! @param line  __LINE__ macro
+//! @note The GL error is listed on stderr
+//! @note This function should be used via the CHECK_ERROR_GL() macro
+////////////////////////////////////////////////////////////////////////////
+inline bool
+sdkCheckErrorGL(const char *file, const int line)
+{
+    bool ret_val = true;
+
+    // check for error
+    GLenum gl_error = glGetError();
+
+    if (gl_error != GL_NO_ERROR)
+    {
+#ifdef _WIN32
+        char tmpStr[512];
+        // NOTE: "%s(%i) : " allows Visual Studio to directly jump to the file at the right line
+        // when the user double clicks on the error line in the Output pane. Like any compile error.
+        sprintf_s(tmpStr, 255, "\n%s(%i) : GL Error : %s\n\n", file, line, gluErrorString(gl_error));
+        fprintf(stderr, "%s", tmpStr);
+#endif
+        fprintf(stderr, "GL Error in file '%s' in line %d :\n", file, line);
+        fprintf(stderr, "%s\n", gluErrorString(gl_error));
+        ret_val = false;
+    }
+
+    return ret_val;
+}
+
+#define SDK_CHECK_ERROR_GL()                                              \
+    if( false == sdkCheckErrorGL( __FILE__, __LINE__)) {                  \
+        exit(EXIT_FAILURE);                                               \
+    }
+
+#endif
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/helper_cuda.h gpu-rodinia_new/cuda/cfd/common/inc/helper_cuda.h
--- gpu-rodinia/cuda/cfd/common/inc/helper_cuda.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/helper_cuda.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,966 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+////////////////////////////////////////////////////////////////////////////////
+// These are CUDA Helper functions for initialization and error checking
+
+#ifndef HELPER_CUDA_H
+#define HELPER_CUDA_H
+
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <helper_string.h>
+
+//#include <string>
+//#include <iostream>
+//#include <sstream>
+
+// Note, it is required that your SDK sample to include the proper header files, please
+// refer the CUDA examples for examples of the needed CUDA headers, which may change depending
+// on which CUDA functions are used.
+
+// CUDA Runtime error messages
+#ifdef __DRIVER_TYPES_H__
+static const char *_cudaGetErrorEnum(cudaError_t error)
+{
+    switch (error)
+    {
+        case cudaSuccess:
+            return "cudaSuccess";
+
+        case cudaErrorMissingConfiguration:
+            return "cudaErrorMissingConfiguration";
+
+        case cudaErrorMemoryAllocation:
+            return "cudaErrorMemoryAllocation";
+
+        case cudaErrorInitializationError:
+            return "cudaErrorInitializationError";
+
+        case cudaErrorLaunchFailure:
+            return "cudaErrorLaunchFailure";
+
+        case cudaErrorPriorLaunchFailure:
+            return "cudaErrorPriorLaunchFailure";
+
+        case cudaErrorLaunchTimeout:
+            return "cudaErrorLaunchTimeout";
+
+        case cudaErrorLaunchOutOfResources:
+            return "cudaErrorLaunchOutOfResources";
+
+        case cudaErrorInvalidDeviceFunction:
+            return "cudaErrorInvalidDeviceFunction";
+
+        case cudaErrorInvalidConfiguration:
+            return "cudaErrorInvalidConfiguration";
+
+        case cudaErrorInvalidDevice:
+            return "cudaErrorInvalidDevice";
+
+        case cudaErrorInvalidValue:
+            return "cudaErrorInvalidValue";
+
+        case cudaErrorInvalidPitchValue:
+            return "cudaErrorInvalidPitchValue";
+
+        case cudaErrorInvalidSymbol:
+            return "cudaErrorInvalidSymbol";
+
+        case cudaErrorMapBufferObjectFailed:
+            return "cudaErrorMapBufferObjectFailed";
+
+        case cudaErrorUnmapBufferObjectFailed:
+            return "cudaErrorUnmapBufferObjectFailed";
+
+        case cudaErrorInvalidHostPointer:
+            return "cudaErrorInvalidHostPointer";
+
+        case cudaErrorInvalidDevicePointer:
+            return "cudaErrorInvalidDevicePointer";
+
+        case cudaErrorInvalidTexture:
+            return "cudaErrorInvalidTexture";
+
+        case cudaErrorInvalidTextureBinding:
+            return "cudaErrorInvalidTextureBinding";
+
+        case cudaErrorInvalidChannelDescriptor:
+            return "cudaErrorInvalidChannelDescriptor";
+
+        case cudaErrorInvalidMemcpyDirection:
+            return "cudaErrorInvalidMemcpyDirection";
+
+        case cudaErrorAddressOfConstant:
+            return "cudaErrorAddressOfConstant";
+
+        case cudaErrorTextureFetchFailed:
+            return "cudaErrorTextureFetchFailed";
+
+        case cudaErrorTextureNotBound:
+            return "cudaErrorTextureNotBound";
+
+        case cudaErrorSynchronizationError:
+            return "cudaErrorSynchronizationError";
+
+        case cudaErrorInvalidFilterSetting:
+            return "cudaErrorInvalidFilterSetting";
+
+        case cudaErrorInvalidNormSetting:
+            return "cudaErrorInvalidNormSetting";
+
+        case cudaErrorMixedDeviceExecution:
+            return "cudaErrorMixedDeviceExecution";
+
+        case cudaErrorCudartUnloading:
+            return "cudaErrorCudartUnloading";
+
+        case cudaErrorUnknown:
+            return "cudaErrorUnknown";
+
+        case cudaErrorNotYetImplemented:
+            return "cudaErrorNotYetImplemented";
+
+        case cudaErrorMemoryValueTooLarge:
+            return "cudaErrorMemoryValueTooLarge";
+
+        case cudaErrorInvalidResourceHandle:
+            return "cudaErrorInvalidResourceHandle";
+
+        case cudaErrorNotReady:
+            return "cudaErrorNotReady";
+
+        case cudaErrorInsufficientDriver:
+            return "cudaErrorInsufficientDriver";
+
+        case cudaErrorSetOnActiveProcess:
+            return "cudaErrorSetOnActiveProcess";
+
+        case cudaErrorInvalidSurface:
+            return "cudaErrorInvalidSurface";
+
+        case cudaErrorNoDevice:
+            return "cudaErrorNoDevice";
+
+        case cudaErrorECCUncorrectable:
+            return "cudaErrorECCUncorrectable";
+
+        case cudaErrorSharedObjectSymbolNotFound:
+            return "cudaErrorSharedObjectSymbolNotFound";
+
+        case cudaErrorSharedObjectInitFailed:
+            return "cudaErrorSharedObjectInitFailed";
+
+        case cudaErrorUnsupportedLimit:
+            return "cudaErrorUnsupportedLimit";
+
+        case cudaErrorDuplicateVariableName:
+            return "cudaErrorDuplicateVariableName";
+
+        case cudaErrorDuplicateTextureName:
+            return "cudaErrorDuplicateTextureName";
+
+        case cudaErrorDuplicateSurfaceName:
+            return "cudaErrorDuplicateSurfaceName";
+
+        case cudaErrorDevicesUnavailable:
+            return "cudaErrorDevicesUnavailable";
+
+        case cudaErrorInvalidKernelImage:
+            return "cudaErrorInvalidKernelImage";
+
+        case cudaErrorNoKernelImageForDevice:
+            return "cudaErrorNoKernelImageForDevice";
+
+        case cudaErrorIncompatibleDriverContext:
+            return "cudaErrorIncompatibleDriverContext";
+
+        case cudaErrorPeerAccessAlreadyEnabled:
+            return "cudaErrorPeerAccessAlreadyEnabled";
+
+        case cudaErrorPeerAccessNotEnabled:
+            return "cudaErrorPeerAccessNotEnabled";
+
+        case cudaErrorDeviceAlreadyInUse:
+            return "cudaErrorDeviceAlreadyInUse";
+
+        case cudaErrorProfilerDisabled:
+            return "cudaErrorProfilerDisabled";
+
+        case cudaErrorProfilerNotInitialized:
+            return "cudaErrorProfilerNotInitialized";
+
+        case cudaErrorProfilerAlreadyStarted:
+            return "cudaErrorProfilerAlreadyStarted";
+
+        case cudaErrorProfilerAlreadyStopped:
+            return "cudaErrorProfilerAlreadyStopped";
+
+#if __CUDA_API_VERSION >= 0x4000
+
+        case cudaErrorAssert:
+            return "cudaErrorAssert";
+
+        case cudaErrorTooManyPeers:
+            return "cudaErrorTooManyPeers";
+
+        case cudaErrorHostMemoryAlreadyRegistered:
+            return "cudaErrorHostMemoryAlreadyRegistered";
+
+        case cudaErrorHostMemoryNotRegistered:
+            return "cudaErrorHostMemoryNotRegistered";
+#endif
+
+        case cudaErrorStartupFailure:
+            return "cudaErrorStartupFailure";
+
+        case cudaErrorApiFailureBase:
+            return "cudaErrorApiFailureBase";
+    }
+
+    return "<unknown>";
+}
+#endif
+
+#ifdef __cuda_cuda_h__
+// CUDA Driver API errors
+static const char *_cudaGetErrorEnum(CUresult error)
+{
+    switch (error)
+    {
+        case CUDA_SUCCESS:
+            return "CUDA_SUCCESS";
+
+        case CUDA_ERROR_INVALID_VALUE:
+            return "CUDA_ERROR_INVALID_VALUE";
+
+        case CUDA_ERROR_OUT_OF_MEMORY:
+            return "CUDA_ERROR_OUT_OF_MEMORY";
+
+        case CUDA_ERROR_NOT_INITIALIZED:
+            return "CUDA_ERROR_NOT_INITIALIZED";
+
+        case CUDA_ERROR_DEINITIALIZED:
+            return "CUDA_ERROR_DEINITIALIZED";
+
+        case CUDA_ERROR_PROFILER_DISABLED:
+            return "CUDA_ERROR_PROFILER_DISABLED";
+
+        case CUDA_ERROR_PROFILER_NOT_INITIALIZED:
+            return "CUDA_ERROR_PROFILER_NOT_INITIALIZED";
+
+        case CUDA_ERROR_PROFILER_ALREADY_STARTED:
+            return "CUDA_ERROR_PROFILER_ALREADY_STARTED";
+
+        case CUDA_ERROR_PROFILER_ALREADY_STOPPED:
+            return "CUDA_ERROR_PROFILER_ALREADY_STOPPED";
+
+        case CUDA_ERROR_NO_DEVICE:
+            return "CUDA_ERROR_NO_DEVICE";
+
+        case CUDA_ERROR_INVALID_DEVICE:
+            return "CUDA_ERROR_INVALID_DEVICE";
+
+        case CUDA_ERROR_INVALID_IMAGE:
+            return "CUDA_ERROR_INVALID_IMAGE";
+
+        case CUDA_ERROR_INVALID_CONTEXT:
+            return "CUDA_ERROR_INVALID_CONTEXT";
+
+        case CUDA_ERROR_CONTEXT_ALREADY_CURRENT:
+            return "CUDA_ERROR_CONTEXT_ALREADY_CURRENT";
+
+        case CUDA_ERROR_MAP_FAILED:
+            return "CUDA_ERROR_MAP_FAILED";
+
+        case CUDA_ERROR_UNMAP_FAILED:
+            return "CUDA_ERROR_UNMAP_FAILED";
+
+        case CUDA_ERROR_ARRAY_IS_MAPPED:
+            return "CUDA_ERROR_ARRAY_IS_MAPPED";
+
+        case CUDA_ERROR_ALREADY_MAPPED:
+            return "CUDA_ERROR_ALREADY_MAPPED";
+
+        case CUDA_ERROR_NO_BINARY_FOR_GPU:
+            return "CUDA_ERROR_NO_BINARY_FOR_GPU";
+
+        case CUDA_ERROR_ALREADY_ACQUIRED:
+            return "CUDA_ERROR_ALREADY_ACQUIRED";
+
+        case CUDA_ERROR_NOT_MAPPED:
+            return "CUDA_ERROR_NOT_MAPPED";
+
+        case CUDA_ERROR_NOT_MAPPED_AS_ARRAY:
+            return "CUDA_ERROR_NOT_MAPPED_AS_ARRAY";
+
+        case CUDA_ERROR_NOT_MAPPED_AS_POINTER:
+            return "CUDA_ERROR_NOT_MAPPED_AS_POINTER";
+
+        case CUDA_ERROR_ECC_UNCORRECTABLE:
+            return "CUDA_ERROR_ECC_UNCORRECTABLE";
+
+        case CUDA_ERROR_UNSUPPORTED_LIMIT:
+            return "CUDA_ERROR_UNSUPPORTED_LIMIT";
+
+        case CUDA_ERROR_CONTEXT_ALREADY_IN_USE:
+            return "CUDA_ERROR_CONTEXT_ALREADY_IN_USE";
+
+        case CUDA_ERROR_INVALID_SOURCE:
+            return "CUDA_ERROR_INVALID_SOURCE";
+
+        case CUDA_ERROR_FILE_NOT_FOUND:
+            return "CUDA_ERROR_FILE_NOT_FOUND";
+
+        case CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND:
+            return "CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND";
+
+        case CUDA_ERROR_SHARED_OBJECT_INIT_FAILED:
+            return "CUDA_ERROR_SHARED_OBJECT_INIT_FAILED";
+
+        case CUDA_ERROR_OPERATING_SYSTEM:
+            return "CUDA_ERROR_OPERATING_SYSTEM";
+
+        case CUDA_ERROR_INVALID_HANDLE:
+            return "CUDA_ERROR_INVALID_HANDLE";
+
+        case CUDA_ERROR_NOT_FOUND:
+            return "CUDA_ERROR_NOT_FOUND";
+
+        case CUDA_ERROR_NOT_READY:
+            return "CUDA_ERROR_NOT_READY";
+
+        case CUDA_ERROR_LAUNCH_FAILED:
+            return "CUDA_ERROR_LAUNCH_FAILED";
+
+        case CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES:
+            return "CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES";
+
+        case CUDA_ERROR_LAUNCH_TIMEOUT:
+            return "CUDA_ERROR_LAUNCH_TIMEOUT";
+
+        case CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING:
+            return "CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING";
+
+        case CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED:
+            return "CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED";
+
+        case CUDA_ERROR_PEER_ACCESS_NOT_ENABLED:
+            return "CUDA_ERROR_PEER_ACCESS_NOT_ENABLED";
+
+        case CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE:
+            return "CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE";
+
+        case CUDA_ERROR_CONTEXT_IS_DESTROYED:
+            return "CUDA_ERROR_CONTEXT_IS_DESTROYED";
+
+        case CUDA_ERROR_ASSERT:
+            return "CUDA_ERROR_ASSERT";
+
+        case CUDA_ERROR_TOO_MANY_PEERS:
+            return "CUDA_ERROR_TOO_MANY_PEERS";
+
+        case CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED:
+            return "CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED";
+
+        case CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED:
+            return "CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED";
+
+        case CUDA_ERROR_UNKNOWN:
+            return "CUDA_ERROR_UNKNOWN";
+    }
+
+    return "<unknown>";
+}
+#endif
+
+#ifdef CUBLAS_API_H_
+// cuBLAS API errors
+static const char *_cudaGetErrorEnum(cublasStatus_t error)
+{
+    switch (error)
+    {
+        case CUBLAS_STATUS_SUCCESS:
+            return "CUBLAS_STATUS_SUCCESS";
+
+        case CUBLAS_STATUS_NOT_INITIALIZED:
+            return "CUBLAS_STATUS_NOT_INITIALIZED";
+
+        case CUBLAS_STATUS_ALLOC_FAILED:
+            return "CUBLAS_STATUS_ALLOC_FAILED";
+
+        case CUBLAS_STATUS_INVALID_VALUE:
+            return "CUBLAS_STATUS_INVALID_VALUE";
+
+        case CUBLAS_STATUS_ARCH_MISMATCH:
+            return "CUBLAS_STATUS_ARCH_MISMATCH";
+
+        case CUBLAS_STATUS_MAPPING_ERROR:
+            return "CUBLAS_STATUS_MAPPING_ERROR";
+
+        case CUBLAS_STATUS_EXECUTION_FAILED:
+            return "CUBLAS_STATUS_EXECUTION_FAILED";
+
+        case CUBLAS_STATUS_INTERNAL_ERROR:
+            return "CUBLAS_STATUS_INTERNAL_ERROR";
+    }
+
+    return "<unknown>";
+}
+#endif
+
+#ifdef _CUFFT_H_
+// cuFFT API errors
+static const char *_cudaGetErrorEnum(cufftResult error)
+{
+    switch (error)
+    {
+        case CUFFT_SUCCESS:
+            return "CUFFT_SUCCESS";
+
+        case CUFFT_INVALID_PLAN:
+            return "CUFFT_INVALID_PLAN";
+
+        case CUFFT_ALLOC_FAILED:
+            return "CUFFT_ALLOC_FAILED";
+
+        case CUFFT_INVALID_TYPE:
+            return "CUFFT_INVALID_TYPE";
+
+        case CUFFT_INVALID_VALUE:
+            return "CUFFT_INVALID_VALUE";
+
+        case CUFFT_INTERNAL_ERROR:
+            return "CUFFT_INTERNAL_ERROR";
+
+        case CUFFT_EXEC_FAILED:
+            return "CUFFT_EXEC_FAILED";
+
+        case CUFFT_SETUP_FAILED:
+            return "CUFFT_SETUP_FAILED";
+
+        case CUFFT_INVALID_SIZE:
+            return "CUFFT_INVALID_SIZE";
+
+        case CUFFT_UNALIGNED_DATA:
+            return "CUFFT_UNALIGNED_DATA";
+    }
+
+    return "<unknown>";
+}
+#endif
+
+
+#ifdef CUSPARSEAPI
+// cuSPARSE API errors
+static const char *_cudaGetErrorEnum(cusparseStatus_t error)
+{
+    switch (error)
+    {
+        case CUSPARSE_STATUS_SUCCESS:
+            return "CUSPARSE_STATUS_SUCCESS";
+
+        case CUSPARSE_STATUS_NOT_INITIALIZED:
+            return "CUSPARSE_STATUS_NOT_INITIALIZED";
+
+        case CUSPARSE_STATUS_ALLOC_FAILED:
+            return "CUSPARSE_STATUS_ALLOC_FAILED";
+
+        case CUSPARSE_STATUS_INVALID_VALUE:
+            return "CUSPARSE_STATUS_INVALID_VALUE";
+
+        case CUSPARSE_STATUS_ARCH_MISMATCH:
+            return "CUSPARSE_STATUS_ARCH_MISMATCH";
+
+        case CUSPARSE_STATUS_MAPPING_ERROR:
+            return "CUSPARSE_STATUS_MAPPING_ERROR";
+
+        case CUSPARSE_STATUS_EXECUTION_FAILED:
+            return "CUSPARSE_STATUS_EXECUTION_FAILED";
+
+        case CUSPARSE_STATUS_INTERNAL_ERROR:
+            return "CUSPARSE_STATUS_INTERNAL_ERROR";
+
+        case CUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED:
+            return "CUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED";
+    }
+
+    return "<unknown>";
+}
+#endif
+
+#ifdef CURAND_H_
+// cuRAND API errors
+static const char *_cudaGetErrorEnum(curandStatus_t error)
+{
+    switch (error)
+    {
+        case CURAND_STATUS_SUCCESS:
+            return "CURAND_STATUS_SUCCESS";
+
+        case CURAND_STATUS_VERSION_MISMATCH:
+            return "CURAND_STATUS_VERSION_MISMATCH";
+
+        case CURAND_STATUS_NOT_INITIALIZED:
+            return "CURAND_STATUS_NOT_INITIALIZED";
+
+        case CURAND_STATUS_ALLOCATION_FAILED:
+            return "CURAND_STATUS_ALLOCATION_FAILED";
+
+        case CURAND_STATUS_TYPE_ERROR:
+            return "CURAND_STATUS_TYPE_ERROR";
+
+        case CURAND_STATUS_OUT_OF_RANGE:
+            return "CURAND_STATUS_OUT_OF_RANGE";
+
+        case CURAND_STATUS_LENGTH_NOT_MULTIPLE:
+            return "CURAND_STATUS_LENGTH_NOT_MULTIPLE";
+
+        case CURAND_STATUS_DOUBLE_PRECISION_REQUIRED:
+            return "CURAND_STATUS_DOUBLE_PRECISION_REQUIRED";
+
+        case CURAND_STATUS_LAUNCH_FAILURE:
+            return "CURAND_STATUS_LAUNCH_FAILURE";
+
+        case CURAND_STATUS_PREEXISTING_FAILURE:
+            return "CURAND_STATUS_PREEXISTING_FAILURE";
+
+        case CURAND_STATUS_INITIALIZATION_FAILED:
+            return "CURAND_STATUS_INITIALIZATION_FAILED";
+
+        case CURAND_STATUS_ARCH_MISMATCH:
+            return "CURAND_STATUS_ARCH_MISMATCH";
+
+        case CURAND_STATUS_INTERNAL_ERROR:
+            return "CURAND_STATUS_INTERNAL_ERROR";
+    }
+
+    return "<unknown>";
+}
+#endif
+
+#ifdef NV_NPPIDEFS_H
+// NPP API errors
+static const char *_cudaGetErrorEnum(NppStatus error)
+{
+    switch (error)
+    {
+        case NPP_NOT_SUPPORTED_MODE_ERROR:
+            return "NPP_NOT_SUPPORTED_MODE_ERROR";
+
+        case NPP_ROUND_MODE_NOT_SUPPORTED_ERROR:
+            return "NPP_ROUND_MODE_NOT_SUPPORTED_ERROR";
+
+        case NPP_RESIZE_NO_OPERATION_ERROR:
+            return "NPP_RESIZE_NO_OPERATION_ERROR";
+
+        case NPP_NOT_SUFFICIENT_COMPUTE_CAPABILITY:
+            return "NPP_NOT_SUFFICIENT_COMPUTE_CAPABILITY";
+
+        case NPP_BAD_ARG_ERROR:
+            return "NPP_BAD_ARG_ERROR";
+
+        case NPP_LUT_NUMBER_OF_LEVELS_ERROR:
+            return "NPP_LUT_NUMBER_OF_LEVELS_ERROR";
+
+        case NPP_TEXTURE_BIND_ERROR:
+            return "NPP_TEXTURE_BIND_ERROR";
+
+        case NPP_COEFF_ERROR:
+            return "NPP_COEFF_ERROR";
+
+        case NPP_RECT_ERROR:
+            return "NPP_RECT_ERROR";
+
+        case NPP_QUAD_ERROR:
+            return "NPP_QUAD_ERROR";
+
+        case NPP_WRONG_INTERSECTION_ROI_ERROR:
+            return "NPP_WRONG_INTERSECTION_ROI_ERROR";
+
+        case NPP_NOT_EVEN_STEP_ERROR:
+            return "NPP_NOT_EVEN_STEP_ERROR";
+
+        case NPP_INTERPOLATION_ERROR:
+            return "NPP_INTERPOLATION_ERROR";
+
+        case NPP_RESIZE_FACTOR_ERROR:
+            return "NPP_RESIZE_FACTOR_ERROR";
+
+        case NPP_HAAR_CLASSIFIER_PIXEL_MATCH_ERROR:
+            return "NPP_HAAR_CLASSIFIER_PIXEL_MATCH_ERROR";
+
+        case NPP_MEMFREE_ERR:
+            return "NPP_MEMFREE_ERR";
+
+        case NPP_MEMSET_ERR:
+            return "NPP_MEMSET_ERR";
+
+        case NPP_MEMCPY_ERROR:
+            return "NPP_MEMCPY_ERROR";
+
+        case NPP_MEM_ALLOC_ERR:
+            return "NPP_MEM_ALLOC_ERR";
+
+        case NPP_HISTO_NUMBER_OF_LEVELS_ERROR:
+            return "NPP_HISTO_NUMBER_OF_LEVELS_ERROR";
+
+        case NPP_MIRROR_FLIP_ERR:
+            return "NPP_MIRROR_FLIP_ERR";
+
+        case NPP_INVALID_INPUT:
+            return "NPP_INVALID_INPUT";
+
+        case NPP_ALIGNMENT_ERROR:
+            return "NPP_ALIGNMENT_ERROR";
+
+        case NPP_STEP_ERROR:
+            return "NPP_STEP_ERROR";
+
+        case NPP_SIZE_ERROR:
+            return "NPP_SIZE_ERROR";
+
+        case NPP_POINTER_ERROR:
+            return "NPP_POINTER_ERROR";
+
+        case NPP_NULL_POINTER_ERROR:
+            return "NPP_NULL_POINTER_ERROR";
+
+        case NPP_CUDA_KERNEL_EXECUTION_ERROR:
+            return "NPP_CUDA_KERNEL_EXECUTION_ERROR";
+
+        case NPP_NOT_IMPLEMENTED_ERROR:
+            return "NPP_NOT_IMPLEMENTED_ERROR";
+
+        case NPP_ERROR:
+            return "NPP_ERROR";
+
+        case NPP_SUCCESS:
+            return "NPP_SUCCESS";
+
+        case NPP_WARNING:
+            return "NPP_WARNING";
+
+        case NPP_WRONG_INTERSECTION_QUAD_WARNING:
+            return "NPP_WRONG_INTERSECTION_QUAD_WARNING";
+
+        case NPP_MISALIGNED_DST_ROI_WARNING:
+            return "NPP_MISALIGNED_DST_ROI_WARNING";
+
+        case NPP_AFFINE_QUAD_INCORRECT_WARNING:
+            return "NPP_AFFINE_QUAD_INCORRECT_WARNING";
+
+        case NPP_DOUBLE_SIZE_WARNING:
+            return "NPP_DOUBLE_SIZE_WARNING";
+
+        case NPP_ODD_ROI_WARNING:
+            return "NPP_ODD_ROI_WARNING";
+
+        case NPP_WRONG_INTERSECTION_ROI_WARNING:
+            return "NPP_WRONG_INTERSECTION_ROI_WARNING";
+    }
+
+    return "<unknown>";
+}
+#endif
+
+template< typename T >
+bool check(T result, char const *const func, const char *const file, int const line)
+{
+    if (result)
+    {
+        fprintf(stderr, "CUDA error at %s:%d code=%d(%s) \"%s\" \n",
+                file, line, static_cast<unsigned int>(result), _cudaGetErrorEnum(result), func);
+        /*
+                std::stringstream ss;
+                std::string msg("CUDA error at ");
+                msg += file;
+                msg += ":";
+                ss << line;
+                msg += ss.str();
+                msg += " code=";
+                ss << static_cast<unsigned int>(result);
+                msg += ss.str();
+                msg += " (";
+                msg += _cudaGetErrorEnum(result);
+                msg += ") \"";
+                msg += func;
+                msg += "\"";
+                //throw msg;
+                std::cerr  << msg <<"\n";
+        */
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+#ifdef __DRIVER_TYPES_H__
+// This will output the proper CUDA error strings in the event that a CUDA host call returns an error
+#define checkCudaErrors(val)           check ( (val), #val, __FILE__, __LINE__ )
+
+// This will output the proper error string when calling cudaGetLastError
+#define getLastCudaError(msg)      __getLastCudaError (msg, __FILE__, __LINE__)
+
+inline void __getLastCudaError(const char *errorMessage, const char *file, const int line)
+{
+    cudaError_t err = cudaGetLastError();
+
+    if (cudaSuccess != err)
+    {
+        fprintf(stderr, "%s(%i) : getLastCudaError() CUDA error : %s : (%d) %s.\n",
+                file, line, errorMessage, (int)err, cudaGetErrorString(err));
+        exit(EXIT_FAILURE);
+    }
+}
+#endif
+
+#ifndef MAX
+#define MAX(a,b) (a > b ? a : b)
+#endif
+
+// Beginning of GPU Architecture definitions
+inline int _ConvertSMVer2Cores(int major, int minor)
+{
+    // Defines for GPU Architecture types (using the SM version to determine the # of cores per SM
+    typedef struct
+    {
+        int SM; // 0xMm (hexidecimal notation), M = SM Major version, and m = SM minor version
+        int Cores;
+    } sSMtoCores;
+
+    sSMtoCores nGpuArchCoresPerSM[] =
+    {
+        { 0x10,  8 }, // Tesla Generation (SM 1.0) G80 class
+        { 0x11,  8 }, // Tesla Generation (SM 1.1) G8x class
+        { 0x12,  8 }, // Tesla Generation (SM 1.2) G9x class
+        { 0x13,  8 }, // Tesla Generation (SM 1.3) GT200 class
+        { 0x20, 32 }, // Fermi Generation (SM 2.0) GF100 class
+        { 0x21, 48 }, // Fermi Generation (SM 2.1) GF10x class
+        { 0x30, 192}, // Kepler Generation (SM 3.0) GK10x class
+        { 0x35, 192}, // Kepler Generation (SM 3.5) GK11x class
+        {   -1, -1 }
+    };
+
+    int index = 0;
+
+    while (nGpuArchCoresPerSM[index].SM != -1)
+    {
+        if (nGpuArchCoresPerSM[index].SM == ((major << 4) + minor))
+        {
+            return nGpuArchCoresPerSM[index].Cores;
+        }
+
+        index++;
+    }
+
+    // If we don't find the values, we default use the previous one to run properly
+    printf("MapSMtoCores for SM %d.%d is undefined.  Default to use %d Cores/SM\n", major, minor, nGpuArchCoresPerSM[7].Cores);
+    return nGpuArchCoresPerSM[7].Cores;
+}
+// end of GPU Architecture definitions
+
+#ifdef __CUDA_RUNTIME_H__
+// General GPU Device CUDA Initialization
+inline int gpuDeviceInit(int devID)
+{
+    int deviceCount;
+    checkCudaErrors(cudaGetDeviceCount(&deviceCount));
+
+    if (deviceCount == 0)
+    {
+        fprintf(stderr, "gpuDeviceInit() CUDA error: no devices supporting CUDA.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    if (devID < 0)
+    {
+        devID = 0;
+    }
+
+    if (devID > deviceCount-1)
+    {
+        fprintf(stderr, "\n");
+        fprintf(stderr, ">> %d CUDA capable GPU device(s) detected. <<\n", deviceCount);
+        fprintf(stderr, ">> gpuDeviceInit (-device=%d) is not a valid GPU device. <<\n", devID);
+        fprintf(stderr, "\n");
+        return -devID;
+    }
+
+    cudaDeviceProp deviceProp;
+    checkCudaErrors(cudaGetDeviceProperties(&deviceProp, devID));
+
+    if (deviceProp.computeMode == cudaComputeModeProhibited)
+    {
+        fprintf(stderr, "Error: device is running in <Compute Mode Prohibited>, no threads can use ::cudaSetDevice().\n");
+        return -1;
+    }
+
+    if (deviceProp.major < 1)
+    {
+        fprintf(stderr, "gpuDeviceInit(): GPU device does not support CUDA.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    checkCudaErrors(cudaSetDevice(devID));
+    printf("gpuDeviceInit() CUDA Device [%d]: \"%s\n", devID, deviceProp.name);
+
+    return devID;
+}
+
+// This function returns the best GPU (with maximum GFLOPS)
+inline int gpuGetMaxGflopsDeviceId()
+{
+    int current_device     = 0, sm_per_multiproc  = 0;
+    int max_compute_perf   = 0, max_perf_device   = 0;
+    int device_count       = 0, best_SM_arch      = 0;
+    cudaDeviceProp deviceProp;
+    cudaGetDeviceCount(&device_count);
+
+    // Find the best major SM Architecture GPU device
+    while (current_device < device_count)
+    {
+        cudaGetDeviceProperties(&deviceProp, current_device);
+
+        // If this GPU is not running on Compute Mode prohibited, then we can add it to the list
+        if (deviceProp.computeMode != cudaComputeModeProhibited)
+        {
+            if (deviceProp.major > 0 && deviceProp.major < 9999)
+            {
+                best_SM_arch = MAX(best_SM_arch, deviceProp.major);
+            }
+        }
+
+        current_device++;
+    }
+
+    // Find the best CUDA capable GPU device
+    current_device = 0;
+
+    while (current_device < device_count)
+    {
+        cudaGetDeviceProperties(&deviceProp, current_device);
+
+        // If this GPU is not running on Compute Mode prohibited, then we can add it to the list
+        if (deviceProp.computeMode != cudaComputeModeProhibited)
+        {
+            if (deviceProp.major == 9999 && deviceProp.minor == 9999)
+            {
+                sm_per_multiproc = 1;
+            }
+            else
+            {
+                sm_per_multiproc = _ConvertSMVer2Cores(deviceProp.major, deviceProp.minor);
+            }
+
+            int compute_perf  = deviceProp.multiProcessorCount * sm_per_multiproc * deviceProp.clockRate;
+
+            if (compute_perf  > max_compute_perf)
+            {
+                // If we find GPU with SM major > 2, search only these
+                if (best_SM_arch > 2)
+                {
+                    // If our device==dest_SM_arch, choose this, or else pass
+                    if (deviceProp.major == best_SM_arch)
+                    {
+                        max_compute_perf  = compute_perf;
+                        max_perf_device   = current_device;
+                    }
+                }
+                else
+                {
+                    max_compute_perf  = compute_perf;
+                    max_perf_device   = current_device;
+                }
+            }
+        }
+
+        ++current_device;
+    }
+
+    return max_perf_device;
+}
+
+
+// Initialization code to find the best CUDA Device
+inline int findCudaDevice(int argc, const char **argv)
+{
+    cudaDeviceProp deviceProp;
+    int devID = 0;
+
+    // If the command-line has a device number specified, use it
+    if (checkCmdLineFlag(argc, argv, "device"))
+    {
+        devID = getCmdLineArgumentInt(argc, argv, "device=");
+
+        if (devID < 0)
+        {
+            printf("Invalid command line parameter\n ");
+            exit(EXIT_FAILURE);
+        }
+        else
+        {
+            devID = gpuDeviceInit(devID);
+
+            if (devID < 0)
+            {
+                printf("exiting...\n");
+                exit(EXIT_FAILURE);
+            }
+        }
+    }
+    else
+    {
+        // Otherwise pick the device with highest Gflops/s
+        devID = gpuGetMaxGflopsDeviceId();
+        checkCudaErrors(cudaSetDevice(devID));
+        checkCudaErrors(cudaGetDeviceProperties(&deviceProp, devID));
+        printf("GPU Device %d: \"%s\" with compute capability %d.%d\n\n", devID, deviceProp.name, deviceProp.major, deviceProp.minor);
+    }
+
+    return devID;
+}
+
+// General check for CUDA GPU SM Capabilities
+inline bool checkCudaCapabilities(int major_version, int minor_version)
+{
+    cudaDeviceProp deviceProp;
+    deviceProp.major = 0;
+    deviceProp.minor = 0;
+    int dev;
+
+    checkCudaErrors(cudaGetDevice(&dev));
+    checkCudaErrors(cudaGetDeviceProperties(&deviceProp, dev));
+
+    if ((deviceProp.major > major_version) ||
+        (deviceProp.major == major_version && deviceProp.minor >= minor_version))
+    {
+        printf("> Device %d: <%16s >, Compute SM %d.%d detected\n", dev, deviceProp.name, deviceProp.major, deviceProp.minor);
+        return true;
+    }
+    else
+    {
+        printf("No GPU device was found that can support CUDA compute capability %d.%d.\n", major_version, minor_version);
+        return false;
+    }
+}
+#endif
+
+// end of CUDA Helper Functions
+
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/helper_functions.h gpu-rodinia_new/cuda/cfd/common/inc/helper_functions.h
--- gpu-rodinia/cuda/cfd/common/inc/helper_functions.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/helper_functions.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,38 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+// These are helper functions for the SDK samples (string parsing, timers, image helpers, etc)
+#ifndef HELPER_FUNCTIONS_H
+#define HELPER_FUNCTIONS_H
+
+#ifdef WIN32
+#pragma warning(disable:4996)
+#endif
+
+// includes, project
+#include <stdio.h>
+#include <stdlib.h>
+#include <string>
+#include <assert.h>
+#include <exception.h>
+#include <math.h>
+
+#include <fstream>
+#include <vector>
+#include <iostream>
+#include <algorithm>
+
+// includes, timer, string parsing, image helpers
+#include <helper_timer.h>   // helper functions for timers
+#include <helper_string.h>  // helper functions for string parsing
+#include <helper_image.h>   // helper functions for image compare, dump, data comparisons
+
+#endif //  HELPER_FUNCTIONS_H
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/helper_image.h gpu-rodinia_new/cuda/cfd/common/inc/helper_image.h
--- gpu-rodinia/cuda/cfd/common/inc/helper_image.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/helper_image.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,1103 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+// These are helper functions for the SDK samples (image,bitmap)
+#ifndef HELPER_IMAGE_H
+#define HELPER_IMAGE_H
+
+#include <string>
+#include <fstream>
+#include <vector>
+#include <iostream>
+#include <algorithm>
+
+#include <assert.h>
+#include <exception.h>
+#include <math.h>
+
+#ifndef MIN
+#define MIN(a,b) ((a < b) ? a : b)
+#endif
+#ifndef MAX
+#define MAX(a,b) ((a > b) ? a : b)
+#endif
+
+#include <helper_string.h>
+
+// namespace unnamed (internal)
+namespace
+{
+    //! size of PGM file header
+    const unsigned int PGMHeaderSize = 0x40;
+
+    // types
+
+    //! Data converter from unsigned char / unsigned byte to type T
+    template<class T>
+    struct ConverterFromUByte;
+
+    //! Data converter from unsigned char / unsigned byte
+    template<>
+    struct ConverterFromUByte<unsigned char>
+    {
+        //! Conversion operator
+        //! @return converted value
+        //! @param  val  value to convert
+        float operator()(const unsigned char &val)
+        {
+            return static_cast<unsigned char>(val);
+        }
+    };
+
+    //! Data converter from unsigned char / unsigned byte to float
+    template<>
+    struct ConverterFromUByte<float>
+    {
+        //! Conversion operator
+        //! @return converted value
+        //! @param  val  value to convert
+        float operator()(const unsigned char &val)
+        {
+            return static_cast<float>(val) / 255.0f;
+        }
+    };
+
+    //! Data converter from unsigned char / unsigned byte to type T
+    template<class T>
+    struct ConverterToUByte;
+
+    //! Data converter from unsigned char / unsigned byte to unsigned int
+    template<>
+    struct ConverterToUByte<unsigned char>
+    {
+        //! Conversion operator (essentially a passthru
+        //! @return converted value
+        //! @param  val  value to convert
+        unsigned char operator()(const unsigned char &val)
+        {
+            return val;
+        }
+    };
+
+    //! Data converter from unsigned char / unsigned byte to unsigned int
+    template<>
+    struct ConverterToUByte<float>
+    {
+        //! Conversion operator
+        //! @return converted value
+        //! @param  val  value to convert
+        unsigned char operator()(const float &val)
+        {
+            return static_cast<unsigned char>(val * 255.0f);
+        }
+    };
+}
+
+#ifdef _WIN32
+#ifndef FOPEN
+#define FOPEN(fHandle,filename,mode) fopen_s(&fHandle, filename, mode)
+#endif
+#ifndef FOPEN_FAIL
+#define FOPEN_FAIL(result) (result != 0)
+#endif
+#ifndef SSCANF
+#define SSCANF sscanf_s
+#endif
+#else
+#ifndef FOPEN
+#define FOPEN(fHandle,filename,mode) (fHandle = fopen(filename, mode))
+#endif
+#ifndef FOPEN_FAIL
+#define FOPEN_FAIL(result) (result == NULL)
+#endif
+#ifndef SSCANF
+#define SSCANF sscanf
+#endif
+#endif
+
+inline bool
+__loadPPM(const char *file, unsigned char **data,
+          unsigned int *w, unsigned int *h, unsigned int *channels)
+{
+    FILE *fp = NULL;
+
+    if (FOPEN_FAIL(FOPEN(fp, file, "rb")))
+    {
+        std::cerr << "__LoadPPM() : Failed to open file: " << file << std::endl;
+        return false;
+    }
+
+    // check header
+    char header[PGMHeaderSize];
+
+    if (fgets(header, PGMHeaderSize, fp) == NULL)
+    {
+        std::cerr << "__LoadPPM() : reading PGM header returned NULL" << std::endl;
+        return false;
+    }
+
+    if (strncmp(header, "P5", 2) == 0)
+    {
+        *channels = 1;
+    }
+    else if (strncmp(header, "P6", 2) == 0)
+    {
+        *channels = 3;
+    }
+    else
+    {
+        std::cerr << "__LoadPPM() : File is not a PPM or PGM image" << std::endl;
+        *channels = 0;
+        return false;
+    }
+
+    // parse header, read maxval, width and height
+    unsigned int width = 0;
+    unsigned int height = 0;
+    unsigned int maxval = 0;
+    unsigned int i = 0;
+
+    while (i < 3)
+    {
+        if (fgets(header, PGMHeaderSize, fp) == NULL)
+        {
+            std::cerr << "__LoadPPM() : reading PGM header returned NULL" << std::endl;
+            return false;
+        }
+
+        if (header[0] == '#')
+        {
+            continue;
+        }
+
+        if (i == 0)
+        {
+            i += SSCANF(header, "%u %u %u", &width, &height, &maxval);
+        }
+        else if (i == 1)
+        {
+            i += SSCANF(header, "%u %u", &height, &maxval);
+        }
+        else if (i == 2)
+        {
+            i += SSCANF(header, "%u", &maxval);
+        }
+    }
+
+    // check if given handle for the data is initialized
+    if (NULL != *data)
+    {
+        if (*w != width || *h != height)
+        {
+            std::cerr << "__LoadPPM() : Invalid image dimensions." << std::endl;
+        }
+    }
+    else
+    {
+        *data = (unsigned char *) malloc(sizeof(unsigned char) * width * height * *channels);
+        *w = width;
+        *h = height;
+    }
+
+    // read and close file
+    if (fread(*data, sizeof(unsigned char), width * height * *channels, fp) == 0)
+    {
+        std::cerr << "__LoadPPM() read data returned error." << std::endl;
+    }
+
+    fclose(fp);
+
+    return true;
+}
+
+template <class T>
+inline bool
+sdkLoadPGM(const char *file, T **data, unsigned int *w, unsigned int *h)
+{
+    unsigned char *idata = NULL;
+    unsigned int channels;
+
+    if (true != __loadPPM(file, &idata, w, h, &channels))
+    {
+        return false;
+    }
+
+    unsigned int size = *w * *h * channels;
+
+    // initialize mem if necessary
+    // the correct size is checked / set in loadPGMc()
+    if (NULL == *data)
+    {
+        *data = (T *) malloc(sizeof(T) * size);
+    }
+
+    // copy and cast data
+    std::transform(idata, idata + size, *data, ConverterFromUByte<T>());
+
+    free(idata);
+
+    return true;
+}
+
+template <class T>
+inline bool
+sdkLoadPPM4(const char *file, T **data,
+            unsigned int *w,unsigned int *h)
+{
+    unsigned char *idata = 0;
+    unsigned int channels;
+
+    if (__loadPPM(file, &idata, w, h, &channels))
+    {
+        // pad 4th component
+        int size = *w * *h;
+        // keep the original pointer
+        unsigned char *idata_orig = idata;
+        *data = (T *) malloc(sizeof(T) * size * 4);
+        unsigned char *ptr = *data;
+
+        for (int i=0; i<size; i++)
+        {
+            *ptr++ = *idata++;
+            *ptr++ = *idata++;
+            *ptr++ = *idata++;
+            *ptr++ = 0;
+        }
+
+        free(idata_orig);
+        return true;
+    }
+    else
+    {
+        free(idata);
+        return false;
+    }
+}
+
+inline bool
+__savePPM(const char *file, unsigned char *data,
+          unsigned int w, unsigned int h, unsigned int channels)
+{
+    assert(NULL != data);
+    assert(w > 0);
+    assert(h > 0);
+
+    std::fstream fh(file, std::fstream::out | std::fstream::binary);
+
+    if (fh.bad())
+    {
+        std::cerr << "__savePPM() : Opening file failed." << std::endl;
+        return false;
+    }
+
+    if (channels == 1)
+    {
+        fh << "P5\n";
+    }
+    else if (channels == 3)
+    {
+        fh << "P6\n";
+    }
+    else
+    {
+        std::cerr << "__savePPM() : Invalid number of channels." << std::endl;
+        return false;
+    }
+
+    fh << w << "\n" << h << "\n" << 0xff << std::endl;
+
+    for (unsigned int i = 0; (i < (w*h*channels)) && fh.good(); ++i)
+    {
+        fh << data[i];
+    }
+
+    fh.flush();
+
+    if (fh.bad())
+    {
+        std::cerr << "__savePPM() : Writing data failed." << std::endl;
+        return false;
+    }
+
+    fh.close();
+
+    return true;
+}
+
+template<class T>
+inline bool
+sdkSavePGM(const char *file, T *data, unsigned int w, unsigned int h)
+{
+    unsigned int size = w * h;
+    unsigned char *idata =
+        (unsigned char *) malloc(sizeof(unsigned char) * size);
+
+    std::transform(data, data + size, idata, ConverterToUByte<T>());
+
+    // write file
+    bool result = __savePPM(file, idata, w, h, 1);
+
+    // cleanup
+    free(idata);
+
+    return result;
+}
+
+inline bool
+sdkSavePPM4ub(const char *file, unsigned char *data,
+              unsigned int w, unsigned int h)
+{
+    // strip 4th component
+    int size = w * h;
+    unsigned char *ndata = (unsigned char *) malloc(sizeof(unsigned char) * size*3);
+    unsigned char *ptr = ndata;
+
+    for (int i=0; i<size; i++)
+    {
+        *ptr++ = *data++;
+        *ptr++ = *data++;
+        *ptr++ = *data++;
+        data++;
+    }
+
+    bool result = __savePPM(file, ndata, w, h, 3);
+    free(ndata);
+    return result;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//! Read file \filename and return the data
+//! @return bool if reading the file succeeded, otherwise false
+//! @param filename name of the source file
+//! @param data  uninitialized pointer, returned initialized and pointing to
+//!        the data read
+//! @param len  number of data elements in data, -1 on error
+//////////////////////////////////////////////////////////////////////////////
+template<class T>
+inline bool
+sdkReadFile(const char *filename, T **data, unsigned int *len, bool verbose)
+{
+    // check input arguments
+    assert(NULL != filename);
+    assert(NULL != len);
+
+    // intermediate storage for the data read
+    std::vector<T>  data_read;
+
+    // open file for reading
+    FILE* fh = NULL;
+
+    // check if filestream is valid
+    if (FOPEN_FAIL(FOPEN(fh, filename, "r")))
+    {
+        printf("Unable to open input file: %s\n", filename);
+        return false;
+    }
+
+    // read all data elements
+    T token;
+    while(!feof(fh)) {
+        fscanf(fh, "%f", &token);
+        data_read.push_back(token);
+    }
+    // the last element is read twice
+    data_read.pop_back();
+    fclose(fh);
+
+    // check if the given handle is already initialized
+    if (NULL != *data)
+    {
+        if (*len != data_read.size())
+        {
+            std::cerr << "sdkReadFile() : Initialized memory given but "
+                      << "size  mismatch with signal read "
+                      << "(data read / data init = " << (unsigned int)data_read.size()
+                      <<  " / " << *len << ")" << std::endl;
+
+            return false;
+        }
+    }
+    else
+    {
+        // allocate storage for the data read
+        *data = (T *) malloc(sizeof(T) * data_read.size());
+        // store signal size
+        *len = static_cast<unsigned int>(data_read.size());
+    }
+
+    // copy data
+    memcpy(*data, &data_read.front(), sizeof(T) * data_read.size());
+
+    return true;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//! Read file \filename and return the data
+//! @return bool if reading the file succeeded, otherwise false
+//! @param filename name of the source file
+//! @param data  uninitialized pointer, returned initialized and pointing to
+//!        the data read
+//! @param len  number of data elements in data, -1 on error
+//////////////////////////////////////////////////////////////////////////////
+template<class T>
+inline bool
+sdkReadFileBlocks(const char *filename, T **data, unsigned int *len, unsigned int block_num, unsigned int block_size, bool verbose)
+{
+    // check input arguments
+    assert(NULL != filename);
+    assert(NULL != len);
+
+    // open file for reading
+    FILE *fh = fopen(filename, "rb");
+
+    if (fh == NULL && verbose)
+    {
+        std::cerr << "sdkReadFile() : Opening file failed." << std::endl;
+        return false;
+    }
+
+    // check if the given handle is already initialized
+    // allocate storage for the data read
+    data[block_num] = (T *) malloc(block_size);
+
+    // read all data elements
+    fseek(fh, block_num * block_size, SEEK_SET);
+    *len = fread(data[block_num], sizeof(T), block_size/sizeof(T), fh);
+
+    fclose(fh);
+
+    return true;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//! Write a data file \filename
+//! @return true if writing the file succeeded, otherwise false
+//! @param filename name of the source file
+//! @param data  data to write
+//! @param len  number of data elements in data, -1 on error
+//! @param epsilon  epsilon for comparison
+//////////////////////////////////////////////////////////////////////////////
+template<class T, class S>
+inline bool
+sdkWriteFile(const char *filename, const T *data, unsigned int len,
+             const S epsilon, bool verbose, bool append = false)
+{
+    assert(NULL != filename);
+    assert(NULL != data);
+
+    // open file for writing
+    //    if (append) {
+    std::fstream fh(filename, std::fstream::out | std::fstream::ate);
+
+    if (verbose)
+    {
+        std::cerr << "sdkWriteFile() : Open file " << filename << " for write/append." << std::endl;
+    }
+
+    /*    } else {
+            std::fstream fh(filename, std::fstream::out);
+            if (verbose) {
+                std::cerr << "sdkWriteFile() : Open file " << filename << " for write." << std::endl;
+            }
+        }
+    */
+
+    // check if filestream is valid
+    if (! fh.good())
+    {
+        if (verbose)
+        {
+            std::cerr << "sdkWriteFile() : Opening file failed." << std::endl;
+        }
+
+        return false;
+    }
+
+    // first write epsilon
+    fh << "# " << epsilon << "\n";
+
+    // write data
+    for (unsigned int i = 0; (i < len) && (fh.good()); ++i)
+    {
+        fh << data[i] << ' ';
+    }
+
+    // Check if writing succeeded
+    if (! fh.good())
+    {
+        if (verbose)
+        {
+            std::cerr << "sdkWriteFile() : Writing file failed." << std::endl;
+        }
+
+        return false;
+    }
+
+    // file ends with nl
+    fh << std::endl;
+
+    return true;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//! Compare two arrays of arbitrary type
+//! @return  true if \a reference and \a data are identical, otherwise false
+//! @param reference  timer_interface to the reference data / gold image
+//! @param data       handle to the computed data
+//! @param len        number of elements in reference and data
+//! @param epsilon    epsilon to use for the comparison
+//////////////////////////////////////////////////////////////////////////////
+template<class T, class S>
+inline bool
+compareData(const T *reference, const T *data, const unsigned int len,
+            const S epsilon, const float threshold)
+{
+    assert(epsilon >= 0);
+
+    bool result = true;
+    unsigned int error_count = 0;
+
+    for (unsigned int i = 0; i < len; ++i)
+    {
+        float diff = (float)reference[i] - (float)data[i];
+        bool comp = (diff <= epsilon) && (diff >= -epsilon);
+        result &= comp;
+
+        error_count += !comp;
+
+#if 0
+
+        if (! comp)
+        {
+            std::cerr << "ERROR, i = " << i << ",\t "
+                      << reference[i] << " / "
+                      << data[i]
+                      << " (reference / data)\n";
+        }
+
+#endif
+    }
+
+    if (threshold == 0.0f)
+    {
+        return (result) ? true : false;
+    }
+    else
+    {
+        if (error_count)
+        {
+            printf("%4.2f(%%) of bytes mismatched (count=%d)\n", (float)error_count*100/(float)len, error_count);
+        }
+
+        return (len*threshold > error_count) ? true : false;
+    }
+}
+
+#ifndef __MIN_EPSILON_ERROR
+#define __MIN_EPSILON_ERROR 1e-3f
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//! Compare two arrays of arbitrary type
+//! @return  true if \a reference and \a data are identical, otherwise false
+//! @param reference  handle to the reference data / gold image
+//! @param data       handle to the computed data
+//! @param len        number of elements in reference and data
+//! @param epsilon    epsilon to use for the comparison
+//! @param epsilon    threshold % of (# of bytes) for pass/fail
+//////////////////////////////////////////////////////////////////////////////
+template<class T, class S>
+inline bool
+compareDataAsFloatThreshold(const T *reference, const T *data, const unsigned int len,
+                            const S epsilon, const float threshold)
+{
+    assert(epsilon >= 0);
+
+    // If we set epsilon to be 0, let's set a minimum threshold
+    float max_error = MAX((float)epsilon, __MIN_EPSILON_ERROR);
+    int error_count = 0;
+    bool result = true;
+
+    for (unsigned int i = 0; i < len; ++i)
+    {
+        float diff = fabs((float)reference[i] - (float)data[i]);
+        bool comp = (diff < max_error);
+        result &= comp;
+
+        if (! comp)
+        {
+            error_count++;
+#if 0
+
+            if (error_count < 50)
+            {
+                printf("\n    ERROR(epsilon=%4.3f), i=%d, (ref)0x%02x / (data)0x%02x / (diff)%d\n",
+                       max_error, i,
+                       *(unsigned int *)&reference[i],
+                       *(unsigned int *)&data[i],
+                       (unsigned int)diff);
+            }
+
+#endif
+        }
+    }
+
+    if (threshold == 0.0f)
+    {
+        if (error_count)
+        {
+            printf("total # of errors = %d\n", error_count);
+        }
+
+        return (error_count == 0) ? true : false;
+    }
+    else
+    {
+        if (error_count)
+        {
+            printf("%4.2f(%%) of bytes mismatched (count=%d)\n", (float)error_count*100/(float)len, error_count);
+        }
+
+        return ((len*threshold > error_count) ? true : false);
+    }
+}
+
+inline
+void sdkDumpBin(void *data, unsigned int bytes, const char *filename)
+{
+    printf("sdkDumpBin: <%s>\n", filename);
+    FILE *fp;
+    FOPEN(fp, filename, "wb");
+    fwrite(data, bytes, 1, fp);
+    fflush(fp);
+    fclose(fp);
+}
+
+inline
+bool sdkCompareBin2BinUint(const char *src_file, const char *ref_file, unsigned int nelements, const float epsilon, const float threshold, char *exec_path)
+{
+    unsigned int *src_buffer, *ref_buffer;
+    FILE *src_fp = NULL, *ref_fp = NULL;
+
+    unsigned long error_count = 0;
+    size_t fsize = 0;
+
+    if (FOPEN_FAIL(FOPEN(src_fp, src_file, "rb")))
+    {
+        printf("compareBin2Bin <unsigned int> unable to open src_file: %s\n", src_file);
+        error_count++;
+    }
+
+    char *ref_file_path = sdkFindFilePath(ref_file, exec_path);
+
+    if (ref_file_path == NULL)
+    {
+        printf("compareBin2Bin <unsigned int>  unable to find <%s> in <%s>\n", ref_file, exec_path);
+        printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", ref_file);
+        printf("Aborting comparison!\n");
+        printf("  FAILED\n");
+        error_count++;
+
+        if (src_fp)
+        {
+            fclose(src_fp);
+        }
+
+        if (ref_fp)
+        {
+            fclose(ref_fp);
+        }
+    }
+    else
+    {
+        if (FOPEN_FAIL(FOPEN(ref_fp, ref_file_path, "rb")))
+        {
+            printf("compareBin2Bin <unsigned int>  unable to open ref_file: %s\n", ref_file_path);
+            error_count++;
+        }
+
+        if (src_fp && ref_fp)
+        {
+            src_buffer = (unsigned int *)malloc(nelements*sizeof(unsigned int));
+            ref_buffer = (unsigned int *)malloc(nelements*sizeof(unsigned int));
+
+            fsize = fread(src_buffer, nelements, sizeof(unsigned int), src_fp);
+            fsize = fread(ref_buffer, nelements, sizeof(unsigned int), ref_fp);
+
+            printf("> compareBin2Bin <unsigned int> nelements=%d, epsilon=%4.2f, threshold=%4.2f\n", nelements, epsilon, threshold);
+            printf("   src_file <%s>, size=%d bytes\n", src_file, (int)fsize);
+            printf("   ref_file <%s>, size=%d bytes\n", ref_file_path, (int)fsize);
+
+            if (!compareData<unsigned int, float>(ref_buffer, src_buffer, nelements, epsilon, threshold))
+            {
+                error_count++;
+            }
+
+            fclose(src_fp);
+            fclose(ref_fp);
+
+            free(src_buffer);
+            free(ref_buffer);
+        }
+        else
+        {
+            if (src_fp)
+            {
+                fclose(src_fp);
+            }
+
+            if (ref_fp)
+            {
+                fclose(ref_fp);
+            }
+        }
+    }
+
+    if (error_count == 0)
+    {
+        printf("  OK\n");
+    }
+    else
+    {
+        printf("  FAILURE: %d errors...\n", (unsigned int)error_count);
+    }
+
+    return (error_count == 0);  // returns true if all pixels pass
+}
+
+inline
+bool sdkCompareBin2BinFloat(const char *src_file, const char *ref_file, unsigned int nelements, const float epsilon, const float threshold, char *exec_path)
+{
+    float *src_buffer, *ref_buffer;
+    FILE *src_fp = NULL, *ref_fp = NULL;
+    size_t fsize = 0;
+
+    unsigned long error_count = 0;
+
+    if (FOPEN_FAIL(FOPEN(src_fp, src_file, "rb")))
+    {
+        printf("compareBin2Bin <float> unable to open src_file: %s\n", src_file);
+        error_count = 1;
+    }
+
+    char *ref_file_path = sdkFindFilePath(ref_file, exec_path);
+
+    if (ref_file_path == NULL)
+    {
+        printf("compareBin2Bin <float> unable to find <%s> in <%s>\n", ref_file, exec_path);
+        printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", exec_path);
+        printf("Aborting comparison!\n");
+        printf("  FAILED\n");
+        error_count++;
+
+        if (src_fp)
+        {
+            fclose(src_fp);
+        }
+
+        if (ref_fp)
+        {
+            fclose(ref_fp);
+        }
+    }
+    else
+    {
+        if (FOPEN_FAIL(FOPEN(ref_fp, ref_file_path, "rb")))
+        {
+            printf("compareBin2Bin <float> unable to open ref_file: %s\n", ref_file_path);
+            error_count = 1;
+        }
+
+        if (src_fp && ref_fp)
+        {
+            src_buffer = (float *)malloc(nelements*sizeof(float));
+            ref_buffer = (float *)malloc(nelements*sizeof(float));
+
+            fsize = fread(src_buffer, nelements, sizeof(float), src_fp);
+            fsize = fread(ref_buffer, nelements, sizeof(float), ref_fp);
+
+            printf("> compareBin2Bin <float> nelements=%d, epsilon=%4.2f, threshold=%4.2f\n", nelements, epsilon, threshold);
+            printf("   src_file <%s>, size=%d bytes\n", src_file, (int)fsize);
+            printf("   ref_file <%s>, size=%d bytes\n", ref_file_path, (int)fsize);
+
+            if (!compareDataAsFloatThreshold<float, float>(ref_buffer, src_buffer, nelements, epsilon, threshold))
+            {
+                error_count++;
+            }
+
+            fclose(src_fp);
+            fclose(ref_fp);
+
+            free(src_buffer);
+            free(ref_buffer);
+        }
+        else
+        {
+            if (src_fp)
+            {
+                fclose(src_fp);
+            }
+
+            if (ref_fp)
+            {
+                fclose(ref_fp);
+            }
+        }
+    }
+
+    if (error_count == 0)
+    {
+        printf("  OK\n");
+    }
+    else
+    {
+        printf("  FAILURE: %d errors...\n", (unsigned int)error_count);
+    }
+
+    return (error_count == 0);  // returns true if all pixels pass
+}
+
+inline bool
+sdkCompareL2fe(const float *reference, const float *data,
+               const unsigned int len, const float epsilon)
+{
+    assert(epsilon >= 0);
+
+    float error = 0;
+    float ref = 0;
+
+    for (unsigned int i = 0; i < len; ++i)
+    {
+
+        float diff = reference[i] - data[i];
+        error += diff * diff;
+        ref += reference[i] * reference[i];
+    }
+
+    float normRef = sqrtf(ref);
+
+    if (fabs(ref) < 1e-7)
+    {
+#ifdef _DEBUG
+        std::cerr << "ERROR, reference l2-norm is 0\n";
+#endif
+        return false;
+    }
+
+    float normError = sqrtf(error);
+    error = normError / normRef;
+    bool result = error < epsilon;
+#ifdef _DEBUG
+
+    if (! result)
+    {
+        std::cerr << "ERROR, l2-norm error "
+                  << error << " is greater than epsilon " << epsilon << "\n";
+    }
+
+#endif
+
+    return result;
+}
+
+inline bool
+sdkLoadPPMub(const char *file, unsigned char **data,
+             unsigned int *w,unsigned int *h)
+{
+    unsigned int channels;
+    return __loadPPM(file, data, w, h, &channels);
+}
+
+inline bool
+sdkLoadPPM4ub(const char *file, unsigned char **data,
+              unsigned int *w, unsigned int *h)
+{
+    unsigned char *idata = 0;
+    unsigned int channels;
+
+    if (__loadPPM(file, &idata, w, h, &channels))
+    {
+        // pad 4th component
+        int size = *w * *h;
+        // keep the original pointer
+        unsigned char *idata_orig = idata;
+        *data = (unsigned char *) malloc(sizeof(unsigned char) * size * 4);
+        unsigned char *ptr = *data;
+
+        for (int i=0; i<size; i++)
+        {
+            *ptr++ = *idata++;
+            *ptr++ = *idata++;
+            *ptr++ = *idata++;
+            *ptr++ = 0;
+        }
+
+        free(idata_orig);
+        return true;
+    }
+    else
+    {
+        free(idata);
+        return false;
+    }
+}
+
+
+inline bool
+sdkComparePPM(const char *src_file, const char *ref_file,
+              const float epsilon, const float threshold, bool verboseErrors)
+{
+    unsigned char *src_data, *ref_data;
+    unsigned long error_count = 0;
+    unsigned int ref_width, ref_height;
+    unsigned int src_width, src_height;
+
+    if (src_file == NULL || ref_file == NULL)
+    {
+        if (verboseErrors)
+        {
+            std::cerr << "PPMvsPPM: src_file or ref_file is NULL.  Aborting comparison\n";
+        }
+
+        return false;
+    }
+
+    if (verboseErrors)
+    {
+        std::cerr << "> Compare (a)rendered:  <" << src_file << ">\n";
+        std::cerr << ">         (b)reference: <" << ref_file << ">\n";
+    }
+
+
+    if (sdkLoadPPM4ub(ref_file, &ref_data, &ref_width, &ref_height) != true)
+    {
+        if (verboseErrors)
+        {
+            std::cerr << "PPMvsPPM: unable to load ref image file: "<< ref_file << "\n";
+        }
+
+        return false;
+    }
+
+    if (sdkLoadPPM4ub(src_file, &src_data, &src_width, &src_height) != true)
+    {
+        std::cerr << "PPMvsPPM: unable to load src image file: " << src_file << "\n";
+        return false;
+    }
+
+    if (src_height != ref_height || src_width != ref_width)
+    {
+        if (verboseErrors) std::cerr << "PPMvsPPM: source and ref size mismatch (" << src_width <<
+                                         "," << src_height << ")vs(" << ref_width << "," << ref_height << ")\n";
+    }
+
+    if (verboseErrors) std::cerr << "PPMvsPPM: comparing images size (" << src_width <<
+                                     "," << src_height << ") epsilon(" << epsilon << "), threshold(" << threshold*100 << "%)\n";
+
+    if (compareData(ref_data, src_data, src_width*src_height*4, epsilon, threshold) == false)
+    {
+        error_count=1;
+    }
+
+    if (error_count == 0)
+    {
+        if (verboseErrors)
+        {
+            std::cerr << "    OK\n\n";
+        }
+    }
+    else
+    {
+        if (verboseErrors)
+        {
+            std::cerr << "    FAILURE!  "<<error_count<<" errors...\n\n";
+        }
+    }
+
+    return (error_count == 0)? true : false;  // returns true if all pixels pass
+}
+
+inline bool
+sdkComparePGM(const char *src_file, const char *ref_file,
+              const float epsilon, const float threshold, bool verboseErrors)
+{
+    unsigned char *src_data = 0, *ref_data = 0;
+    unsigned long error_count = 0;
+    unsigned int ref_width, ref_height;
+    unsigned int src_width, src_height;
+
+    if (src_file == NULL || ref_file == NULL)
+    {
+        if (verboseErrors)
+        {
+            std::cerr << "PGMvsPGM: src_file or ref_file is NULL.  Aborting comparison\n";
+        }
+
+        return false;
+    }
+
+    if (verboseErrors)
+    {
+        std::cerr << "> Compare (a)rendered:  <" << src_file << ">\n";
+        std::cerr << ">         (b)reference: <" << ref_file << ">\n";
+    }
+
+
+    if (sdkLoadPPMub(ref_file, &ref_data, &ref_width, &ref_height) != true)
+    {
+        if (verboseErrors)
+        {
+            std::cerr << "PGMvsPGM: unable to load ref image file: "<< ref_file << "\n";
+        }
+
+        return false;
+    }
+
+    if (sdkLoadPPMub(src_file, &src_data, &src_width, &src_height) != true)
+    {
+        std::cerr << "PGMvsPGM: unable to load src image file: " << src_file << "\n";
+        return false;
+    }
+
+    if (src_height != ref_height || src_width != ref_width)
+    {
+        if (verboseErrors) std::cerr << "PGMvsPGM: source and ref size mismatch (" << src_width <<
+                                         "," << src_height << ")vs(" << ref_width << "," << ref_height << ")\n";
+    }
+
+    if (verboseErrors) std::cerr << "PGMvsPGM: comparing images size (" << src_width <<
+                                     "," << src_height << ") epsilon(" << epsilon << "), threshold(" << threshold*100 << "%)\n";
+
+    if (compareData(ref_data, src_data, src_width*src_height, epsilon, threshold) == false)
+    {
+        error_count=1;
+    }
+
+    if (error_count == 0)
+    {
+        if (verboseErrors)
+        {
+            std::cerr << "    OK\n\n";
+        }
+    }
+    else
+    {
+        if (verboseErrors)
+        {
+            std::cerr << "    FAILURE!  "<<error_count<<" errors...\n\n";
+        }
+    }
+
+    return (error_count == 0)? true : false;  // returns true if all pixels pass
+}
+
+#endif // HELPER_IMAGE_H
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/helper_math.h gpu-rodinia_new/cuda/cfd/common/inc/helper_math.h
--- gpu-rodinia/cuda/cfd/common/inc/helper_math.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/helper_math.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,1449 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+/*
+ *  This file implements common mathematical operations on vector types
+ *  (float3, float4 etc.) since these are not provided as standard by CUDA.
+ *
+ *  The syntax is modeled on the Cg standard library.
+ *
+ *  This is part of the Helper library includes
+ *
+ *    Thanks to Linh Hah for additions and fixes.
+ */
+
+#ifndef HELPER_MATH_H
+#define HELPER_MATH_H
+
+#include "cuda_runtime.h"
+
+typedef unsigned int uint;
+typedef unsigned short ushort;
+
+#ifndef __CUDACC__
+#include <math.h>
+
+////////////////////////////////////////////////////////////////////////////////
+// host implementations of CUDA functions
+////////////////////////////////////////////////////////////////////////////////
+
+inline float fminf(float a, float b)
+{
+    return a < b ? a : b;
+}
+
+inline float fmaxf(float a, float b)
+{
+    return a > b ? a : b;
+}
+
+inline int max(int a, int b)
+{
+    return a > b ? a : b;
+}
+
+inline int min(int a, int b)
+{
+    return a < b ? a : b;
+}
+
+inline float rsqrtf(float x)
+{
+    return 1.0f / sqrtf(x);
+}
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// constructors
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 make_float2(float s)
+{
+    return make_float2(s, s);
+}
+inline __host__ __device__ float2 make_float2(float3 a)
+{
+    return make_float2(a.x, a.y);
+}
+inline __host__ __device__ float2 make_float2(int2 a)
+{
+    return make_float2(float(a.x), float(a.y));
+}
+inline __host__ __device__ float2 make_float2(uint2 a)
+{
+    return make_float2(float(a.x), float(a.y));
+}
+
+inline __host__ __device__ int2 make_int2(int s)
+{
+    return make_int2(s, s);
+}
+inline __host__ __device__ int2 make_int2(int3 a)
+{
+    return make_int2(a.x, a.y);
+}
+inline __host__ __device__ int2 make_int2(uint2 a)
+{
+    return make_int2(int(a.x), int(a.y));
+}
+inline __host__ __device__ int2 make_int2(float2 a)
+{
+    return make_int2(int(a.x), int(a.y));
+}
+
+inline __host__ __device__ uint2 make_uint2(uint s)
+{
+    return make_uint2(s, s);
+}
+inline __host__ __device__ uint2 make_uint2(uint3 a)
+{
+    return make_uint2(a.x, a.y);
+}
+inline __host__ __device__ uint2 make_uint2(int2 a)
+{
+    return make_uint2(uint(a.x), uint(a.y));
+}
+
+inline __host__ __device__ float3 make_float3(float s)
+{
+    return make_float3(s, s, s);
+}
+inline __host__ __device__ float3 make_float3(float2 a)
+{
+    return make_float3(a.x, a.y, 0.0f);
+}
+inline __host__ __device__ float3 make_float3(float2 a, float s)
+{
+    return make_float3(a.x, a.y, s);
+}
+inline __host__ __device__ float3 make_float3(float4 a)
+{
+    return make_float3(a.x, a.y, a.z);
+}
+inline __host__ __device__ float3 make_float3(int3 a)
+{
+    return make_float3(float(a.x), float(a.y), float(a.z));
+}
+inline __host__ __device__ float3 make_float3(uint3 a)
+{
+    return make_float3(float(a.x), float(a.y), float(a.z));
+}
+
+inline __host__ __device__ int3 make_int3(int s)
+{
+    return make_int3(s, s, s);
+}
+inline __host__ __device__ int3 make_int3(int2 a)
+{
+    return make_int3(a.x, a.y, 0);
+}
+inline __host__ __device__ int3 make_int3(int2 a, int s)
+{
+    return make_int3(a.x, a.y, s);
+}
+inline __host__ __device__ int3 make_int3(uint3 a)
+{
+    return make_int3(int(a.x), int(a.y), int(a.z));
+}
+inline __host__ __device__ int3 make_int3(float3 a)
+{
+    return make_int3(int(a.x), int(a.y), int(a.z));
+}
+
+inline __host__ __device__ uint3 make_uint3(uint s)
+{
+    return make_uint3(s, s, s);
+}
+inline __host__ __device__ uint3 make_uint3(uint2 a)
+{
+    return make_uint3(a.x, a.y, 0);
+}
+inline __host__ __device__ uint3 make_uint3(uint2 a, uint s)
+{
+    return make_uint3(a.x, a.y, s);
+}
+inline __host__ __device__ uint3 make_uint3(uint4 a)
+{
+    return make_uint3(a.x, a.y, a.z);
+}
+inline __host__ __device__ uint3 make_uint3(int3 a)
+{
+    return make_uint3(uint(a.x), uint(a.y), uint(a.z));
+}
+
+inline __host__ __device__ float4 make_float4(float s)
+{
+    return make_float4(s, s, s, s);
+}
+inline __host__ __device__ float4 make_float4(float3 a)
+{
+    return make_float4(a.x, a.y, a.z, 0.0f);
+}
+inline __host__ __device__ float4 make_float4(float3 a, float w)
+{
+    return make_float4(a.x, a.y, a.z, w);
+}
+inline __host__ __device__ float4 make_float4(int4 a)
+{
+    return make_float4(float(a.x), float(a.y), float(a.z), float(a.w));
+}
+inline __host__ __device__ float4 make_float4(uint4 a)
+{
+    return make_float4(float(a.x), float(a.y), float(a.z), float(a.w));
+}
+
+inline __host__ __device__ int4 make_int4(int s)
+{
+    return make_int4(s, s, s, s);
+}
+inline __host__ __device__ int4 make_int4(int3 a)
+{
+    return make_int4(a.x, a.y, a.z, 0);
+}
+inline __host__ __device__ int4 make_int4(int3 a, int w)
+{
+    return make_int4(a.x, a.y, a.z, w);
+}
+inline __host__ __device__ int4 make_int4(uint4 a)
+{
+    return make_int4(int(a.x), int(a.y), int(a.z), int(a.w));
+}
+inline __host__ __device__ int4 make_int4(float4 a)
+{
+    return make_int4(int(a.x), int(a.y), int(a.z), int(a.w));
+}
+
+
+inline __host__ __device__ uint4 make_uint4(uint s)
+{
+    return make_uint4(s, s, s, s);
+}
+inline __host__ __device__ uint4 make_uint4(uint3 a)
+{
+    return make_uint4(a.x, a.y, a.z, 0);
+}
+inline __host__ __device__ uint4 make_uint4(uint3 a, uint w)
+{
+    return make_uint4(a.x, a.y, a.z, w);
+}
+inline __host__ __device__ uint4 make_uint4(int4 a)
+{
+    return make_uint4(uint(a.x), uint(a.y), uint(a.z), uint(a.w));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// negate
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 operator-(float2 &a)
+{
+    return make_float2(-a.x, -a.y);
+}
+inline __host__ __device__ int2 operator-(int2 &a)
+{
+    return make_int2(-a.x, -a.y);
+}
+inline __host__ __device__ float3 operator-(float3 &a)
+{
+    return make_float3(-a.x, -a.y, -a.z);
+}
+inline __host__ __device__ int3 operator-(int3 &a)
+{
+    return make_int3(-a.x, -a.y, -a.z);
+}
+inline __host__ __device__ float4 operator-(float4 &a)
+{
+    return make_float4(-a.x, -a.y, -a.z, -a.w);
+}
+inline __host__ __device__ int4 operator-(int4 &a)
+{
+    return make_int4(-a.x, -a.y, -a.z, -a.w);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// addition
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 operator+(float2 a, float2 b)
+{
+    return make_float2(a.x + b.x, a.y + b.y);
+}
+inline __host__ __device__ void operator+=(float2 &a, float2 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+}
+inline __host__ __device__ float2 operator+(float2 a, float b)
+{
+    return make_float2(a.x + b, a.y + b);
+}
+inline __host__ __device__ float2 operator+(float b, float2 a)
+{
+    return make_float2(a.x + b, a.y + b);
+}
+inline __host__ __device__ void operator+=(float2 &a, float b)
+{
+    a.x += b;
+    a.y += b;
+}
+
+inline __host__ __device__ int2 operator+(int2 a, int2 b)
+{
+    return make_int2(a.x + b.x, a.y + b.y);
+}
+inline __host__ __device__ void operator+=(int2 &a, int2 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+}
+inline __host__ __device__ int2 operator+(int2 a, int b)
+{
+    return make_int2(a.x + b, a.y + b);
+}
+inline __host__ __device__ int2 operator+(int b, int2 a)
+{
+    return make_int2(a.x + b, a.y + b);
+}
+inline __host__ __device__ void operator+=(int2 &a, int b)
+{
+    a.x += b;
+    a.y += b;
+}
+
+inline __host__ __device__ uint2 operator+(uint2 a, uint2 b)
+{
+    return make_uint2(a.x + b.x, a.y + b.y);
+}
+inline __host__ __device__ void operator+=(uint2 &a, uint2 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+}
+inline __host__ __device__ uint2 operator+(uint2 a, uint b)
+{
+    return make_uint2(a.x + b, a.y + b);
+}
+inline __host__ __device__ uint2 operator+(uint b, uint2 a)
+{
+    return make_uint2(a.x + b, a.y + b);
+}
+inline __host__ __device__ void operator+=(uint2 &a, uint b)
+{
+    a.x += b;
+    a.y += b;
+}
+
+
+inline __host__ __device__ float3 operator+(float3 a, float3 b)
+{
+    return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
+}
+inline __host__ __device__ void operator+=(float3 &a, float3 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+    a.z += b.z;
+}
+inline __host__ __device__ float3 operator+(float3 a, float b)
+{
+    return make_float3(a.x + b, a.y + b, a.z + b);
+}
+inline __host__ __device__ void operator+=(float3 &a, float b)
+{
+    a.x += b;
+    a.y += b;
+    a.z += b;
+}
+
+inline __host__ __device__ int3 operator+(int3 a, int3 b)
+{
+    return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
+}
+inline __host__ __device__ void operator+=(int3 &a, int3 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+    a.z += b.z;
+}
+inline __host__ __device__ int3 operator+(int3 a, int b)
+{
+    return make_int3(a.x + b, a.y + b, a.z + b);
+}
+inline __host__ __device__ void operator+=(int3 &a, int b)
+{
+    a.x += b;
+    a.y += b;
+    a.z += b;
+}
+
+inline __host__ __device__ uint3 operator+(uint3 a, uint3 b)
+{
+    return make_uint3(a.x + b.x, a.y + b.y, a.z + b.z);
+}
+inline __host__ __device__ void operator+=(uint3 &a, uint3 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+    a.z += b.z;
+}
+inline __host__ __device__ uint3 operator+(uint3 a, uint b)
+{
+    return make_uint3(a.x + b, a.y + b, a.z + b);
+}
+inline __host__ __device__ void operator+=(uint3 &a, uint b)
+{
+    a.x += b;
+    a.y += b;
+    a.z += b;
+}
+
+inline __host__ __device__ int3 operator+(int b, int3 a)
+{
+    return make_int3(a.x + b, a.y + b, a.z + b);
+}
+inline __host__ __device__ uint3 operator+(uint b, uint3 a)
+{
+    return make_uint3(a.x + b, a.y + b, a.z + b);
+}
+inline __host__ __device__ float3 operator+(float b, float3 a)
+{
+    return make_float3(a.x + b, a.y + b, a.z + b);
+}
+
+inline __host__ __device__ float4 operator+(float4 a, float4 b)
+{
+    return make_float4(a.x + b.x, a.y + b.y, a.z + b.z,  a.w + b.w);
+}
+inline __host__ __device__ void operator+=(float4 &a, float4 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+    a.z += b.z;
+    a.w += b.w;
+}
+inline __host__ __device__ float4 operator+(float4 a, float b)
+{
+    return make_float4(a.x + b, a.y + b, a.z + b, a.w + b);
+}
+inline __host__ __device__ float4 operator+(float b, float4 a)
+{
+    return make_float4(a.x + b, a.y + b, a.z + b, a.w + b);
+}
+inline __host__ __device__ void operator+=(float4 &a, float b)
+{
+    a.x += b;
+    a.y += b;
+    a.z += b;
+    a.w += b;
+}
+
+inline __host__ __device__ int4 operator+(int4 a, int4 b)
+{
+    return make_int4(a.x + b.x, a.y + b.y, a.z + b.z,  a.w + b.w);
+}
+inline __host__ __device__ void operator+=(int4 &a, int4 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+    a.z += b.z;
+    a.w += b.w;
+}
+inline __host__ __device__ int4 operator+(int4 a, int b)
+{
+    return make_int4(a.x + b, a.y + b, a.z + b,  a.w + b);
+}
+inline __host__ __device__ int4 operator+(int b, int4 a)
+{
+    return make_int4(a.x + b, a.y + b, a.z + b,  a.w + b);
+}
+inline __host__ __device__ void operator+=(int4 &a, int b)
+{
+    a.x += b;
+    a.y += b;
+    a.z += b;
+    a.w += b;
+}
+
+inline __host__ __device__ uint4 operator+(uint4 a, uint4 b)
+{
+    return make_uint4(a.x + b.x, a.y + b.y, a.z + b.z,  a.w + b.w);
+}
+inline __host__ __device__ void operator+=(uint4 &a, uint4 b)
+{
+    a.x += b.x;
+    a.y += b.y;
+    a.z += b.z;
+    a.w += b.w;
+}
+inline __host__ __device__ uint4 operator+(uint4 a, uint b)
+{
+    return make_uint4(a.x + b, a.y + b, a.z + b,  a.w + b);
+}
+inline __host__ __device__ uint4 operator+(uint b, uint4 a)
+{
+    return make_uint4(a.x + b, a.y + b, a.z + b,  a.w + b);
+}
+inline __host__ __device__ void operator+=(uint4 &a, uint b)
+{
+    a.x += b;
+    a.y += b;
+    a.z += b;
+    a.w += b;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// subtract
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 operator-(float2 a, float2 b)
+{
+    return make_float2(a.x - b.x, a.y - b.y);
+}
+inline __host__ __device__ void operator-=(float2 &a, float2 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+}
+inline __host__ __device__ float2 operator-(float2 a, float b)
+{
+    return make_float2(a.x - b, a.y - b);
+}
+inline __host__ __device__ float2 operator-(float b, float2 a)
+{
+    return make_float2(b - a.x, b - a.y);
+}
+inline __host__ __device__ void operator-=(float2 &a, float b)
+{
+    a.x -= b;
+    a.y -= b;
+}
+
+inline __host__ __device__ int2 operator-(int2 a, int2 b)
+{
+    return make_int2(a.x - b.x, a.y - b.y);
+}
+inline __host__ __device__ void operator-=(int2 &a, int2 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+}
+inline __host__ __device__ int2 operator-(int2 a, int b)
+{
+    return make_int2(a.x - b, a.y - b);
+}
+inline __host__ __device__ int2 operator-(int b, int2 a)
+{
+    return make_int2(b - a.x, b - a.y);
+}
+inline __host__ __device__ void operator-=(int2 &a, int b)
+{
+    a.x -= b;
+    a.y -= b;
+}
+
+inline __host__ __device__ uint2 operator-(uint2 a, uint2 b)
+{
+    return make_uint2(a.x - b.x, a.y - b.y);
+}
+inline __host__ __device__ void operator-=(uint2 &a, uint2 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+}
+inline __host__ __device__ uint2 operator-(uint2 a, uint b)
+{
+    return make_uint2(a.x - b, a.y - b);
+}
+inline __host__ __device__ uint2 operator-(uint b, uint2 a)
+{
+    return make_uint2(b - a.x, b - a.y);
+}
+inline __host__ __device__ void operator-=(uint2 &a, uint b)
+{
+    a.x -= b;
+    a.y -= b;
+}
+
+inline __host__ __device__ float3 operator-(float3 a, float3 b)
+{
+    return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
+}
+inline __host__ __device__ void operator-=(float3 &a, float3 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+    a.z -= b.z;
+}
+inline __host__ __device__ float3 operator-(float3 a, float b)
+{
+    return make_float3(a.x - b, a.y - b, a.z - b);
+}
+inline __host__ __device__ float3 operator-(float b, float3 a)
+{
+    return make_float3(b - a.x, b - a.y, b - a.z);
+}
+inline __host__ __device__ void operator-=(float3 &a, float b)
+{
+    a.x -= b;
+    a.y -= b;
+    a.z -= b;
+}
+
+inline __host__ __device__ int3 operator-(int3 a, int3 b)
+{
+    return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
+}
+inline __host__ __device__ void operator-=(int3 &a, int3 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+    a.z -= b.z;
+}
+inline __host__ __device__ int3 operator-(int3 a, int b)
+{
+    return make_int3(a.x - b, a.y - b, a.z - b);
+}
+inline __host__ __device__ int3 operator-(int b, int3 a)
+{
+    return make_int3(b - a.x, b - a.y, b - a.z);
+}
+inline __host__ __device__ void operator-=(int3 &a, int b)
+{
+    a.x -= b;
+    a.y -= b;
+    a.z -= b;
+}
+
+inline __host__ __device__ uint3 operator-(uint3 a, uint3 b)
+{
+    return make_uint3(a.x - b.x, a.y - b.y, a.z - b.z);
+}
+inline __host__ __device__ void operator-=(uint3 &a, uint3 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+    a.z -= b.z;
+}
+inline __host__ __device__ uint3 operator-(uint3 a, uint b)
+{
+    return make_uint3(a.x - b, a.y - b, a.z - b);
+}
+inline __host__ __device__ uint3 operator-(uint b, uint3 a)
+{
+    return make_uint3(b - a.x, b - a.y, b - a.z);
+}
+inline __host__ __device__ void operator-=(uint3 &a, uint b)
+{
+    a.x -= b;
+    a.y -= b;
+    a.z -= b;
+}
+
+inline __host__ __device__ float4 operator-(float4 a, float4 b)
+{
+    return make_float4(a.x - b.x, a.y - b.y, a.z - b.z,  a.w - b.w);
+}
+inline __host__ __device__ void operator-=(float4 &a, float4 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+    a.z -= b.z;
+    a.w -= b.w;
+}
+inline __host__ __device__ float4 operator-(float4 a, float b)
+{
+    return make_float4(a.x - b, a.y - b, a.z - b,  a.w - b);
+}
+inline __host__ __device__ void operator-=(float4 &a, float b)
+{
+    a.x -= b;
+    a.y -= b;
+    a.z -= b;
+    a.w -= b;
+}
+
+inline __host__ __device__ int4 operator-(int4 a, int4 b)
+{
+    return make_int4(a.x - b.x, a.y - b.y, a.z - b.z,  a.w - b.w);
+}
+inline __host__ __device__ void operator-=(int4 &a, int4 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+    a.z -= b.z;
+    a.w -= b.w;
+}
+inline __host__ __device__ int4 operator-(int4 a, int b)
+{
+    return make_int4(a.x - b, a.y - b, a.z - b,  a.w - b);
+}
+inline __host__ __device__ int4 operator-(int b, int4 a)
+{
+    return make_int4(b - a.x, b - a.y, b - a.z, b - a.w);
+}
+inline __host__ __device__ void operator-=(int4 &a, int b)
+{
+    a.x -= b;
+    a.y -= b;
+    a.z -= b;
+    a.w -= b;
+}
+
+inline __host__ __device__ uint4 operator-(uint4 a, uint4 b)
+{
+    return make_uint4(a.x - b.x, a.y - b.y, a.z - b.z,  a.w - b.w);
+}
+inline __host__ __device__ void operator-=(uint4 &a, uint4 b)
+{
+    a.x -= b.x;
+    a.y -= b.y;
+    a.z -= b.z;
+    a.w -= b.w;
+}
+inline __host__ __device__ uint4 operator-(uint4 a, uint b)
+{
+    return make_uint4(a.x - b, a.y - b, a.z - b,  a.w - b);
+}
+inline __host__ __device__ uint4 operator-(uint b, uint4 a)
+{
+    return make_uint4(b - a.x, b - a.y, b - a.z, b - a.w);
+}
+inline __host__ __device__ void operator-=(uint4 &a, uint b)
+{
+    a.x -= b;
+    a.y -= b;
+    a.z -= b;
+    a.w -= b;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// multiply
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 operator*(float2 a, float2 b)
+{
+    return make_float2(a.x * b.x, a.y * b.y);
+}
+inline __host__ __device__ void operator*=(float2 &a, float2 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+}
+inline __host__ __device__ float2 operator*(float2 a, float b)
+{
+    return make_float2(a.x * b, a.y * b);
+}
+inline __host__ __device__ float2 operator*(float b, float2 a)
+{
+    return make_float2(b * a.x, b * a.y);
+}
+inline __host__ __device__ void operator*=(float2 &a, float b)
+{
+    a.x *= b;
+    a.y *= b;
+}
+
+inline __host__ __device__ int2 operator*(int2 a, int2 b)
+{
+    return make_int2(a.x * b.x, a.y * b.y);
+}
+inline __host__ __device__ void operator*=(int2 &a, int2 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+}
+inline __host__ __device__ int2 operator*(int2 a, int b)
+{
+    return make_int2(a.x * b, a.y * b);
+}
+inline __host__ __device__ int2 operator*(int b, int2 a)
+{
+    return make_int2(b * a.x, b * a.y);
+}
+inline __host__ __device__ void operator*=(int2 &a, int b)
+{
+    a.x *= b;
+    a.y *= b;
+}
+
+inline __host__ __device__ uint2 operator*(uint2 a, uint2 b)
+{
+    return make_uint2(a.x * b.x, a.y * b.y);
+}
+inline __host__ __device__ void operator*=(uint2 &a, uint2 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+}
+inline __host__ __device__ uint2 operator*(uint2 a, uint b)
+{
+    return make_uint2(a.x * b, a.y * b);
+}
+inline __host__ __device__ uint2 operator*(uint b, uint2 a)
+{
+    return make_uint2(b * a.x, b * a.y);
+}
+inline __host__ __device__ void operator*=(uint2 &a, uint b)
+{
+    a.x *= b;
+    a.y *= b;
+}
+
+inline __host__ __device__ float3 operator*(float3 a, float3 b)
+{
+    return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
+}
+inline __host__ __device__ void operator*=(float3 &a, float3 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+    a.z *= b.z;
+}
+inline __host__ __device__ float3 operator*(float3 a, float b)
+{
+    return make_float3(a.x * b, a.y * b, a.z * b);
+}
+inline __host__ __device__ float3 operator*(float b, float3 a)
+{
+    return make_float3(b * a.x, b * a.y, b * a.z);
+}
+inline __host__ __device__ void operator*=(float3 &a, float b)
+{
+    a.x *= b;
+    a.y *= b;
+    a.z *= b;
+}
+
+inline __host__ __device__ int3 operator*(int3 a, int3 b)
+{
+    return make_int3(a.x * b.x, a.y * b.y, a.z * b.z);
+}
+inline __host__ __device__ void operator*=(int3 &a, int3 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+    a.z *= b.z;
+}
+inline __host__ __device__ int3 operator*(int3 a, int b)
+{
+    return make_int3(a.x * b, a.y * b, a.z * b);
+}
+inline __host__ __device__ int3 operator*(int b, int3 a)
+{
+    return make_int3(b * a.x, b * a.y, b * a.z);
+}
+inline __host__ __device__ void operator*=(int3 &a, int b)
+{
+    a.x *= b;
+    a.y *= b;
+    a.z *= b;
+}
+
+inline __host__ __device__ uint3 operator*(uint3 a, uint3 b)
+{
+    return make_uint3(a.x * b.x, a.y * b.y, a.z * b.z);
+}
+inline __host__ __device__ void operator*=(uint3 &a, uint3 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+    a.z *= b.z;
+}
+inline __host__ __device__ uint3 operator*(uint3 a, uint b)
+{
+    return make_uint3(a.x * b, a.y * b, a.z * b);
+}
+inline __host__ __device__ uint3 operator*(uint b, uint3 a)
+{
+    return make_uint3(b * a.x, b * a.y, b * a.z);
+}
+inline __host__ __device__ void operator*=(uint3 &a, uint b)
+{
+    a.x *= b;
+    a.y *= b;
+    a.z *= b;
+}
+
+inline __host__ __device__ float4 operator*(float4 a, float4 b)
+{
+    return make_float4(a.x * b.x, a.y * b.y, a.z * b.z,  a.w * b.w);
+}
+inline __host__ __device__ void operator*=(float4 &a, float4 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+    a.z *= b.z;
+    a.w *= b.w;
+}
+inline __host__ __device__ float4 operator*(float4 a, float b)
+{
+    return make_float4(a.x * b, a.y * b, a.z * b,  a.w * b);
+}
+inline __host__ __device__ float4 operator*(float b, float4 a)
+{
+    return make_float4(b * a.x, b * a.y, b * a.z, b * a.w);
+}
+inline __host__ __device__ void operator*=(float4 &a, float b)
+{
+    a.x *= b;
+    a.y *= b;
+    a.z *= b;
+    a.w *= b;
+}
+
+inline __host__ __device__ int4 operator*(int4 a, int4 b)
+{
+    return make_int4(a.x * b.x, a.y * b.y, a.z * b.z,  a.w * b.w);
+}
+inline __host__ __device__ void operator*=(int4 &a, int4 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+    a.z *= b.z;
+    a.w *= b.w;
+}
+inline __host__ __device__ int4 operator*(int4 a, int b)
+{
+    return make_int4(a.x * b, a.y * b, a.z * b,  a.w * b);
+}
+inline __host__ __device__ int4 operator*(int b, int4 a)
+{
+    return make_int4(b * a.x, b * a.y, b * a.z, b * a.w);
+}
+inline __host__ __device__ void operator*=(int4 &a, int b)
+{
+    a.x *= b;
+    a.y *= b;
+    a.z *= b;
+    a.w *= b;
+}
+
+inline __host__ __device__ uint4 operator*(uint4 a, uint4 b)
+{
+    return make_uint4(a.x * b.x, a.y * b.y, a.z * b.z,  a.w * b.w);
+}
+inline __host__ __device__ void operator*=(uint4 &a, uint4 b)
+{
+    a.x *= b.x;
+    a.y *= b.y;
+    a.z *= b.z;
+    a.w *= b.w;
+}
+inline __host__ __device__ uint4 operator*(uint4 a, uint b)
+{
+    return make_uint4(a.x * b, a.y * b, a.z * b,  a.w * b);
+}
+inline __host__ __device__ uint4 operator*(uint b, uint4 a)
+{
+    return make_uint4(b * a.x, b * a.y, b * a.z, b * a.w);
+}
+inline __host__ __device__ void operator*=(uint4 &a, uint b)
+{
+    a.x *= b;
+    a.y *= b;
+    a.z *= b;
+    a.w *= b;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// divide
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 operator/(float2 a, float2 b)
+{
+    return make_float2(a.x / b.x, a.y / b.y);
+}
+inline __host__ __device__ void operator/=(float2 &a, float2 b)
+{
+    a.x /= b.x;
+    a.y /= b.y;
+}
+inline __host__ __device__ float2 operator/(float2 a, float b)
+{
+    return make_float2(a.x / b, a.y / b);
+}
+inline __host__ __device__ void operator/=(float2 &a, float b)
+{
+    a.x /= b;
+    a.y /= b;
+}
+inline __host__ __device__ float2 operator/(float b, float2 a)
+{
+    return make_float2(b / a.x, b / a.y);
+}
+
+inline __host__ __device__ float3 operator/(float3 a, float3 b)
+{
+    return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
+}
+inline __host__ __device__ void operator/=(float3 &a, float3 b)
+{
+    a.x /= b.x;
+    a.y /= b.y;
+    a.z /= b.z;
+}
+inline __host__ __device__ float3 operator/(float3 a, float b)
+{
+    return make_float3(a.x / b, a.y / b, a.z / b);
+}
+inline __host__ __device__ void operator/=(float3 &a, float b)
+{
+    a.x /= b;
+    a.y /= b;
+    a.z /= b;
+}
+inline __host__ __device__ float3 operator/(float b, float3 a)
+{
+    return make_float3(b / a.x, b / a.y, b / a.z);
+}
+
+inline __host__ __device__ float4 operator/(float4 a, float4 b)
+{
+    return make_float4(a.x / b.x, a.y / b.y, a.z / b.z,  a.w / b.w);
+}
+inline __host__ __device__ void operator/=(float4 &a, float4 b)
+{
+    a.x /= b.x;
+    a.y /= b.y;
+    a.z /= b.z;
+    a.w /= b.w;
+}
+inline __host__ __device__ float4 operator/(float4 a, float b)
+{
+    return make_float4(a.x / b, a.y / b, a.z / b,  a.w / b);
+}
+inline __host__ __device__ void operator/=(float4 &a, float b)
+{
+    a.x /= b;
+    a.y /= b;
+    a.z /= b;
+    a.w /= b;
+}
+inline __host__ __device__ float4 operator/(float b, float4 a)
+{
+    return make_float4(b / a.x, b / a.y, b / a.z, b / a.w);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// min
+////////////////////////////////////////////////////////////////////////////////
+
+inline  __host__ __device__ float2 fminf(float2 a, float2 b)
+{
+    return make_float2(fminf(a.x,b.x), fminf(a.y,b.y));
+}
+inline __host__ __device__ float3 fminf(float3 a, float3 b)
+{
+    return make_float3(fminf(a.x,b.x), fminf(a.y,b.y), fminf(a.z,b.z));
+}
+inline  __host__ __device__ float4 fminf(float4 a, float4 b)
+{
+    return make_float4(fminf(a.x,b.x), fminf(a.y,b.y), fminf(a.z,b.z), fminf(a.w,b.w));
+}
+
+inline __host__ __device__ int2 min(int2 a, int2 b)
+{
+    return make_int2(min(a.x,b.x), min(a.y,b.y));
+}
+inline __host__ __device__ int3 min(int3 a, int3 b)
+{
+    return make_int3(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z));
+}
+inline __host__ __device__ int4 min(int4 a, int4 b)
+{
+    return make_int4(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z), min(a.w,b.w));
+}
+
+inline __host__ __device__ uint2 min(uint2 a, uint2 b)
+{
+    return make_uint2(min(a.x,b.x), min(a.y,b.y));
+}
+inline __host__ __device__ uint3 min(uint3 a, uint3 b)
+{
+    return make_uint3(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z));
+}
+inline __host__ __device__ uint4 min(uint4 a, uint4 b)
+{
+    return make_uint4(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z), min(a.w,b.w));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// max
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 fmaxf(float2 a, float2 b)
+{
+    return make_float2(fmaxf(a.x,b.x), fmaxf(a.y,b.y));
+}
+inline __host__ __device__ float3 fmaxf(float3 a, float3 b)
+{
+    return make_float3(fmaxf(a.x,b.x), fmaxf(a.y,b.y), fmaxf(a.z,b.z));
+}
+inline __host__ __device__ float4 fmaxf(float4 a, float4 b)
+{
+    return make_float4(fmaxf(a.x,b.x), fmaxf(a.y,b.y), fmaxf(a.z,b.z), fmaxf(a.w,b.w));
+}
+
+inline __host__ __device__ int2 max(int2 a, int2 b)
+{
+    return make_int2(max(a.x,b.x), max(a.y,b.y));
+}
+inline __host__ __device__ int3 max(int3 a, int3 b)
+{
+    return make_int3(max(a.x,b.x), max(a.y,b.y), max(a.z,b.z));
+}
+inline __host__ __device__ int4 max(int4 a, int4 b)
+{
+    return make_int4(max(a.x,b.x), max(a.y,b.y), max(a.z,b.z), max(a.w,b.w));
+}
+
+inline __host__ __device__ uint2 max(uint2 a, uint2 b)
+{
+    return make_uint2(max(a.x,b.x), max(a.y,b.y));
+}
+inline __host__ __device__ uint3 max(uint3 a, uint3 b)
+{
+    return make_uint3(max(a.x,b.x), max(a.y,b.y), max(a.z,b.z));
+}
+inline __host__ __device__ uint4 max(uint4 a, uint4 b)
+{
+    return make_uint4(max(a.x,b.x), max(a.y,b.y), max(a.z,b.z), max(a.w,b.w));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// lerp
+// - linear interpolation between a and b, based on value t in [0, 1] range
+////////////////////////////////////////////////////////////////////////////////
+
+inline __device__ __host__ float lerp(float a, float b, float t)
+{
+    return a + t*(b-a);
+}
+inline __device__ __host__ float2 lerp(float2 a, float2 b, float t)
+{
+    return a + t*(b-a);
+}
+inline __device__ __host__ float3 lerp(float3 a, float3 b, float t)
+{
+    return a + t*(b-a);
+}
+inline __device__ __host__ float4 lerp(float4 a, float4 b, float t)
+{
+    return a + t*(b-a);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// clamp
+// - clamp the value v to be in the range [a, b]
+////////////////////////////////////////////////////////////////////////////////
+
+inline __device__ __host__ float clamp(float f, float a, float b)
+{
+    return fmaxf(a, fminf(f, b));
+}
+inline __device__ __host__ int clamp(int f, int a, int b)
+{
+    return max(a, min(f, b));
+}
+inline __device__ __host__ uint clamp(uint f, uint a, uint b)
+{
+    return max(a, min(f, b));
+}
+
+inline __device__ __host__ float2 clamp(float2 v, float a, float b)
+{
+    return make_float2(clamp(v.x, a, b), clamp(v.y, a, b));
+}
+inline __device__ __host__ float2 clamp(float2 v, float2 a, float2 b)
+{
+    return make_float2(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y));
+}
+inline __device__ __host__ float3 clamp(float3 v, float a, float b)
+{
+    return make_float3(clamp(v.x, a, b), clamp(v.y, a, b), clamp(v.z, a, b));
+}
+inline __device__ __host__ float3 clamp(float3 v, float3 a, float3 b)
+{
+    return make_float3(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y), clamp(v.z, a.z, b.z));
+}
+inline __device__ __host__ float4 clamp(float4 v, float a, float b)
+{
+    return make_float4(clamp(v.x, a, b), clamp(v.y, a, b), clamp(v.z, a, b), clamp(v.w, a, b));
+}
+inline __device__ __host__ float4 clamp(float4 v, float4 a, float4 b)
+{
+    return make_float4(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y), clamp(v.z, a.z, b.z), clamp(v.w, a.w, b.w));
+}
+
+inline __device__ __host__ int2 clamp(int2 v, int a, int b)
+{
+    return make_int2(clamp(v.x, a, b), clamp(v.y, a, b));
+}
+inline __device__ __host__ int2 clamp(int2 v, int2 a, int2 b)
+{
+    return make_int2(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y));
+}
+inline __device__ __host__ int3 clamp(int3 v, int a, int b)
+{
+    return make_int3(clamp(v.x, a, b), clamp(v.y, a, b), clamp(v.z, a, b));
+}
+inline __device__ __host__ int3 clamp(int3 v, int3 a, int3 b)
+{
+    return make_int3(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y), clamp(v.z, a.z, b.z));
+}
+inline __device__ __host__ int4 clamp(int4 v, int a, int b)
+{
+    return make_int4(clamp(v.x, a, b), clamp(v.y, a, b), clamp(v.z, a, b), clamp(v.w, a, b));
+}
+inline __device__ __host__ int4 clamp(int4 v, int4 a, int4 b)
+{
+    return make_int4(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y), clamp(v.z, a.z, b.z), clamp(v.w, a.w, b.w));
+}
+
+inline __device__ __host__ uint2 clamp(uint2 v, uint a, uint b)
+{
+    return make_uint2(clamp(v.x, a, b), clamp(v.y, a, b));
+}
+inline __device__ __host__ uint2 clamp(uint2 v, uint2 a, uint2 b)
+{
+    return make_uint2(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y));
+}
+inline __device__ __host__ uint3 clamp(uint3 v, uint a, uint b)
+{
+    return make_uint3(clamp(v.x, a, b), clamp(v.y, a, b), clamp(v.z, a, b));
+}
+inline __device__ __host__ uint3 clamp(uint3 v, uint3 a, uint3 b)
+{
+    return make_uint3(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y), clamp(v.z, a.z, b.z));
+}
+inline __device__ __host__ uint4 clamp(uint4 v, uint a, uint b)
+{
+    return make_uint4(clamp(v.x, a, b), clamp(v.y, a, b), clamp(v.z, a, b), clamp(v.w, a, b));
+}
+inline __device__ __host__ uint4 clamp(uint4 v, uint4 a, uint4 b)
+{
+    return make_uint4(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y), clamp(v.z, a.z, b.z), clamp(v.w, a.w, b.w));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// dot product
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float dot(float2 a, float2 b)
+{
+    return a.x * b.x + a.y * b.y;
+}
+inline __host__ __device__ float dot(float3 a, float3 b)
+{
+    return a.x * b.x + a.y * b.y + a.z * b.z;
+}
+inline __host__ __device__ float dot(float4 a, float4 b)
+{
+    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
+}
+
+inline __host__ __device__ int dot(int2 a, int2 b)
+{
+    return a.x * b.x + a.y * b.y;
+}
+inline __host__ __device__ int dot(int3 a, int3 b)
+{
+    return a.x * b.x + a.y * b.y + a.z * b.z;
+}
+inline __host__ __device__ int dot(int4 a, int4 b)
+{
+    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
+}
+
+inline __host__ __device__ uint dot(uint2 a, uint2 b)
+{
+    return a.x * b.x + a.y * b.y;
+}
+inline __host__ __device__ uint dot(uint3 a, uint3 b)
+{
+    return a.x * b.x + a.y * b.y + a.z * b.z;
+}
+inline __host__ __device__ uint dot(uint4 a, uint4 b)
+{
+    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// length
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float length(float2 v)
+{
+    return sqrtf(dot(v, v));
+}
+inline __host__ __device__ float length(float3 v)
+{
+    return sqrtf(dot(v, v));
+}
+inline __host__ __device__ float length(float4 v)
+{
+    return sqrtf(dot(v, v));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// normalize
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 normalize(float2 v)
+{
+    float invLen = rsqrtf(dot(v, v));
+    return v * invLen;
+}
+inline __host__ __device__ float3 normalize(float3 v)
+{
+    float invLen = rsqrtf(dot(v, v));
+    return v * invLen;
+}
+inline __host__ __device__ float4 normalize(float4 v)
+{
+    float invLen = rsqrtf(dot(v, v));
+    return v * invLen;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// floor
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 floorf(float2 v)
+{
+    return make_float2(floorf(v.x), floorf(v.y));
+}
+inline __host__ __device__ float3 floorf(float3 v)
+{
+    return make_float3(floorf(v.x), floorf(v.y), floorf(v.z));
+}
+inline __host__ __device__ float4 floorf(float4 v)
+{
+    return make_float4(floorf(v.x), floorf(v.y), floorf(v.z), floorf(v.w));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// frac - returns the fractional portion of a scalar or each vector component
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float fracf(float v)
+{
+    return v - floorf(v);
+}
+inline __host__ __device__ float2 fracf(float2 v)
+{
+    return make_float2(fracf(v.x), fracf(v.y));
+}
+inline __host__ __device__ float3 fracf(float3 v)
+{
+    return make_float3(fracf(v.x), fracf(v.y), fracf(v.z));
+}
+inline __host__ __device__ float4 fracf(float4 v)
+{
+    return make_float4(fracf(v.x), fracf(v.y), fracf(v.z), fracf(v.w));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// fmod
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 fmodf(float2 a, float2 b)
+{
+    return make_float2(fmodf(a.x, b.x), fmodf(a.y, b.y));
+}
+inline __host__ __device__ float3 fmodf(float3 a, float3 b)
+{
+    return make_float3(fmodf(a.x, b.x), fmodf(a.y, b.y), fmodf(a.z, b.z));
+}
+inline __host__ __device__ float4 fmodf(float4 a, float4 b)
+{
+    return make_float4(fmodf(a.x, b.x), fmodf(a.y, b.y), fmodf(a.z, b.z), fmodf(a.w, b.w));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// absolute value
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float2 fabs(float2 v)
+{
+    return make_float2(fabs(v.x), fabs(v.y));
+}
+inline __host__ __device__ float3 fabs(float3 v)
+{
+    return make_float3(fabs(v.x), fabs(v.y), fabs(v.z));
+}
+inline __host__ __device__ float4 fabs(float4 v)
+{
+    return make_float4(fabs(v.x), fabs(v.y), fabs(v.z), fabs(v.w));
+}
+
+inline __host__ __device__ int2 abs(int2 v)
+{
+    return make_int2(abs(v.x), abs(v.y));
+}
+inline __host__ __device__ int3 abs(int3 v)
+{
+    return make_int3(abs(v.x), abs(v.y), abs(v.z));
+}
+inline __host__ __device__ int4 abs(int4 v)
+{
+    return make_int4(abs(v.x), abs(v.y), abs(v.z), abs(v.w));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// reflect
+// - returns reflection of incident ray I around surface normal N
+// - N should be normalized, reflected vector's length is equal to length of I
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float3 reflect(float3 i, float3 n)
+{
+    return i - 2.0f * n * dot(n,i);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// cross product
+////////////////////////////////////////////////////////////////////////////////
+
+inline __host__ __device__ float3 cross(float3 a, float3 b)
+{
+    return make_float3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// smoothstep
+// - returns 0 if x < a
+// - returns 1 if x > b
+// - otherwise returns smooth interpolation between 0 and 1 based on x
+////////////////////////////////////////////////////////////////////////////////
+
+inline __device__ __host__ float smoothstep(float a, float b, float x)
+{
+    float y = clamp((x - a) / (b - a), 0.0f, 1.0f);
+    return (y*y*(3.0f - (2.0f*y)));
+}
+inline __device__ __host__ float2 smoothstep(float2 a, float2 b, float2 x)
+{
+    float2 y = clamp((x - a) / (b - a), 0.0f, 1.0f);
+    return (y*y*(make_float2(3.0f) - (make_float2(2.0f)*y)));
+}
+inline __device__ __host__ float3 smoothstep(float3 a, float3 b, float3 x)
+{
+    float3 y = clamp((x - a) / (b - a), 0.0f, 1.0f);
+    return (y*y*(make_float3(3.0f) - (make_float3(2.0f)*y)));
+}
+inline __device__ __host__ float4 smoothstep(float4 a, float4 b, float4 x)
+{
+    float4 y = clamp((x - a) / (b - a), 0.0f, 1.0f);
+    return (y*y*(make_float4(3.0f) - (make_float4(2.0f)*y)));
+}
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/helper_string.h gpu-rodinia_new/cuda/cfd/common/inc/helper_string.h
--- gpu-rodinia/cuda/cfd/common/inc/helper_string.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/helper_string.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,421 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+// These are helper functions for the SDK samples (string parsing, timers, etc)
+#ifndef STRING_HELPER_H
+#define STRING_HELPER_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fstream>
+#include <string>
+
+#ifdef _WIN32
+#ifndef STRCASECMP
+#define STRCASECMP  _stricmp
+#endif
+#ifndef STRNCASECMP
+#define STRNCASECMP _strnicmp
+#endif
+#ifndef STRCPY
+#define STRCPY(sFilePath, nLength, sPath) strcpy_s(sFilePath, nLength, sPath)
+#endif
+
+#ifndef FOPEN
+#define FOPEN(fHandle,filename,mode) fopen_s(&fHandle, filename, mode)
+#endif
+#ifndef FOPEN_FAIL
+#define FOPEN_FAIL(result) (result != 0)
+#endif
+#ifndef SSCANF
+#define SSCANF sscanf_s
+#endif
+
+#else
+#include <string.h>
+#include <strings.h>
+
+#ifndef STRCASECMP
+#define STRCASECMP  strcasecmp
+#endif
+#ifndef STRNCASECMP
+#define STRNCASECMP strncasecmp
+#endif
+#ifndef STRCPY
+#define STRCPY(sFilePath, nLength, sPath) strcpy(sFilePath, sPath)
+#endif
+
+#ifndef FOPEN
+#define FOPEN(fHandle,filename,mode) (fHandle = fopen(filename, mode))
+#endif
+#ifndef FOPEN_FAIL
+#define FOPEN_FAIL(result) (result == NULL)
+#endif
+#ifndef SSCANF
+#define SSCANF sscanf
+#endif
+#endif
+
+// CUDA Utility Helper Functions
+inline int stringRemoveDelimiter(char delimiter, const char *string)
+{
+    int string_start = 0;
+
+    while (string[string_start] == delimiter)
+    {
+        string_start++;
+    }
+
+    if (string_start >= (int)strlen(string)-1)
+    {
+        return 0;
+    }
+
+    return string_start;
+}
+
+inline int getFileExtension(char *filename, char **extension)
+{
+    int string_length = (int)strlen(filename);
+
+    while (filename[string_length--] != '.') {
+        if (string_length == 0)
+            break;
+    }
+    if (string_length > 0) string_length += 2;
+
+    if (string_length == 0) 
+        *extension = NULL;
+    else 
+        *extension = &filename[string_length];
+
+    return string_length;
+}
+
+
+inline int checkCmdLineFlag(const int argc, const char **argv, const char *string_ref)
+{
+    bool bFound = false;
+
+    if (argc >= 1)
+    {
+        for (int i=1; i < argc; i++)
+        {
+            int string_start = stringRemoveDelimiter('-', argv[i]);
+            const char *string_argv = &argv[i][string_start];
+
+            const char *equal_pos = strchr(string_argv, '=');
+            int argv_length = (int)(equal_pos == 0 ? strlen(string_argv) : equal_pos - string_argv);
+
+            int length = (int)strlen(string_ref);
+
+            if (length == argv_length && !STRNCASECMP(string_argv, string_ref, length))
+            {
+
+                bFound = true;
+                continue;
+            }
+        }
+    }
+
+    return (int)bFound;
+}
+
+inline int getCmdLineArgumentInt(const int argc, const char **argv, const char *string_ref)
+{
+    bool bFound = false;
+    int value = -1;
+
+    if (argc >= 1)
+    {
+        for (int i=1; i < argc; i++)
+        {
+            int string_start = stringRemoveDelimiter('-', argv[i]);
+            const char *string_argv = &argv[i][string_start];
+            int length = (int)strlen(string_ref);
+
+            if (!STRNCASECMP(string_argv, string_ref, length))
+            {
+                if (length+1 <= (int)strlen(string_argv))
+                {
+                    int auto_inc = (string_argv[length] == '=') ? 1 : 0;
+                    value = atoi(&string_argv[length + auto_inc]);
+                }
+                else
+                {
+                    value = 0;
+                }
+
+                bFound = true;
+                continue;
+            }
+        }
+    }
+
+    if (bFound)
+    {
+        return value;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+inline float getCmdLineArgumentFloat(const int argc, const char **argv, const char *string_ref)
+{
+    bool bFound = false;
+    float value = -1;
+
+    if (argc >= 1)
+    {
+        for (int i=1; i < argc; i++)
+        {
+            int string_start = stringRemoveDelimiter('-', argv[i]);
+            const char *string_argv = &argv[i][string_start];
+            int length = (int)strlen(string_ref);
+
+            if (!STRNCASECMP(string_argv, string_ref, length))
+            {
+                if (length+1 <= (int)strlen(string_argv))
+                {
+                    int auto_inc = (string_argv[length] == '=') ? 1 : 0;
+                    value = (float)atof(&string_argv[length + auto_inc]);
+                }
+                else
+                {
+                    value = 0.f;
+                }
+
+                bFound = true;
+                continue;
+            }
+        }
+    }
+
+    if (bFound)
+    {
+        return value;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+inline bool getCmdLineArgumentString(const int argc, const char **argv,
+                                     const char *string_ref, char **string_retval)
+{
+    bool bFound = false;
+
+    if (argc >= 1)
+    {
+        for (int i=1; i < argc; i++)
+        {
+            int string_start = stringRemoveDelimiter('-', argv[i]);
+            char *string_argv = (char *)&argv[i][string_start];
+            int length = (int)strlen(string_ref);
+
+            if (!STRNCASECMP(string_argv, string_ref, length))
+            {
+                *string_retval = &string_argv[length+1];
+                bFound = true;
+                continue;
+            }
+        }
+    }
+
+    if (!bFound)
+    {
+        *string_retval = NULL;
+    }
+
+    return bFound;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//! Find the path for a file assuming that
+//! files are found in the searchPath.
+//!
+//! @return the path if succeeded, otherwise 0
+//! @param filename         name of the file
+//! @param executable_path  optional absolute path of the executable
+//////////////////////////////////////////////////////////////////////////////
+inline char *sdkFindFilePath(const char *filename, const char *executable_path)
+{
+    // <executable_name> defines a variable that is replaced with the name of the executable
+
+    // Typical relative search paths to locate needed companion files (e.g. sample input data, or JIT source files)
+    // The origin for the relative search may be the .exe file, a .bat file launching an .exe, a browser .exe launching the .exe or .bat, etc
+    const char *searchPath[] =
+    {
+        "./",                                       // same dir
+        "./common/",                                // "/common/" subdir
+        "./common/data/",                           // "/common/data/" subdir
+        "./data/",                                  // "/data/" subdir
+        "./src/",                                   // "/src/" subdir
+        "./src/<executable_name>/data/",            // "/src/<executable_name>/data/" subdir
+        "./inc/",                                   // "/inc/" subdir
+        "./0_Simple/",                              // "/0_Simple/" subdir
+        "./1_Utilities/",                           // "/1_Utilities/" subdir
+        "./2_Graphics/",                            // "/2_Graphics/" subdir
+        "./3_Imaging/",                             // "/3_Imaging/" subdir
+        "./4_Financial/",                           // "/4_Financial/" subdir
+        "./5_Simulations/",                         // "/5_Simulations/" subdir
+        "./6_Advanced/",                            // "/6_Advanced/" subdir
+        "./7_CUDALibraries/",                       // "/7_CUDALibraries/" subdir
+
+        "../",                                      // up 1 in tree
+        "../common/",                               // up 1 in tree, "/common/" subdir
+        "../common/data/",                          // up 1 in tree, "/common/data/" subdir
+        "../data/",                                 // up 1 in tree, "/data/" subdir
+        "../src/",                                  // up 1 in tree, "/src/" subdir
+        "../inc/",                                  // up 1 in tree, "/inc/" subdir
+        "../C/src/<executable_name>/",              // up 1 in tree, "/C/src/<executable_name>/" subdir
+        "../C/src/<executable_name>/data/",         // up 1 in tree, "/C/src/<executable_name>/data/" subdir
+        "../C/src/<executable_name>/src/",          // up 1 in tree, "/C/src/<executable_name>/src/" subdir
+        "../C/src/<executable_name>/inc/",          // up 1 in tree, "/C/src/<executable_name>/inc/" subdir
+        "../C/",                                      // up 1 in tree
+        "../C/common/",                               // up 1 in tree, "/common/" subdir
+        "../C/common/data/",                          // up 1 in tree, "/common/data/" subdir
+        "../C/data/",                                 // up 1 in tree, "/data/" subdir
+        "../C/src/",                                  // up 1 in tree, "/src/" subdir
+        "../C/inc/",                                  // up 1 in tree, "/inc/" subdir
+        "../C/0_Simple/<executable_name>/data/",         // up 1 in tree, "/0_Simple/<executable_name>/" subdir
+        "../C/1_Utilities/<executable_name>/data/",      // up 1 in tree, "/1_Utilities/<executable_name>/" subdir
+        "../C/2_Graphics/<executable_name>/data/",       // up 1 in tree, "/2_Graphics/<executable_name>/" subdir
+        "../C/3_Imaging/<executable_name>/data/",        // up 1 in tree, "/3_Imaging/<executable_name>/" subdir
+        "../C/4_Financial/<executable_name>/data/",      // up 1 in tree, "/4_Financial/<executable_name>/" subdir
+        "../C/5_Simulations/<executable_name>/data/",    // up 1 in tree, "/5_Simulations/<executable_name>/" subdir
+        "../C/6_Advanced/<executable_name>/data/",       // up 1 in tree, "/6_Advanced/<executable_name>/" subdir
+        "../C/7_CUDALibraries/<executable_name>/data/",  // up 1 in tree, "/7_CUDALibraries/<executable_name>/" subdir
+
+        "../0_Simple/<executable_name>/data/",           // up 1 in tree, "/0_Simple/<executable_name>/" subdir
+        "../1_Utilities/<executable_name>/data/",        // up 1 in tree, "/1_Utilities/<executable_name>/" subdir
+        "../2_Graphics/<executable_name>/data/",         // up 1 in tree, "/2_Graphics/<executable_name>/" subdir
+        "../3_Imaging/<executable_name>/data/",          // up 1 in tree, "/3_Imaging/<executable_name>/" subdir
+        "../4_Financial/<executable_name>/data/",        // up 1 in tree, "/4_Financial/<executable_name>/" subdir
+        "../5_Simulations/<executable_name>/data/",      // up 1 in tree, "/5_Simulations/<executable_name>/" subdir
+        "../6_Advanced/<executable_name>/data/",         // up 1 in tree, "/6_Advanced/<executable_name>/" subdir
+        "../7_CUDALibraries/<executable_name>/data/",    // up 1 in tree, "/7_CUDALibraries/<executable_name>/" subdir
+        "../../",                                   // up 2 in tree
+        "../../common/",                            // up 2 in tree, "/common/" subdir
+        "../../common/data/",                       // up 2 in tree, "/common/data/" subdir
+        "../../data/",                              // up 2 in tree, "/data/" subdir
+        "../../src/",                               // up 2 in tree, "/src/" subdir
+        "../../inc/",                               // up 2 in tree, "/inc/" subdir
+        "../../sandbox/<executable_name>/data/",    // up 2 in tree, "/sandbox/<executable_name>/" subdir
+        "../../0_Simple/<executable_name>/data/",        // up 2 in tree, "/0_Simple/<executable_name>/" subdir
+        "../../1_Utilities/<executable_name>/data/",     // up 2 in tree, "/1_Utilities/<executable_name>/" subdir
+        "../../2_Graphics/<executable_name>/data/",      // up 2 in tree, "/2_Graphics/<executable_name>/" subdir
+        "../../3_Imaging/<executable_name>/data/",       // up 2 in tree, "/3_Imaging/<executable_name>/" subdir
+        "../../4_Financial/<executable_name>/data/",     // up 2 in tree, "/4_Financial/<executable_name>/" subdir
+        "../../5_Simulations/<executable_name>/data/",   // up 2 in tree, "/5_Simulations/<executable_name>/" subdir
+        "../../6_Advanced/<executable_name>/data/",      // up 2 in tree, "/6_Advanced/<executable_name>/" subdir
+        "../../7_CUDALibraries/<executable_name>/data/", // up 2 in tree, "/7_CUDALibraries/<executable_name>/" subdir
+        "../../../",                                // up 3 in tree
+        "../../../src/<executable_name>/",          // up 3 in tree, "/src/<executable_name>/" subdir
+        "../../../src/<executable_name>/data/",     // up 3 in tree, "/src/<executable_name>/data/" subdir
+        "../../../src/<executable_name>/src/",      // up 3 in tree, "/src/<executable_name>/src/" subdir
+        "../../../src/<executable_name>/inc/",      // up 3 in tree, "/src/<executable_name>/inc/" subdir
+        "../../../sandbox/<executable_name>/",      // up 3 in tree, "/sandbox/<executable_name>/" subdir
+        "../../../sandbox/<executable_name>/data/", // up 3 in tree, "/sandbox/<executable_name>/data/" subdir
+        "../../../sandbox/<executable_name>/src/",  // up 3 in tree, "/sandbox/<executable_name>/src/" subdir
+        "../../../sandbox/<executable_name>/inc/",   // up 3 in tree, "/sandbox/<executable_name>/inc/" subdir
+        "../../../0_Simple/<executable_name>/data/",     // up 3 in tree, "/0_Simple/<executable_name>/" subdir
+        "../../../1_Utilities/<executable_name>/data/",  // up 3 in tree, "/1_Utilities/<executable_name>/" subdir
+        "../../../2_Graphics/<executable_name>/data/",   // up 3 in tree, "/2_Graphics/<executable_name>/" subdir
+        "../../../3_Imaging/<executable_name>/data/",    // up 3 in tree, "/3_Imaging/<executable_name>/" subdir
+        "../../../4_Financial/<executable_name>/data/",  // up 3 in tree, "/4_Financial/<executable_name>/" subdir
+        "../../../5_Simulations/<executable_name>/data/",// up 3 in tree, "/5_Simulations/<executable_name>/" subdir
+        "../../../6_Advanced/<executable_name>/data/",   // up 3 in tree, "/6_Advanced/<executable_name>/" subdir
+        "../../../7_CUDALibraries/<executable_name>/data/", // up 3 in tree, "/7_CUDALibraries/<executable_name>/" subdir
+        "../../../common/",                         // up 3 in tree, "../../../common/" subdir
+        "../../../common/data/",                    // up 3 in tree, "../../../common/data/" subdir
+        "../../../data/",                           // up 3 in tree, "../../../data/" subdir
+    };
+
+    // Extract the executable name
+    std::string executable_name;
+
+    if (executable_path != 0)
+    {
+        executable_name = std::string(executable_path);
+
+#ifdef _WIN32
+        // Windows path delimiter
+        size_t delimiter_pos = executable_name.find_last_of('\\');
+        executable_name.erase(0, delimiter_pos + 1);
+
+        if (executable_name.rfind(".exe") != std::string::npos)
+        {
+            // we strip .exe, only if the .exe is found
+            executable_name.resize(executable_name.size() - 4);
+        }
+
+#else
+        // Linux & OSX path delimiter
+        size_t delimiter_pos = executable_name.find_last_of('/');
+        executable_name.erase(0,delimiter_pos+1);
+#endif
+    }
+
+    // Loop over all search paths and return the first hit
+    for (unsigned int i = 0; i < sizeof(searchPath)/sizeof(char *); ++i)
+    {
+        std::string path(searchPath[i]);
+        size_t executable_name_pos = path.find("<executable_name>");
+
+        // If there is executable_name variable in the searchPath
+        // replace it with the value
+        if (executable_name_pos != std::string::npos)
+        {
+            if (executable_path != 0)
+            {
+                path.replace(executable_name_pos, strlen("<executable_name>"), executable_name);
+            }
+            else
+            {
+                // Skip this path entry if no executable argument is given
+                continue;
+            }
+        }
+
+#ifdef _DEBUG
+        printf("sdkFindFilePath <%s> in %s\n", filename, path.c_str());
+#endif
+
+        // Test if the file exists
+        path.append(filename);
+        FILE *fp;
+        FOPEN(fp, path.c_str(), "rb");
+
+        if (fp != NULL)
+        {
+            fclose(fp);
+            // File found
+            // returning an allocated array here for backwards compatibility reasons
+            char *file_path = (char *) malloc(path.length() + 1);
+            STRCPY(file_path, path.length() + 1, path.c_str());
+            return file_path;
+        }
+
+        if (fp)
+        {
+            fclose(fp);
+        }
+    }
+
+    // File not found
+    return 0;
+}
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/helper_timer.h gpu-rodinia_new/cuda/cfd/common/inc/helper_timer.h
--- gpu-rodinia/cuda/cfd/common/inc/helper_timer.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/helper_timer.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,495 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+// Helper Timing Functions
+#ifndef HELPER_TIMER_H
+#define HELPER_TIMER_H
+
+// includes, system
+#include <vector>
+
+// includes, project
+#include <exception.h>
+
+// Definition of the StopWatch Interface, this is used if we don't want to use the CUT functions
+// But rather in a self contained class interface
+class StopWatchInterface
+{
+    public:
+        StopWatchInterface() {};
+        virtual ~StopWatchInterface() {};
+
+    public:
+        //! Start time measurement
+        virtual void start() = 0;
+
+        //! Stop time measurement
+        virtual void stop() = 0;
+
+        //! Reset time counters to zero
+        virtual void reset() = 0;
+
+        //! Time in msec. after start. If the stop watch is still running (i.e. there
+        //! was no call to stop()) then the elapsed time is returned, otherwise the
+        //! time between the last start() and stop call is returned
+        virtual float getTime() = 0;
+
+        //! Mean time to date based on the number of times the stopwatch has been
+        //! _stopped_ (ie finished sessions) and the current total time
+        virtual float getAverageTime() = 0;
+};
+
+
+//////////////////////////////////////////////////////////////////
+// Begin Stopwatch timer class definitions for all OS platforms //
+//////////////////////////////////////////////////////////////////
+#ifdef WIN32
+// includes, system
+#define WINDOWS_LEAN_AND_MEAN
+#include <windows.h>
+#undef min
+#undef max
+
+//! Windows specific implementation of StopWatch
+class StopWatchWin : public StopWatchInterface
+{
+    public:
+        //! Constructor, default
+        StopWatchWin() :
+            start_time(),     end_time(),
+            diff_time(0.0f),  total_time(0.0f),
+            running(false), clock_sessions(0), freq(0), freq_set(false)
+        {
+            if (! freq_set)
+            {
+                // helper variable
+                LARGE_INTEGER temp;
+
+                // get the tick frequency from the OS
+                QueryPerformanceFrequency((LARGE_INTEGER *) &temp);
+
+                // convert to type in which it is needed
+                freq = ((double) temp.QuadPart) / 1000.0;
+
+                // rememeber query
+                freq_set = true;
+            }
+        };
+
+        // Destructor
+        ~StopWatchWin() { };
+
+    public:
+        //! Start time measurement
+        inline void start();
+
+        //! Stop time measurement
+        inline void stop();
+
+        //! Reset time counters to zero
+        inline void reset();
+
+        //! Time in msec. after start. If the stop watch is still running (i.e. there
+        //! was no call to stop()) then the elapsed time is returned, otherwise the
+        //! time between the last start() and stop call is returned
+        inline float getTime();
+
+        //! Mean time to date based on the number of times the stopwatch has been
+        //! _stopped_ (ie finished sessions) and the current total time
+        inline float getAverageTime();
+
+    private:
+        // member variables
+
+        //! Start of measurement
+        LARGE_INTEGER  start_time;
+        //! End of measurement
+        LARGE_INTEGER  end_time;
+
+        //! Time difference between the last start and stop
+        float  diff_time;
+
+        //! TOTAL time difference between starts and stops
+        float  total_time;
+
+        //! flag if the stop watch is running
+        bool running;
+
+        //! Number of times clock has been started
+        //! and stopped to allow averaging
+        int clock_sessions;
+
+        //! tick frequency
+        double  freq;
+
+        //! flag if the frequency has been set
+        bool  freq_set;
+};
+
+// functions, inlined
+
+////////////////////////////////////////////////////////////////////////////////
+//! Start time measurement
+////////////////////////////////////////////////////////////////////////////////
+inline void
+StopWatchWin::start()
+{
+    QueryPerformanceCounter((LARGE_INTEGER *) &start_time);
+    running = true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Stop time measurement and increment add to the current diff_time summation
+//! variable. Also increment the number of times this clock has been run.
+////////////////////////////////////////////////////////////////////////////////
+inline void
+StopWatchWin::stop()
+{
+    QueryPerformanceCounter((LARGE_INTEGER *) &end_time);
+    diff_time = (float)
+                (((double) end_time.QuadPart - (double) start_time.QuadPart) / freq);
+
+    total_time += diff_time;
+    clock_sessions++;
+    running = false;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Reset the timer to 0. Does not change the timer running state but does
+//! recapture this point in time as the current start time if it is running.
+////////////////////////////////////////////////////////////////////////////////
+inline void
+StopWatchWin::reset()
+{
+    diff_time = 0;
+    total_time = 0;
+    clock_sessions = 0;
+
+    if (running)
+    {
+        QueryPerformanceCounter((LARGE_INTEGER *) &start_time);
+    }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+//! Time in msec. after start. If the stop watch is still running (i.e. there
+//! was no call to stop()) then the elapsed time is returned added to the
+//! current diff_time sum, otherwise the current summed time difference alone
+//! is returned.
+////////////////////////////////////////////////////////////////////////////////
+inline float
+StopWatchWin::getTime()
+{
+    // Return the TOTAL time to date
+    float retval = total_time;
+
+    if (running)
+    {
+        LARGE_INTEGER temp;
+        QueryPerformanceCounter((LARGE_INTEGER *) &temp);
+        retval += (float)
+                  (((double)(temp.QuadPart - start_time.QuadPart)) / freq);
+    }
+
+    return retval;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Time in msec. for a single run based on the total number of COMPLETED runs
+//! and the total time.
+////////////////////////////////////////////////////////////////////////////////
+inline float
+StopWatchWin::getAverageTime()
+{
+    return (clock_sessions > 0) ? (total_time/clock_sessions) : 0.0f;
+}
+#else
+// Declarations for Stopwatch on Linux and Mac OSX
+// includes, system
+#include <ctime>
+#include <sys/time.h>
+
+//! Windows specific implementation of StopWatch
+class StopWatchLinux : public StopWatchInterface
+{
+    public:
+        //! Constructor, default
+        StopWatchLinux() :
+            start_time(), diff_time(0.0), total_time(0.0),
+            running(false), clock_sessions(0)
+        { };
+
+        // Destructor
+        virtual ~StopWatchLinux()
+        { };
+
+    public:
+        //! Start time measurement
+        inline void start();
+
+        //! Stop time measurement
+        inline void stop();
+
+        //! Reset time counters to zero
+        inline void reset();
+
+        //! Time in msec. after start. If the stop watch is still running (i.e. there
+        //! was no call to stop()) then the elapsed time is returned, otherwise the
+        //! time between the last start() and stop call is returned
+        inline float getTime();
+
+        //! Mean time to date based on the number of times the stopwatch has been
+        //! _stopped_ (ie finished sessions) and the current total time
+        inline float getAverageTime();
+
+    private:
+
+        // helper functions
+
+        //! Get difference between start time and current time
+        inline float getDiffTime();
+
+    private:
+
+        // member variables
+
+        //! Start of measurement
+        struct timeval  start_time;
+
+        //! Time difference between the last start and stop
+        float  diff_time;
+
+        //! TOTAL time difference between starts and stops
+        float  total_time;
+
+        //! flag if the stop watch is running
+        bool running;
+
+        //! Number of times clock has been started
+        //! and stopped to allow averaging
+        int clock_sessions;
+};
+
+// functions, inlined
+
+////////////////////////////////////////////////////////////////////////////////
+//! Start time measurement
+////////////////////////////////////////////////////////////////////////////////
+inline void
+StopWatchLinux::start()
+{
+    gettimeofday(&start_time, 0);
+    running = true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Stop time measurement and increment add to the current diff_time summation
+//! variable. Also increment the number of times this clock has been run.
+////////////////////////////////////////////////////////////////////////////////
+inline void
+StopWatchLinux::stop()
+{
+    diff_time = getDiffTime();
+    total_time += diff_time;
+    running = false;
+    clock_sessions++;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Reset the timer to 0. Does not change the timer running state but does
+//! recapture this point in time as the current start time if it is running.
+////////////////////////////////////////////////////////////////////////////////
+inline void
+StopWatchLinux::reset()
+{
+    diff_time = 0;
+    total_time = 0;
+    clock_sessions = 0;
+
+    if (running)
+    {
+        gettimeofday(&start_time, 0);
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Time in msec. after start. If the stop watch is still running (i.e. there
+//! was no call to stop()) then the elapsed time is returned added to the
+//! current diff_time sum, otherwise the current summed time difference alone
+//! is returned.
+////////////////////////////////////////////////////////////////////////////////
+inline float
+StopWatchLinux::getTime()
+{
+    // Return the TOTAL time to date
+    float retval = total_time;
+
+    if (running)
+    {
+        retval += getDiffTime();
+    }
+
+    return retval;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Time in msec. for a single run based on the total number of COMPLETED runs
+//! and the total time.
+////////////////////////////////////////////////////////////////////////////////
+inline float
+StopWatchLinux::getAverageTime()
+{
+    return (clock_sessions > 0) ? (total_time/clock_sessions) : 0.0f;
+}
+////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////
+inline float
+StopWatchLinux::getDiffTime()
+{
+    struct timeval t_time;
+    gettimeofday(&t_time, 0);
+
+    // time difference in milli-seconds
+    return (float)(1000.0 * (t_time.tv_sec - start_time.tv_sec)
+                   + (0.001 * (t_time.tv_usec - start_time.tv_usec)));
+}
+#endif // _WIN32
+
+////////////////////////////////////////////////////////////////////////////////
+//! Timer functionality exported
+
+////////////////////////////////////////////////////////////////////////////////
+//! Create a new timer
+//! @return true if a time has been created, otherwise false
+//! @param  name of the new timer, 0 if the creation failed
+////////////////////////////////////////////////////////////////////////////////
+inline bool
+sdkCreateTimer(StopWatchInterface **timer_interface)
+{
+    //printf("sdkCreateTimer called object %08x\n", (void *)*timer_interface);
+#ifdef _WIN32
+    *timer_interface = (StopWatchInterface *)new StopWatchWin();
+#else
+    *timer_interface = (StopWatchInterface *)new StopWatchLinux();
+#endif
+    return (*timer_interface != NULL) ? true : false;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+//! Delete a timer
+//! @return true if a time has been deleted, otherwise false
+//! @param  name of the timer to delete
+////////////////////////////////////////////////////////////////////////////////
+inline bool
+sdkDeleteTimer(StopWatchInterface **timer_interface)
+{
+    //printf("sdkDeleteTimer called object %08x\n", (void *)*timer_interface);
+    if (*timer_interface)
+    {
+        delete *timer_interface;
+        *timer_interface = NULL;
+    }
+
+    return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Start the time with name \a name
+//! @param name  name of the timer to start
+////////////////////////////////////////////////////////////////////////////////
+inline bool
+sdkStartTimer(StopWatchInterface **timer_interface)
+{
+    //printf("sdkStartTimer called object %08x\n", (void *)*timer_interface);
+    if (*timer_interface)
+    {
+        (*timer_interface)->start();
+    }
+
+    return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Stop the time with name \a name. Does not reset.
+//! @param name  name of the timer to stop
+////////////////////////////////////////////////////////////////////////////////
+inline bool
+sdkStopTimer(StopWatchInterface **timer_interface)
+{
+    // printf("sdkStopTimer called object %08x\n", (void *)*timer_interface);
+    if (*timer_interface)
+    {
+        (*timer_interface)->stop();
+    }
+
+    return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Resets the timer's counter.
+//! @param name  name of the timer to reset.
+////////////////////////////////////////////////////////////////////////////////
+inline bool
+sdkResetTimer(StopWatchInterface **timer_interface)
+{
+    // printf("sdkResetTimer called object %08x\n", (void *)*timer_interface);
+    if (*timer_interface)
+    {
+        (*timer_interface)->reset();
+    }
+
+    return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Return the average time for timer execution as the total time
+//! for the timer dividied by the number of completed (stopped) runs the timer
+//! has made.
+//! Excludes the current running time if the timer is currently running.
+//! @param name  name of the timer to return the time of
+////////////////////////////////////////////////////////////////////////////////
+inline float
+sdkGetAverageTimerValue(StopWatchInterface **timer_interface)
+{
+    //  printf("sdkGetAverageTimerValue called object %08x\n", (void *)*timer_interface);
+    if (*timer_interface)
+    {
+        return (*timer_interface)->getAverageTime();
+    }
+    else
+    {
+        return 0.0f;
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//! Total execution time for the timer over all runs since the last reset
+//! or timer creation.
+//! @param name  name of the timer to obtain the value of.
+////////////////////////////////////////////////////////////////////////////////
+inline float
+sdkGetTimerValue(StopWatchInterface **timer_interface)
+{
+    // printf("sdkGetTimerValue called object %08x\n", (void *)*timer_interface);
+    if (*timer_interface)
+    {
+        return (*timer_interface)->getTime();
+    }
+    else
+    {
+        return 0.0f;
+    }
+}
+
+#endif // HELPER_TIMER_H
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/multithreading.h gpu-rodinia_new/cuda/cfd/common/inc/multithreading.h
--- gpu-rodinia/cuda/cfd/common/inc/multithreading.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/multithreading.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,60 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+#ifndef MULTITHREADING_H
+#define MULTITHREADING_H
+
+
+//Simple portable thread library.
+
+#if _WIN32
+//Windows threads.
+#include <windows.h>
+
+typedef HANDLE CUTThread;
+typedef unsigned(WINAPI *CUT_THREADROUTINE)(void *);
+
+#define CUT_THREADPROC unsigned WINAPI
+#define  CUT_THREADEND return 0
+
+#else
+//POSIX threads.
+#include <pthread.h>
+
+typedef pthread_t CUTThread;
+typedef void *(*CUT_THREADROUTINE)(void *);
+
+#define CUT_THREADPROC void
+#define  CUT_THREADEND
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    //Create thread.
+    CUTThread cutStartThread(CUT_THREADROUTINE, void *data);
+
+    //Wait for thread to finish.
+    void cutEndThread(CUTThread thread);
+
+    //Destroy thread.
+    void cutDestroyThread(CUTThread thread);
+
+    //Wait for multiple threads.
+    void cutWaitForThreads(const CUTThread *threads, int num);
+
+#ifdef __cplusplus
+} //extern "C"
+#endif
+
+#endif //MULTITHREADING_H
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/nvMath.h gpu-rodinia_new/cuda/cfd/common/inc/nvMath.h
--- gpu-rodinia/cuda/cfd/common/inc/nvMath.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/nvMath.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,95 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//
+// Template math library for common 3D functionality
+//
+// This code is in part deriver from glh, a cross platform glut helper library.
+// The copyright for glh follows this notice.
+//
+// Copyright (c) NVIDIA Corporation. All rights reserved.
+////////////////////////////////////////////////////////////////////////////////
+
+/*
+    Copyright (c) 2000 Cass Everitt
+    Copyright (c) 2000 NVIDIA Corporation
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or
+    without modification, are permitted provided that the following
+    conditions are met:
+
+     * Redistributions of source code must retain the above
+       copyright notice, this list of conditions and the following
+       disclaimer.
+
+     * Redistributions in binary form must reproduce the above
+       copyright notice, this list of conditions and the following
+       disclaimer in the documentation and/or other materials
+       provided with the distribution.
+
+     * The names of contributors to this software may not be used
+       to endorse or promote products derived from this software
+       without specific prior written permission.
+
+       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+       ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+       FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+       REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+       INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+       BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+       CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+       LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+       ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+       POSSIBILITY OF SUCH DAMAGE.
+
+
+    Cass Everitt - cass@r3.nu
+*/
+
+#ifndef NV_MATH_H
+#define NV_MATH_H
+
+#include <math.h>
+
+#include <nvVector.h>
+#include <nvMatrix.h>
+#include <nvQuaternion.h>
+
+#define NV_PI   float(3.1415926535897932384626433832795)
+
+namespace nv
+{
+
+    typedef vec2<float> vec2f;
+    typedef vec3<float> vec3f;
+    typedef vec3<int> vec3i;
+    typedef vec3<unsigned int> vec3ui;
+    typedef vec4<float> vec4f;
+    typedef matrix4<float> matrix4f;
+    typedef quaternion<float> quaternionf;
+
+
+    inline void applyRotation(const quaternionf &r)
+    {
+        float angle;
+        vec3f axis;
+        r.get_value(axis, angle);
+        glRotatef(angle/3.1415926f * 180.0f, axis[0], axis[1], axis[2]);
+    }
+
+
+
+};
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/nvMatrix.h gpu-rodinia_new/cuda/cfd/common/inc/nvMatrix.h
--- gpu-rodinia/cuda/cfd/common/inc/nvMatrix.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/nvMatrix.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,524 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//
+// Template math library for common 3D functionality
+//
+// nvMatrix.h - template matrix code
+//
+// This code is in part deriver from glh, a cross platform glut helper library.
+// The copyright for glh follows this notice.
+//
+// Copyright (c) NVIDIA Corporation. All rights reserved.
+////////////////////////////////////////////////////////////////////////////////
+
+/*
+    Copyright (c) 2000 Cass Everitt
+    Copyright (c) 2000 NVIDIA Corporation
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or
+    without modification, are permitted provided that the following
+    conditions are met:
+
+     * Redistributions of source code must retain the above
+       copyright notice, this list of conditions and the following
+       disclaimer.
+
+     * Redistributions in binary form must reproduce the above
+       copyright notice, this list of conditions and the following
+       disclaimer in the documentation and/or other materials
+       provided with the distribution.
+
+     * The names of contributors to this software may not be used
+       to endorse or promote products derived from this software
+       without specific prior written permission.
+
+       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+       ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+       FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+       REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+       INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+       BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+       CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+       LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+       ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+       POSSIBILITY OF SUCH DAMAGE.
+
+
+    Cass Everitt - cass@r3.nu
+*/
+
+#ifndef NV_MATRIX_H
+#define NV_MATRIX_H
+
+namespace nv
+{
+
+    template <class T> class vec2;
+    template <class T> class vec3;
+    template <class T> class vec4;
+
+    ////////////////////////////////////////////////////////////////////////////////
+    //
+    //  Matrix
+    //
+    ////////////////////////////////////////////////////////////////////////////////
+    template<class T>
+    class matrix4
+    {
+
+        public:
+
+            matrix4()
+            {
+                make_identity();
+            }
+
+            matrix4(T t)
+            {
+                set_value(t);
+            }
+
+            matrix4(const T *m)
+            {
+                set_value(m);
+            }
+
+            matrix4(T a00, T a01, T a02, T a03,
+                    T a10, T a11, T a12, T a13,
+                    T a20, T a21, T a22, T a23,
+                    T a30, T a31, T a32, T a33) :
+                _11(a00), _12(a01), _13(a02), _14(a03),
+                _21(a10), _22(a11), _23(a12), _24(a13),
+                _31(a20), _32(a21), _33(a22), _34(a23),
+                _41(a30), _42(a31), _43(a32), _44(a33)
+            {}
+
+
+            void get_value(T *mp) const
+            {
+                int c = 0;
+
+                for (int j=0; j < 4; j++)
+                    for (int i=0; i < 4; i++)
+                    {
+                        mp[c++] = element(i,j);
+                    }
+            }
+
+            const T *get_value() const
+            {
+                return _array;
+            }
+
+            void set_value(T *mp)
+            {
+                int c = 0;
+
+                for (int j=0; j < 4; j++)
+                    for (int i=0; i < 4; i++)
+                    {
+                        element(i,j) = mp[c++];
+                    }
+            }
+
+            void set_value(T r)
+            {
+                for (int i=0; i < 4; i++)
+                    for (int j=0; j < 4; j++)
+                    {
+                        element(i,j) = r;
+                    }
+            }
+
+            void make_identity()
+            {
+                element(0,0) = 1.0;
+                element(0,1) = 0.0;
+                element(0,2) = 0.0;
+                element(0,3) = 0.0;
+
+                element(1,0) = 0.0;
+                element(1,1) = 1.0;
+                element(1,2) = 0.0;
+                element(1,3) = 0.0;
+
+                element(2,0) = 0.0;
+                element(2,1) = 0.0;
+                element(2,2) = 1.0;
+                element(2,3) = 0.0;
+
+                element(3,0) = 0.0;
+                element(3,1) = 0.0;
+                element(3,2) = 0.0;
+                element(3,3) = 1.0;
+            }
+
+            // set a uniform scale
+            void set_scale(T s)
+            {
+                element(0,0) = s;
+                element(1,1) = s;
+                element(2,2) = s;
+            }
+
+            void set_scale(const vec3<T> &s)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    element(i,i) = s[i];
+                }
+            }
+
+
+            void set_translate(const vec3<T> &t)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    element(i,3) = t[i];
+                }
+            }
+
+            void set_row(int r, const vec4<T> &t)
+            {
+                for (int i = 0; i < 4; i++)
+                {
+                    element(r,i) = t[i];
+                }
+            }
+
+            void set_column(int c, const vec4<T> &t)
+            {
+                for (int i = 0; i < 4; i++)
+                {
+                    element(i,c) = t[i];
+                }
+            }
+
+            vec4<T> get_row(int r) const
+            {
+                vec4<T> v;
+
+                for (int i = 0; i < 4; i++)
+                {
+                    v[i] = element(r,i);
+                }
+
+                return v;
+            }
+
+            vec4<T> get_column(int c) const
+            {
+                vec4<T> v;
+
+                for (int i = 0; i < 4; i++)
+                {
+                    v[i] = element(i,c);
+                }
+
+                return v;
+            }
+
+            friend matrix4 inverse(const matrix4 &m)
+            {
+                matrix4 minv;
+
+                T r1[8], r2[8], r3[8], r4[8];
+                T *s[4], *tmprow;
+
+                s[0] = &r1[0];
+                s[1] = &r2[0];
+                s[2] = &r3[0];
+                s[3] = &r4[0];
+
+                register int i,j,p,jj;
+
+                for (i=0; i<4; i++)
+                {
+                    for (j=0; j<4; j++)
+                    {
+                        s[i][j] = m.element(i,j);
+
+                        if (i==j)
+                        {
+                            s[i][j+4] = 1.0;
+                        }
+                        else
+                        {
+                            s[i][j+4] = 0.0;
+                        }
+                    }
+                }
+
+                T scp[4];
+
+                for (i=0; i<4; i++)
+                {
+                    scp[i] = T(fabs(s[i][0]));
+
+                    for (j=1; j<4; j++)
+                        if (T(fabs(s[i][j])) > scp[i])
+                        {
+                            scp[i] = T(fabs(s[i][j]));
+                        }
+
+                    if (scp[i] == 0.0)
+                    {
+                        return minv;    // singular matrix!
+                    }
+                }
+
+                int pivot_to;
+                T scp_max;
+
+                for (i=0; i<4; i++)
+                {
+                    // select pivot row
+                    pivot_to = i;
+                    scp_max = T(fabs(s[i][i]/scp[i]));
+
+                    // find out which row should be on top
+                    for (p=i+1; p<4; p++)
+                        if (T(fabs(s[p][i]/scp[p])) > scp_max)
+                        {
+                            scp_max = T(fabs(s[p][i]/scp[p]));
+                            pivot_to = p;
+                        }
+
+                    // Pivot if necessary
+                    if (pivot_to != i)
+                    {
+                        tmprow = s[i];
+                        s[i] = s[pivot_to];
+                        s[pivot_to] = tmprow;
+                        T tmpscp;
+                        tmpscp = scp[i];
+                        scp[i] = scp[pivot_to];
+                        scp[pivot_to] = tmpscp;
+                    }
+
+                    T mji;
+
+                    // perform gaussian elimination
+                    for (j=i+1; j<4; j++)
+                    {
+                        mji = s[j][i]/s[i][i];
+                        s[j][i] = 0.0;
+
+                        for (jj=i+1; jj<8; jj++)
+                        {
+                            s[j][jj] -= mji*s[i][jj];
+                        }
+                    }
+                }
+
+                if (s[3][3] == 0.0)
+                {
+                    return minv;    // singular matrix!
+                }
+
+                //
+                // Now we have an upper triangular matrix.
+                //
+                //  x x x x | y y y y
+                //  0 x x x | y y y y
+                //  0 0 x x | y y y y
+                //  0 0 0 x | y y y y
+                //
+                //  we'll back substitute to get the inverse
+                //
+                //  1 0 0 0 | z z z z
+                //  0 1 0 0 | z z z z
+                //  0 0 1 0 | z z z z
+                //  0 0 0 1 | z z z z
+                //
+
+                T mij;
+
+                for (i=3; i>0; i--)
+                {
+                    for (j=i-1; j > -1; j--)
+                    {
+                        mij = s[j][i]/s[i][i];
+
+                        for (jj=j+1; jj<8; jj++)
+                        {
+                            s[j][jj] -= mij*s[i][jj];
+                        }
+                    }
+                }
+
+                for (i=0; i<4; i++)
+                    for (j=0; j<4; j++)
+                    {
+                        minv(i,j) = s[i][j+4] / s[i][i];
+                    }
+
+                return minv;
+            }
+
+
+            friend matrix4 transpose(const matrix4 &m)
+            {
+                matrix4 mtrans;
+
+                for (int i=0; i<4; i++)
+                    for (int j=0; j<4; j++)
+                    {
+                        mtrans(i,j) = m.element(j,i);
+                    }
+
+                return mtrans;
+            }
+
+            matrix4 &operator *= (const matrix4 &rhs)
+            {
+                matrix4 mt(*this);
+                set_value(T(0));
+
+                for (int i=0; i < 4; i++)
+                    for (int j=0; j < 4; j++)
+                        for (int c=0; c < 4; c++)
+                        {
+                            element(i,j) += mt(i,c) * rhs(c,j);
+                        }
+
+                return *this;
+            }
+
+            friend matrix4 operator * (const matrix4 &lhs, const matrix4 &rhs)
+            {
+                matrix4 r(T(0));
+
+                for (int i=0; i < 4; i++)
+                    for (int j=0; j < 4; j++)
+                        for (int c=0; c < 4; c++)
+                        {
+                            r.element(i,j) += lhs(i,c) * rhs(c,j);
+                        }
+
+                return r;
+            }
+
+            // dst = M * src
+            vec4<T> operator *(const vec4<T> &src) const
+            {
+                vec4<T> r;
+
+                for (int i = 0; i < 4; i++)
+                    r[i]  = (src[0] * element(i,0) + src[1] * element(i,1) +
+                             src[2] * element(i,2) + src[3] * element(i,3));
+
+                return r;
+            }
+
+            // dst = src * M
+            friend vec4<T> operator *(const vec4<T> &lhs, const matrix4 &rhs)
+            {
+                vec4<T> r;
+
+                for (int i = 0; i < 4; i++)
+                    r[i]  = (lhs[0] * rhs.element(0,i) + lhs[1] * rhs.element(1,i) +
+                             lhs[2] * rhs.element(2,i) + lhs[3] * rhs.element(3,i));
+
+                return r;
+            }
+
+            T &operator()(int row, int col)
+            {
+                return element(row,col);
+            }
+
+            const T &operator()(int row, int col) const
+            {
+                return element(row,col);
+            }
+
+            T &element(int row, int col)
+            {
+                return _array[row | (col<<2)];
+            }
+
+            const T &element(int row, int col) const
+            {
+                return _array[row | (col<<2)];
+            }
+
+            matrix4 &operator *= (const T &r)
+            {
+                for (int i = 0; i < 4; ++i)
+                {
+                    element(0,i) *= r;
+                    element(1,i) *= r;
+                    element(2,i) *= r;
+                    element(3,i) *= r;
+                }
+
+                return *this;
+            }
+
+            matrix4 &operator += (const matrix4 &mat)
+            {
+                for (int i = 0; i < 4; ++i)
+                {
+                    element(0,i) += mat.element(0,i);
+                    element(1,i) += mat.element(1,i);
+                    element(2,i) += mat.element(2,i);
+                    element(3,i) += mat.element(3,i);
+                }
+
+                return *this;
+            }
+
+
+            friend bool operator == (const matrix4 &lhs, const matrix4 &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < 16; i++)
+                {
+                    r &= lhs._array[i] == rhs._array[i];
+                }
+
+                return r;
+            }
+
+            friend bool operator != (const matrix4 &lhs, const matrix4 &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < 16; i++)
+                {
+                    r &= lhs._array[i] != rhs._array[i];
+                }
+
+                return r;
+            }
+
+            union
+            {
+                struct
+                {
+                    T _11, _12, _13, _14;   // standard names for components
+                    T _21, _22, _23, _24;   // standard names for components
+                    T _31, _32, _33, _34;   // standard names for components
+                    T _41, _42, _43, _44;   // standard names for components
+                };
+                T _array[16];     // array access
+            };
+    };
+
+};
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/nvQuaternion.h gpu-rodinia_new/cuda/cfd/common/inc/nvQuaternion.h
--- gpu-rodinia/cuda/cfd/common/inc/nvQuaternion.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/nvQuaternion.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,514 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//
+// Template math library for common 3D functionality
+//
+// nvQuaterion.h - quaternion template and utility functions
+//
+// This code is in part deriver from glh, a cross platform glut helper library.
+// The copyright for glh follows this notice.
+//
+// Copyright (c) NVIDIA Corporation. All rights reserved.
+////////////////////////////////////////////////////////////////////////////////
+
+/*
+    Copyright (c) 2000 Cass Everitt
+    Copyright (c) 2000 NVIDIA Corporation
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or
+    without modification, are permitted provided that the following
+    conditions are met:
+
+     * Redistributions of source code must retain the above
+       copyright notice, this list of conditions and the following
+       disclaimer.
+
+     * Redistributions in binary form must reproduce the above
+       copyright notice, this list of conditions and the following
+       disclaimer in the documentation and/or other materials
+       provided with the distribution.
+
+     * The names of contributors to this software may not be used
+       to endorse or promote products derived from this software
+       without specific prior written permission.
+
+       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+       ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+       FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+       REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+       INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+       BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+       CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+       LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+       ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+       POSSIBILITY OF SUCH DAMAGE.
+
+
+    Cass Everitt - cass@r3.nu
+*/
+#ifndef NV_QUATERNION_H
+#define NV_QUATERNION_H
+
+namespace nv
+{
+
+    template <class T> class vec2;
+    template <class T> class vec3;
+    template <class T> class vec4;
+
+    ////////////////////////////////////////////////////////////////////////////////
+    //
+    //  Quaternion
+    //
+    ////////////////////////////////////////////////////////////////////////////////
+
+    template< class T>
+    class quaternion
+    {
+        public:
+
+            quaternion() : x(0.0), y(0.0), z(0.0), w(0.0)
+            {
+            }
+
+            quaternion(const T v[4])
+            {
+                set_value(v);
+            }
+
+
+            quaternion(T q0, T q1, T q2, T q3)
+            {
+                set_value(q0, q1, q2, q3);
+            }
+
+
+            quaternion(const matrix4<T> &m)
+            {
+                set_value(m);
+            }
+
+
+            quaternion(const vec3<T> &axis, T radians)
+            {
+                set_value(axis, radians);
+            }
+
+
+            quaternion(const vec3<T> &rotateFrom, const vec3<T> &rotateTo)
+            {
+                set_value(rotateFrom, rotateTo);
+            }
+
+            quaternion(const vec3<T> &from_look, const vec3<T> &from_up,
+                       const vec3<T> &to_look, const vec3<T> &to_up)
+            {
+                set_value(from_look, from_up, to_look, to_up);
+            }
+
+            const T *get_value() const
+            {
+                return  &_array[0];
+            }
+
+            void get_value(T &q0, T &q1, T &q2, T &q3) const
+            {
+                q0 = _array[0];
+                q1 = _array[1];
+                q2 = _array[2];
+                q3 = _array[3];
+            }
+
+            quaternion &set_value(T q0, T q1, T q2, T q3)
+            {
+                _array[0] = q0;
+                _array[1] = q1;
+                _array[2] = q2;
+                _array[3] = q3;
+                return *this;
+            }
+
+            void get_value(vec3<T> &axis, T &radians) const
+            {
+                radians = T(acos(_array[3]) * T(2.0));
+
+                if (radians == T(0.0))
+                {
+                    axis = vec3<T>(0.0, 0.0, 1.0);
+                }
+                else
+                {
+                    axis[0] = _array[0];
+                    axis[1] = _array[1];
+                    axis[2] = _array[2];
+                    axis = normalize(axis);
+                }
+            }
+
+            void get_value(matrix4<T> &m) const
+            {
+                T s, xs, ys, zs, wx, wy, wz, xx, xy, xz, yy, yz, zz;
+
+                T norm = _array[0] * _array[0] + _array[1] * _array[1] + _array[2] * _array[2] + _array[3] * _array[3];
+
+                s = (norm == T(0.0)) ? T(0.0) : (T(2.0) / norm);
+
+                xs = _array[0] * s;
+                ys = _array[1] * s;
+                zs = _array[2] * s;
+
+                wx = _array[3] * xs;
+                wy = _array[3] * ys;
+                wz = _array[3] * zs;
+
+                xx = _array[0] * xs;
+                xy = _array[0] * ys;
+                xz = _array[0] * zs;
+
+                yy = _array[1] * ys;
+                yz = _array[1] * zs;
+                zz = _array[2] * zs;
+
+                m(0,0) = T(T(1.0) - (yy + zz));
+                m(1,0) = T(xy + wz);
+                m(2,0) = T(xz - wy);
+
+                m(0,1) = T(xy - wz);
+                m(1,1) = T(T(1.0) - (xx + zz));
+                m(2,1) = T(yz + wx);
+
+                m(0,2) = T(xz + wy);
+                m(1,2) = T(yz - wx);
+                m(2,2) = T(T(1.0) - (xx + yy));
+
+                m(3,0) = m(3,1) = m(3,2) = m(0,3) = m(1,3) = m(2,3) = T(0.0);
+                m(3,3) = T(1.0);
+            }
+
+            quaternion &set_value(const T *qp)
+            {
+                for (int i = 0; i < 4; i++)
+                {
+                    _array[i] = qp[i];
+                }
+
+                return *this;
+            }
+
+            quaternion &set_value(const matrix4<T> &m)
+            {
+                T tr, s;
+                int i, j, k;
+                const int nxt[3] = { 1, 2, 0 };
+
+                tr = m(0,0) + m(1,1) + m(2,2);
+
+                if (tr > T(0))
+                {
+                    s = T(sqrt(tr + m(3,3)));
+                    _array[3] = T(s * 0.5);
+                    s = T(0.5) / s;
+
+                    _array[0] = T((m(1,2) - m(2,1)) * s);
+                    _array[1] = T((m(2,0) - m(0,2)) * s);
+                    _array[2] = T((m(0,1) - m(1,0)) * s);
+                }
+                else
+                {
+                    i = 0;
+
+                    if (m(1,1) > m(0,0))
+                    {
+                        i = 1;
+                    }
+
+                    if (m(2,2) > m(i,i))
+                    {
+                        i = 2;
+                    }
+
+                    j = nxt[i];
+                    k = nxt[j];
+
+                    s = T(sqrt((m(i,j) - (m(j,j) + m(k,k))) + T(1.0)));
+
+                    _array[i] = T(s * 0.5);
+                    s = T(0.5 / s);
+
+                    _array[3] = T((m(j,k) - m(k,j)) * s);
+                    _array[j] = T((m(i,j) + m(j,i)) * s);
+                    _array[k] = T((m(i,k) + m(k,i)) * s);
+                }
+
+                return *this;
+            }
+
+            quaternion &set_value(const vec3<T> &axis, T theta)
+            {
+                T sqnorm = square_norm(axis);
+
+                if (sqnorm == T(0.0))
+                {
+                    // axis too small.
+                    x = y = z = T(0.0);
+                    w = T(1.0);
+                }
+                else
+                {
+                    theta *= T(0.5);
+                    T sin_theta = T(sin(theta));
+
+                    if (sqnorm != T(1))
+                    {
+                        sin_theta /= T(sqrt(sqnorm));
+                    }
+
+                    x = sin_theta * axis[0];
+                    y = sin_theta * axis[1];
+                    z = sin_theta * axis[2];
+                    w = T(cos(theta));
+                }
+
+                return *this;
+            }
+
+            quaternion &set_value(const vec3<T> &rotateFrom, const vec3<T> &rotateTo)
+            {
+                vec3<T> p1, p2;
+                T alpha;
+
+                p1 = normalize(rotateFrom);
+                p2 = normalize(rotateTo);
+
+                alpha = dot(p1, p2);
+
+                if (alpha == T(1.0))
+                {
+                    *this = quaternion();
+                    return *this;
+                }
+
+                // ensures that the anti-parallel case leads to a positive dot
+                if (alpha == T(-1.0))
+                {
+                    vec3<T> v;
+
+                    if (p1[0] != p1[1] || p1[0] != p1[2])
+                    {
+                        v = vec3<T>(p1[1], p1[2], p1[0]);
+                    }
+                    else
+                    {
+                        v = vec3<T>(-p1[0], p1[1], p1[2]);
+                    }
+
+                    v -= p1 * dot(p1, v);
+                    v = normalize(v);
+
+                    set_value(v, T(3.1415926));
+                    return *this;
+                }
+
+                p1 = normalize(cross(p1, p2));
+
+                set_value(p1,T(acos(alpha)));
+
+                return *this;
+            }
+
+            quaternion &set_value(const vec3<T> &from_look, const vec3<T> &from_up,
+                                  const vec3<T> &to_look, const vec3<T> &to_up)
+            {
+                quaternion r_look = quaternion(from_look, to_look);
+
+                vec3<T> rotated_from_up(from_up);
+                r_look.mult_vec(rotated_from_up);
+
+                quaternion r_twist = quaternion(rotated_from_up, to_up);
+
+                *this = r_twist;
+                *this *= r_look;
+                return *this;
+            }
+
+            quaternion &operator *= (const quaternion<T> &qr)
+            {
+                quaternion ql(*this);
+
+                w = ql.w * qr.w - ql.x * qr.x - ql.y * qr.y - ql.z * qr.z;
+                x = ql.w * qr.x + ql.x * qr.w + ql.y * qr.z - ql.z * qr.y;
+                y = ql.w * qr.y + ql.y * qr.w + ql.z * qr.x - ql.x * qr.z;
+                z = ql.w * qr.z + ql.z * qr.w + ql.x * qr.y - ql.y * qr.x;
+
+                return *this;
+            }
+
+            friend quaternion normalize(const quaternion<T> &q)
+            {
+                quaternion r(q);
+                T rnorm = T(1.0) / T(sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z));
+
+                r.x *= rnorm;
+                r.y *= rnorm;
+                r.z *= rnorm;
+                r.w *= rnorm;
+            }
+
+            friend quaternion<T> conjugate(const quaternion<T> &q)
+            {
+                quaternion<T> r(q);
+                r._array[0] *= T(-1.0);
+                r._array[1] *= T(-1.0);
+                r._array[2] *= T(-1.0);
+                return r;
+            }
+
+            friend quaternion<T> inverse(const quaternion<T> &q)
+            {
+                return conjugate(q);
+            }
+
+            //
+            // Quaternion multiplication with cartesian vector
+            // v' = q*v*q(star)
+            //
+            void mult_vec(const vec3<T> &src, vec3<T> &dst) const
+            {
+                T v_coef = w * w - x * x - y * y - z * z;
+                T u_coef = T(2.0) * (src[0] * x + src[1] * y + src[2] * z);
+                T c_coef = T(2.0) * w;
+
+                dst.v[0] = v_coef * src.v[0] + u_coef * x + c_coef * (y * src.v[2] - z * src.v[1]);
+                dst.v[1] = v_coef * src.v[1] + u_coef * y + c_coef * (z * src.v[0] - x * src.v[2]);
+                dst.v[2] = v_coef * src.v[2] + u_coef * z + c_coef * (x * src.v[1] - y * src.v[0]);
+            }
+
+            void mult_vec(vec3<T> &src_and_dst) const
+            {
+                mult_vec(vec3<T>(src_and_dst), src_and_dst);
+            }
+
+            void scale_angle(T scaleFactor)
+            {
+                vec3<T> axis;
+                T radians;
+
+                get_value(axis, radians);
+                radians *= scaleFactor;
+                set_value(axis, radians);
+            }
+
+            friend quaternion<T> slerp(const quaternion<T> &p, const quaternion<T> &q, T alpha)
+            {
+                quaternion r;
+
+                T cos_omega = p.x * q.x + p.y * q.y + p.z * q.z + p.w * q.w;
+                // if B is on opposite hemisphere from A, use -B instead
+
+                int bflip;
+
+                if ((bflip = (cos_omega < T(0))))
+                {
+                    cos_omega = -cos_omega;
+                }
+
+                // complementary interpolation parameter
+                T beta = T(1) - alpha;
+
+                if (cos_omega >= T(1))
+                {
+                    return p;
+                }
+
+                T omega = T(acos(cos_omega));
+                T one_over_sin_omega = T(1.0) / T(sin(omega));
+
+                beta    = T(sin(omega*beta)  * one_over_sin_omega);
+                alpha   = T(sin(omega*alpha) * one_over_sin_omega);
+
+                if (bflip)
+                {
+                    alpha = -alpha;
+                }
+
+                r.x = beta * p._array[0]+ alpha * q._array[0];
+                r.y = beta * p._array[1]+ alpha * q._array[1];
+                r.z = beta * p._array[2]+ alpha * q._array[2];
+                r.w = beta * p._array[3]+ alpha * q._array[3];
+                return r;
+            }
+
+            T &operator [](int i)
+            {
+                return _array[i];
+            }
+
+            const T &operator [](int i) const
+            {
+                return _array[i];
+            }
+
+
+            friend bool operator == (const quaternion<T> &lhs, const quaternion<T> &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < 4; i++)
+                {
+                    r &= lhs._array[i] == rhs._array[i];
+                }
+
+                return r;
+            }
+
+            friend bool operator != (const quaternion<T> &lhs, const quaternion<T> &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < 4; i++)
+                {
+                    r &= lhs._array[i] == rhs._array[i];
+                }
+
+                return r;
+            }
+
+            friend quaternion<T> operator * (const quaternion<T> &lhs, const quaternion<T> &rhs)
+            {
+                quaternion r(lhs);
+                r *= rhs;
+                return r;
+            }
+
+
+            union
+            {
+                struct
+                {
+                    T x;
+                    T y;
+                    T z;
+                    T w;
+                };
+                T _array[4];
+            };
+
+    };
+
+
+
+};
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/nvShaderUtils.h gpu-rodinia_new/cuda/cfd/common/inc/nvShaderUtils.h
--- gpu-rodinia/cuda/cfd/common/inc/nvShaderUtils.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/nvShaderUtils.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,259 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+/*
+ *
+ * Utility functions for compiling shaders and programs
+ *
+ * Author: Evan Hart
+ * Copyright (c) NVIDIA Corporation. All rights reserved.
+ *
+ */
+
+
+#ifndef NV_SHADER_UTILS_H
+#define NV_SHADER_UTILS_H
+
+#include <stdio.h>
+#include <string.h>
+
+#include <GL/glew.h>
+
+namespace nv
+{
+
+
+    //
+    //
+    ////////////////////////////////////////////////////////////
+    inline GLuint CompileGLSLShader(GLenum target, const char *shader)
+    {
+        GLuint object;
+
+        object = glCreateShader(target);
+
+        if (!object)
+        {
+            return object;
+        }
+
+        glShaderSource(object, 1, &shader, NULL);
+
+        glCompileShader(object);
+
+        // check if shader compiled
+        GLint compiled = 0;
+        glGetShaderiv(object, GL_COMPILE_STATUS, &compiled);
+
+        if (!compiled)
+        {
+#ifdef NV_REPORT_COMPILE_ERRORS
+            char temp[256] = "";
+            glGetShaderInfoLog(object, 256, NULL, temp);
+            fprintf(stderr, "Compile failed:\n%s\n", temp);
+#endif
+            glDeleteShader(object);
+            return 0;
+        }
+
+        return object;
+    }
+
+    //
+    //
+    ////////////////////////////////////////////////////////////
+    inline GLuint CompileGLSLShaderFromFile(GLenum target, const char *filename)
+    {
+        FILE *shaderFile;
+        char *text;
+        long size;
+        size_t fsize = 0;
+
+        // read files as binary to prevent problems from newline translation
+#ifdef _WIN32
+
+        if (fopen_s(&shaderFile, filename, "rb") != 0)
+#else
+        if ((shaderFile = fopen(filename, "rb")) == 0)
+#endif
+        {
+            return 0;
+        }
+
+        // Get the length of the file
+        fseek(shaderFile, 0, SEEK_END);
+        size = ftell(shaderFile);
+
+        // Read the file contents from the start, then close file and add a null terminator
+        fseek(shaderFile, 0, SEEK_SET);
+        text = new char[size+1];
+        fsize = fread(text, size, 1, shaderFile);
+        fclose(shaderFile);
+
+        if (fsize == 0)
+        {
+            printf("CompileGLSLShaderFromFile(), error... fsize = 0\n");
+        }
+
+        text[size] = '\0';
+
+        GLuint object = CompileGLSLShader(target, text);
+
+        delete []text;
+
+        return object;
+    }
+
+
+    // Create a program composed of vertex and fragment shaders.
+    inline GLuint LinkGLSLProgram(GLuint vertexShader, GLuint fragmentShader)
+    {
+        GLuint program = glCreateProgram();
+        glAttachShader(program, vertexShader);
+        glAttachShader(program, fragmentShader);
+        glLinkProgram(program);
+
+#ifdef NV_REPORT_COMPILE_ERRORS
+        // Get error log.
+        GLint charsWritten, infoLogLength;
+        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLogLength);
+
+        char *infoLog = new char[infoLogLength];
+        glGetProgramInfoLog(program, infoLogLength, &charsWritten, infoLog);
+        printf(infoLog);
+        delete [] infoLog;
+#endif
+
+        // Test linker result.
+        GLint linkSucceed = GL_FALSE;
+        glGetProgramiv(program, GL_LINK_STATUS, &linkSucceed);
+
+        if (linkSucceed == GL_FALSE)
+        {
+            glDeleteProgram(program);
+            return 0;
+        }
+
+        return program;
+    }
+
+
+    // Create a program composed of vertex, geometry and fragment shaders.
+    inline GLuint LinkGLSLProgram(GLuint vertexShader, GLuint geometryShader, GLint inputType, GLint vertexOut, GLint outputType, GLuint fragmentShader)
+    {
+        GLuint program = glCreateProgram();
+        glAttachShader(program, vertexShader);
+        glAttachShader(program, geometryShader);
+        glProgramParameteriEXT(program, GL_GEOMETRY_INPUT_TYPE_EXT, inputType);
+        glProgramParameteriEXT(program, GL_GEOMETRY_VERTICES_OUT_EXT, vertexOut);
+        glProgramParameteriEXT(program, GL_GEOMETRY_OUTPUT_TYPE_EXT, outputType);
+        glAttachShader(program, fragmentShader);
+        glLinkProgram(program);
+
+#ifdef NV_REPORT_COMPILE_ERRORS
+        // Get error log.
+        GLint charsWritten, infoLogLength;
+        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLogLength);
+
+        char *infoLog = new char[infoLogLength];
+        glGetProgramInfoLog(program, infoLogLength, &charsWritten, infoLog);
+        printf(infoLog);
+        delete [] infoLog;
+#endif
+
+        // Test linker result.
+        GLint linkSucceed = GL_FALSE;
+        glGetProgramiv(program, GL_LINK_STATUS, &linkSucceed);
+
+        if (linkSucceed == GL_FALSE)
+        {
+            glDeleteProgram(program);
+            return 0;
+        }
+
+        return program;
+    }
+
+    //
+    //
+    ////////////////////////////////////////////////////////////
+    inline GLuint CompileASMShader(GLenum program_type, const char *code)
+    {
+        GLuint program_id;
+        glGenProgramsARB(1, &program_id);
+        glBindProgramARB(program_type, program_id);
+        glProgramStringARB(program_type, GL_PROGRAM_FORMAT_ASCII_ARB, (GLsizei) strlen(code), (GLubyte *) code);
+
+        GLint error_pos;
+        glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &error_pos);
+
+        if (error_pos != -1)
+        {
+#ifdef NV_REPORT_COMPILE_ERRORS
+            const GLubyte *error_string;
+            error_string = glGetString(GL_PROGRAM_ERROR_STRING_ARB);
+            fprintf(stderr, "Program error at position: %d\n%s\n", (int)error_pos, error_string);
+#endif
+            return 0;
+        }
+
+        return program_id;
+    }
+
+    //
+    //
+    ////////////////////////////////////////////////////////////
+    inline GLuint CompileASMShaderFromFile(GLenum target, const char *filename)
+    {
+        FILE *shaderFile;
+        char *text;
+        long size;
+        size_t fsize = 0;
+
+        // read files as binary to prevent problems from newline translation
+#ifdef _WIN32
+
+        if (fopen_s(&shaderFile, filename, "rb") != 0)
+#else
+        if ((shaderFile = fopen(filename, "rb")) == 0)
+#endif
+        {
+            return 0;
+        }
+
+        // Get the length of the file
+        fseek(shaderFile, 0, SEEK_END);
+        size = ftell(shaderFile);
+
+        // Read the file contents from the start, then close file and add a null terminator
+        fseek(shaderFile, 0, SEEK_SET);
+        text = new char[size+1];
+        fsize = fread(text, size, 1, shaderFile);
+        fclose(shaderFile);
+
+        if (fsize == 0)
+        {
+            printf("CompileGLSLShaderFromFile(), error... fsize = 0\n");
+        }
+
+        text[size] = '\0';
+
+        GLuint program_id = CompileASMShader(target, text);
+
+        delete []text;
+
+        return program_id;
+    }
+
+} // nv namespace
+
+#endif
+
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/nvVector.h gpu-rodinia_new/cuda/cfd/common/inc/nvVector.h
--- gpu-rodinia/cuda/cfd/common/inc/nvVector.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/nvVector.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,1058 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//
+// Template math library for common 3D functionality
+//
+// nvVector.h - 2-vector, 3-vector, and 4-vector templates and utilities
+//
+// This code is in part deriver from glh, a cross platform glut helper library.
+// The copyright for glh follows this notice.
+//
+// Copyright (c) NVIDIA Corporation. All rights reserved.
+////////////////////////////////////////////////////////////////////////////////
+
+/*
+    Copyright (c) 2000 Cass Everitt
+    Copyright (c) 2000 NVIDIA Corporation
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or
+    without modification, are permitted provided that the following
+    conditions are met:
+
+     * Redistributions of source code must retain the above
+       copyright notice, this list of conditions and the following
+       disclaimer.
+
+     * Redistributions in binary form must reproduce the above
+       copyright notice, this list of conditions and the following
+       disclaimer in the documentation and/or other materials
+       provided with the distribution.
+
+     * The names of contributors to this software may not be used
+       to endorse or promote products derived from this software
+       without specific prior written permission.
+
+       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+       ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+       FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+       REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+       INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+       BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+       CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+       LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+       ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+       POSSIBILITY OF SUCH DAMAGE.
+
+
+    Cass Everitt - cass@r3.nu
+*/
+#ifndef NV_VECTOR_H
+#define NV_VECTOR_H
+
+namespace nv
+{
+
+    template <class T> class vec2;
+    template <class T> class vec3;
+    template <class T> class vec4;
+
+    //////////////////////////////////////////////////////////////////////
+    //
+    // vec2 - template class for 2-tuple vector
+    //
+    //////////////////////////////////////////////////////////////////////
+    template <class T>
+    class vec2
+    {
+        public:
+
+            typedef T value_type;
+            int size() const
+            {
+                return 2;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Constructors
+            //
+            ////////////////////////////////////////////////////////
+
+            // Default/scalar constructor
+            vec2(const T &t = T())
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = t;
+                }
+            }
+
+            // Construct from array
+            vec2(const T *tp)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = tp[i];
+                }
+            }
+
+            // Construct from explicit values
+            vec2(const T v0, const T v1)
+            {
+                x = v0;
+                y = v1;
+            }
+
+            explicit vec2(const vec3<T> &u)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = u._array[i];
+                }
+            }
+
+            explicit vec2(const vec4<T> &u)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = u._array[i];
+                }
+            }
+
+            const T *get_value() const
+            {
+                return _array;
+            }
+
+            vec2<T> &set_value(const T *rhs)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = rhs[i];
+                }
+
+                return *this;
+            }
+
+            // indexing operators
+            T &operator [](int i)
+            {
+                return _array[i];
+            }
+
+            const T &operator [](int i) const
+            {
+                return _array[i];
+            }
+
+            // type-cast operators
+            operator T *()
+            {
+                return _array;
+            }
+
+            operator const T *() const
+            {
+                return _array;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Math operators
+            //
+            ////////////////////////////////////////////////////////
+
+            // scalar multiply assign
+            friend vec2<T> &operator *= (vec2<T> &lhs, T d)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] *= d;
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector multiply assign
+            friend vec2<T> &operator *= (vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] *= rhs[i];
+                }
+
+                return lhs;
+            }
+
+            // scalar divide assign
+            friend vec2<T> &operator /= (vec2<T> &lhs, T d)
+            {
+                if (d == 0)
+                {
+                    return lhs;
+                }
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] /= d;
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector divide assign
+            friend vec2<T> &operator /= (vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] /= rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector add assign
+            friend vec2<T> &operator += (vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] += rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector subtract assign
+            friend vec2<T> &operator -= (vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] -= rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // unary negate
+            friend vec2<T> operator - (const vec2<T> &rhs)
+            {
+                vec2<T> rv;
+
+                for (int i = 0; i < rhs.size(); i++)
+                {
+                    rv._array[i] = -rhs._array[i];
+                }
+
+                return rv;
+            }
+
+            // vector add
+            friend vec2<T> operator + (const vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                vec2<T> rt(lhs);
+                return rt += rhs;
+            }
+
+            // vector subtract
+            friend vec2<T> operator - (const vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                vec2<T> rt(lhs);
+                return rt -= rhs;
+            }
+
+            // scalar multiply
+            friend vec2<T> operator * (const vec2<T> &lhs, T rhs)
+            {
+                vec2<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // scalar multiply
+            friend vec2<T> operator * (T lhs, const vec2<T> &rhs)
+            {
+                vec2<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // vector component-wise multiply
+            friend vec2<T> operator * (const vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                vec2<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // scalar multiply
+            friend vec2<T> operator / (const vec2<T> &lhs, T rhs)
+            {
+                vec2<T> rt(lhs);
+                return rt /= rhs;
+            }
+
+            // vector component-wise multiply
+            friend vec2<T> operator / (const vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                vec2<T> rt(lhs);
+                return rt /= rhs;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Comparison operators
+            //
+            ////////////////////////////////////////////////////////
+
+            // equality
+            friend bool operator == (const vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    r &= lhs._array[i] == rhs._array[i];
+                }
+
+                return r;
+            }
+
+            // inequality
+            friend bool operator != (const vec2<T> &lhs, const vec2<T> &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    r &= lhs._array[i] != rhs._array[i];
+                }
+
+                return r;
+            }
+
+            //data intentionally left public to allow vec2.x
+            union
+            {
+                struct
+                {
+                    T x,y;          // standard names for components
+                };
+                struct
+                {
+                    T s,t;          // standard names for components
+                };
+                T _array[2];     // array access
+            };
+    };
+
+    //////////////////////////////////////////////////////////////////////
+    //
+    // vec3 - template class for 3-tuple vector
+    //
+    //////////////////////////////////////////////////////////////////////
+    template <class T>
+    class vec3
+    {
+        public:
+
+            typedef T value_type;
+            int size() const
+            {
+                return 3;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Constructors
+            //
+            ////////////////////////////////////////////////////////
+
+            // Default/scalar constructor
+            vec3(const T &t = T())
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = t;
+                }
+            }
+
+            // Construct from array
+            vec3(const T *tp)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = tp[i];
+                }
+            }
+
+            // Construct from explicit values
+            vec3(const T v0, const T v1, const T v2)
+            {
+                x = v0;
+                y = v1;
+                z = v2;
+            }
+
+            explicit vec3(const vec4<T> &u)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = u._array[i];
+                }
+            }
+
+            explicit vec3(const vec2<T> &u, T v0)
+            {
+                x = u.x;
+                y = u.y;
+                z = v0;
+            }
+
+            const T *get_value() const
+            {
+                return _array;
+            }
+
+            vec3<T> &set_value(const T *rhs)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = rhs[i];
+                }
+
+                return *this;
+            }
+
+            // indexing operators
+            T &operator [](int i)
+            {
+                return _array[i];
+            }
+
+            const T &operator [](int i) const
+            {
+                return _array[i];
+            }
+
+            // type-cast operators
+            operator T *()
+            {
+                return _array;
+            }
+
+            operator const T *() const
+            {
+                return _array;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Math operators
+            //
+            ////////////////////////////////////////////////////////
+
+            // scalar multiply assign
+            friend vec3<T> &operator *= (vec3<T> &lhs, T d)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] *= d;
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector multiply assign
+            friend vec3<T> &operator *= (vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] *= rhs[i];
+                }
+
+                return lhs;
+            }
+
+            // scalar divide assign
+            friend vec3<T> &operator /= (vec3<T> &lhs, T d)
+            {
+                if (d == 0)
+                {
+                    return lhs;
+                }
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] /= d;
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector divide assign
+            friend vec3<T> &operator /= (vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] /= rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector add assign
+            friend vec3<T> &operator += (vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] += rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector subtract assign
+            friend vec3<T> &operator -= (vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] -= rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // unary negate
+            friend vec3<T> operator - (const vec3<T> &rhs)
+            {
+                vec3<T> rv;
+
+                for (int i = 0; i < rhs.size(); i++)
+                {
+                    rv._array[i] = -rhs._array[i];
+                }
+
+                return rv;
+            }
+
+            // vector add
+            friend vec3<T> operator + (const vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                vec3<T> rt(lhs);
+                return rt += rhs;
+            }
+
+            // vector subtract
+            friend vec3<T> operator - (const vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                vec3<T> rt(lhs);
+                return rt -= rhs;
+            }
+
+            // scalar multiply
+            friend vec3<T> operator * (const vec3<T> &lhs, T rhs)
+            {
+                vec3<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // scalar multiply
+            friend vec3<T> operator * (T lhs, const vec3<T> &rhs)
+            {
+                vec3<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // vector component-wise multiply
+            friend vec3<T> operator * (const vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                vec3<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // scalar multiply
+            friend vec3<T> operator / (const vec3<T> &lhs, T rhs)
+            {
+                vec3<T> rt(lhs);
+                return rt /= rhs;
+            }
+
+            // vector component-wise multiply
+            friend vec3<T> operator / (const vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                vec3<T> rt(lhs);
+                return rt /= rhs;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Comparison operators
+            //
+            ////////////////////////////////////////////////////////
+
+            // equality
+            friend bool operator == (const vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    r &= lhs._array[i] == rhs._array[i];
+                }
+
+                return r;
+            }
+
+            // inequality
+            friend bool operator != (const vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    r &= lhs._array[i] != rhs._array[i];
+                }
+
+                return r;
+            }
+
+            ////////////////////////////////////////////////////////////////////////////////
+            //
+            // dimension specific operations
+            //
+            ////////////////////////////////////////////////////////////////////////////////
+
+            // cross product
+            friend vec3<T> cross(const vec3<T> &lhs, const vec3<T> &rhs)
+            {
+                vec3<T> r;
+
+                r.x = lhs.y * rhs.z - lhs.z * rhs.y;
+                r.y = lhs.z * rhs.x - lhs.x * rhs.z;
+                r.z = lhs.x * rhs.y - lhs.y * rhs.x;
+
+                return r;
+            }
+
+            //data intentionally left public to allow vec2.x
+            union
+            {
+                struct
+                {
+                    T x, y, z;          // standard names for components
+                };
+                struct
+                {
+                    T s, t, r;          // standard names for components
+                };
+                T _array[3];     // array access
+            };
+    };
+
+    //////////////////////////////////////////////////////////////////////
+    //
+    // vec4 - template class for 4-tuple vector
+    //
+    //////////////////////////////////////////////////////////////////////
+    template <class T>
+    class vec4
+    {
+        public:
+
+            typedef T value_type;
+            int size() const
+            {
+                return 4;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Constructors
+            //
+            ////////////////////////////////////////////////////////
+
+            // Default/scalar constructor
+            vec4(const T &t = T())
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = t;
+                }
+            }
+
+            // Construct from array
+            vec4(const T *tp)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = tp[i];
+                }
+            }
+
+            // Construct from explicit values
+            vec4(const T v0, const T v1, const T v2, const T v3)
+            {
+                x = v0;
+                y = v1;
+                z = v2;
+                w = v3;
+            }
+
+            explicit vec4(const vec3<T> &u, T v0)
+            {
+                x = u.x;
+                y = u.y;
+                z = u.z;
+                w = v0;
+            }
+
+            explicit vec4(const vec2<T> &u, T v0, T v1)
+            {
+                x = u.x;
+                y = u.y;
+                z = v0;
+                w = v1;
+            }
+
+            const T *get_value() const
+            {
+                return _array;
+            }
+
+            vec4<T> &set_value(const T *rhs)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    _array[i] = rhs[i];
+                }
+
+                return *this;
+            }
+
+            // indexing operators
+            T &operator [](int i)
+            {
+                return _array[i];
+            }
+
+            const T &operator [](int i) const
+            {
+                return _array[i];
+            }
+
+            // type-cast operators
+            operator T *()
+            {
+                return _array;
+            }
+
+            operator const T *() const
+            {
+                return _array;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Math operators
+            //
+            ////////////////////////////////////////////////////////
+
+            // scalar multiply assign
+            friend vec4<T> &operator *= (vec4<T> &lhs, T d)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] *= d;
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector multiply assign
+            friend vec4<T> &operator *= (vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] *= rhs[i];
+                }
+
+                return lhs;
+            }
+
+            // scalar divide assign
+            friend vec4<T> &operator /= (vec4<T> &lhs, T d)
+            {
+                if (d == 0)
+                {
+                    return lhs;
+                }
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] /= d;
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector divide assign
+            friend vec4<T> &operator /= (vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] /= rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector add assign
+            friend vec4<T> &operator += (vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] += rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // component-wise vector subtract assign
+            friend vec4<T> &operator -= (vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    lhs._array[i] -= rhs._array[i];
+                }
+
+                return lhs;
+            }
+
+            // unary negate
+            friend vec4<T> operator - (const vec4<T> &rhs)
+            {
+                vec4<T> rv;
+
+                for (int i = 0; i < rhs.size(); i++)
+                {
+                    rv._array[i] = -rhs._array[i];
+                }
+
+                return rv;
+            }
+
+            // vector add
+            friend vec4<T> operator + (const vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                vec4<T> rt(lhs);
+                return rt += rhs;
+            }
+
+            // vector subtract
+            friend vec4<T> operator - (const vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                vec4<T> rt(lhs);
+                return rt -= rhs;
+            }
+
+            // scalar multiply
+            friend vec4<T> operator * (const vec4<T> &lhs, T rhs)
+            {
+                vec4<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // scalar multiply
+            friend vec4<T> operator * (T lhs, const vec4<T> &rhs)
+            {
+                vec4<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // vector component-wise multiply
+            friend vec4<T> operator * (const vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                vec4<T> rt(lhs);
+                return rt *= rhs;
+            }
+
+            // scalar multiply
+            friend vec4<T> operator / (const vec4<T> &lhs, T rhs)
+            {
+                vec4<T> rt(lhs);
+                return rt /= rhs;
+            }
+
+            // vector component-wise multiply
+            friend vec4<T> operator / (const vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                vec4<T> rt(lhs);
+                return rt /= rhs;
+            }
+
+            ////////////////////////////////////////////////////////
+            //
+            //  Comparison operators
+            //
+            ////////////////////////////////////////////////////////
+
+            // equality
+            friend bool operator == (const vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    r &= lhs._array[i] == rhs._array[i];
+                }
+
+                return r;
+            }
+
+            // inequality
+            friend bool operator != (const vec4<T> &lhs, const vec4<T> &rhs)
+            {
+                bool r = true;
+
+                for (int i = 0; i < lhs.size(); i++)
+                {
+                    r &= lhs._array[i] != rhs._array[i];
+                }
+
+                return r;
+            }
+
+            //data intentionally left public to allow vec2.x
+            union
+            {
+                struct
+                {
+                    T x, y, z, w;          // standard names for components
+                };
+                struct
+                {
+                    T s, t, r, q;          // standard names for components
+                };
+                T _array[4];     // array access
+            };
+    };
+
+    ////////////////////////////////////////////////////////////////////////////////
+    //
+    // Generic vector operations
+    //
+    ////////////////////////////////////////////////////////////////////////////////
+
+    // compute the dot product of two vectors
+    template<class T>
+    inline typename T::value_type dot(const T &lhs, const T &rhs)
+    {
+        typename T::value_type r = 0;
+
+        for (int i = 0; i < lhs.size(); i++)
+        {
+            r += lhs._array[i] * rhs._array[i];
+        }
+
+        return r;
+    }
+
+    // return the length of the provided vector
+    template< class T>
+    inline typename T::value_type length(const T &vec)
+    {
+        typename T::value_type r = 0;
+
+        for (int i = 0; i < vec.size(); i++)
+        {
+            r += vec._array[i]*vec._array[i];
+        }
+
+        return typename T::value_type(sqrt(r));
+    }
+
+    // return the squared norm
+    template< class T>
+    inline typename T::value_type square_norm(const T &vec)
+    {
+        typename T::value_type r = 0;
+
+        for (int i = 0; i < vec.size(); i++)
+        {
+            r += vec._array[i]*vec._array[i];
+        }
+
+        return r;
+    }
+
+    // return the normalized version of the vector
+    template< class T>
+    inline T normalize(const T &vec)
+    {
+        typename T::value_type sum(0);
+        T r;
+
+        for (int i = 0; i < vec.size(); i++)
+        {
+            sum += vec._array[i] * vec._array[i];
+        }
+
+        sum = typename T::value_type(sqrt(sum));
+
+        if (sum > 0)
+            for (int i = 0; i < vec.size(); i++)
+            {
+                r._array[i] = vec._array[i] / sum;
+            }
+
+        return r;
+    }
+
+    // In VC8 : min and max are already defined by a #define...
+#ifdef min
+#undef min
+#endif
+#ifdef max
+#undef max
+#endif
+    //componentwise min
+    template< class T>
+    inline T min(const T &lhs, const T &rhs)
+    {
+        T rt;
+
+        for (int i = 0; i < lhs.size(); i++)
+        {
+            rt._array[i] = std::min(lhs._array[i], rhs._array[i]);
+        }
+
+        return rt;
+    }
+
+    // componentwise max
+    template< class T>
+    inline T max(const T &lhs, const T &rhs)
+    {
+        T rt;
+
+        for (int i = 0; i < lhs.size(); i++)
+        {
+            rt._array[i] = std::max(lhs._array[i], rhs._array[i]);
+        }
+
+        return rt;
+    }
+
+
+};
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/paramgl.h gpu-rodinia_new/cuda/cfd/common/inc/paramgl.h
--- gpu-rodinia/cuda/cfd/common/inc/paramgl.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/paramgl.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,308 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+/*
+   ParamListGL
+   - class derived from ParamList to do simple OpenGL rendering of a parameter list
+   sgg 8/2001
+*/
+
+#ifndef PARAMGL_H
+#define PARAMGL_H
+
+#if defined(__APPLE__) || defined(MACOSX)
+#include <GLUT/glut.h>
+#else
+#include <GL/freeglut.h>
+#endif
+
+#include <string.h>
+#include <param.h>
+
+inline void beginWinCoords(void)
+{
+    glMatrixMode(GL_MODELVIEW);
+    glPushMatrix();
+    glLoadIdentity();
+    glTranslatef(0.0, (GLfloat)(glutGet(GLUT_WINDOW_HEIGHT) - 1.0), 0.0);
+    glScalef(1.0, -1.0, 1.0);
+
+    glMatrixMode(GL_PROJECTION);
+    glPushMatrix();
+    glLoadIdentity();
+    glOrtho(0, glutGet(GLUT_WINDOW_WIDTH), 0, glutGet(GLUT_WINDOW_HEIGHT), -1, 1);
+
+    glMatrixMode(GL_MODELVIEW);
+}
+
+inline void endWinCoords(void)
+{
+    glMatrixMode(GL_PROJECTION);
+    glPopMatrix();
+
+    glMatrixMode(GL_MODELVIEW);
+    glPopMatrix();
+}
+
+inline void glPrint(int x, int y, const char *s, void *font)
+{
+    glRasterPos2f((GLfloat)x, (GLfloat)y);
+    int len = (int) strlen(s);
+
+    for (int i = 0; i < len; i++)
+    {
+        glutBitmapCharacter(font, s[i]);
+    }
+}
+
+inline void glPrintShadowed(int x, int y, const char *s, void *font, float *color)
+{
+    glColor3f(0.0, 0.0, 0.0);
+    glPrint(x-1, y-1, s, font);
+
+    glColor3fv((GLfloat *) color);
+    glPrint(x, y, s, font);
+}
+
+class ParamListGL : public ParamList
+{
+    public:
+        ParamListGL(const char *name = "") :
+            ParamList(name),
+            m_active(true),
+            m_text_color_selected(1.0, 1.0, 1.0),
+            m_text_color_unselected(0.75, 0.75, 0.75),
+            m_text_color_shadow(0.0, 0.0, 0.0),
+            m_bar_color_outer(0.25, 0.25, 0.25),
+            m_bar_color_inner(1.0, 1.0, 1.0)
+        {
+            m_font = (void *) GLUT_BITMAP_9_BY_15; // GLUT_BITMAP_8_BY_13;
+            m_font_h = 15;
+            m_bar_x = 260;
+            m_bar_w = 250;
+            m_bar_h = 10;
+            m_bar_offset = 5;
+            m_text_x = 5;
+            m_separation = 15;
+            m_value_x = 200;
+            m_start_x = 0;
+            m_start_y = 0;
+        }
+
+        void Render(int x, int y, bool shadow = false)
+        {
+            beginWinCoords();
+
+            m_start_x = x;
+            m_start_y = y;
+
+            for (std::vector<ParamBase *>::const_iterator p = m_params.begin(); p != m_params.end(); ++p)
+            {
+                if ((*p)->IsList())
+                {
+                    ParamListGL *list = (ParamListGL *)(*p);
+                    list->Render(x+10, y);
+                    y += m_separation*list->GetSize();
+                }
+                else
+                {
+                    if (p == m_current)
+                    {
+                        glColor3fv(&m_text_color_selected.r);
+                    }
+                    else
+                    {
+                        glColor3fv(&m_text_color_unselected.r);
+                    }
+
+                    if (shadow)
+                    {
+                        glPrintShadowed(x + m_text_x, y + m_font_h, (*p)->GetName().c_str(), m_font, (p == m_current) ? &m_text_color_selected.r : &m_text_color_unselected.r);
+                        glPrintShadowed(x + m_value_x, y + m_font_h, (*p)->GetValueString().c_str(), m_font, (p == m_current) ? &m_text_color_selected.r : &m_text_color_unselected.r);
+                    }
+                    else
+                    {
+                        glPrint(x + m_text_x, y + m_font_h, (*p)->GetName().c_str(), m_font);
+                        glPrint(x + m_value_x, y + m_font_h, (*p)->GetValueString().c_str(), m_font);
+                    }
+
+                    glColor3fv((GLfloat *) &m_bar_color_outer.r);
+                    glBegin(GL_LINE_LOOP);
+                    glVertex2f((GLfloat)(x + m_bar_x)          , (GLfloat)(y + m_bar_offset));
+                    glVertex2f((GLfloat)(x + m_bar_x + m_bar_w), (GLfloat)(y + m_bar_offset));
+                    glVertex2f((GLfloat)(x + m_bar_x + m_bar_w), (GLfloat)(y + m_bar_offset + m_bar_h));
+                    glVertex2f((GLfloat)(x + m_bar_x)          , (GLfloat)(y + m_bar_offset + m_bar_h));
+                    glEnd();
+
+                    glColor3fv((GLfloat *) &m_bar_color_inner.r);
+                    glRectf((GLfloat)(x + m_bar_x), (GLfloat)(y + m_bar_offset + m_bar_h), (GLfloat)(x + m_bar_x + ((m_bar_w-1)*(*p)->GetPercentage())), (GLfloat)(y + m_bar_offset + 1));
+
+                    y += m_separation;
+                }
+            }
+
+            endWinCoords();
+        }
+
+        bool Mouse(int x, int y, int button=GLUT_LEFT_BUTTON, int state=GLUT_DOWN)
+        {
+            if ((y < m_start_y) || (y > (int)(m_start_y + (m_separation * m_params.size()) - 1)))
+            {
+                m_active = false;
+                return false;
+            }
+
+            m_active = true;
+
+            int i = (y - m_start_y) / m_separation;
+
+            if ((button==GLUT_LEFT_BUTTON) && (state==GLUT_DOWN))
+            {
+#if defined(__GNUC__) && (__GNUC__ < 3)
+                m_current = &m_params[i];
+#else
+
+                // MJH: workaround since the version of vector::at used here is non-standard
+                for (m_current = m_params.begin(); m_current != m_params.end() && i > 0; m_current++, i--) ;
+
+                //m_current = (std::vector<ParamBase *>::const_iterator)&m_params.at(i);
+#endif
+
+                if ((x > m_bar_x) && (x < m_bar_x + m_bar_w))
+                {
+                    Motion(x, y);
+                }
+            }
+
+            return true;
+        }
+
+        bool Motion(int x, int y)
+        {
+            if ((y < m_start_y) || (y > m_start_y + (m_separation * (int)m_params.size()) - 1))
+            {
+                return false;
+            }
+
+            if (x < m_bar_x)
+            {
+                (*m_current)->SetPercentage(0.0);
+                return true;
+            }
+
+            if (x > m_bar_x + m_bar_w)
+            {
+                (*m_current)->SetPercentage(1.0);
+                return true;
+            }
+
+            (*m_current)->SetPercentage((x-m_bar_x) / (float) m_bar_w);
+            return true;
+        }
+
+        void Special(int key, int x, int y)
+        {
+            if (!m_active)
+                return;
+
+            switch (key)
+            {
+                case GLUT_KEY_DOWN:
+                    Increment();
+                    break;
+
+                case GLUT_KEY_UP:
+                    Decrement();
+                    break;
+
+                case GLUT_KEY_RIGHT:
+                    GetCurrent()->Increment();
+                    break;
+
+                case GLUT_KEY_LEFT:
+                    GetCurrent()->Decrement();
+                    break;
+
+                case GLUT_KEY_HOME:
+                    GetCurrent()->Reset();
+                    break;
+
+                case GLUT_KEY_END:
+                    GetCurrent()->SetPercentage(1.0);
+                    break;
+            }
+
+            glutPostRedisplay();
+        }
+
+        void SetFont(void *font, int height)
+        {
+            m_font = font;
+            m_font_h = height;
+        }
+
+        void SetSelectedColor(float r, float g, float b)
+        {
+            m_text_color_selected = Color(r, g, b);
+        }
+        void SetUnSelectedColor(float r, float g, float b)
+        {
+            m_text_color_unselected = Color(r, g, b);
+        }
+        void SetBarColorInner(float r, float g, float b)
+        {
+            m_bar_color_inner = Color(r, g, b);
+        }
+        void SetBarColorOuter(float r, float g, float b)
+        {
+            m_bar_color_outer = Color(r, g, b);
+        }
+
+        void SetActive(bool b)
+        {
+            m_active = b;
+        }
+
+    private:
+        void *m_font;
+        int m_font_h;       // font height
+
+        int m_bar_x;        // bar start x position
+        int m_bar_w;        // bar width
+        int m_bar_h;        // bar height
+        int m_text_x;       // text start x position
+        int m_separation;   // bar separation in y
+        int m_value_x;      // value text x position
+        int m_bar_offset;   // bar offset in y
+
+        int m_start_x, m_start_y;
+
+        bool m_active;
+
+        struct Color
+        {
+            Color(float _r, float _g, float _b)
+            {
+                r = _r;
+                g = _g;
+                b = _b;
+            }
+            float r, g, b;
+        };
+
+        Color m_text_color_selected;
+        Color m_text_color_unselected;
+        Color m_text_color_shadow;
+        Color m_bar_color_outer;
+        Color m_bar_color_inner;
+};
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/param.h gpu-rodinia_new/cuda/cfd/common/inc/param.h
--- gpu-rodinia/cuda/cfd/common/inc/param.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/param.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,310 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+/*
+ Simple parameter system
+ sgreen@nvidia.com 4/2001
+*/
+
+#ifndef PARAM_H
+#define PARAM_H
+
+#include <string>
+#include <vector>
+#include <map>
+#include <iostream>
+#include <sstream>
+#include <iomanip>
+
+// base class for named parameter
+class ParamBase
+{
+    public:
+        ParamBase(const char *name) : m_name(name) { }
+        virtual ~ParamBase() { }
+
+        std::string &GetName()
+        {
+            return m_name;
+        }
+
+        virtual float GetFloatValue() = 0;
+        virtual int GetIntValue() = 0;
+        virtual std::string GetValueString() = 0;
+
+        virtual void Reset() = 0;
+        virtual void Increment() = 0;
+        virtual void Decrement() = 0;
+
+        virtual float GetPercentage() = 0;
+        virtual void SetPercentage(float p) = 0;
+
+        virtual void Write(std::ostream &stream) = 0;
+        virtual void Read(std::istream &stream) = 0;
+
+        virtual bool IsList() = 0;
+
+    protected:
+        std::string m_name;
+};
+
+// derived class for single-valued parameter
+template<class T> class Param : public ParamBase
+{
+    public:
+        Param(const char *name, T value = 0, T min = 0, T max = 10000, T step = 1, T *ptr = 0) :
+            ParamBase(name),
+            m_default(value),
+            m_min(min),
+            m_max(max),
+            m_step(step),
+            m_precision(3)
+        {
+            if (ptr)
+            {
+                m_ptr = ptr;
+            }
+            else
+            {
+                m_ptr = &m_value;
+            }
+
+            *m_ptr = value;
+        }
+        ~Param() { }
+
+        T GetValue() const
+        {
+            return *m_ptr;
+        }
+        T SetValue(const T value)
+        {
+            *m_ptr = value;
+        }
+
+        float GetFloatValue()
+        {
+            return (float) *m_ptr;
+        }
+        int GetIntValue()
+        {
+            return (int) *m_ptr;
+        }
+
+        std::string GetValueString()
+        {
+            std::ostringstream ost;
+            ost<<std::setprecision(m_precision)<<std::fixed;
+            ost<<*m_ptr;
+            return ost.str();
+        }
+
+        void SetPrecision(int x)
+        {
+            m_precision = x;
+        }
+
+        float GetPercentage()
+        {
+            return (*m_ptr - m_min) / (float)(m_max - m_min);
+        }
+
+        void SetPercentage(float p)
+        {
+            *m_ptr = (T)(m_min + p * (m_max - m_min));
+        }
+
+        void Reset()
+        {
+            *m_ptr = m_default;
+        }
+
+        void Increment()
+        {
+            *m_ptr += m_step;
+
+            if (*m_ptr > m_max)
+            {
+                *m_ptr = m_max;
+            }
+        }
+
+        void Decrement()
+        {
+            *m_ptr -= m_step;
+
+            if (*m_ptr < m_min)
+            {
+                *m_ptr = m_min;
+            }
+        }
+
+        void Write(std::ostream &stream)
+        {
+            stream << m_name << " " << *m_ptr << '\n';
+        }
+        void Read(std::istream &stream)
+        {
+            stream >> m_name >> *m_ptr;
+        }
+
+        bool IsList()
+        {
+            return false;
+        }
+
+    private:
+        T m_value;
+        T *m_ptr;         // pointer to value declared elsewhere
+        T m_default, m_min, m_max, m_step;
+        int m_precision;  // number of digits after decimal point in string output
+};
+
+const Param<int> dummy("error");
+
+// list of parameters
+class ParamList : public ParamBase
+{
+    public:
+        ParamList(const char *name = "") :
+            ParamBase(name)
+        {
+            active = true;
+        }
+        ~ParamList() { }
+
+        float GetFloatValue()
+        {
+            return 0.0f;
+        }
+        int GetIntValue()
+        {
+            return 0;
+        }
+
+        void AddParam(ParamBase *param)
+        {
+            m_params.push_back(param);
+            m_map[param->GetName()] = param;
+            m_current = m_params.begin();
+        }
+
+        // look-up parameter based on name
+        ParamBase *GetParam(char *name)
+        {
+            ParamBase *p = m_map[name];
+
+            if (p)
+            {
+                return p;
+            }
+            else
+            {
+                return (ParamBase *) &dummy;
+            }
+        }
+
+        ParamBase *GetParam(int i)
+        {
+            return m_params[i];
+        }
+
+        ParamBase *GetCurrent()
+        {
+            return *m_current;
+        }
+
+        int GetSize()
+        {
+            return (int)m_params.size();
+        }
+
+        std::string GetValueString()
+        {
+            return m_name;
+        }
+
+        // functions to traverse list
+        void Reset()
+        {
+            m_current = m_params.begin();
+        }
+
+        void Increment()
+        {
+            m_current++;
+
+            if (m_current == m_params.end())
+            {
+                m_current = m_params.begin();
+            }
+        }
+
+        void Decrement()
+        {
+            if (m_current == m_params.begin())
+            {
+                m_current = m_params.end()-1;
+            }
+            else
+            {
+                m_current--;
+            }
+
+        }
+
+        float GetPercentage()
+        {
+            return 0.0f;
+        }
+        void SetPercentage(float /*p*/) {}
+
+        void Write(std::ostream &stream)
+        {
+            stream << m_name << '\n';
+
+            for (std::vector<ParamBase *>::const_iterator p = m_params.begin(); p != m_params.end(); ++p)
+            {
+                (*p)->Write(stream);
+            }
+        }
+
+        void Read(std::istream &stream)
+        {
+            stream >> m_name;
+
+            for (std::vector<ParamBase *>::const_iterator p = m_params.begin(); p != m_params.end(); ++p)
+            {
+                (*p)->Read(stream);
+            }
+        }
+
+        bool IsList()
+        {
+            return true;
+        }
+
+        void ResetAll()
+        {
+            for (std::vector<ParamBase *>::const_iterator p = m_params.begin(); p != m_params.end(); ++p)
+            {
+                (*p)->Reset();
+            }
+        }
+
+    protected:
+        bool active;
+        std::vector<ParamBase *> m_params;
+        std::map<std::string, ParamBase *> m_map;
+        std::vector<ParamBase *>::const_iterator m_current;
+};
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/rendercheck_d3d10.h gpu-rodinia_new/cuda/cfd/common/inc/rendercheck_d3d10.h
--- gpu-rodinia/cuda/cfd/common/inc/rendercheck_d3d10.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/rendercheck_d3d10.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,37 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+#pragma once
+
+#ifndef _RENDERCHECK_D3D10_H_
+#define _RENDERCHECK_D3D10_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <d3d10.h>
+#include <d3dx10.h>
+
+class CheckRenderD3D10
+{
+    public:
+
+        CheckRenderD3D10() {}
+
+        static HRESULT ActiveRenderTargetToPPM(ID3D10Device  *pDevice, const char *zFileName);
+        static HRESULT ResourceToPPM(ID3D10Device *pDevice, ID3D10Resource *pResource, const char *zFileName);
+
+        static bool PPMvsPPM(const char *src_file, const char *ref_file, const char *exec_path,
+                             const float epsilon, const float threshold = 0.0f);
+};
+
+#endif
\ No newline at end of file
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/rendercheck_d3d11.h gpu-rodinia_new/cuda/cfd/common/inc/rendercheck_d3d11.h
--- gpu-rodinia/cuda/cfd/common/inc/rendercheck_d3d11.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/rendercheck_d3d11.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,38 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+
+#pragma once
+
+#ifndef _RENDERCHECK_D3D11_H_
+#define _RENDERCHECK_D3D11_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <d3d11.h>
+#include <d3dx11.h>
+
+class CheckRenderD3D11
+{
+    public:
+
+        CheckRenderD3D11() {}
+
+        static HRESULT ActiveRenderTargetToPPM(ID3D11Device  *pDevice, const char *zFileName);
+        static HRESULT ResourceToPPM(ID3D11Device *pDevice, ID3D11Resource *pResource, const char *zFileName);
+
+        static bool PPMvsPPM(const char *src_file, const char *ref_file, const char *exec_path,
+                             const float epsilon, const float threshold = 0.0f);
+};
+
+#endif
\ No newline at end of file
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/rendercheck_d3d9.h gpu-rodinia_new/cuda/cfd/common/inc/rendercheck_d3d9.h
--- gpu-rodinia/cuda/cfd/common/inc/rendercheck_d3d9.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/rendercheck_d3d9.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,36 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+#pragma once
+
+#ifndef _RENDERCHECK_D3D9_H_
+#define _RENDERCHECK_D3D9_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <d3d9.h>
+
+class CheckRenderD3D9
+{
+    public:
+
+        CheckRenderD3D9() {}
+
+        static HRESULT BackbufferToPPM(IDirect3DDevice9 *pDevice, const char *zFileName);
+        static HRESULT SurfaceToPPM(IDirect3DDevice9 *pDevice, IDirect3DSurface9 *pSurface, const char *zFileName);
+
+        static bool PPMvsPPM(const char *src_file, const char *ref_file, const char *exec_path,
+                             const float epsilon, const float threshold = 0.0f);
+};
+
+#endif
\ No newline at end of file
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/rendercheck_gl.h gpu-rodinia_new/cuda/cfd/common/inc/rendercheck_gl.h
--- gpu-rodinia/cuda/cfd/common/inc/rendercheck_gl.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/rendercheck_gl.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,1438 @@
+/**
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+
+#ifndef _RENDERCHECK_GL_H_
+#define _RENDERCHECK_GL_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <vector>
+#include <map>
+#include <string>
+
+#include <GL/glew.h>
+
+#if defined(__APPLE__) || defined(MACOSX)
+#include <GLUT/glut.h>
+#else
+#include <GL/freeglut.h>
+#endif
+
+#include <nvShaderUtils.h>
+
+#include <helper_image.h>
+
+using std::vector;
+using std::map;
+using std::string;
+
+#define BUFFER_OFFSET(i) ((char *)NULL + (i))
+
+#if _DEBUG
+#define CHECK_FBO     checkStatus(__FILE__, __LINE__, true)
+#else
+#define CHECK_FBO     true
+#endif
+
+
+
+class CheckRender
+{
+    public:
+        CheckRender(unsigned int width, unsigned int height, unsigned int Bpp,
+                    bool bQAReadback, bool bUseFBO, bool bUsePBO) :
+            m_Width(width), m_Height(height), m_Bpp(Bpp), m_bQAReadback(bQAReadback),
+            m_bUseFBO(bUseFBO), m_bUsePBO(bUsePBO), m_PixelFormat(GL_BGRA), m_fThresholdCompare(0.0f)
+        {
+            allocateMemory(width, height, Bpp, bUseFBO, bUsePBO);
+        }
+
+        virtual ~CheckRender()
+        {
+            // Release PBO resources
+            if (m_bUsePBO)
+            {
+                glDeleteBuffersARB(1, &m_pboReadback);
+                m_pboReadback = 0;
+            }
+
+            free(m_pImageData);
+        }
+
+        virtual void allocateMemory(unsigned int width, unsigned int height, unsigned int Bpp,
+                                    bool bUseFBO, bool bUsePBO)
+        {
+            // Create the PBO for readbacks
+            if (bUsePBO)
+            {
+                glGenBuffersARB(1, &m_pboReadback);
+                glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_pboReadback);
+                glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, width*height*Bpp, NULL, GL_STREAM_READ);
+                glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
+            }
+
+            m_pImageData = (unsigned char *)malloc(width*height*Bpp);  // This is the image data stored in system memory
+        }
+
+
+        virtual void setExecPath(char *path)
+        {
+            strcpy(m_ExecPath, path);
+        }
+        virtual void EnableQAReadback(bool bStatus)
+        {
+            m_bQAReadback = bStatus;
+        }
+        virtual bool IsQAReadback()
+        {
+            return m_bQAReadback;
+        }
+        virtual bool IsFBO()
+        {
+            return m_bUseFBO;
+        }
+        virtual bool IsPBO()
+        {
+            return m_bUsePBO;
+        }
+        virtual void *imageData()
+        {
+            return m_pImageData;
+        }
+
+        // Interface to this class functions
+        virtual void setPixelFormat(GLenum format)
+        {
+            m_PixelFormat = format;
+        }
+        virtual int  getPixelFormat()
+        {
+            return m_PixelFormat;
+        }
+        virtual bool checkStatus(const char *zfile, int line, bool silent) = 0;
+        virtual bool readback(GLuint width, GLuint height) = 0;
+        virtual bool readback(GLuint width, GLuint height, GLuint bufObject) = 0;
+        virtual bool readback(GLuint width, GLuint height, unsigned char *membuf) = 0;
+
+        virtual void bindReadback()
+        {
+            if (!m_bQAReadback)
+            {
+                printf("CheckRender::bindReadback() uninitialized!\n");
+                return;
+            }
+
+            if (m_bUsePBO)
+            {
+                glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, m_pboReadback);   // Bind the PBO
+            }
+        }
+
+        virtual void unbindReadback()
+        {
+            if (!m_bQAReadback)
+            {
+                printf("CheckRender::unbindReadback() uninitialized!\n");
+                return;
+            }
+
+            if (m_bUsePBO)
+            {
+                glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0);   // Release the bind on the PBO
+            }
+        }
+
+        virtual void savePGM(const char *zfilename, bool bInvert, void **ppReadBuf)
+        {
+            if (zfilename != NULL)
+            {
+                if (bInvert)
+                {
+                    unsigned char *readBuf;
+                    unsigned char *writeBuf= (unsigned char *)malloc(m_Width * m_Height);
+
+                    for (unsigned int y=0; y < m_Height; y++)
+                    {
+                        if (ppReadBuf)
+                        {
+                            readBuf = *(unsigned char **)ppReadBuf;
+                        }
+                        else
+                        {
+                            readBuf = (unsigned char *)m_pImageData;
+                        }
+
+                        memcpy(&writeBuf[m_Width*m_Bpp*y], (readBuf+ m_Width*(m_Height-1-y)), m_Width);
+                    }
+
+                    // we copy the results back to original system buffer
+                    if (ppReadBuf)
+                    {
+                        memcpy(*ppReadBuf, writeBuf, m_Width*m_Height);
+                    }
+                    else
+                    {
+                        memcpy(m_pImageData, writeBuf, m_Width*m_Height);
+                    }
+
+                    free(writeBuf);
+                }
+
+                printf("> Saving PGM: <%s>\n", zfilename);
+
+                if (ppReadBuf)
+                {
+                    sdkSavePGM<unsigned char>(zfilename, *(unsigned char **)ppReadBuf, m_Width, m_Height);
+                }
+                else
+                {
+                    sdkSavePGM<unsigned char>(zfilename, (unsigned char *)m_pImageData, m_Width, m_Height);
+                }
+            }
+        }
+
+        virtual void savePPM(const char *zfilename, bool bInvert, void **ppReadBuf)
+        {
+            if (zfilename != NULL)
+            {
+                if (bInvert)
+                {
+                    unsigned char *readBuf;
+                    unsigned char *writeBuf= (unsigned char *)malloc(m_Width * m_Height * m_Bpp);
+
+                    for (unsigned int y=0; y < m_Height; y++)
+                    {
+                        if (ppReadBuf)
+                        {
+                            readBuf = *(unsigned char **)ppReadBuf;
+                        }
+                        else
+                        {
+                            readBuf = (unsigned char *)m_pImageData;
+                        }
+
+                        memcpy(&writeBuf[m_Width*m_Bpp*y], (readBuf+ m_Width*m_Bpp*(m_Height-1-y)), m_Width*m_Bpp);
+                    }
+
+                    // we copy the results back to original system buffer
+                    if (ppReadBuf)
+                    {
+                        memcpy(*ppReadBuf, writeBuf, m_Width*m_Height*m_Bpp);
+                    }
+                    else
+                    {
+                        memcpy(m_pImageData, writeBuf, m_Width*m_Height*m_Bpp);
+                    }
+
+                    free(writeBuf);
+                }
+
+                printf("> Saving PPM: <%s>\n", zfilename);
+
+                if (ppReadBuf)
+                {
+                    sdkSavePPM4ub(zfilename, *(unsigned char **)ppReadBuf, m_Width, m_Height);
+                }
+                else
+                {
+                    sdkSavePPM4ub(zfilename, (unsigned char *)m_pImageData, m_Width, m_Height);
+                }
+            }
+        }
+
+        virtual bool PGMvsPGM(const char *src_file, const char *ref_file, const float epsilon, const float threshold = 0.0f)
+        {
+            unsigned char *src_data = NULL, *ref_data = NULL;
+            unsigned long error_count = 0;
+            unsigned int width, height;
+
+            char *ref_file_path = sdkFindFilePath(ref_file, m_ExecPath);
+
+            if (ref_file_path == NULL)
+            {
+                printf("CheckRender::PGMvsPGM unable to find <%s> in <%s> Aborting comparison!\n", ref_file, m_ExecPath);
+                printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", ref_file);
+                printf("Aborting comparison!\n");
+                printf("  FAILED\n");
+                error_count++;
+            }
+            else
+            {
+
+                if (src_file == NULL || ref_file_path == NULL)
+                {
+                    printf("PGMvsPGM: Aborting comparison\n");
+                    return false;
+                }
+
+                printf("   src_file <%s>\n", src_file);
+                printf("   ref_file <%s>\n", ref_file_path);
+
+                if (sdkLoadPPMub(ref_file_path, &ref_data, &width, &height) != true)
+                {
+                    printf("PGMvsPGM: unable to load ref image file: %s\n", ref_file_path);
+                    return false;
+                }
+
+                if (sdkLoadPPMub(src_file, &src_data, &width, &height) != true)
+                {
+                    printf("PGMvsPGM: unable to load src image file: %s\n", src_file);
+                    return false;
+                }
+
+                printf("PGMvsPGM: comparing images size (%d,%d) epsilon(%2.4f), threshold(%4.2f%%)\n", m_Height, m_Width, epsilon, threshold*100);
+
+                if (compareDataAsFloatThreshold<unsigned char, float>(ref_data, src_data, m_Height*m_Width, epsilon, threshold) == false)
+                {
+                    error_count = 1;
+                }
+            }
+
+            if (error_count == 0)
+            {
+                printf("  OK\n");
+            }
+            else
+            {
+                printf("  FAILURE: %d errors...\n", (unsigned int)error_count);
+            }
+
+            return (error_count == 0);  // returns true if all pixels pass
+        }
+
+        virtual bool PPMvsPPM(const char *src_file, const char *ref_file, const float epsilon, const float threshold = 0.0f)
+        {
+            unsigned long error_count = 0;
+
+            char *ref_file_path = sdkFindFilePath(ref_file, m_ExecPath);
+
+            if (ref_file_path == NULL)
+            {
+                printf("CheckRender::PPMvsPPM unable to find <%s> in <%s> Aborting comparison!\n", ref_file, m_ExecPath);
+                printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", ref_file);
+                printf("Aborting comparison!\n");
+                printf("  FAILED\n");
+                error_count++;
+            }
+
+            if (src_file == NULL || ref_file_path == NULL)
+            {
+                printf("PPMvsPPM: Aborting comparison\n");
+                return false;
+            }
+
+            printf("   src_file <%s>\n", src_file);
+            printf("   ref_file <%s>\n", ref_file_path);
+            return (sdkComparePPM(src_file, ref_file_path, epsilon, threshold, true) == true ? true : false);
+        }
+
+
+        void    setThresholdCompare(float value)
+        {
+            m_fThresholdCompare = value;
+        }
+
+        virtual void dumpBin(void *data, unsigned int bytes, const char *filename)
+        {
+            printf("CheckRender::dumpBin: <%s>\n", filename);
+            FILE *fp = fopen(filename, "wb");
+            fwrite(data, bytes, 1, fp);
+            fflush(fp);
+            fclose(fp);
+        }
+
+        virtual bool compareBin2BinUint(const char *src_file, const char *ref_file, unsigned int nelements, const float epsilon, const float threshold)
+        {
+            unsigned int *src_buffer, *ref_buffer;
+            FILE *src_fp = NULL, *ref_fp = NULL;
+
+            unsigned long error_count = 0;
+            size_t fsize = 0;
+
+            if ((src_fp = fopen(src_file, "rb")) == NULL)
+            {
+                printf("compareBin2Bin <unsigned int> unable to open src_file: %s\n", src_file);
+                error_count++;
+            }
+
+            char *ref_file_path = sdkFindFilePath(ref_file, m_ExecPath);
+
+            if (ref_file_path == NULL)
+            {
+                printf("compareBin2Bin <unsigned int>  unable to find <%s> in <%s>\n", ref_file, m_ExecPath);
+                printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", ref_file);
+                printf("Aborting comparison!\n");
+                printf("  FAILED\n");
+                error_count++;
+
+                if (src_fp)
+                {
+                    fclose(src_fp);
+                }
+
+                if (ref_fp)
+                {
+                    fclose(ref_fp);
+                }
+            }
+            else
+            {
+                if ((ref_fp = fopen(ref_file_path, "rb")) == NULL)
+                {
+                    printf("compareBin2Bin <unsigned int>  unable to open ref_file: %s\n", ref_file_path);
+                    error_count++;
+                }
+
+                if (src_fp && ref_fp)
+                {
+                    src_buffer = (unsigned int *)malloc(nelements*sizeof(unsigned int));
+                    ref_buffer = (unsigned int *)malloc(nelements*sizeof(unsigned int));
+
+                    fsize = fread(src_buffer, nelements, sizeof(unsigned int), src_fp);
+                    fsize = fread(ref_buffer, nelements, sizeof(unsigned int), ref_fp);
+
+                    printf("> compareBin2Bin <unsigned int> nelements=%d, epsilon=%4.2f, threshold=%4.2f\n", nelements, epsilon, threshold);
+                    printf("   src_file <%s>\n", src_file);
+                    printf("   ref_file <%s>\n", ref_file_path);
+
+                    if (!compareData<unsigned int, float>(ref_buffer, src_buffer, nelements, epsilon, threshold))
+                    {
+                        error_count++;
+                    }
+
+                    fclose(src_fp);
+                    fclose(ref_fp);
+
+                    free(src_buffer);
+                    free(ref_buffer);
+                }
+                else
+                {
+                    if (src_fp)
+                    {
+                        fclose(src_fp);
+                    }
+
+                    if (ref_fp)
+                    {
+                        fclose(ref_fp);
+                    }
+                }
+            }
+
+            if (error_count == 0)
+            {
+                printf("  OK\n");
+            }
+            else
+            {
+                printf("  FAILURE: %d errors...\n", (unsigned int)error_count);
+            }
+
+            return (error_count == 0);  // returns true if all pixels pass
+        }
+
+        virtual bool compareBin2BinFloat(const char *src_file, const char *ref_file, unsigned int nelements, const float epsilon, const float threshold)
+        {
+            float *src_buffer, *ref_buffer;
+            FILE *src_fp = NULL, *ref_fp = NULL;
+            size_t fsize = 0;
+
+            unsigned long error_count = 0;
+
+            if ((src_fp = fopen(src_file, "rb")) == NULL)
+            {
+                printf("compareBin2Bin <float> unable to open src_file: %s\n", src_file);
+                error_count = 1;
+            }
+
+            char *ref_file_path = sdkFindFilePath(ref_file, m_ExecPath);
+
+            if (ref_file_path == NULL)
+            {
+                printf("compareBin2Bin <float> unable to find <%s> in <%s>\n", ref_file, m_ExecPath);
+                printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", m_ExecPath);
+                printf("Aborting comparison!\n");
+                printf("  FAILED\n");
+                error_count++;
+
+                if (src_fp)
+                {
+                    fclose(src_fp);
+                }
+
+                if (ref_fp)
+                {
+                    fclose(ref_fp);
+                }
+            }
+            else
+            {
+                if ((ref_fp = fopen(ref_file_path, "rb")) == NULL)
+                {
+                    printf("compareBin2Bin <float> unable to open ref_file: %s\n", ref_file_path);
+                    error_count = 1;
+                }
+
+                if (src_fp && ref_fp)
+                {
+                    src_buffer = (float *)malloc(nelements*sizeof(float));
+                    ref_buffer = (float *)malloc(nelements*sizeof(float));
+
+                    fsize = fread(src_buffer, nelements, sizeof(float), src_fp);
+                    fsize = fread(ref_buffer, nelements, sizeof(float), ref_fp);
+
+                    printf("> compareBin2Bin <float> nelements=%d, epsilon=%4.2f, threshold=%4.2f\n", nelements, epsilon, threshold);
+                    printf("   src_file <%s>\n", src_file);
+                    printf("   ref_file <%s>\n", ref_file_path);
+
+                    if (!compareDataAsFloatThreshold<float, float>(ref_buffer, src_buffer, nelements, epsilon, threshold))
+                    {
+                        error_count++;
+                    }
+
+                    fclose(src_fp);
+                    fclose(ref_fp);
+
+                    free(src_buffer);
+                    free(ref_buffer);
+                }
+                else
+                {
+                    if (src_fp)
+                    {
+                        fclose(src_fp);
+                    }
+
+                    if (ref_fp)
+                    {
+                        fclose(ref_fp);
+                    }
+                }
+            }
+
+            if (error_count == 0)
+            {
+                printf("  OK\n");
+            }
+            else
+            {
+                printf("  FAILURE: %d errors...\n", (unsigned int)error_count);
+            }
+
+            return (error_count == 0);  // returns true if all pixels pass
+        }
+
+
+    protected:
+        unsigned int  m_Width, m_Height, m_Bpp;
+        unsigned char *m_pImageData;  // This is the image data stored in system memory
+        bool          m_bQAReadback, m_bUseFBO, m_bUsePBO;
+        GLuint        m_pboReadback;
+        GLenum        m_PixelFormat;
+        float         m_fThresholdCompare;
+        char          m_ExecPath[256];
+};
+
+
+class CheckBackBuffer : public CheckRender
+{
+    public:
+        CheckBackBuffer(unsigned int width, unsigned int height, unsigned int Bpp, bool bUseOpenGL = true) :
+            CheckRender(width, height, Bpp, false, false, bUseOpenGL)
+        {
+        }
+
+        virtual ~CheckBackBuffer()
+        {
+        }
+
+        virtual bool checkStatus(const char *zfile, int line, bool silent)
+        {
+            GLenum nErrorCode = glGetError();
+
+            if (nErrorCode != GL_NO_ERROR)
+            {
+                if (!silent)
+                {
+                    printf("Assertion failed(%s,%d): %s\n", zfile, line, gluErrorString(nErrorCode));
+                }
+            }
+
+            return true;
+        }
+
+        virtual bool readback(GLuint width, GLuint height)
+        {
+            bool ret = false;
+
+            if (m_bUsePBO)
+            {
+                // binds the PBO for readback
+                bindReadback();
+
+                // Initiate the readback BLT from BackBuffer->PBO->membuf
+                glReadPixels(0, 0, width, height, getPixelFormat(),      GL_UNSIGNED_BYTE, BUFFER_OFFSET(0));
+                ret = checkStatus(__FILE__, __LINE__, true);
+
+                if (!ret)
+                {
+                    printf("CheckBackBuffer::glReadPixels() checkStatus = %d\n", ret);
+                }
+
+                // map - unmap simulates readback without the copy
+                void *ioMem = glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_ONLY_ARB);
+                memcpy(m_pImageData,    ioMem, width*height*m_Bpp);
+
+                glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB);
+
+                // release the PBO
+                unbindReadback();
+            }
+            else
+            {
+                // reading direct from the backbuffer
+                glReadBuffer(GL_FRONT);
+                glReadPixels(0, 0, width, height, getPixelFormat(), GL_UNSIGNED_BYTE, m_pImageData);
+            }
+
+            return ret;
+        }
+
+        virtual bool readback(GLuint width, GLuint height, GLuint bufObject)
+        {
+            bool ret = false;
+
+            if (m_bUseFBO)
+            {
+                if (m_bUsePBO)
+                {
+                    printf("CheckBackBuffer::readback() FBO->PBO->m_pImageData\n");
+                    // binds the PBO for readback
+                    bindReadback();
+
+                    // bind FBO buffer (we want to transfer FBO -> PBO)
+                    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, bufObject);
+
+                    // Now initiate the readback to PBO
+                    glReadPixels(0, 0, width, height, getPixelFormat(),      GL_UNSIGNED_BYTE, BUFFER_OFFSET(0));
+                    ret = checkStatus(__FILE__, __LINE__, true);
+
+                    if (!ret)
+                    {
+                        printf("CheckBackBuffer::readback() FBO->PBO checkStatus = %d\n", ret);
+                    }
+
+                    // map - unmap simulates readback without the copy
+                    void *ioMem = glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_ONLY_ARB);
+                    memcpy(m_pImageData,    ioMem, width*height*m_Bpp);
+
+                    glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB);
+
+                    // release the FBO
+                    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+                    // release the PBO
+                    unbindReadback();
+                }
+                else
+                {
+                    printf("CheckBackBuffer::readback() FBO->m_pImageData\n");
+                    // Reading direct to FBO using glReadPixels
+                    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, bufObject);
+                    ret = checkStatus(__FILE__, __LINE__, true);
+
+                    if (!ret)
+                    {
+                        printf("CheckBackBuffer::readback::glBindFramebufferEXT() fbo=%d checkStatus = %d\n", bufObject, ret);
+                    }
+
+                    glReadBuffer(static_cast<GLenum>(GL_COLOR_ATTACHMENT0_EXT));
+                    ret &= checkStatus(__FILE__, __LINE__, true);
+
+                    if (!ret)
+                    {
+                        printf("CheckBackBuffer::readback::glReadBuffer() fbo=%d checkStatus = %d\n", bufObject, ret);
+                    }
+
+                    glReadPixels(0, 0, width, height, getPixelFormat(), GL_UNSIGNED_BYTE, m_pImageData);
+
+                    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+                }
+            }
+            else
+            {
+
+                printf("CheckBackBuffer::readback() PBO->m_pImageData\n");
+                // read from bufObject (PBO) to system memorys image
+                glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, bufObject);   // Bind the PBO
+
+                // map - unmap simulates readback without the copy
+                void *ioMem = glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_ONLY_ARB);
+
+                // allocate a buffer so we can flip the image
+                unsigned char *temp_buf = (unsigned char *)malloc(width*height*m_Bpp);
+                memcpy(temp_buf, ioMem, width*height*m_Bpp);
+
+                // let's flip the image as we copy
+                for (unsigned int y = 0; y < height; y++)
+                {
+                    memcpy((void *)&(m_pImageData[(height-y)*width*m_Bpp]), (void *)&(temp_buf[y*width*m_Bpp]), width*m_Bpp);
+                }
+
+                free(temp_buf);
+
+                glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB);
+
+                // read from bufObject (PBO) to system memory image
+                glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0);   // unBind the PBO
+            }
+
+            return CHECK_FBO;
+        }
+
+        virtual bool readback(GLuint width, GLuint height, unsigned char *memBuf)
+        {
+            // let's flip the image as we copy
+            for (unsigned int y = 0; y < height; y++)
+            {
+                memcpy((void *)&(m_pImageData[(height-y)*width*m_Bpp]), (void *)&(memBuf[y*width*m_Bpp]), width*m_Bpp);
+            }
+
+            return true;
+        }
+
+    private:
+        virtual void bindFragmentProgram() {};
+        virtual void bindRenderPath() {};
+        virtual void unbindRenderPath() {};
+
+        // bind to the BackBuffer to Texture
+        virtual void bindTexture() {};
+
+        // release this bind
+        virtual void unbindTexture() {};
+};
+
+
+// structure defining the properties of a single buffer
+struct bufferConfig
+{
+    string name;
+    GLenum format;
+    int bits;
+};
+
+// structures defining properties of an FBO
+struct fboConfig
+{
+    string name;
+    GLenum colorFormat;
+    GLenum depthFormat;
+    int redbits;
+    int depthBits;
+    int depthSamples;
+    int coverageSamples;
+};
+
+struct fboData
+{
+    GLuint colorTex; //color texture
+    GLuint depthTex; //depth texture
+    GLuint fb;      // render framebuffer
+    GLuint resolveFB; //multisample resolve target
+    GLuint colorRB; //color render buffer
+    GLuint depthRB; // depth render buffer
+};
+
+
+class CFrameBufferObject
+{
+    public:
+        CFrameBufferObject(unsigned int width, unsigned int height, unsigned int Bpp, bool bUseFloat, GLenum eTarget) :
+            m_Width(width),
+            m_Height(height),
+            m_bUseFloat(bUseFloat),
+            m_eGLTarget(eTarget)
+        {
+            glGenFramebuffersEXT(1, &m_fboData.fb);
+
+            m_fboData.colorTex = createTexture(m_eGLTarget, width, height,
+                                               (bUseFloat ? GL_RGBA32F_ARB : GL_RGBA8), GL_RGBA);
+
+            m_fboData.depthTex = createTexture(m_eGLTarget, width, height,
+                                               GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT);
+
+            attachTexture(m_eGLTarget, m_fboData.colorTex,   GL_COLOR_ATTACHMENT0_EXT);
+            attachTexture(m_eGLTarget, m_fboData.depthTex,   GL_DEPTH_ATTACHMENT_EXT);
+
+            //    bool ret = checkStatus(__FILE__, __LINE__, true);
+        }
+
+        virtual ~CFrameBufferObject()
+        {
+            //   freeResources();
+        }
+
+        GLuint createTexture(GLenum target, int w, int h, GLint internalformat, GLenum format)
+        {
+            GLuint texid;
+            glGenTextures(1, &texid);
+            glBindTexture(target, texid);
+
+            glTexParameteri(target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+            glTexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glTexParameteri(target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+            glTexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+            glTexImage2D(target, 0, internalformat, w, h, 0, format, GL_FLOAT, 0);
+            return texid;
+        }
+
+        void    attachTexture(GLenum texTarget,
+                              GLuint texId,
+                              GLenum attachment   = GL_COLOR_ATTACHMENT0_EXT,
+                              int mipLevel        = 0,
+                              int zSlice          = 0)
+        {
+            bindRenderPath();
+
+            switch (texTarget)
+            {
+                case GL_TEXTURE_1D:
+                    glFramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT, attachment,
+                                              GL_TEXTURE_1D, texId, mipLevel);
+                    break;
+
+                case GL_TEXTURE_3D:
+                    glFramebufferTexture3DEXT(GL_FRAMEBUFFER_EXT, attachment,
+                                              GL_TEXTURE_3D, texId, mipLevel, zSlice);
+                    break;
+
+                default:
+                    // Default is GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE_ARB, or cube faces
+                    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment,
+                                              texTarget, texId, mipLevel);
+                    break;
+            }
+
+            unbindRenderPath();
+        }
+
+        bool initialize(unsigned width, unsigned height, fboConfig &rConfigFBO, fboData &rActiveFBO)
+        {
+            //Framebuffer config options
+            vector<bufferConfig> colorConfigs;
+            vector<bufferConfig> depthConfigs;
+            bufferConfig temp;
+
+            //add default color configs
+            temp.name   = (m_bUseFloat ? "RGBA32F" : "RGBA8");
+            temp.bits   = (m_bUseFloat ? 32 : 8);
+            temp.format = (m_bUseFloat ? GL_RGBA32F_ARB : GL_RGBA8);
+            colorConfigs.push_back(temp);
+
+            //add default depth configs
+            temp.name = "D24";
+            temp.bits = 24;
+            temp.format = GL_DEPTH_COMPONENT24;
+            depthConfigs.push_back(temp);
+
+            // If the FBO can be created, add it to the list of available configs, and make a menu entry
+            string root = colorConfigs[0].name + " " + depthConfigs[0].name;
+
+            rConfigFBO.colorFormat  = colorConfigs[0].format;
+            rConfigFBO.depthFormat  = depthConfigs[0].format;
+            rConfigFBO.redbits      = colorConfigs[0].bits;
+            rConfigFBO.depthBits    = depthConfigs[0].bits;
+
+            //single sample
+            rConfigFBO.name             = root;
+            rConfigFBO.coverageSamples  = 0;
+            rConfigFBO.depthSamples     = 0;
+
+            create(width, height, rConfigFBO, rActiveFBO);
+
+            glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+            if (m_bUseFloat)
+            {
+                // load fragment programs
+                const char *strTextureProgram2D =
+                    "!!ARBfp1.0\n"
+                    "TEX result.color, fragment.texcoord[0], texture[0], 2D;\n"
+                    "END\n";
+
+                m_textureProgram = nv::CompileASMShader(GL_FRAGMENT_PROGRAM_ARB, strTextureProgram2D);
+
+                const char *strOverlayProgram =
+                    "!!ARBfp1.0\n"
+                    "TEMP t;\n"
+                    "TEX t, fragment.texcoord[0], texture[0], 2D;\n"
+                    "MOV result.color, t;\n"
+                    "END\n";
+
+                m_overlayProgram = nv::CompileASMShader(GL_FRAGMENT_PROGRAM_ARB, strOverlayProgram);
+            }
+
+            return CHECK_FBO;
+        }
+
+        bool create(GLuint width, GLuint height, fboConfig &config, fboData &data)
+        {
+            bool multisample = config.depthSamples > 0;
+            bool ret = true;
+            GLint query;
+
+            printf("\nCreating FBO <%s> (%dx%d) Float:%s\n", config.name.c_str(), (int)width, (int)height, (m_bUseFloat ? "Y":"N"));
+
+            glGenFramebuffersEXT(1, &data.fb);
+            glGenTextures(1, &data.colorTex);
+
+            // init texture
+            glBindTexture(m_eGLTarget, data.colorTex);
+            glTexImage2D(m_eGLTarget, 0, config.colorFormat,
+                         width, height, 0, GL_RGBA,
+                         (m_bUseFloat ? GL_FLOAT : GL_UNSIGNED_BYTE),
+                         NULL);
+
+            glGenerateMipmapEXT(m_eGLTarget);
+
+            glTexParameterf(m_eGLTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+            glTexParameterf(m_eGLTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+            glTexParameterf(m_eGLTarget, GL_TEXTURE_MIN_FILTER, GL_NEAREST);  // GL_LINEAR_MIPMAP_LINEAR);
+            glTexParameterf(m_eGLTarget, GL_TEXTURE_MAG_FILTER, GL_NEAREST);  // GL_LINEAR);
+
+            {
+                glGenTextures(1, &data.depthTex);
+                data.depthRB = 0;
+                data.colorRB = 0;
+                data.resolveFB = 0;
+
+                //non-multisample, so bind things directly to the FBO
+                glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, data.fb);
+                glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, m_eGLTarget, data.colorTex, 0);
+
+                glBindTexture(m_eGLTarget, data.depthTex);
+                glTexImage2D(m_eGLTarget, 0, config.depthFormat,
+                             width, height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
+
+                glTexParameterf(m_eGLTarget, GL_TEXTURE_MIN_FILTER, GL_NEAREST);  // GL_LINEAR);
+                glTexParameterf(m_eGLTarget, GL_TEXTURE_MAG_FILTER, GL_NEAREST);  // GL_LINEAR);
+                glTexParameterf(m_eGLTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+                glTexParameterf(m_eGLTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+                glTexParameterf(m_eGLTarget, GL_DEPTH_TEXTURE_MODE, GL_LUMINANCE);
+
+                glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, m_eGLTarget, data.depthTex, 0);
+
+                ret &= checkStatus(__FILE__, __LINE__, true);
+            }
+
+            glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, data.fb);
+            glGetIntegerv(GL_RED_BITS, &query);
+
+            if (query != config.redbits)
+            {
+                ret = false;
+            }
+
+            glGetIntegerv(GL_DEPTH_BITS, &query);
+
+            if (query != config.depthBits)
+            {
+                ret = false;
+            }
+
+            if (multisample)
+            {
+                glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, data.resolveFB);
+                glGetIntegerv(GL_RED_BITS, &query);
+
+                if (query != config.redbits)
+                {
+                    ret = false;
+                }
+            }
+
+            glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+            ret &= checkStatus(__FILE__, __LINE__, true);
+
+            return ret;
+        }
+
+        virtual void freeResources()
+        {
+            if (m_fboData.fb)
+            {
+                glDeleteFramebuffersEXT(1, &m_fboData.fb);
+            }
+
+            if (m_fboData.resolveFB)
+            {
+                glDeleteFramebuffersEXT(1, &m_fboData.resolveFB);
+            }
+
+            if (m_fboData.colorRB)
+            {
+                glDeleteRenderbuffersEXT(1, &m_fboData.colorRB);
+            }
+
+            if (m_fboData.depthRB)
+            {
+                glDeleteRenderbuffersEXT(1, &m_fboData.depthRB);
+            }
+
+            if (m_fboData.colorTex)
+            {
+                glDeleteTextures(1, &m_fboData.colorTex);
+            }
+
+            if (m_fboData.depthTex)
+            {
+                glDeleteTextures(1, &m_fboData.depthTex);
+            }
+
+            glDeleteProgramsARB(1, &m_textureProgram);
+            glDeleteProgramsARB(1, &m_overlayProgram);
+        }
+
+        virtual bool checkStatus(const char *zfile, int line, bool silent)
+        {
+            GLenum status;
+            status = (GLenum) glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+
+            if (status != GL_FRAMEBUFFER_COMPLETE_EXT)
+            {
+                printf("<%s : %d> - ", zfile, line);
+            }
+
+            switch (status)
+            {
+                case GL_FRAMEBUFFER_COMPLETE_EXT:
+                    break;
+
+                case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
+                    if (!silent)
+                    {
+                        printf("Unsupported framebuffer format\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, missing attachment\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, duplicate attachment\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, attached images must have same dimensions\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, attached images must have same format\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, missing draw buffer\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, missing read buffer\n");
+                    }
+
+                    return false;
+
+                default:
+                    assert(0);
+                    return false;
+            }
+
+            return true;
+        }
+
+        virtual void renderQuad(int width, int height, GLenum eTarget)
+        {
+            float width_norm  = (float)width/(float)m_Width,
+                  height_norm = (float)height/(float)m_Height;
+
+            // Bind the FBO texture for the display path
+            glBindTexture(eTarget, m_fboData.colorTex);
+
+            glGenerateMipmapEXT(GL_TEXTURE_2D);
+            glBindTexture(eTarget, 0);
+
+            // now render to the full screen using this texture
+            glClearColor(0.2f, 0.2f, 0.2f, 0.0f);
+            glClear(GL_COLOR_BUFFER_BIT);
+
+            glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, m_textureProgram);
+            glEnable(GL_FRAGMENT_PROGRAM_ARB);
+            glDisable(GL_DEPTH_TEST);
+
+            glBegin(GL_QUADS);
+            {
+                glVertex2f(0.0f      , 0.0f);
+                glTexCoord2f(0.0f      , 0.0f);
+                glVertex2f(0.0f      , height_norm);
+                glTexCoord2f(width_norm, 0.0f);
+                glVertex2f(width_norm, height_norm);
+                glTexCoord2f(width_norm, height_norm);
+                glVertex2f(width_norm, 0.0f);
+                glTexCoord2f(0.0f      , height_norm);
+            }
+            glEnd();
+
+            // Release the FBO texture (finished rendering)
+            glBindTexture(eTarget, 0);
+        }
+
+        // bind to the Fragment Program
+        void bindFragmentProgram()
+        {
+            glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, m_textureProgram);
+            glEnable(GL_FRAGMENT_PROGRAM_ARB);
+        }
+
+        // bind to the FrameBuffer Object
+        void bindRenderPath()
+        {
+            glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, m_fboData.fb);
+        }
+
+        // release current FrameBuffer Object
+        void unbindRenderPath()
+        {
+            glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+        }
+
+        // bind to the FBO to Texture
+        void bindTexture()
+        {
+            glBindTexture(m_eGLTarget, m_fboData.colorTex);
+        }
+
+        // release this bind
+        void unbindTexture()
+        {
+            glBindTexture(m_eGLTarget, 0);
+        }
+
+        GLuint getFbo()
+        {
+            return m_fboData.fb;
+        }
+        GLuint getTex()
+        {
+            return m_fboData.colorTex;
+        }
+        GLuint getDepthTex()
+        {
+            return m_fboData.depthTex;
+        }
+
+    private:
+        GLuint    m_Width, m_Height;
+        fboData   m_fboData;
+        fboConfig m_fboConfig;
+
+        GLuint    m_textureProgram;
+        GLuint    m_overlayProgram;
+
+        bool      m_bUseFloat;
+        GLenum    m_eGLTarget;
+};
+
+
+// CheckFBO - render and verify contents of the FBO
+class CheckFBO: public CheckRender
+{
+    public:
+        CheckFBO(unsigned int width, unsigned int height, unsigned int Bpp) :
+            CheckRender(width, height, Bpp, false, false, true),
+            m_pFrameBufferObject(NULL)
+        {
+        }
+
+        CheckFBO(unsigned int width, unsigned int height, unsigned int Bpp, CFrameBufferObject *pFrameBufferObject) :
+            CheckRender(width, height, Bpp, false, true, true),
+            m_pFrameBufferObject(pFrameBufferObject)
+        {
+        }
+
+        virtual ~CheckFBO()
+        {
+        }
+
+        virtual bool checkStatus(const char *zfile, int line, bool silent)
+        {
+            GLenum status;
+            status = (GLenum) glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+
+            if (status != GL_FRAMEBUFFER_COMPLETE_EXT)
+            {
+                printf("<%s : %d> - ", zfile, line);
+            }
+
+            switch (status)
+            {
+                case GL_FRAMEBUFFER_COMPLETE_EXT:
+                    break;
+
+                case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
+                    if (!silent)
+                    {
+                        printf("Unsupported framebuffer format\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, missing attachment\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, duplicate attachment\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, attached images must have same dimensions\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, attached images must have same format\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, missing draw buffer\n");
+                    }
+
+                    return false;
+
+                case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
+                    if (!silent)
+                    {
+                        printf("Framebuffer incomplete, missing read buffer\n");
+                    }
+
+                    return false;
+
+                default:
+                    assert(0);
+                    return false;
+            }
+
+            return true;
+        }
+
+        virtual bool readback(GLuint width, GLuint height)
+        {
+            bool ret = false;
+
+            if (m_bUsePBO)
+            {
+                // binds the PBO for readback
+                bindReadback();
+
+                // bind FBO buffer (we want to transfer FBO -> PBO)
+                glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, m_pFrameBufferObject->getFbo());
+
+                // Now initiate the readback to PBO
+                glReadPixels(0, 0, width, height, getPixelFormat(),      GL_UNSIGNED_BYTE, BUFFER_OFFSET(0));
+                ret = checkStatus(__FILE__, __LINE__, true);
+
+                if (!ret)
+                {
+                    printf("CheckFBO::readback() FBO->PBO checkStatus = %d\n", ret);
+                }
+
+                // map - unmap simulates readback without the copy
+                void *ioMem = glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_ONLY_ARB);
+                memcpy(m_pImageData,    ioMem, width*height*m_Bpp);
+
+                glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB);
+
+                // release the FBO
+                glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+                // release the PBO
+                unbindReadback();
+            }
+            else
+            {
+                // Reading back from FBO using glReadPixels
+                glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, m_pFrameBufferObject->getFbo());
+                ret = checkStatus(__FILE__, __LINE__, true);
+
+                if (!ret)
+                {
+                    printf("CheckFBO::readback::glBindFramebufferEXT() checkStatus = %d\n", ret);
+                }
+
+                glReadBuffer(static_cast<GLenum>(GL_COLOR_ATTACHMENT0_EXT));
+                ret &= checkStatus(__FILE__, __LINE__, true);
+
+                if (!ret)
+                {
+                    printf("CheckFBO::readback::glReadBuffer() checkStatus = %d\n", ret);
+                }
+
+                glReadPixels(0, 0, width, height, getPixelFormat(), GL_UNSIGNED_BYTE, m_pImageData);
+
+                glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+            }
+
+            return CHECK_FBO;
+        }
+
+        virtual bool readback(GLuint width, GLuint height, GLuint bufObject)
+        {
+            bool ret = false;
+
+            if (m_bUseFBO)
+            {
+                if (m_bUsePBO)
+                {
+                    printf("CheckFBO::readback() FBO->PBO->m_pImageData\n");
+                    // binds the PBO for readback
+                    bindReadback();
+
+                    // bind FBO buffer (we want to transfer FBO -> PBO)
+                    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, bufObject);
+
+                    // Now initiate the readback to PBO
+                    glReadPixels(0, 0, width, height, getPixelFormat(),      GL_UNSIGNED_BYTE, BUFFER_OFFSET(0));
+                    ret = checkStatus(__FILE__, __LINE__, true);
+
+                    if (!ret)
+                    {
+                        printf("CheckFBO::readback() FBO->PBO checkStatus = %d\n", ret);
+                    }
+
+                    // map - unmap simulates readback without the copy
+                    void *ioMem = glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_ONLY_ARB);
+                    memcpy(m_pImageData,    ioMem, width*height*m_Bpp);
+
+                    glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB);
+
+                    // release the FBO
+                    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+                    // release the PBO
+                    unbindReadback();
+                }
+                else
+                {
+                    printf("CheckFBO::readback() FBO->m_pImageData\n");
+                    // Reading direct to FBO using glReadPixels
+                    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, bufObject);
+                    ret = checkStatus(__FILE__, __LINE__, true);
+
+                    if (!ret)
+                    {
+                        printf("CheckFBO::readback::glBindFramebufferEXT() fbo=%d checkStatus = %d\n", (int)bufObject, (int)ret);
+                    }
+
+                    glReadBuffer(static_cast<GLenum>(GL_COLOR_ATTACHMENT0_EXT));
+                    ret &= checkStatus(__FILE__, __LINE__, true);
+
+                    if (!ret)
+                    {
+                        printf("CheckFBO::readback::glReadBuffer() fbo=%d checkStatus = %d\n", (int)bufObject, (int)ret);
+                    }
+
+                    glReadPixels(0, 0, width, height, getPixelFormat(), GL_UNSIGNED_BYTE, m_pImageData);
+
+                    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+                }
+            }
+            else
+            {
+                printf("CheckFBO::readback() PBO->m_pImageData\n");
+                // read from bufObject (PBO) to system memorys image
+                glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, bufObject);   // Bind the PBO
+
+                // map - unmap simulates readback without the copy
+                void *ioMem = glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_ONLY_ARB);
+                memcpy(m_pImageData,    ioMem, width*height*m_Bpp);
+
+                glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB);
+
+                // read from bufObject (PBO) to system memory image
+                glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0);   // unBind the PBO
+            }
+
+            return CHECK_FBO;
+        }
+
+        virtual bool readback(GLuint width, GLuint height, unsigned char *memBuf)
+        {
+            // let's flip the image as we copy
+            for (unsigned int y = 0; y < height; y++)
+            {
+                memcpy((void *)&(m_pImageData[(height-y)*width*m_Bpp]), (void *)&(memBuf[y*width*m_Bpp]), width*m_Bpp);
+            }
+
+            return true;
+        }
+
+    private:
+        CFrameBufferObject *m_pFrameBufferObject;
+};
+
+#endif // _RENDERCHECK_GL_H_
+
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/inc/timer.h gpu-rodinia_new/cuda/cfd/common/inc/timer.h
--- gpu-rodinia/cuda/cfd/common/inc/timer.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/inc/timer.h	2023-06-06 17:20:53.976838417 -0600
@@ -0,0 +1,65 @@
+/////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+//
+// Please refer to the NVIDIA end user license agreement (EULA) associated
+// with this source code for terms and conditions that govern your use of
+// this software. Any use, reproduction, disclosure, or distribution of
+// this software and related documentation outside the terms of the EULA
+// is strictly prohibited.
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef TIMER_H
+#define TIMER_H
+
+#include <stdlib.h>
+
+#ifdef _WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#else
+#include <sys/time.h>
+#endif
+
+#ifdef _WIN32
+double PCFreq = 0.0;
+__int64 timerStart = 0;
+#else
+struct timeval timerStart;
+#endif
+
+void StartTimer()
+{
+#ifdef _WIN32
+    LARGE_INTEGER li;
+
+    if (!QueryPerformanceFrequency(&li))
+    {
+        printf("QueryPerformanceFrequency failed!\n");
+    }
+
+    PCFreq = (double)li.QuadPart/1000.0;
+    QueryPerformanceCounter(&li);
+    timerStart = li.QuadPart;
+#else
+    gettimeofday(&timerStart, NULL);
+#endif
+}
+
+// time elapsed in ms
+double GetTimer()
+{
+#ifdef _WIN32
+    LARGE_INTEGER li;
+    QueryPerformanceCounter(&li);
+    return (double)(li.QuadPart-timerStart)/PCFreq;
+#else
+    struct timeval timerStop, timerElapsed;
+    gettimeofday(&timerStop, NULL);
+    timersub(&timerStop, &timerStart, &timerElapsed);
+    return timerElapsed.tv_sec*1000.0+timerElapsed.tv_usec/1000.0;
+#endif
+}
+#endif // TIMER_H
+
Binary files gpu-rodinia/cuda/cfd/common/lib/linux/i686/libGLEW.a and gpu-rodinia_new/cuda/cfd/common/lib/linux/i686/libGLEW.a differ
Binary files gpu-rodinia/cuda/cfd/common/lib/linux/x86_64/libGLEW.a and gpu-rodinia_new/cuda/cfd/common/lib/linux/x86_64/libGLEW.a differ
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/make.config gpu-rodinia_new/cuda/cfd/common/make.config
--- gpu-rodinia/cuda/cfd/common/make.config	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/make.config	2023-06-06 17:20:53.980838341 -0600
@@ -0,0 +1,33 @@
+# CUDA toolkit installation path
+CUDA_DIR = /usr/local/cuda
+
+# CUDA toolkit libraries
+CUDA_LIB_DIR := $(CUDA_DIR)/lib
+ifeq ($(shell uname -m), x86_64)
+     ifeq ($(shell if test -d $(CUDA_DIR)/lib64; then echo T; else echo F; fi), T)
+     	CUDA_LIB_DIR := $(CUDA_DIR)/lib64
+     endif
+endif
+
+# CUDA SDK installation path
+#SDK_DIR = $(HOME)/NVIDIA_GPU_Computing_SDK/C
+SDK_DIR =/if10/kw5na/NVIDIA_GPU_Computing_SDK4/C
+#SDK_DIR =/if10/kw5na/NVIDIA_CUDA_Computing_SDK4/C
+
+# OPENCL
+
+# NVIDIA_DIR
+
+# OPENCL_DIR =/if10/kw5na/NVIDIA_GPU_Computing_SDK4
+# OPENCL_INC = $(OPENCL_DIR)/OpenCL/common/inc
+# OPENCL_LIB = $(OPENCL_DIR)/OpenCL/common/lib -lOpenCL
+
+# AMD_DIR
+OPENCL_DIR = /if10/kw5na/Packages/AMD-APP-SDK-v2.8-RC-lnx64
+OPENCL_INC = $(OPENCL_DIR)/include/ 
+OPENCL_LIB = $(OPENCL_DIR)/lib/x86_64/ -lOpenCL
+#ifeq ($(shell uname -m), x86_64)
+#     ifeq ($(shell if test -d $(OPENCL_DIR)/lib/x86_64/; then echo T; else echo F; fi), T)
+#     	OPENCL_LIB = $(OPENCL_DIR)/lib/x86_64/
+#     endif
+#endif
\ No newline at end of file
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/src/cuda_runtime_dynlink.cpp gpu-rodinia_new/cuda/cfd/common/src/cuda_runtime_dynlink.cpp
--- gpu-rodinia/cuda/cfd/common/src/cuda_runtime_dynlink.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/src/cuda_runtime_dynlink.cpp	2023-06-06 17:20:53.980838341 -0600
@@ -0,0 +1,309 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+#include <dynlink/cuda_runtime_dynlink.h>
+
+tcudaMalloc3D                   *cudaMalloc3D;
+tcudaMalloc3DArray              *cudaMalloc3DArray;
+tcudaMemset3D                   *cudaMemset3D;
+tcudaMemcpy3D                   *cudaMemcpy3D;
+tcudaMemcpy3DAsync              *cudaMemcpy3DAsync;
+tcudaMalloc                     *cudaMalloc;
+tcudaMallocHost                 *cudaMallocHost;
+tcudaMallocPitch                *cudaMallocPitch;
+tcudaMallocArray                *cudaMallocArray;
+tcudaFree                       *cudaFree;
+tcudaFreeHost                   *cudaFreeHost;
+tcudaFreeArray                  *cudaFreeArray;
+tcudaMemcpy                     *cudaMemcpy;
+tcudaMemcpyToArray              *cudaMemcpyToArray;
+tcudaMemcpyFromArray            *cudaMemcpyFromArray;
+tcudaMemcpyArrayToArray         *cudaMemcpyArrayToArray;
+tcudaMemcpy2D                   *cudaMemcpy2D;
+tcudaMemcpy2DToArray            *cudaMemcpy2DToArray;
+tcudaMemcpy2DFromArray          *cudaMemcpy2DFromArray;
+tcudaMemcpy2DArrayToArray       *cudaMemcpy2DArrayToArray;
+tcudaMemcpyToSymbol             *cudaMemcpyToSymbol;
+tcudaMemcpyFromSymbol           *cudaMemcpyFromSymbol;
+tcudaMemcpyAsync                *cudaMemcpyAsync;
+tcudaMemcpyToArrayAsync         *cudaMemcpyToArrayAsync;
+tcudaMemcpyFromArrayAsync       *cudaMemcpyFromArrayAsync;
+tcudaMemcpy2DAsync              *cudaMemcpy2DAsync;
+tcudaMemcpy2DToArrayAsync       *cudaMemcpy2DToArrayAsync;
+tcudaMemcpy2DFromArrayAsync     *cudaMemcpy2DFromArrayAsync;
+tcudaMemcpyToSymbolAsync        *cudaMemcpyToSymbolAsync;
+tcudaMemcpyFromSymbolAsync      *cudaMemcpyFromSymbolAsync;
+tcudaMemset                     *cudaMemset;
+tcudaMemset2D                   *cudaMemset2D;
+tcudaGetSymbolAddress           *cudaGetSymbolAddress;
+tcudaGetSymbolSize              *cudaGetSymbolSize;
+tcudaGetDeviceCount             *cudaGetDeviceCount;
+tcudaGetDeviceProperties        *cudaGetDeviceProperties;
+tcudaChooseDevice               *cudaChooseDevice;
+tcudaSetDevice                  *cudaSetDevice;
+tcudaGetDevice                  *cudaGetDevice;
+tcudaBindTexture                *cudaBindTexture;
+tcudaBindTextureToArray         *cudaBindTextureToArray;
+tcudaUnbindTexture              *cudaUnbindTexture;
+tcudaGetTextureAlignmentOffset  *cudaGetTextureAlignmentOffset;
+tcudaGetTextureReference        *cudaGetTextureReference;
+tcudaGetChannelDesc             *cudaGetChannelDesc;
+tcudaCreateChannelDesc          *cudaCreateChannelDesc;
+tcudaGetLastError               *cudaGetLastError;
+tcudaGetErrorString             *cudaGetErrorString;
+tcudaConfigureCall              *cudaConfigureCall;
+tcudaSetupArgument              *cudaSetupArgument;
+tcudaLaunch                     *cudaLaunch;
+tcudaStreamCreate               *cudaStreamCreate;
+tcudaStreamDestroy              *cudaStreamDestroy;
+tcudaStreamSynchronize          *cudaStreamSynchronize;
+tcudaStreamQuery                *cudaStreamQuery;
+tcudaEventCreate                *cudaEventCreate;
+tcudaEventRecord                *cudaEventRecord;
+tcudaEventQuery                 *cudaEventQuery;
+tcudaEventSynchronize           *cudaEventSynchronize;
+tcudaEventDestroy               *cudaEventDestroy;
+tcudaEventElapsedTime           *cudaEventElapsedTime;
+tcudaSetDoubleForDevice         *cudaSetDoubleForDevice;
+tcudaSetDoubleForHost           *cudaSetDoubleForHost;
+tcudaDeviceReset                *cudaDeviceReset;
+tcudaDeviceSynchronize          *cudaDeviceSynchronize;
+
+
+
+#if defined(_WIN32) || defined(_WIN64)
+#define _WIN    1
+#define _OS _WIN
+#elif defined(__unix__)
+#define _UNIX   2
+#define _OS _UNIX
+#endif
+
+
+#if (_OS == _WIN)
+
+#include <Windows.h>
+
+__host__ cudaError_t CUDARTAPI cudaRuntimeDynload(void)
+{
+
+#define QUOTE(x)        #x
+#define GET_PROC(name)  name = (t##name *)GetProcAddress(CudaRtLib, QUOTE(name)); if (name == NULL) return cudaErrorUnknown
+
+    HMODULE CudaRtLib = LoadLibrary(L"cudart.dll");
+
+    if (CudaRtLib == NULL)
+    {
+        return cudaErrorUnknown;
+    }
+    else
+    {
+        GET_PROC(cudaMalloc3D);
+        GET_PROC(cudaMalloc3DArray);
+        GET_PROC(cudaMemset3D);
+        GET_PROC(cudaMemcpy3D);
+        GET_PROC(cudaMemcpy3DAsync);
+
+        GET_PROC(cudaMalloc);
+        GET_PROC(cudaMallocHost);
+        GET_PROC(cudaMallocPitch);
+        GET_PROC(cudaMallocArray);
+        GET_PROC(cudaFree);
+        GET_PROC(cudaFreeHost);
+        GET_PROC(cudaFreeArray);
+
+        GET_PROC(cudaMemcpy);
+        GET_PROC(cudaMemcpyToArray);
+        GET_PROC(cudaMemcpyFromArray);
+        GET_PROC(cudaMemcpyArrayToArray);
+        GET_PROC(cudaMemcpy2D);
+        GET_PROC(cudaMemcpy2DToArray);
+        GET_PROC(cudaMemcpy2DFromArray);
+        GET_PROC(cudaMemcpy2DArrayToArray);
+        GET_PROC(cudaMemcpyToSymbol);
+        GET_PROC(cudaMemcpyFromSymbol);
+
+        GET_PROC(cudaMemcpyAsync);
+        GET_PROC(cudaMemcpyToArrayAsync);
+        GET_PROC(cudaMemcpyFromArrayAsync);
+        GET_PROC(cudaMemcpy2DAsync);
+        GET_PROC(cudaMemcpy2DToArrayAsync);
+        GET_PROC(cudaMemcpy2DFromArrayAsync);
+        GET_PROC(cudaMemcpyToSymbolAsync);
+        GET_PROC(cudaMemcpyFromSymbolAsync);
+
+        GET_PROC(cudaMemset);
+        GET_PROC(cudaMemset2D);
+
+        GET_PROC(cudaGetSymbolAddress);
+        GET_PROC(cudaGetSymbolSize);
+
+        GET_PROC(cudaGetDeviceCount);
+        GET_PROC(cudaGetDeviceProperties);
+        GET_PROC(cudaChooseDevice);
+        GET_PROC(cudaSetDevice);
+        GET_PROC(cudaGetDevice);
+
+        GET_PROC(cudaBindTexture);
+        GET_PROC(cudaBindTextureToArray);
+        GET_PROC(cudaUnbindTexture);
+        GET_PROC(cudaGetTextureAlignmentOffset);
+        GET_PROC(cudaGetTextureReference);
+
+        GET_PROC(cudaGetChannelDesc);
+        GET_PROC(cudaCreateChannelDesc);
+
+        GET_PROC(cudaGetLastError);
+        GET_PROC(cudaGetErrorString);
+
+        GET_PROC(cudaConfigureCall);
+        GET_PROC(cudaSetupArgument);
+        GET_PROC(cudaLaunch);
+
+        GET_PROC(cudaStreamCreate);
+        GET_PROC(cudaStreamDestroy);
+        GET_PROC(cudaStreamSynchronize);
+        GET_PROC(cudaStreamQuery);
+
+        GET_PROC(cudaEventCreate);
+        GET_PROC(cudaEventRecord);
+        GET_PROC(cudaEventQuery);
+        GET_PROC(cudaEventSynchronize);
+        GET_PROC(cudaEventDestroy);
+        GET_PROC(cudaEventElapsedTime);
+
+        GET_PROC(cudaSetDoubleForDevice);
+        GET_PROC(cudaSetDoubleForHost);
+
+        GET_PROC(cudaDeviceReset);
+        GET_PROC(cudaDeviceSynchronize);
+    }
+
+    return cudaSuccess;
+
+#undef QUOTE
+#undef GET_PROC
+
+}
+
+#elif (_OS == _UNIX)
+
+#include <dlfcn.h>
+
+__host__ cudaError_t CUDARTAPI cudaRuntimeDynload(void)
+{
+#define QUOTE(x)        #x
+#define GET_PROC(name)  name = (t##name *)dlsym(CudaRtLib, QUOTE(name)); if (name == NULL) return cudaErrorUnknown
+
+    void *CudaRtLib = dlopen("libcudart.so", RTLD_LAZY);
+
+    if (CudaRtLib == NULL)
+    {
+        return cudaErrorUnknown;
+    }
+    else
+    {
+        GET_PROC(cudaMalloc3D);
+        GET_PROC(cudaMalloc3DArray);
+        GET_PROC(cudaMemset3D);
+        GET_PROC(cudaMemcpy3D);
+        GET_PROC(cudaMemcpy3DAsync);
+
+        GET_PROC(cudaMalloc);
+        GET_PROC(cudaMallocHost);
+        GET_PROC(cudaMallocPitch);
+        GET_PROC(cudaMallocArray);
+        GET_PROC(cudaFree);
+        GET_PROC(cudaFreeHost);
+        GET_PROC(cudaFreeArray);
+
+        GET_PROC(cudaMemcpy);
+        GET_PROC(cudaMemcpyToArray);
+        GET_PROC(cudaMemcpyFromArray);
+        GET_PROC(cudaMemcpyArrayToArray);
+        GET_PROC(cudaMemcpy2D);
+        GET_PROC(cudaMemcpy2DToArray);
+        GET_PROC(cudaMemcpy2DFromArray);
+        GET_PROC(cudaMemcpy2DArrayToArray);
+        GET_PROC(cudaMemcpyToSymbol);
+        GET_PROC(cudaMemcpyFromSymbol);
+
+        GET_PROC(cudaMemcpyAsync);
+        GET_PROC(cudaMemcpyToArrayAsync);
+        GET_PROC(cudaMemcpyFromArrayAsync);
+        GET_PROC(cudaMemcpy2DAsync);
+        GET_PROC(cudaMemcpy2DToArrayAsync);
+        GET_PROC(cudaMemcpy2DFromArrayAsync);
+        GET_PROC(cudaMemcpyToSymbolAsync);
+        GET_PROC(cudaMemcpyFromSymbolAsync);
+
+        GET_PROC(cudaMemset);
+        GET_PROC(cudaMemset2D);
+
+        GET_PROC(cudaGetSymbolAddress);
+        GET_PROC(cudaGetSymbolSize);
+
+        GET_PROC(cudaGetDeviceCount);
+        GET_PROC(cudaGetDeviceProperties);
+        GET_PROC(cudaChooseDevice);
+        GET_PROC(cudaSetDevice);
+        GET_PROC(cudaGetDevice);
+
+        GET_PROC(cudaBindTexture);
+        GET_PROC(cudaBindTextureToArray);
+        GET_PROC(cudaUnbindTexture);
+        GET_PROC(cudaGetTextureAlignmentOffset);
+        GET_PROC(cudaGetTextureReference);
+
+        GET_PROC(cudaGetChannelDesc);
+        GET_PROC(cudaCreateChannelDesc);
+
+        GET_PROC(cudaGetLastError);
+        GET_PROC(cudaGetErrorString);
+
+        GET_PROC(cudaConfigureCall);
+        GET_PROC(cudaSetupArgument);
+        GET_PROC(cudaLaunch);
+
+        GET_PROC(cudaStreamCreate);
+        GET_PROC(cudaStreamDestroy);
+        GET_PROC(cudaStreamSynchronize);
+        GET_PROC(cudaStreamQuery);
+
+        GET_PROC(cudaEventCreate);
+        GET_PROC(cudaEventRecord);
+        GET_PROC(cudaEventQuery);
+        GET_PROC(cudaEventSynchronize);
+        GET_PROC(cudaEventDestroy);
+        GET_PROC(cudaEventElapsedTime);
+
+        GET_PROC(cudaSetDoubleForDevice);
+        GET_PROC(cudaSetDoubleForHost);
+
+        GET_PROC(cudaDeviceReset);
+        GET_PROC(cudaDeviceSynchronize);
+    }
+
+    return cudaSuccess;
+
+#undef QUOTE
+#undef GET_PROC
+}
+
+
+
+#endif
+
+
+
+
+
+
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/src/multithreading.cpp gpu-rodinia_new/cuda/cfd/common/src/multithreading.cpp
--- gpu-rodinia/cuda/cfd/common/src/multithreading.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/src/multithreading.cpp	2023-06-06 17:20:53.980838341 -0600
@@ -0,0 +1,78 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+
+
+#include <multithreading.h>
+
+#if _WIN32
+//Create thread
+CUTThread cutStartThread(CUT_THREADROUTINE func, void *data)
+{
+    return CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func, data, 0, NULL);
+}
+
+//Wait for thread to finish
+void cutEndThread(CUTThread thread)
+{
+    WaitForSingleObject(thread, INFINITE);
+    CloseHandle(thread);
+}
+
+//Destroy thread
+void cutDestroyThread(CUTThread thread)
+{
+    TerminateThread(thread, 0);
+    CloseHandle(thread);
+}
+
+//Wait for multiple threads
+void cutWaitForThreads(const CUTThread *threads, int num)
+{
+    WaitForMultipleObjects(num, threads, true, INFINITE);
+
+    for (int i = 0; i < num; i++)
+    {
+        CloseHandle(threads[i]);
+    }
+}
+
+#else
+//Create thread
+CUTThread cutStartThread(CUT_THREADROUTINE func, void *data)
+{
+    pthread_t thread;
+    pthread_create(&thread, NULL, func, data);
+    return thread;
+}
+
+//Wait for thread to finish
+void cutEndThread(CUTThread thread)
+{
+    pthread_join(thread, NULL);
+}
+
+//Destroy thread
+void cutDestroyThread(CUTThread thread)
+{
+    pthread_cancel(thread);
+}
+
+//Wait for multiple threads
+void cutWaitForThreads(const CUTThread *threads, int num)
+{
+    for (int i = 0; i < num; i++)
+    {
+        cutEndThread(threads[i]);
+    }
+}
+
+#endif
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/src/rendercheck_d3d10.cpp gpu-rodinia_new/cuda/cfd/common/src/rendercheck_d3d10.cpp
--- gpu-rodinia/cuda/cfd/common/src/rendercheck_d3d10.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/src/rendercheck_d3d10.cpp	2023-06-06 17:20:53.980838341 -0600
@@ -0,0 +1,103 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//
+//  Utility funcs to wrap up saving a surface or the back buffer as a PPM file
+//  In addition, wraps up a threshold comparision of two PPMs.
+//
+//  These functions are designed to be used to implement an automated QA testing for SDK samples.
+//
+//  Author: Bryan Dudash
+//  Email: sdkfeedback@nvidia.com
+//
+// Copyright (c) NVIDIA Corporation. All rights reserved.
+////////////////////////////////////////////////////////////////////////////////
+
+#include <helper_functions.h>
+#include <rendercheck_d3d10.h>
+
+HRESULT CheckRenderD3D10::ActiveRenderTargetToPPM(ID3D10Device *pDevice, const char *zFileName)
+{
+    ID3D10RenderTargetView *pRTV = NULL;
+    pDevice->OMGetRenderTargets(1,&pRTV,NULL);
+
+    ID3D10Resource *pSourceResource = NULL;
+    pRTV->GetResource(&pSourceResource);
+
+    return ResourceToPPM(pDevice,pSourceResource,zFileName);
+}
+
+HRESULT CheckRenderD3D10::ResourceToPPM(ID3D10Device *pDevice, ID3D10Resource *pResource, const char *zFileName)
+{
+    D3D10_RESOURCE_DIMENSION rType;
+    pResource->GetType(&rType);
+
+    if (rType != D3D10_RESOURCE_DIMENSION_TEXTURE2D)
+    {
+        printf("SurfaceToPPM: pResource is not a 2D texture! Aborting...\n");
+        return E_FAIL;
+    }
+
+    ID3D10Texture2D *pSourceTexture = (ID3D10Texture2D *)pResource;
+    ID3D10Texture2D *pTargetTexture = NULL;
+
+    D3D10_TEXTURE2D_DESC desc;
+    pSourceTexture->GetDesc(&desc);
+    desc.BindFlags = 0;
+    desc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
+    desc.Usage = D3D10_USAGE_STAGING;
+
+    if (FAILED(pDevice->CreateTexture2D(&desc,NULL,&pTargetTexture)))
+    {
+        printf("SurfaceToPPM: Unable to create target Texture resoruce! Aborting... \n");
+        return E_FAIL;
+    }
+
+    pDevice->CopyResource(pTargetTexture,pSourceTexture);
+
+    D3D10_MAPPED_TEXTURE2D mappedTex2D;
+    pTargetTexture->Map(0,D3D10_MAP_READ,0,&mappedTex2D);
+
+    // Need to convert from dx pitch to pitch=width
+    unsigned char *pPPMData = new unsigned char[desc.Width*desc.Height*4];
+
+    for (unsigned int iHeight = 0; iHeight<desc.Height; iHeight++)
+    {
+        memcpy(&(pPPMData[iHeight*desc.Width*4]),(unsigned char *)(mappedTex2D.pData)+iHeight*mappedTex2D.RowPitch,desc.Width*4);
+    }
+
+    pTargetTexture->Unmap(0);
+
+    // Prepends the PPM header info and bumps byte data afterwards
+    sdkSavePPM4ub(zFileName, pPPMData, desc.Width, desc.Height);
+
+    delete [] pPPMData;
+    pTargetTexture->Release();
+
+    return S_OK;
+}
+
+bool CheckRenderD3D10::PPMvsPPM(const char *src_file, const char *ref_file, const char *exec_path,
+                                const float epsilon, const float threshold)
+{
+    char *ref_file_path = sdkFindFilePath(ref_file, exec_path);
+
+    if (ref_file_path == NULL)
+    {
+        printf("CheckRenderD3D10::PPMvsPPM unable to find <%s> in <%s> Aborting comparison!\n", ref_file, exec_path);
+        printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", ref_file);
+        printf("Aborting comparison!\n");
+        printf("  FAILURE!\n");
+        return false;
+    }
+
+    return (sdkComparePPM(src_file,ref_file_path,epsilon,threshold,true) == true);
+}
\ No newline at end of file
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/src/rendercheck_d3d11.cpp gpu-rodinia_new/cuda/cfd/common/src/rendercheck_d3d11.cpp
--- gpu-rodinia/cuda/cfd/common/src/rendercheck_d3d11.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/src/rendercheck_d3d11.cpp	2023-06-06 17:20:53.980838341 -0600
@@ -0,0 +1,107 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//
+//  Utility funcs to wrap up saving a surface or the back buffer as a PPM file
+//  In addition, wraps up a threshold comparision of two PPMs.
+//
+//  These functions are designed to be used to implement an automated QA testing for SDK samples.
+//
+//  Author: Bryan Dudash
+//  Email: sdkfeedback@nvidia.com
+//
+// Copyright (c) NVIDIA Corporation. All rights reserved.
+////////////////////////////////////////////////////////////////////////////////
+
+#include <helper_functions.h>
+#include <rendercheck_d3d11.h>
+
+HRESULT CheckRenderD3D11::ActiveRenderTargetToPPM(ID3D11Device *pDevice, const char *zFileName)
+{
+    ID3D11DeviceContext *pDeviceCtxt;
+    pDevice->GetImmediateContext(&pDeviceCtxt);
+    ID3D11RenderTargetView *pRTV = NULL;
+    pDeviceCtxt->OMGetRenderTargets(1,&pRTV,NULL);
+
+    ID3D11Resource *pSourceResource = NULL;
+    pRTV->GetResource(&pSourceResource);
+
+    return ResourceToPPM(pDevice,pSourceResource,zFileName);
+}
+
+HRESULT CheckRenderD3D11::ResourceToPPM(ID3D11Device *pDevice, ID3D11Resource *pResource, const char *zFileName)
+{
+    ID3D11DeviceContext *pDeviceCtxt;
+    pDevice->GetImmediateContext(&pDeviceCtxt);
+    D3D11_RESOURCE_DIMENSION rType;
+    pResource->GetType(&rType);
+
+    if (rType != D3D11_RESOURCE_DIMENSION_TEXTURE2D)
+    {
+        printf("SurfaceToPPM: pResource is not a 2D texture! Aborting...\n");
+        return E_FAIL;
+    }
+
+    ID3D11Texture2D *pSourceTexture = (ID3D11Texture2D *)pResource;
+    ID3D11Texture2D *pTargetTexture = NULL;
+
+    D3D11_TEXTURE2D_DESC desc;
+    pSourceTexture->GetDesc(&desc);
+    desc.BindFlags = 0;
+    desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
+    desc.Usage = D3D11_USAGE_STAGING;
+
+    if (FAILED(pDevice->CreateTexture2D(&desc,NULL,&pTargetTexture)))
+    {
+        printf("SurfaceToPPM: Unable to create target Texture resoruce! Aborting... \n");
+        return E_FAIL;
+    }
+
+    pDeviceCtxt->CopyResource(pTargetTexture,pSourceTexture);
+
+    D3D11_MAPPED_SUBRESOURCE mappedTex2D;
+    pDeviceCtxt->Map(pTargetTexture, 0, D3D11_MAP_READ,0,&mappedTex2D);
+
+    // Need to convert from dx pitch to pitch=width
+    unsigned char *pPPMData = new unsigned char[desc.Width*desc.Height*4];
+
+    for (unsigned int iHeight = 0; iHeight<desc.Height; iHeight++)
+    {
+        memcpy(&(pPPMData[iHeight*desc.Width*4]),(unsigned char *)(mappedTex2D.pData)+iHeight*mappedTex2D.RowPitch,desc.Width*4);
+    }
+
+    pDeviceCtxt->Unmap(pTargetTexture, 0);
+
+    // Prepends the PPM header info and bumps byte data afterwards
+    sdkSavePPM4ub(zFileName, pPPMData, desc.Width, desc.Height);
+
+    delete [] pPPMData;
+    pTargetTexture->Release();
+
+    return S_OK;
+}
+
+bool CheckRenderD3D11::PPMvsPPM(const char *src_file, const char *ref_file, const char *exec_path,
+                                const float epsilon, const float threshold)
+{
+    char *ref_file_path = sdkFindFilePath(ref_file, exec_path);
+
+    if (ref_file_path == NULL)
+    {
+        printf("CheckRenderD3D11::PPMvsPPM unable to find <%s> in <%s> Aborting comparison!\n", ref_file, exec_path);
+        printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", ref_file);
+        printf("Aborting comparison!\n");
+        printf("  FAILURE!\n");
+        return false;
+    }
+
+    return sdkComparePPM(src_file,ref_file_path,epsilon,threshold,true) == true;
+}
\ No newline at end of file
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/src/rendercheck_d3d9.cpp gpu-rodinia_new/cuda/cfd/common/src/rendercheck_d3d9.cpp
--- gpu-rodinia/cuda/cfd/common/src/rendercheck_d3d9.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/src/rendercheck_d3d9.cpp	2023-06-06 17:20:53.980838341 -0600
@@ -0,0 +1,138 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+//
+//  Utility funcs to wrap up savings a surface or the back buffer as a PPM file
+//  In addition, wraps up a threshold comparision of two PPMs.
+//
+//  These functions are designed to be used to implement an automated QA testing for SDK samples.
+//
+//  Author: Bryan Dudash
+//  Email: sdkfeedback@nvidia.com
+//
+// Copyright (c) NVIDIA Corporation. All rights reserved.
+////////////////////////////////////////////////////////////////////////////////
+
+#include <helper_functions.h>
+#include <rendercheck_d3d9.h>
+#include <d3dx9.h>
+
+// originally copied from checkrender_gl.cpp and slightly modified
+bool CheckRenderD3D9::PPMvsPPM(const char *src_file, const char *ref_file, const char *exec_path,
+                               const float epsilon, const float threshold)
+{
+    char *ref_file_path = sdkFindFilePath(ref_file, exec_path);
+
+    if (ref_file_path == NULL)
+    {
+        printf("CheckRenderD3D9::PPMvsPPM unable to find <%s> in <%s> Aborting comparison!\n", ref_file, exec_path);
+        printf(">>> Check info.xml and [project//data] folder <%s> <<<\n", ref_file);
+        printf("Aborting comparison!\n");
+        printf("  FAILURE!\n");
+        return false;
+    }
+
+    return (sdkComparePPM(src_file, ref_file_path, epsilon, threshold, true) == true);
+};
+
+HRESULT CheckRenderD3D9::BackbufferToPPM(IDirect3DDevice9 *pDevice, const char *zFileName)
+{
+    IDirect3DSurface9 *pSurface = NULL;
+
+    if (FAILED(pDevice->GetBackBuffer(0,0,D3DBACKBUFFER_TYPE_MONO, &pSurface)))
+    {
+        printf("Unable to get the back buffer.  Aborting...\n");
+        return E_FAIL;
+    }
+
+    //D3DXSaveSurfaceToFile("C:\\bing.dds",D3DXIFF_DDS,pSurface,NULL,NULL);
+
+    HRESULT hr = S_OK;
+    hr = SurfaceToPPM(pDevice,pSurface,zFileName);
+
+    pSurface->Release();
+
+    return hr;
+}
+
+HRESULT CheckRenderD3D9::SurfaceToPPM(IDirect3DDevice9 *pDevice, IDirect3DSurface9 *pSurface, const char *zFileName)
+{
+    D3DSURFACE_DESC pDesc;
+    pSurface->GetDesc(&pDesc);
+
+    // $$ For now only support common 8bit formats.  TODO: support for more complex formats via conversion?
+    if (!(pDesc.Format == D3DFMT_A8R8G8B8 || pDesc.Format == D3DFMT_X8R8G8B8))
+    {
+        return E_INVALIDARG;
+    }
+
+    IDirect3DTexture9 *pTargetTex = NULL;
+
+    if (FAILED(pDevice->CreateTexture(pDesc.Width,pDesc.Height,1,D3DUSAGE_DYNAMIC,pDesc.Format,D3DPOOL_SYSTEMMEM,&pTargetTex,NULL)))
+    {
+        printf("Unable to create texture for surface transfer! Aborting...\n");
+        return E_FAIL;
+    }
+
+    IDirect3DSurface9 *pTargetSurface = NULL;
+
+    if (FAILED(pTargetTex->GetSurfaceLevel(0,&pTargetSurface)))
+    {
+        printf("Unable to get surface for surface transfer! Aborting...\n");
+        return E_FAIL;
+    }
+
+    // This is required because we cannot lock a D3DPOOL_DEAULT surface directly.  So, we copy to our sysmem surface.
+    if (FAILED(pDevice->GetRenderTargetData(pSurface,pTargetSurface)))
+    {
+        printf("Unable to GetRenderTargetData() for surface transfer! Aborting...\n");
+        return E_FAIL;
+    }
+
+    D3DLOCKED_RECT lockedRect;
+    HRESULT hr = pTargetSurface->LockRect(&lockedRect,NULL,0);
+
+    // Need to convert from dx pitch to pitch=width
+    //
+    // $ PPM is BGR and not RGB it seems. Saved image looks "funny" in viewer(red and blue swapped), but since ref will be dumped using same method, this is ok.
+    //      however, if we want the saved image to be properly colored, then we can swizzle the color bytes here.
+    unsigned char *pPPMData = new unsigned char[pDesc.Width*pDesc.Height*4];
+
+    for (unsigned int iHeight = 0; iHeight<pDesc.Height; iHeight++)
+    {
+#if 1 // swizzle to implment RGB to BGR conversion.
+
+        for (unsigned int iWidth = 0; iWidth< pDesc.Width; iWidth++)
+        {
+            DWORD color = *(DWORD *)((unsigned char *)(lockedRect.pBits)+iHeight*lockedRect.Pitch + iWidth*4);
+
+            // R<->B, [7:0] <-> [23:16], swizzle
+            color = ((color&0xFF)<<16) | (color&0xFF00) | ((color&0xFF0000)>>16) | (color&0xFF000000);
+
+            memcpy(&(pPPMData[(iHeight*pDesc.Width + iWidth)*4]),(unsigned char *)&color,4);
+        }
+
+#else
+        memcpy(&(pPPMData[iHeight*pDesc.Width*4]),(unsigned char *)(lockedRect.pBits)+iHeight*lockedRect.Pitch,pDesc.Width*4);
+#endif
+    }
+
+    pTargetSurface->UnlockRect();
+
+    // Prepends the PPM header info and bumps byte data afterwards
+    sdkSavePPM4ub(zFileName, pPPMData, pDesc.Width, pDesc.Height);
+
+    delete [] pPPMData;
+    pTargetSurface->Release();
+    pTargetTex->Release();
+
+    return S_OK;
+}
\ No newline at end of file
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/src/stopwatch.cpp gpu-rodinia_new/cuda/cfd/common/src/stopwatch.cpp
--- gpu-rodinia/cuda/cfd/common/src/stopwatch.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/src/stopwatch.cpp	2023-06-06 17:20:53.980838341 -0600
@@ -0,0 +1,112 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+/* CUda UTility Library */
+
+#include <vector>
+
+// includes, file
+#include <stopwatch.h>
+
+// includes, project
+#include <exception.h>
+
+////////////////////////////////////////////////////////////////////////////////
+// static variables
+
+//! global index for all stop watches
+#ifdef _WIN32
+/*static*/ std::vector< StopWatchC * > StopWatchC::swatches;
+#else
+template<class OSPolicy>
+/*static*/ std::vector< StopWatchBase<OSPolicy>* >
+StopWatchBase<OSPolicy>::    swatches;
+#endif
+
+
+// namespace, unnamed
+namespace
+{
+    // convenience typedef
+    typedef  std::vector< StopWatchC * >::size_type  swatches_size_type;
+
+    //////////////////////////////////////////////////////////////////////////////
+    //! Translate stop watch name to index
+    //////////////////////////////////////////////////////////////////////////////
+    swatches_size_type
+    nameToIndex(const unsigned int &name)
+    {
+
+#ifdef _DEBUG
+        const swatches_size_type pos = name - 1;
+
+        if ((pos >= StopWatchC::swatches.size())
+            || (NULL == StopWatchC::swatches[pos]))
+        {
+            RUNTIME_EXCEPTION("No StopWatch with the requested name exist.");
+        }
+
+        return pos;
+#else
+        return name - 1;
+#endif
+    }
+
+} // end namespace, unnamed
+
+// Stop watch
+namespace StopWatch
+{
+    //////////////////////////////////////////////////////////////////////////////
+    //! Create a stop watch
+    //////////////////////////////////////////////////////////////////////////////
+    const unsigned int
+    create()
+    {
+        // create new stopwatch
+        StopWatchC *swatch = new StopWatchC();
+
+        if (NULL == swatch)
+        {
+            return 0;
+        }
+
+        // store new stop watch
+        StopWatchC::swatches.push_back(swatch);
+
+        // return the handle to the new stop watch
+        return (unsigned int) StopWatchC::swatches.size();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////
+    // Get a handle to the stop watch with the name \a name
+    //////////////////////////////////////////////////////////////////////////////
+    StopWatchC &
+    get(const unsigned int &name)
+    {
+        return *(StopWatchC::swatches[nameToIndex(name)]);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////
+    // Delete the stop watch with the name \a name
+    //////////////////////////////////////////////////////////////////////////////
+    void
+    destroy(const unsigned int &name)
+    {
+        // get index into global memory
+        swatches_size_type  pos = nameToIndex(name);
+        // delete stop watch
+        delete StopWatchC::swatches[pos];
+        // invalidate storage
+        StopWatchC::swatches[pos] = NULL;
+    }
+
+} // end namespace, StopWatch
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/common/src/stopwatch_linux.cpp gpu-rodinia_new/cuda/cfd/common/src/stopwatch_linux.cpp
--- gpu-rodinia/cuda/cfd/common/src/stopwatch_linux.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/common/src/stopwatch_linux.cpp	2023-06-06 17:20:53.980838341 -0600
@@ -0,0 +1,33 @@
+/*
+ * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
+ *
+ * Please refer to the NVIDIA end user license agreement (EULA) associated
+ * with this source code for terms and conditions that govern your use of
+ * this software. Any use, reproduction, disclosure, or distribution of
+ * this software and related documentation outside the terms of the EULA
+ * is strictly prohibited.
+ *
+ */
+
+/* CUda UTility Library */
+
+// includes, file
+#include <stopwatch_linux.h>
+
+
+////////////////////////////////////////////////////////////////////////////////
+//! Constructor, default
+////////////////////////////////////////////////////////////////////////////////
+StopWatchLinux::StopWatchLinux() :
+    start_time(),
+    diff_time(0.0),
+    total_time(0.0),
+    running(false),
+    clock_sessions(0)
+{ }
+
+////////////////////////////////////////////////////////////////////////////////
+// Destructor
+////////////////////////////////////////////////////////////////////////////////
+StopWatchLinux::~StopWatchLinux() { }
+
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/Makefile gpu-rodinia_new/cuda/cfd/Makefile
--- gpu-rodinia/cuda/cfd/Makefile	2015-12-11 08:46:05.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/Makefile	2023-06-06 17:20:53.968838568 -0600
@@ -1,6 +1,7 @@
 include ../../common/make.config
 
 CUDA_SDK_PATH := $(SDK_DIR)
+HELPER_PATH := ./
 
 # Determine the correct version of the cutil library
 CUTIL_LIB = # -lcutil
@@ -9,22 +10,23 @@
         CUTIL_LIB = #-lcutil_x86_64
      endif
 endif
-
-
+#NVCC_LIB_PATH := -L. -L$(SDK_DIR)/C/lib -L$(LIB_DIR)/ -L$(SDK_DIR)/shared/lib
+#CUTIL_LIB :=  $(NVCC_LIB_PATH) -lcutil_x86_64 -lcuda -lstdc++ -lm
+ARCH:=$(CUDA_FLAG)
 all: euler3d euler3d_double  pre_euler3d  pre_euler3d_double 
 
 euler3d: euler3d.cu
-	nvcc $(KERNEL_DIM) -O2 -Xptxas -v --gpu-architecture=compute_20 --gpu-code=compute_20 euler3d.cu -o euler3d -I$(CUDA_SDK_PATH)/common/inc  -L$(CUDA_SDK_PATH)/lib $(CUTIL_LIB)
+	nvcc $(KERNEL_DIM) -O2 -Xptxas -v euler3d.cu $(ARCH) -o euler3d -I$(HELPER_PATH)/common/inc  -L$(HELPER_PATH)/lib $(CUTIL_LIB)
 
 euler3d_double: euler3d_double.cu
-	nvcc -Xptxas -v -O3 --gpu-architecture=compute_20 --gpu-code=compute_20 euler3d_double.cu -o euler3d_double -I$(CUDA_SDK_PATH)/common/inc  -L$(CUDA_SDK_PATH)/lib $(CUTIL_LIB)
+	nvcc -Xptxas -v -O3  $(ARCH) euler3d_double.cu -o euler3d_double -I$(HELPER_PATH)/common/inc  -L$(HELPER_PATH)/lib $(CUTIL_LIB)
 
 
 pre_euler3d: pre_euler3d.cu
-	nvcc -Xptxas -v -O3 --gpu-architecture=compute_20 --gpu-code=compute_20 pre_euler3d.cu -o pre_euler3d -I$(CUDA_SDK_PATH)/common/inc  -L$(CUDA_SDK_PATH)/lib $(CUTIL_LIB)
+	nvcc -Xptxas -v -O3  $(ARCH) pre_euler3d.cu -o pre_euler3d -I$(HELPER_PATH)/common/inc  -L$(HELPER_PATH)/lib $(CUTIL_LIB)
 
 pre_euler3d_double: pre_euler3d_double.cu
-	nvcc -Xptxas -v -O3 --gpu-architecture=compute_20 --gpu-code=compute_20 pre_euler3d_double.cu -o pre_euler3d_double -I$(CUDA_SDK_PATH)/common/inc  -L$(CUDA_SDK_PATH)/lib $(CUTIL_LIB)
+	nvcc -Xptxas -v -O3  $(ARCH) pre_euler3d_double.cu -o pre_euler3d_double -I$(HELPER_PATH)/common/inc  -L$(HELPER_PATH)/lib $(CUTIL_LIB)
 
 
 clean:
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/cfd/run gpu-rodinia_new/cuda/cfd/run
--- gpu-rodinia/cuda/cfd/run	2015-12-11 08:46:05.000000000 -0700
+++ gpu-rodinia_new/cuda/cfd/run	2023-06-06 17:20:53.972838493 -0600
@@ -1,7 +1,7 @@
-There are three datasets:
+#There are three datasets:
 
 ./euler3d ../../data/cfd/fvcorr.domn.097K   
-./euler3d ../../data/cfd/fvcorr.domn.193K   
-./euler3d ../../data/cfd/missile.domn.0.2M  
+#./euler3d ../../data/cfd/fvcorr.domn.193K   
+#./euler3d ../../data/cfd/missile.domn.0.2M  
 
-replace euler3d with other CFD programs
\ No newline at end of file
+#replace euler3d with other CFD programs
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/clean_all.sh gpu-rodinia_new/cuda/clean_all.sh
--- gpu-rodinia/cuda/clean_all.sh	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/clean_all.sh	2023-06-06 15:29:54.079795151 -0600
@@ -0,0 +1,17 @@
+#EXEs=$(find Samples/ -type f -executable) # find all executable paths
+MAKEFILES=$(find ./ -iname "Makefile") # find all executable paths
+
+for mkfile in ${MAKEFILES}
+do
+        mk=${mkfile##*/} # get the name of executable [[Bash -- get the last substring for a separator]]
+        size=${#mk} #[[Bash -- get the length of a string]]
+        dir=${mkfile::(-$size+0)} #[[Bash -- get the specific substring]]
+        cd $dir;
+        echo "in ${dir}....." 
+        #(time eval ${PRELOAD_FLAG} "./${run}") >stdout.txt 2>stderr.txt
+        rm -rf stdout* stderr* makelog *plain* *gpufpx*
+        rm -rf density density_energy momentum
+        rm -rf *.out *.ii
+        make clean 
+	cd -;
+done
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/compileCodes.sh gpu-rodinia_new/cuda/compileCodes.sh
--- gpu-rodinia/cuda/compileCodes.sh	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/compileCodes.sh	2023-06-06 14:22:22.816702781 -0600
@@ -0,0 +1,18 @@
+#!/bin/bash
+
+# set PATH and LD_LIBRARY_PATH for CUDA/OpenCL installation (may need to be adjusted)
+export PATH=$PATH:/usr/local/cuda/bin
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib:/usr/local/cuda/lib64
+
+for currDir in *
+do
+    echo $currDir
+    if [ -d $currDir ]
+	then
+		cd $currDir
+		pwd
+		make clean
+		make
+		cd ..
+    fi
+done
\ No newline at end of file
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/comp_run_all.sh gpu-rodinia_new/cuda/comp_run_all.sh
--- gpu-rodinia/cuda/comp_run_all.sh	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/comp_run_all.sh	2023-06-06 15:57:54.071952799 -0600
@@ -0,0 +1,37 @@
+#EXEs=$(find Samples/ -type f -executable) # find all executable paths
+#export GPUFPX_OBJ=/fpxbench/nvbit_release/tools/GPU-FPX/GPU-FPX.so
+#export GPUFPX_PRELOAD_FLAG="LD_PRELOAD=${GPUFPX_OBJ}"
+source ../../share.sh
+MAKEFILES=$(find ./ -name "Makefile") # find all executable paths
+for mkfile in ${MAKEFILES}
+do
+        mk=${mkfile##*/} # get the name of executable [[Bash -- get the last substring for a separator]]
+        size=${#mk} #[[Bash -- get the length of a string]]
+        dir=${mkfile::(-$size+0)} #[[Bash -- get the specific substring]]
+        cd $dir;
+        echo "in ${dir}....." 
+        #(time eval ${PRELOAD_FLAG} "./${run}") >stdout.txt 2>stderr.txt
+#	./run
+#	run=$(find ./ -type f -executable)
+	if $ENABLE_COMPILE;
+	then
+		make clean
+        	make&>makelog 
+	fi
+	if $ENABLE_PLAIN; 
+	then
+		chmod +x run
+		comm_plain="eval ./run"
+        	echo ${comm_plain} > run_plain.sh
+        	echo "run plain program"
+        	(time timeout -k 1s 2000s bash run_plain.sh) >stdout.plain.txt 2>stderr.plain.txt
+	fi
+	if $ENABLE_GPUFPX;
+	then
+        	comm_gpufpx="eval ${GPUFPX_PRELOAD_FLAG} ./run"
+        	echo ${comm_gpufpx} > run_gpufpx.sh
+        	echo "run gpu-fpx on program"
+        	(time timeout -k 1s 2000s bash run_gpufpx.sh) >${gpufpx_output_filename} 2>${gpufpx_err_filename}
+	fi
+	cd -;
+done
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/dwt2d/Makefile gpu-rodinia_new/cuda/dwt2d/Makefile
--- gpu-rodinia/cuda/dwt2d/Makefile	2015-12-11 08:46:14.000000000 -0700
+++ gpu-rodinia_new/cuda/dwt2d/Makefile	2023-06-06 15:51:14.303541348 -0600
@@ -9,7 +9,7 @@
 performancetest=1
 
 # NVCC Options
-NVCCFLAGS += -arch sm_20
+NVCCFLAGS += $(CUDA_FLAG)
 
 # Files
 CFILES := 
@@ -109,4 +109,4 @@
 
 clean:
 	rm -f $(COBJS) $(CXXOBJS) $(CUOBJS) $(EXECUTABLE)
-	rm *.bmp.dwt.*		
\ No newline at end of file
+	rm -f *.bmp.dwt.*		
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/dwt2d/run gpu-rodinia_new/cuda/dwt2d/run
--- gpu-rodinia/cuda/dwt2d/run	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/dwt2d/run	2023-06-06 14:22:22.736704314 -0600
@@ -0,0 +1,3 @@
+#./dwt2d 192.bmp -d 192x192 -f -5 -l 3
+#ls
+./dwt2d rgb.bmp -d 1024x1024 -f -5 -l 3
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/dwt2d/run.sh gpu-rodinia_new/cuda/dwt2d/run.sh
--- gpu-rodinia/cuda/dwt2d/run.sh	2015-12-11 08:46:14.000000000 -0700
+++ gpu-rodinia_new/cuda/dwt2d/run.sh	1969-12-31 17:00:00.000000000 -0700
@@ -1,3 +0,0 @@
-./dwt2d 192.bmp -d 192x192 -f -5 -l 3
-ls
-./dwt2d rgb.bmp -d 1024x1024 -f -5 -l 3
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/gaussian/gaussian.cu gpu-rodinia_new/cuda/gaussian/gaussian.cu
--- gpu-rodinia/cuda/gaussian/gaussian.cu	2015-12-11 08:46:08.000000000 -0700
+++ gpu-rodinia_new/cuda/gaussian/gaussian.cu	2023-06-06 14:22:22.736704314 -0600
@@ -19,6 +19,10 @@
 #include <string.h>
 #include <math.h>
 
+#ifdef TIMING
+#include "timing.h"
+#endif
+
 #ifdef RD_WG_SIZE_0_0
         #define MAXBLOCKSIZE RD_WG_SIZE_0_0
 #elif defined(RD_WG_SIZE_0)
@@ -40,6 +44,18 @@
         #define BLOCK_SIZE_XY 4
 #endif
 
+#ifdef TIMING
+struct timeval tv;
+struct timeval tv_total_start, tv_total_end;
+struct timeval tv_h2d_start, tv_h2d_end;
+struct timeval tv_d2h_start, tv_d2h_end;
+struct timeval tv_kernel_start, tv_kernel_end;
+struct timeval tv_mem_alloc_start, tv_mem_alloc_end;
+struct timeval tv_close_start, tv_close_end;
+float init_time = 0, mem_alloc_time = 0, h2d_time = 0, kernel_time = 0,
+      d2h_time = 0, close_time = 0, total_time = 0;
+#endif
+
 int Size;
 float *a, *b, *finalVec;
 float *m;
@@ -92,7 +108,7 @@
 int main(int argc, char *argv[])
 {
   printf("WG size of kernel 1 = %d, WG size of kernel 2= %d X %d\n", MAXBLOCKSIZE, BLOCK_SIZE_XY, BLOCK_SIZE_XY);
-    int verbose = 1;
+    int verbose = 0;
     int i, j;
     char flag;
     if (argc < 2) {
@@ -121,7 +137,7 @@
         exit(0);
     }
     
-    //PrintDeviceProperties();
+    PrintDeviceProperties();
     //char filename[100];
     //sprintf(filename,"matrices/matrix%d.txt",size);
 
@@ -193,6 +209,10 @@
     free(m);
     free(a);
     free(b);
+
+#ifdef  TIMING
+	printf("Exec: %f\n", kernel_time);
+#endif
 }
 /*------------------------------------------------------
  ** PrintDeviceProperties
@@ -358,6 +378,10 @@
 	dim3 dimBlockXY(blockSize2d,blockSize2d);
 	dim3 dimGridXY(gridSize2d,gridSize2d);
 
+#ifdef  TIMING
+	gettimeofday(&tv_kernel_start, NULL);
+#endif
+
     // begin timing kernels
     struct timeval time_start;
     gettimeofday(&time_start, NULL);
@@ -373,6 +397,11 @@
     gettimeofday(&time_end, NULL);
     totalKernelTime = (time_end.tv_sec * 1000000 + time_end.tv_usec) - (time_start.tv_sec * 1000000 + time_start.tv_usec);
 	
+#ifdef  TIMING
+	tvsub(&time_end, &tv_kernel_start, &tv);
+	kernel_time += tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
 	// copy memory back to CPU
 	cudaMemcpy(m, m_cuda, Size * Size * sizeof(float),cudaMemcpyDeviceToHost );
 	cudaMemcpy(a, a_cuda, Size * Size * sizeof(float),cudaMemcpyDeviceToHost );
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/gaussian/Makefile gpu-rodinia_new/cuda/gaussian/Makefile
--- gpu-rodinia/cuda/gaussian/Makefile	2015-12-11 08:46:08.000000000 -0700
+++ gpu-rodinia_new/cuda/gaussian/Makefile	2023-06-06 15:51:12.527575036 -0600
@@ -1,6 +1,6 @@
 include ../../common/make.config
 
-CC := $(CUDA_DIR)/bin/nvcc
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 
 INCLUDE := $(CUDA_DIR)/include
 
@@ -10,5 +10,9 @@
 release: $(SRC)
 	$(CC) $(KERNEL_DIM) $(SRC) -o $(EXE) -I$(INCLUDE) -L$(CUDA_LIB_DIR) 
 
+clang: $(SRC)
+	clang++ $(SRC) -o $(EXE) -I../util --cuda-gpu-arch=sm_20 \
+		-L/usr/local/cuda/lib64 -lcudart_static -ldl -lrt -pthread -DTIMING
+
 clean:
-	rm gaussian
+	rm -f gaussian
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/gaussian/run gpu-rodinia_new/cuda/gaussian/run
--- gpu-rodinia/cuda/gaussian/run	2015-12-11 08:46:08.000000000 -0700
+++ gpu-rodinia_new/cuda/gaussian/run	2023-06-06 14:22:22.736704314 -0600
@@ -1,2 +1,2 @@
 ./gaussian -f ../../data/gaussian/matrix4.txt
-./gaussian -s 16
\ No newline at end of file
+#./gaussian -s 16
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/heartwall/AVI/makefile gpu-rodinia_new/cuda/heartwall/AVI/makefile
--- gpu-rodinia/cuda/heartwall/AVI/makefile	2015-12-11 08:46:05.000000000 -0700
+++ gpu-rodinia_new/cuda/heartwall/AVI/makefile	2023-06-06 15:51:24.615345722 -0600
@@ -10,4 +10,4 @@
 
 # delete files
 clean:
-	rm *.o *.out
+	rm -f *.o *.out
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/heartwall/Makefile gpu-rodinia_new/cuda/heartwall/Makefile
--- gpu-rodinia/cuda/heartwall/Makefile	2015-12-11 08:46:05.000000000 -0700
+++ gpu-rodinia_new/cuda/heartwall/Makefile	2023-06-06 14:22:22.740704237 -0600
@@ -1,15 +1,16 @@
-
+include ../../common/make.config
 ifdef OUTPUT
 override OUTPUT = -DOUTPUT
 endif
 
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 # link objects(binaries) together
 heartwall: main.o ./AVI/avilib.o ./AVI/avimod.o 
-	nvcc main.o ./AVI/avilib.o ./AVI/avimod.o -I/usr/local/cuda/include -lm -o heartwall
+	$(CC) main.o ./AVI/avilib.o ./AVI/avimod.o -I/usr/local/cuda/include -lm -o heartwall
 
 # compile main function file into object (binary)
 main.o: main.cu kernel.cu define.c
-	nvcc $(OUTPUT) $(KERNEL_DIM) main.cu -I./AVI -c -O3
+	$(CC) $(OUTPUT) $(KERNEL_DIM) main.cu -I./AVI -c -O3
 
 ./AVI/avilib.o ./AVI/avimod.o:
 	cd AVI; make;
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/hotspot/Makefile gpu-rodinia_new/cuda/hotspot/Makefile
--- gpu-rodinia/cuda/hotspot/Makefile	2015-12-11 08:46:06.000000000 -0700
+++ gpu-rodinia_new/cuda/hotspot/Makefile	2023-06-06 14:22:22.740704237 -0600
@@ -1,7 +1,7 @@
 include ../../common/make.config
 
-CC := $(CUDA_DIR)/bin/nvcc
-
+#CC := $(CUDA_DIR)/bin/nvcc
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 INCLUDE := $(CUDA_DIR)/include
 
 SRC = hotspot.cu
Binary files gpu-rodinia/cuda/hotspot3D/3D and gpu-rodinia_new/cuda/hotspot3D/3D differ
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/hotspot3D/Makefile gpu-rodinia_new/cuda/hotspot3D/Makefile
--- gpu-rodinia/cuda/hotspot3D/Makefile	2015-12-11 08:46:16.000000000 -0700
+++ gpu-rodinia_new/cuda/hotspot3D/Makefile	2023-06-06 14:22:22.744704161 -0600
@@ -1,7 +1,7 @@
-include ~/rodinia_3.0/common/make.config
-
-CC := $(CUDA_DIR)/bin/nvcc
+include ../../common/make.config
 
+//CC := $(CUDA_DIR)/bin/nvcc
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 INCLUDE := $(CUDA_DIR)/include
 
 SRC = 3D.cu
@@ -10,7 +10,7 @@
 
 OUTPUT = *.out
 
-FLAGS = -g -G #-arch sm_20 --ptxas-options=-v
+#FLAGS = -g -G #-arch sm_20 --ptxas-options=-v
 release: $(SRC)
 	$(CC) $(KERNEL_DIM) $(FLAGS) $(SRC) -o $(EXE) -I$(INCLUDE) -L$(CUDA_LIB_DIR) 
 
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/huffman/Makefile gpu-rodinia_new/cuda/huffman/Makefile
--- gpu-rodinia/cuda/huffman/Makefile	2015-12-11 08:46:05.000000000 -0700
+++ gpu-rodinia_new/cuda/huffman/Makefile	2023-06-06 14:22:22.760703855 -0600
@@ -3,8 +3,8 @@
 
 CUDA_INCLUDEPATH=/usr/local/cuda-6.5/include
 
-NVCC_OPTS=-O3 -arch=sm_35 -Xcompiler -m64 -g -G
-
+#NVCC_OPTS=-O3 -arch=sm_35 -Xcompiler -m64 -g -G
+NVCC_OPTS=$(CUDA_FLAG) -Xcompiler -m64
 GCC_OPTS=-O3 -Wall -Wextra -m64
 
 OBJ = main_test_cu.o stats_logger.o vlc_kernel_sm64huff.o scan.o pack_kernels.o cpuencode.o
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/hybridsort/bucketsort.cu gpu-rodinia_new/cuda/hybridsort/bucketsort.cu
--- gpu-rodinia/cuda/hybridsort/bucketsort.cu	2015-12-11 08:46:06.000000000 -0700
+++ gpu-rodinia_new/cuda/hybridsort/bucketsort.cu	2023-06-06 14:22:22.764703777 -0600
@@ -7,8 +7,8 @@
 ////////////////////////////////////////////////////////////////////////////////
 // Includes
 ////////////////////////////////////////////////////////////////////////////////
-#include <GL/glew.h>
-#include <GL/glut.h>
+//#include <GL/glew.h>
+//#include <GL/glut.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/hybridsort/Makefile gpu-rodinia_new/cuda/hybridsort/Makefile
--- gpu-rodinia/cuda/hybridsort/Makefile	2015-12-11 08:46:06.000000000 -0700
+++ gpu-rodinia_new/cuda/hybridsort/Makefile	2023-06-06 15:50:03.564883188 -0600
@@ -1,7 +1,8 @@
 include ../../common/make.config
 CC := $(CUDA_DIR)/bin/nvcc
 
-CC_FLAGS = -arch=sm_20
+CC_FLAGS = $(CUDA_FLAG)
+#CC_FLAGS = -arch=sm_70
 
 ifdef VERIFY
 override VERIFY = -DVERIFY
@@ -20,4 +21,4 @@
 
 
 clean:
-	rm	*.o hybridsort
+	rm -f	*.o hybridsort
Binary files gpu-rodinia/cuda/kmeans/kmeans.h.gch and gpu-rodinia_new/cuda/kmeans/kmeans.h.gch differ
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/kmeans/Makefile gpu-rodinia_new/cuda/kmeans/Makefile
--- gpu-rodinia/cuda/kmeans/Makefile	2015-12-11 08:46:18.000000000 -0700
+++ gpu-rodinia_new/cuda/kmeans/Makefile	2023-06-06 14:22:22.768703702 -0600
@@ -6,7 +6,7 @@
 
 # CUDA compiler
 NVCC = $(CUDA_DIR)/bin/nvcc
-NVCC_FLAGS = -I$(CUDA_DIR)/include 
+NVCC_FLAGS = $(CUDA_FLAG) -I$(CUDA_DIR)/include 
 
 # 'make dbg=1' enables NVCC debugging
 ifeq ($(dbg),1)
@@ -24,7 +24,7 @@
 kmeans: cluster.o getopt.o kmeans.o kmeans_clustering.o kmeans_cuda.o rmse.o
 	$(CC) $(CC_FLAGS) cluster.o getopt.o kmeans.o kmeans_clustering.o kmeans_cuda.o rmse.o -o kmeans -L$(CUDA_LIB_DIR) -lcuda -lcudart -lm
 
-%.o: %.[ch]
+%.o: %.c
 	$(CC) $(CC_FLAGS) $< -c
 
 kmeans_cuda.o: kmeans_cuda.cu 
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lavaMD/makefile gpu-rodinia_new/cuda/lavaMD/makefile
--- gpu-rodinia/cuda/lavaMD/makefile	2015-12-11 08:46:07.000000000 -0700
+++ gpu-rodinia_new/cuda/lavaMD/makefile	1969-12-31 17:00:00.000000000 -0700
@@ -1,92 +0,0 @@
-include ../../common/make.config
-
-# Example
-# target: dependencies
-	# command 1
-	# command 2
-          # .
-          # .
-          # .
-	# command n
-ifdef OUTPUT
-override OUTPUT = -DOUTPUT
-endif
-
-C_C = gcc
-OMP_LIB = -lgomp
-OMP_FLAG = -fopenmp
-
-CUD_C = $(CUDA_DIR)/bin/nvcc
-# OMP_FLAG = 	-Xcompiler paste_one_here
-CUDA_FLAG = -arch sm_13
-
-# link objects (binaries) together
-a.out:		main.o \
-			./kernel/kernel_gpu_cuda_wrapper.o \
-			./util/num/num.o \
-			./util/timer/timer.o \
-			./util/device/device.o
-	$(C_C)	$(KERNEL_DIM) main.o \
-			./kernel/kernel_gpu_cuda_wrapper.o \
-			./util/num/num.o \
-			./util/timer/timer.o \
-			./util/device/device.o \
-			-lm \
-			-L/usr/local/cuda/lib64 \
-			-lcuda -lcudart \
-			$(OMP_LIB) \
-			-o lavaMD
-
-# compile function files into objects (binaries)
-main.o:		main.h \
-			main.c \
-			./kernel/kernel_gpu_cuda_wrapper.h \
-			./kernel/kernel_gpu_cuda_wrapper.cu \
-			./util/num/num.h \
-			./util/num/num.c \
-			./util/timer/timer.h \
-			./util/timer/timer.c \
-			./util/device/device.h \
-			./util/device/device.cu
-	$(C_C)	$(KERNEL_DIM) $(OUTPUT) main.c \
-			-c \
-			-o main.o \
-			-O3
-
-./kernel/kernel_gpu_cuda_wrapper.o:	./kernel/kernel_gpu_cuda_wrapper.h \
-									./kernel/kernel_gpu_cuda_wrapper.cu
-	$(CUD_C) $(KERNEL_DIM)						./kernel/kernel_gpu_cuda_wrapper.cu \
-									-c \
-									-o ./kernel/kernel_gpu_cuda_wrapper.o \
-									-O3 \
-									$(CUDA_FLAG)
-
-./util/num/num.o:	./util/num/num.h \
-					./util/num/num.c
-	$(C_C)			./util/num/num.c \
-					-c \
-					-o ./util/num/num.o \
-					-O3
-
-./util/timer/timer.o:	./util/timer/timer.h \
-						./util/timer/timer.c
-	$(C_C)				./util/timer/timer.c \
-						-c \
-						-o ./util/timer/timer.o \
-						-O3
-
-./util/device/device.o:	./util/device/device.h \
-						./util/device/device.cu
-	$(CUD_C)			./util/device/device.cu \
-						-c \
-						-o ./util/device/device.o \
-						-O3
-
-# delete all object and executable files
-clean:
-	rm	*.o \
-		./kernel/*.o \
-		./util/num/*.o \
-		./util/timer/*.o \
-		./util/device/*.o \
-		lavaMD
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lavaMD/Makefile gpu-rodinia_new/cuda/lavaMD/Makefile
--- gpu-rodinia/cuda/lavaMD/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/lavaMD/Makefile	2023-06-06 15:50:16.892630389 -0600
@@ -0,0 +1,92 @@
+include ../../common/make.config
+
+# Example
+# target: dependencies
+	# command 1
+	# command 2
+          # .
+          # .
+          # .
+	# command n
+ifdef OUTPUT
+override OUTPUT = -DOUTPUT
+endif
+
+C_C = gcc
+OMP_LIB = -lgomp
+OMP_FLAG = -fopenmp
+
+CUD_C = $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
+# OMP_FLAG = 	-Xcompiler paste_one_here
+#CUDA_FLAG = -arch sm_13
+
+# link objects (binaries) together
+a.out:		main.o \
+			./kernel/kernel_gpu_cuda_wrapper.o \
+			./util/num/num.o \
+			./util/timer/timer.o \
+			./util/device/device.o
+	$(C_C)	$(KERNEL_DIM) main.o \
+			./kernel/kernel_gpu_cuda_wrapper.o \
+			./util/num/num.o \
+			./util/timer/timer.o \
+			./util/device/device.o \
+			-lm \
+			-L/usr/local/cuda/lib64 \
+			-lcuda -lcudart \
+			$(OMP_LIB) \
+			-o lavaMD
+
+# compile function files into objects (binaries)
+main.o:		main.h \
+			main.c \
+			./kernel/kernel_gpu_cuda_wrapper.h \
+			./kernel/kernel_gpu_cuda_wrapper.cu \
+			./util/num/num.h \
+			./util/num/num.c \
+			./util/timer/timer.h \
+			./util/timer/timer.c \
+			./util/device/device.h \
+			./util/device/device.cu
+	$(C_C)	$(KERNEL_DIM) $(OUTPUT) main.c \
+			-c \
+			-o main.o \
+			-O3
+
+./kernel/kernel_gpu_cuda_wrapper.o:	./kernel/kernel_gpu_cuda_wrapper.h \
+									./kernel/kernel_gpu_cuda_wrapper.cu
+	$(CUD_C) $(KERNEL_DIM)						./kernel/kernel_gpu_cuda_wrapper.cu \
+									-c \
+									-o ./kernel/kernel_gpu_cuda_wrapper.o \
+									-O3 \
+									$(CUDA_FLAG)
+
+./util/num/num.o:	./util/num/num.h \
+					./util/num/num.c
+	$(C_C)			./util/num/num.c \
+					-c \
+					-o ./util/num/num.o \
+					-O3
+
+./util/timer/timer.o:	./util/timer/timer.h \
+						./util/timer/timer.c
+	$(C_C)				./util/timer/timer.c \
+						-c \
+						-o ./util/timer/timer.o \
+						-O3
+
+./util/device/device.o:	./util/device/device.h \
+						./util/device/device.cu
+	$(CUD_C)			./util/device/device.cu \
+						-c \
+						-o ./util/device/device.o \
+						-O3
+
+# delete all object and executable files
+clean:
+	rm -f	*.o \
+		./kernel/*.o \
+		./util/num/*.o \
+		./util/timer/*.o \
+		./util/device/*.o \
+		lavaMD
Binary files gpu-rodinia/cuda/leukocyte/CUDA/avilib.h.gch and gpu-rodinia_new/cuda/leukocyte/CUDA/avilib.h.gch differ
Binary files gpu-rodinia/cuda/leukocyte/CUDA/find_ellipse.h.gch and gpu-rodinia_new/cuda/leukocyte/CUDA/find_ellipse.h.gch differ
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/leukocyte/CUDA/makefile gpu-rodinia_new/cuda/leukocyte/CUDA/makefile
--- gpu-rodinia/cuda/leukocyte/CUDA/makefile	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/leukocyte/CUDA/makefile	2023-06-06 15:51:28.891264619 -0600
@@ -0,0 +1,54 @@
+include ../../../common/make.config
+
+ifdef OUTPUT
+override OUTPUT = -DOUTPUT
+endif
+
+# C compiler
+CC = gcc
+CC_FLAGS = -g -O3 -Wall -I$(MATRIX_DIR)
+
+# CUDA compiler
+NVCC = $(CUDA_DIR)/bin/nvcc
+NVCC_FLAGS = $(CUDA_FLAG) -I$(CUDA_DIR)/include -I$(SDK_DIR)/common/inc
+
+# Matrix library path
+MATRIX_DIR = ../meschach_lib
+
+# 'make dbg=1' enables NVCC debugging
+ifeq ($(dbg),1)
+	NVCC_FLAGS += -g -O0
+else
+	NVCC_FLAGS += -O3
+endif
+
+# 'make emu=1' compiles the CUDA kernels for emulation
+ifeq ($(emu),1)
+	NVCC_FLAGS += -deviceemu
+endif
+
+
+leukocyte: detect_main.o avilib.o find_ellipse.o find_ellipse_kernel.o track_ellipse.o track_ellipse_kernel.o misc_math.o $(MATRIX_DIR)/meschach.a
+	$(CC) $(CC_FLAGS) -lm avilib.o find_ellipse.o find_ellipse_kernel.o track_ellipse.o track_ellipse_kernel.o misc_math.o detect_main.o -o leukocyte $(MATRIX_DIR)/meschach.a -L$(CUDA_LIB_DIR) -lm -lcuda -lcudart
+
+%.o: %.c
+	$(CC)  $(OUTPUT) $(CC_FLAGS) $< -c
+
+detect_main.o: detect_main.c find_ellipse.h track_ellipse.h avilib.h 
+	$(CC) $(CC_FLAGS) detect_main.c -c
+
+find_ellipse_kernel.o: find_ellipse_kernel.cu find_ellipse_kernel.h
+	$(NVCC) $(NVCC_FLAGS) -c find_ellipse_kernel.cu
+
+track_ellipse_kernel.o: track_ellipse_kernel.cu track_ellipse_kernel.h
+	$(NVCC) $(NVCC_FLAGS) -I$(MATRIX_DIR) -c track_ellipse_kernel.cu
+
+find_ellipse.o: avilib.h
+
+track_ellipse.o: find_ellipse.h avilib.h
+
+$(MATRIX_DIR)/meschach.a:
+	cd $(MATRIX_DIR); ./configure --with-all; make all; make clean
+
+clean:
+	rm -f *.o *~ leukocyte *.linkinfo
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/leukocyte/CUDA/Makefile gpu-rodinia_new/cuda/leukocyte/CUDA/Makefile
--- gpu-rodinia/cuda/leukocyte/CUDA/Makefile	2015-12-11 08:46:14.000000000 -0700
+++ gpu-rodinia_new/cuda/leukocyte/CUDA/Makefile	1969-12-31 17:00:00.000000000 -0700
@@ -1,54 +0,0 @@
-include ../../../common/make.config
-
-ifdef OUTPUT
-override OUTPUT = -DOUTPUT
-endif
-
-# C compiler
-CC = gcc
-CC_FLAGS = -g -O3 -Wall -I$(MATRIX_DIR)
-
-# CUDA compiler
-NVCC = $(CUDA_DIR)/bin/nvcc
-NVCC_FLAGS = -I$(CUDA_DIR)/include -I$(SDK_DIR)/common/inc
-
-# Matrix library path
-MATRIX_DIR = ../meschach_lib
-
-# 'make dbg=1' enables NVCC debugging
-ifeq ($(dbg),1)
-	NVCC_FLAGS += -g -O0
-else
-	NVCC_FLAGS += -O3
-endif
-
-# 'make emu=1' compiles the CUDA kernels for emulation
-ifeq ($(emu),1)
-	NVCC_FLAGS += -deviceemu
-endif
-
-
-leukocyte: detect_main.o avilib.o find_ellipse.o find_ellipse_kernel.o track_ellipse.o track_ellipse_kernel.o misc_math.o $(MATRIX_DIR)/meschach.a
-	$(CC) $(CC_FLAGS) -lm avilib.o find_ellipse.o find_ellipse_kernel.o track_ellipse.o track_ellipse_kernel.o misc_math.o detect_main.o -o leukocyte $(MATRIX_DIR)/meschach.a -L$(CUDA_LIB_DIR) -lm -lcuda -lcudart
-
-%.o: %.[ch]
-	$(CC)  $(OUTPUT) $(CC_FLAGS) $< -c
-
-detect_main.o: detect_main.c find_ellipse.h track_ellipse.h avilib.h 
-	$(CC) $(CC_FLAGS) detect_main.c -c
-
-find_ellipse_kernel.o: find_ellipse_kernel.cu find_ellipse_kernel.h
-	$(NVCC) $(NVCC_FLAGS) -c find_ellipse_kernel.cu
-
-track_ellipse_kernel.o: track_ellipse_kernel.cu track_ellipse_kernel.h
-	$(NVCC) $(NVCC_FLAGS) -I$(MATRIX_DIR) -c track_ellipse_kernel.cu
-
-find_ellipse.o: avilib.h
-
-track_ellipse.o: find_ellipse.h avilib.h
-
-$(MATRIX_DIR)/meschach.a:
-	cd $(MATRIX_DIR); ./configure --with-all; make all; make clean
-
-clean:
-	rm -f *.o *~ leukocyte *.linkinfo
Binary files gpu-rodinia/cuda/leukocyte/CUDA/misc_math.h.gch and gpu-rodinia_new/cuda/leukocyte/CUDA/misc_math.h.gch differ
Binary files gpu-rodinia/cuda/leukocyte/CUDA/track_ellipse.h.gch and gpu-rodinia_new/cuda/leukocyte/CUDA/track_ellipse.h.gch differ
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/leukocyte/meschach_lib/MACHINES/Cray/makefile gpu-rodinia_new/cuda/leukocyte/meschach_lib/MACHINES/Cray/makefile
--- gpu-rodinia/cuda/leukocyte/meschach_lib/MACHINES/Cray/makefile	2015-12-11 08:46:11.000000000 -0700
+++ gpu-rodinia_new/cuda/leukocyte/meschach_lib/MACHINES/Cray/makefile	2023-06-06 15:51:35.639136608 -0600
@@ -213,6 +213,6 @@
 	$(CC) $(CFLAGS) $(DEFS) -o tstpxvec tstpxvec.o \
 	meschach.a $(LIBS)
 ar_create:
-	rm meschach.a
+	rm -rf meschach.a
 	ar ruv meschach.a $(LIST1) $(LIST2) $(LIST3) \
         $(ZLIST1) $(ZLIST2) $(OLDLIST)
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lud/base/makefile gpu-rodinia_new/cuda/lud/base/makefile
--- gpu-rodinia/cuda/lud/base/makefile	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/lud/base/makefile	2023-06-06 14:22:22.796703165 -0600
@@ -0,0 +1,118 @@
+# Makefile for LU Decomposition
+#
+#
+
+# DEBUG can be set to YES to include debugging info, or NO otherwise
+DEBUG          := YES
+
+# PROFILE can be set to YES to include profiling info, or NO otherwise
+PROFILE        := NO
+
+# ------------  name of the executable  ----------------------------------------
+EXECUTABLE      := lud_base
+
+# ------------  list of all source files  --------------------------------------
+SOURCES         := lud.c lud_base.c ../common/common.c 
+
+# ------------  compiler  ------------------------------------------------------
+CC              := gcc
+CXX             := g++
+
+# ------------  compiler flags  ------------------------------------------------
+DEBUG_CFLAGS    := -Wall -O0 -g
+RELEASE_CFLAGS  := -Wall -O3 
+COMMON_CFLAGS   := 
+
+# ------------  compiler defs  ------------------------------------------------
+DEBUG_CDEFS    := -D_DEBUG_RESULT
+RELEASE_CDEFS  := 
+COMMON_CDEFS   := 
+
+# ------------  linker flags  --------------------------------------------------
+DEBUG_LDFLAGS    := -g
+RELEASE_LDFLAGS  := 
+COMMON_LDFLAGS   := 
+
+ifeq (YES, ${DEBUG})
+  CFLAGS       := ${DEBUG_CFLAGS} ${DEBUG_CDEFS}
+  CXXFLAGS     := ${DEBUG_CXXFLAGS} ${DEBUG_CDEFS}
+  LDFLAGS      := ${DEBUG_LDFLAGS}
+else
+  CFLAGS       := ${RELEASE_CFLAGS} ${RELEASE_CDEFS}
+  CXXFLAGS     := ${RELEASE_CXXFLAGS} ${RELEASE_CDEFS}
+  LDFLAGS      := ${RELEASE_LDFLAGS}
+endif
+
+CFLAGS         := ${CFLAGS} ${COMMON_CFLAGS}
+CXXFLAGS       := ${CXXFLAGS} ${COMMON_CFLAGS}
+LDFLAGS        := ${LDFLAGS} ${COMMON_LDFLAGS}
+
+ifeq (YES, ${PROFILE})
+  CFLAGS       := ${CFLAGS}   -pg -O3
+  CXXFLAGS     := ${CXXFLAGS} -pg -O3
+  LDFLAGS      := ${LDFLAGS}  -pg
+endif
+
+# ------------  additional system include directories  -------------------------
+GLOBAL_INC_DIR  =
+
+# ------------  private include directories  -----------------------------------
+LOCAL_INC_DIR   = ../common
+
+# ------------  system libraries  (e.g. -lm )  ---------------------------------
+SYS_LIBS        = 
+
+# ------------  additional system library directories  -------------------------
+GLOBAL_LIB_DIR  =
+
+# ------------  additional system libraries  -----------------------------------
+GLOBAL_LIBS     =
+
+# ------------  private library directories  -----------------------------------
+LOCAL_LIB_DIR   = 
+
+# ------------  private libraries  (e.g. libxyz.a )  ---------------------------
+LOCAL_LIBS      =
+
+
+C_SOURCES       = $(filter     %.c, $(SOURCES))
+CPP_SOURCES     = $(filter-out %.c, $(SOURCES))
+ALL_INC_DIR     = $(addprefix -I, $(LOCAL_INC_DIR) $(GLOBAL_INC_DIR))
+ALL_LIB_DIR     = $(addprefix -L, $(LOCAL_LIB_DIR) $(GLOBAL_LIB_DIR))
+GLOBAL_LIBSS    = $(addprefix $(GLOBAL_LIB_DIR)/, $(GLOBAL_LIBS))
+LOCAL_LIBSS     = $(addprefix $(LOCAL_LIB_DIR)/, $(LOCAL_LIBS))
+ALL_CFLAGS      = $(CFLAGS) $(ALL_INC_DIR)
+ALL_LFLAGS      = $(LDFLAGS) $(ALL_LIB_DIR)
+BASENAMES       = $(basename $(SOURCES))
+
+# ------------  generate the names of the object files  ------------------------
+OBJECTS         = $(addsuffix .o,$(BASENAMES))
+ 
+# ------------  make the executable (the default goal)  ------------------------
+$(EXECUTABLE):	$(OBJECTS)
+ifeq ($(strip $(CPP_SOURCES)),)
+	$(CC)  $(ALL_LFLAGS) -o $(EXECUTABLE) $(OBJECTS) $(LOCAL_LIBSS) $(GLOBAL_LIBSS) $(SYS_LIBS)
+else
+	$(CXX) $(ALL_LFLAGS) -o $(EXECUTABLE) $(OBJECTS) $(LOCAL_LIBSS) $(GLOBAL_LIBSS) $(SYS_LIBS)
+endif
+
+# ------------  make the objects  ----------------------------------------------
+%.o:		%.c
+				$(CC)  -c $(ALL_CFLAGS) $< -o $@
+
+%.o:		%.cc
+				$(CXX) -c $(ALL_CFLAGS) $< -o $@
+
+%.o:		%.cpp
+				$(CXX) -c $(ALL_CFLAGS) $< -o $@
+
+%.o:		%.C
+				$(CXX) -c $(ALL_CFLAGS) $< -o $@
+
+clean:
+	-rm --force $(EXECUTABLE) $(OBJECTS) *~
+
+.PHONY: clean
+
+# ==============================================================================
+# vim: set tabstop=2: set shiftwidth=2:
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lud/base/Makefile gpu-rodinia_new/cuda/lud/base/Makefile
--- gpu-rodinia/cuda/lud/base/Makefile	2015-12-11 08:46:09.000000000 -0700
+++ gpu-rodinia_new/cuda/lud/base/Makefile	1969-12-31 17:00:00.000000000 -0700
@@ -1,118 +0,0 @@
-# Makefile for LU Decomposition
-#
-#
-
-# DEBUG can be set to YES to include debugging info, or NO otherwise
-DEBUG          := YES
-
-# PROFILE can be set to YES to include profiling info, or NO otherwise
-PROFILE        := NO
-
-# ------------  name of the executable  ----------------------------------------
-EXECUTABLE      := lud_base
-
-# ------------  list of all source files  --------------------------------------
-SOURCES         := lud.c lud_base.c ../common/common.c 
-
-# ------------  compiler  ------------------------------------------------------
-CC              := gcc
-CXX             := g++
-
-# ------------  compiler flags  ------------------------------------------------
-DEBUG_CFLAGS    := -Wall -O0 -g
-RELEASE_CFLAGS  := -Wall -O3 
-COMMON_CFLAGS   := 
-
-# ------------  compiler defs  ------------------------------------------------
-DEBUG_CDEFS    := -D_DEBUG_RESULT
-RELEASE_CDEFS  := 
-COMMON_CDEFS   := 
-
-# ------------  linker flags  --------------------------------------------------
-DEBUG_LDFLAGS    := -g
-RELEASE_LDFLAGS  := 
-COMMON_LDFLAGS   := 
-
-ifeq (YES, ${DEBUG})
-  CFLAGS       := ${DEBUG_CFLAGS} ${DEBUG_CDEFS}
-  CXXFLAGS     := ${DEBUG_CXXFLAGS} ${DEBUG_CDEFS}
-  LDFLAGS      := ${DEBUG_LDFLAGS}
-else
-  CFLAGS       := ${RELEASE_CFLAGS} ${RELEASE_CDEFS}
-  CXXFLAGS     := ${RELEASE_CXXFLAGS} ${RELEASE_CDEFS}
-  LDFLAGS      := ${RELEASE_LDFLAGS}
-endif
-
-CFLAGS         := ${CFLAGS} ${COMMON_CFLAGS}
-CXXFLAGS       := ${CXXFLAGS} ${COMMON_CFLAGS}
-LDFLAGS        := ${LDFLAGS} ${COMMON_LDFLAGS}
-
-ifeq (YES, ${PROFILE})
-  CFLAGS       := ${CFLAGS}   -pg -O3
-  CXXFLAGS     := ${CXXFLAGS} -pg -O3
-  LDFLAGS      := ${LDFLAGS}  -pg
-endif
-
-# ------------  additional system include directories  -------------------------
-GLOBAL_INC_DIR  =
-
-# ------------  private include directories  -----------------------------------
-LOCAL_INC_DIR   = ../common
-
-# ------------  system libraries  (e.g. -lm )  ---------------------------------
-SYS_LIBS        = 
-
-# ------------  additional system library directories  -------------------------
-GLOBAL_LIB_DIR  =
-
-# ------------  additional system libraries  -----------------------------------
-GLOBAL_LIBS     =
-
-# ------------  private library directories  -----------------------------------
-LOCAL_LIB_DIR   = 
-
-# ------------  private libraries  (e.g. libxyz.a )  ---------------------------
-LOCAL_LIBS      =
-
-
-C_SOURCES       = $(filter     %.c, $(SOURCES))
-CPP_SOURCES     = $(filter-out %.c, $(SOURCES))
-ALL_INC_DIR     = $(addprefix -I, $(LOCAL_INC_DIR) $(GLOBAL_INC_DIR))
-ALL_LIB_DIR     = $(addprefix -L, $(LOCAL_LIB_DIR) $(GLOBAL_LIB_DIR))
-GLOBAL_LIBSS    = $(addprefix $(GLOBAL_LIB_DIR)/, $(GLOBAL_LIBS))
-LOCAL_LIBSS     = $(addprefix $(LOCAL_LIB_DIR)/, $(LOCAL_LIBS))
-ALL_CFLAGS      = $(CFLAGS) $(ALL_INC_DIR)
-ALL_LFLAGS      = $(LDFLAGS) $(ALL_LIB_DIR)
-BASENAMES       = $(basename $(SOURCES))
-
-# ------------  generate the names of the object files  ------------------------
-OBJECTS         = $(addsuffix .o,$(BASENAMES))
- 
-# ------------  make the executable (the default goal)  ------------------------
-$(EXECUTABLE):	$(OBJECTS)
-ifeq ($(strip $(CPP_SOURCES)),)
-	$(CC)  $(ALL_LFLAGS) -o $(EXECUTABLE) $(OBJECTS) $(LOCAL_LIBSS) $(GLOBAL_LIBSS) $(SYS_LIBS)
-else
-	$(CXX) $(ALL_LFLAGS) -o $(EXECUTABLE) $(OBJECTS) $(LOCAL_LIBSS) $(GLOBAL_LIBSS) $(SYS_LIBS)
-endif
-
-# ------------  make the objects  ----------------------------------------------
-%.o:		%.c
-				$(CC)  -c $(ALL_CFLAGS) $< -o $@
-
-%.o:		%.cc
-				$(CXX) -c $(ALL_CFLAGS) $< -o $@
-
-%.o:		%.cpp
-				$(CXX) -c $(ALL_CFLAGS) $< -o $@
-
-%.o:		%.C
-				$(CXX) -c $(ALL_CFLAGS) $< -o $@
-
-clean:
-	-rm --force $(EXECUTABLE) $(OBJECTS) *~
-
-.PHONY: clean
-
-# ==============================================================================
-# vim: set tabstop=2: set shiftwidth=2:
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lud/cuda/lud.cu gpu-rodinia_new/cuda/lud/cuda/lud.cu
--- gpu-rodinia/cuda/lud/cuda/lud.cu	2015-12-11 08:46:08.000000000 -0700
+++ gpu-rodinia_new/cuda/lud/cuda/lud.cu	2023-06-06 14:22:22.800703087 -0600
@@ -25,6 +25,10 @@
 
 #include "common.h"
 
+#ifdef TIMING
+#include "timing.h"
+#endif
+
 #ifdef RD_WG_SIZE_0_0
         #define BLOCK_SIZE RD_WG_SIZE_0_0
 #elif defined(RD_WG_SIZE_0)
@@ -48,6 +52,17 @@
 extern void
 lud_cuda(float *d_m, int matrix_dim);
 
+#ifdef TIMING
+struct timeval tv;
+struct timeval tv_total_start, tv_total_end;
+struct timeval tv_h2d_start, tv_h2d_end;
+struct timeval tv_d2h_start, tv_d2h_end;
+struct timeval tv_kernel_start, tv_kernel_end;
+struct timeval tv_mem_alloc_start, tv_mem_alloc_end;
+struct timeval tv_close_start, tv_close_end;
+float init_time = 0, mem_alloc_time = 0, h2d_time = 0, kernel_time = 0,
+      d2h_time = 0, close_time = 0, total_time = 0;
+#endif
 
 int
 main ( int argc, char *argv[] )
@@ -134,8 +149,18 @@
   cudaMemcpy(d_m, m, matrix_dim*matrix_dim*sizeof(float), 
 	     cudaMemcpyHostToDevice);
 
+#ifdef  TIMING
+  gettimeofday(&tv_kernel_start, NULL);
+#endif
+
   lud_cuda(d_m, matrix_dim);
 
+#ifdef  TIMING
+  gettimeofday(&tv_kernel_end, NULL);
+  tvsub(&tv_kernel_end, &tv_kernel_start, &tv);
+  kernel_time += tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
   cudaMemcpy(m, d_m, matrix_dim*matrix_dim*sizeof(float), 
 	     cudaMemcpyDeviceToHost);
 
@@ -156,5 +181,9 @@
 
   free(m);
 
+#ifdef  TIMING
+  printf("Exec: %f\n", kernel_time);
+#endif
+
   return EXIT_SUCCESS;
 }				/* ----------  end of function main  ---------- */
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lud/cuda/makefile gpu-rodinia_new/cuda/lud/cuda/makefile
--- gpu-rodinia/cuda/lud/cuda/makefile	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/lud/cuda/makefile	2023-06-06 14:22:22.800703087 -0600
@@ -0,0 +1,62 @@
+include ../../../common/make.config
+CC = gcc
+#NVCC = nvcc
+NVCC = $(CUDA_DIR)/bin/nvcc
+
+DEFS += \
+		-DGPU_TIMER \
+		$(SPACE)
+#NVCCFLAGS += -I../common \
+			 -O3 \
+			 -use_fast_math \
+			 -arch=sm_20 \
+			 -lm \
+			 $(SPACE)
+
+
+NVCCFLAGS += -I../common \
+			 -O3 \
+			 $(CUDA_FLAG) \
+			 -lm \
+			 $(SPACE)
+
+CFLAGS += -I../common \
+					-I/usr/include/cuda \
+		  -O3 \
+		  -Wall \
+		  $(SPACE)
+
+# Add source files here
+EXECUTABLE  := lud_cuda
+# Cuda source files (compiled with cudacc)
+CUFILES     := lud_kernel.cu
+# C/C++ source files (compiled with gcc / c++)
+CCFILES     := lud.c lud_cuda.c ../common/common.c
+
+OBJS = ../common/common.o lud.o lud_kernel.o
+
+.PHONY: all clean 
+all : $(EXECUTABLE)
+
+.c.o : 
+	$(NVCC) $(KERNEL_DIM) $(NVCCFLAGS) $(DEFS) -o $@ -c $<
+
+%.o:	%.cu 
+	$(NVCC) $(KERNEL_DIM) $(NVCCFLAGS) $(DEFS) -o $@ -c $<
+
+# clang: $(SRC)
+# 	clang++ lud.cu lud_kernel.cu ../common/common.c -o $(EXECUTABLE) \
+# 		-I../common -I../../util --cuda-gpu-arch=sm_20 \
+# 		-L/usr/local/cuda/lib64 -lcudart_static -ldl -lrt -pthread -DTIMING
+#
+clang: $(SRC)
+	clang++ lud.cu lud_kernel.cu ../common/common.c -o $(EXECUTABLE) \
+		-I../common -I../../util --cuda-gpu-arch=sm_70 \
+		-L/usr/local/cuda/lib64 -lcudart_static -ldl -lrt -pthread -DTIMING
+
+
+$(EXECUTABLE) : $(OBJS)
+	$(NVCC) $(NVCCFLAGS) -o $@  $?
+
+clean:
+	rm -f $(EXECUTABLE) $(OBJS) *.linkinfo
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lud/cuda/Makefile gpu-rodinia_new/cuda/lud/cuda/Makefile
--- gpu-rodinia/cuda/lud/cuda/Makefile	2015-12-11 08:46:09.000000000 -0700
+++ gpu-rodinia_new/cuda/lud/cuda/Makefile	1969-12-31 17:00:00.000000000 -0700
@@ -1,44 +0,0 @@
-CC = gcc
-NVCC = nvcc
-
-DEFS += \
-		-DGPU_TIMER \
-		$(SPACE)
-
-NVCCFLAGS += -I../common \
-			 -O3 \
-			 -use_fast_math \
-			 -arch=sm_13 \
-			 -lm \
-			 $(SPACE)
-
-CFLAGS += -I../common \
-					-I/usr/include/cuda \
-		  -O3 \
-		  -Wall \
-		  $(SPACE)
-
-# Add source files here
-EXECUTABLE  := lud_cuda
-# Cuda source files (compiled with cudacc)
-CUFILES     := lud_kernel.cu
-# C/C++ source files (compiled with gcc / c++)
-CCFILES     := lud.c lud_cuda.c ../common/common.c
-
-OBJS = ../common/common.o lud.o lud_kernel.o
-
-.PHONY: all clean 
-all : $(EXECUTABLE)
-
-.c.o : 
-	$(NVCC) $(KERNEL_DIM) $(NVCCFLAGS) $(DEFS) -o $@ -c $<
-
-%.o:	%.cu 
-	$(NVCC) $(KERNEL_DIM) $(NVCCFLAGS) $(DEFS) -o $@ -c $<
-
-
-$(EXECUTABLE) : $(OBJS)
-	$(NVCC) $(NVCCFLAGS) -o $@  $?
-
-clean:
-	rm -f $(EXECUTABLE) $(OBJS) *.linkinfo
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lud/Makefile gpu-rodinia_new/cuda/lud/Makefile
--- gpu-rodinia/cuda/lud/Makefile	2015-12-11 08:46:09.000000000 -0700
+++ gpu-rodinia_new/cuda/lud/Makefile	2023-06-06 14:22:22.800703087 -0600
@@ -3,5 +3,8 @@
 lud_cuda:
 	cd cuda; make
 
+#clang:
+#	cd cuda; make clang
+
 clean:
 	cd cuda; make clean
Binary files gpu-rodinia/cuda/lud/tools/gen_input and gpu-rodinia_new/cuda/lud/tools/gen_input differ
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lud/tools/makefile gpu-rodinia_new/cuda/lud/tools/makefile
--- gpu-rodinia/cuda/lud/tools/makefile	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/lud/tools/makefile	2023-06-06 14:22:22.800703087 -0600
@@ -0,0 +1,2 @@
+gen_input: gen_input.c
+	gcc -o gen_input -O3 gen_input.c -fopenmp
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/lud/tools/Makefile gpu-rodinia_new/cuda/lud/tools/Makefile
--- gpu-rodinia/cuda/lud/tools/Makefile	2015-12-11 08:46:08.000000000 -0700
+++ gpu-rodinia_new/cuda/lud/tools/Makefile	1969-12-31 17:00:00.000000000 -0700
@@ -1,2 +0,0 @@
-gen_input: gen_input.c
-	gcc -o gen_input -O3 gen_input.c -fopenmp
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/myocyte/Makefile gpu-rodinia_new/cuda/myocyte/Makefile
--- gpu-rodinia/cuda/myocyte/Makefile	2015-12-11 08:46:06.000000000 -0700
+++ gpu-rodinia_new/cuda/myocyte/Makefile	2023-06-06 15:50:44.312110279 -0600
@@ -1,3 +1,4 @@
+include ../../common/make.config
 # Example
 # target: dependencies
 	# command 1
@@ -8,8 +9,9 @@
 	# command n
 
 # link objects(binaries) together
+NVCC=$(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 myocyte.out:		main.o
-	nvcc	main.o \
+	$(NVCC)	main.o \
 				-I/usr/local/cuda/include \
 				-L/usr/local/cuda/lib \
 				-lm -lcuda -lcudart \
@@ -35,9 +37,9 @@
 				kernel_fin_2.cu \
 				file.c \
 				timer.c
-	nvcc	main.cu \
+	$(NVCC)	main.cu \
 				-c -O3 -g
 
 # delete all object files
 clean:
-	rm *.o *.out output.txt
+	rm -f *.o *.out output.txt
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/nn/Makefile gpu-rodinia_new/cuda/nn/Makefile
--- gpu-rodinia/cuda/nn/Makefile	2015-12-11 08:46:06.000000000 -0700
+++ gpu-rodinia_new/cuda/nn/Makefile	2023-06-06 14:22:22.804703012 -0600
@@ -1,7 +1,7 @@
 include ../../common/make.config
 
 LOCAL_CC = gcc -g -O3 -Wall
-CC := $(CUDA_DIR)/bin/nvcc
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 
 all : nn hurricane_gen
 
@@ -12,6 +12,14 @@
 	$(CC) -cuda nn_cuda.cu
 	$(CC) -o nn nn_cuda.cu
 
+clang: $(SRC)
+	clang++ nn_cuda.cu -o nn -I../util \
+		-L/usr/local/cuda/lib64 -lcudart_static -ldl -lrt -pthread -DTIMING
+#clang: $(SRC)
+#	clang++ nn_cuda.cu -o nn -I../util --cuda-gpu-arch=sm_20 \
+		-L/usr/local/cuda/lib64 -lcudart_static -ldl -lrt -pthread -DTIMING
+
+
 hurricane_gen : hurricane_gen.c
 	$(LOCAL_CC) -o $@ $< -lm
 
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/nn/nn_cuda.cu gpu-rodinia_new/cuda/nn/nn_cuda.cu
--- gpu-rodinia/cuda/nn/nn_cuda.cu	2015-12-11 08:46:06.000000000 -0700
+++ gpu-rodinia_new/cuda/nn/nn_cuda.cu	2023-06-06 14:22:22.804703012 -0600
@@ -10,6 +10,20 @@
 #include <vector>
 #include "cuda.h"
 
+#ifdef TIMING
+#include "timing.h"
+
+struct timeval tv;
+struct timeval tv_total_start, tv_total_end;
+struct timeval tv_h2d_start, tv_h2d_end;
+struct timeval tv_d2h_start, tv_d2h_end;
+struct timeval tv_kernel_start, tv_kernel_end;
+struct timeval tv_mem_alloc_start, tv_mem_alloc_end;
+struct timeval tv_close_start, tv_close_end;
+float init_time = 0, mem_alloc_time = 0, h2d_time = 0, kernel_time = 0,
+      d2h_time = 0, close_time = 0, total_time = 0;
+#endif
+
 #define min( a, b )			a > b ? b : a
 #define ceilDiv( a, b )		( a + b - 1 ) / b
 #define print( x )			printf( #x ": %lu\n", (unsigned long) x )
@@ -145,9 +159,20 @@
     /**
     * Execute kernel
     */
+
+#ifdef  TIMING
+  gettimeofday(&tv_kernel_start, NULL);
+#endif
+
     euclid<<< gridDim, threadsPerBlock >>>(d_locations,d_distances,numRecords,lat,lng);
     cudaThreadSynchronize();
 
+#ifdef  TIMING
+    gettimeofday(&tv_kernel_end, NULL);
+    tvsub(&tv_kernel_end, &tv_kernel_start, &tv);
+    kernel_time += tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
     //Copy data from device memory to host memory
     cudaMemcpy( distances, d_distances, sizeof(float)*numRecords, cudaMemcpyDeviceToHost );
 
@@ -164,6 +189,9 @@
 	cudaFree(d_locations);
 	cudaFree(d_distances);
 
+#ifdef  TIMING
+    printf("Exec: %f\n", kernel_time);
+#endif
 }
 
 int loadData(char *filename,std::vector<Record> &records,std::vector<LatLong> &locations){
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/nw/Makefile gpu-rodinia_new/cuda/nw/Makefile
--- gpu-rodinia/cuda/nw/Makefile	2015-12-11 08:46:09.000000000 -0700
+++ gpu-rodinia_new/cuda/nw/Makefile	2023-06-06 14:22:22.808702934 -0600
@@ -1,6 +1,6 @@
 include ../../common/make.config
 
-CC := $(CUDA_DIR)/bin/nvcc
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 
 INCLUDE := $(CUDA_DIR)/include
 
@@ -11,6 +11,10 @@
 release: $(SRC)
 	$(CC) ${KERNEL_DIM} $(SRC) -o $(EXE) -I$(INCLUDE) -L$(CUDA_LIB_DIR) 
 
+clang: $(SRC)
+	clang++ $(SRC) -o $(EXE) -I../util --cuda-gpu-arch=sm_70 \
+		-L/usr/local/cuda/lib64 -lcudart_static -ldl -lrt -pthread -DTIMING
+
 enum: $(SRC)
 	$(CC) ${KERNEL_DIM} -deviceemu $(SRC) -o $(EXE) -I$(INCLUDE) -L$(CUDA_LIB_DIR) 
 
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/nw/needle.cu gpu-rodinia_new/cuda/nw/needle.cu
--- gpu-rodinia/cuda/nw/needle.cu	2015-12-11 08:46:09.000000000 -0700
+++ gpu-rodinia_new/cuda/nw/needle.cu	2023-06-06 14:22:22.808702934 -0600
@@ -1,240 +1,266 @@
-#define LIMIT -999
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#include "needle.h"
-#include <cuda.h>
-#include <sys/time.h>
-
-// includes, kernels
-#include "needle_kernel.cu"
-
-////////////////////////////////////////////////////////////////////////////////
-// declaration, forward
-void runTest( int argc, char** argv);
-
-
-int blosum62[24][24] = {
-{ 4, -1, -2, -2,  0, -1, -1,  0, -2, -1, -1, -1, -1, -2, -1,  1,  0, -3, -2,  0, -2, -1,  0, -4},
-{-1,  5,  0, -2, -3,  1,  0, -2,  0, -3, -2,  2, -1, -3, -2, -1, -1, -3, -2, -3, -1,  0, -1, -4},
-{-2,  0,  6,  1, -3,  0,  0,  0,  1, -3, -3,  0, -2, -3, -2,  1,  0, -4, -2, -3,  3,  0, -1, -4},
-{-2, -2,  1,  6, -3,  0,  2, -1, -1, -3, -4, -1, -3, -3, -1,  0, -1, -4, -3, -3,  4,  1, -1, -4},
-{ 0, -3, -3, -3,  9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1, -3, -3, -2, -4},
-{-1,  1,  0,  0, -3,  5,  2, -2,  0, -3, -2,  1,  0, -3, -1,  0, -1, -2, -1, -2,  0,  3, -1, -4},
-{-1,  0,  0,  2, -4,  2,  5, -2,  0, -3, -3,  1, -2, -3, -1,  0, -1, -3, -2, -2,  1,  4, -1, -4},
-{ 0, -2,  0, -1, -3, -2, -2,  6, -2, -4, -4, -2, -3, -3, -2,  0, -2, -2, -3, -3, -1, -2, -1, -4},
-{-2,  0,  1, -1, -3,  0,  0, -2,  8, -3, -3, -1, -2, -1, -2, -1, -2, -2,  2, -3,  0,  0, -1, -4},
-{-1, -3, -3, -3, -1, -3, -3, -4, -3,  4,  2, -3,  1,  0, -3, -2, -1, -3, -1,  3, -3, -3, -1, -4},
-{-1, -2, -3, -4, -1, -2, -3, -4, -3,  2,  4, -2,  2,  0, -3, -2, -1, -2, -1,  1, -4, -3, -1, -4},
-{-1,  2,  0, -1, -3,  1,  1, -2, -1, -3, -2,  5, -1, -3, -1,  0, -1, -3, -2, -2,  0,  1, -1, -4},
-{-1, -1, -2, -3, -1,  0, -2, -3, -2,  1,  2, -1,  5,  0, -2, -1, -1, -1, -1,  1, -3, -1, -1, -4},
-{-2, -3, -3, -3, -2, -3, -3, -3, -1,  0,  0, -3,  0,  6, -4, -2, -2,  1,  3, -1, -3, -3, -1, -4},
-{-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4,  7, -1, -1, -4, -3, -2, -2, -1, -2, -4},
-{ 1, -1,  1,  0, -1,  0,  0,  0, -1, -2, -2,  0, -1, -2, -1,  4,  1, -3, -2, -2,  0,  0,  0, -4},
-{ 0, -1,  0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1,  1,  5, -2, -2,  0, -1, -1,  0, -4},
-{-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1,  1, -4, -3, -2, 11,  2, -3, -4, -3, -2, -4},
-{-2, -2, -2, -3, -2, -1, -2, -3,  2, -1, -1, -2, -1,  3, -3, -2, -2,  2,  7, -1, -3, -2, -1, -4},
-{ 0, -3, -3, -3, -1, -2, -2, -3, -3,  3,  1, -2,  1, -1, -2, -2,  0, -3, -1,  4, -3, -2, -1, -4},
-{-2, -1,  3,  4, -3,  0,  1, -1,  0, -3, -4,  0, -3, -3, -2,  0, -1, -4, -3, -3,  4,  1, -1, -4},
-{-1,  0,  0,  1, -3,  3,  4, -2,  0, -3, -3,  1, -1, -3, -1,  0, -1, -3, -2, -2,  1,  4, -1, -4},
-{ 0, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2,  0,  0, -2, -1, -1, -1, -1, -1, -4},
-{-4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,  1}
-};
-
-double gettime() {
-  struct timeval t;
-  gettimeofday(&t,NULL);
-  return t.tv_sec+t.tv_usec*1e-6;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Program main
-////////////////////////////////////////////////////////////////////////////////
-int
-main( int argc, char** argv) 
-{
-
-  printf("WG size of kernel = %d \n", BLOCK_SIZE);
-
-    runTest( argc, argv);
-
-    return EXIT_SUCCESS;
-}
-
-void usage(int argc, char **argv)
-{
-	fprintf(stderr, "Usage: %s <max_rows/max_cols> <penalty> \n", argv[0]);
-	fprintf(stderr, "\t<dimension>  - x and y dimensions\n");
-	fprintf(stderr, "\t<penalty> - penalty(positive integer)\n");
-	exit(1);
-}
-
-void runTest( int argc, char** argv) 
-{
-    int max_rows, max_cols, penalty;
-    int *input_itemsets, *output_itemsets, *referrence;
-	int *matrix_cuda,  *referrence_cuda;
-	int size;
-	
-    
-    // the lengths of the two sequences should be able to divided by 16.
-	// And at current stage  max_rows needs to equal max_cols
-	if (argc == 3)
-	{
-		max_rows = atoi(argv[1]);
-		max_cols = atoi(argv[1]);
-		penalty = atoi(argv[2]);
-	}
-    else{
-	usage(argc, argv);
-    }
-	
-	if(atoi(argv[1])%16!=0){
-	fprintf(stderr,"The dimension values must be a multiple of 16\n");
-	exit(1);
-	}
-	
-
-	max_rows = max_rows + 1;
-	max_cols = max_cols + 1;
-	referrence = (int *)malloc( max_rows * max_cols * sizeof(int) );
-    input_itemsets = (int *)malloc( max_rows * max_cols * sizeof(int) );
-	output_itemsets = (int *)malloc( max_rows * max_cols * sizeof(int) );
-	
-
-	if (!input_itemsets)
-		fprintf(stderr, "error: can not allocate memory");
-
-    srand ( 7 );
-	
-	
-    for (int i = 0 ; i < max_cols; i++){
-		for (int j = 0 ; j < max_rows; j++){
-			input_itemsets[i*max_cols+j] = 0;
-		}
-	}
-	
-	printf("Start Needleman-Wunsch\n");
-	
-	for( int i=1; i< max_rows ; i++){    //please define your own sequence. 
-       input_itemsets[i*max_cols] = rand() % 10 + 1;
-	}
-    for( int j=1; j< max_cols ; j++){    //please define your own sequence.
-       input_itemsets[j] = rand() % 10 + 1;
-	}
-
-
-	for (int i = 1 ; i < max_cols; i++){
-		for (int j = 1 ; j < max_rows; j++){
-		referrence[i*max_cols+j] = blosum62[input_itemsets[i*max_cols]][input_itemsets[j]];
-		}
-	}
-
-    for( int i = 1; i< max_rows ; i++)
-       input_itemsets[i*max_cols] = -i * penalty;
-	for( int j = 1; j< max_cols ; j++)
-       input_itemsets[j] = -j * penalty;
-
-
-    size = max_cols * max_rows;
-	cudaMalloc((void**)& referrence_cuda, sizeof(int)*size);
-	cudaMalloc((void**)& matrix_cuda, sizeof(int)*size);
-	
-	cudaMemcpy(referrence_cuda, referrence, sizeof(int) * size, cudaMemcpyHostToDevice);
-	cudaMemcpy(matrix_cuda, input_itemsets, sizeof(int) * size, cudaMemcpyHostToDevice);
-
-    dim3 dimGrid;
-	dim3 dimBlock(BLOCK_SIZE, 1);
-	int block_width = ( max_cols - 1 )/BLOCK_SIZE;
-
-	printf("Processing top-left matrix\n");
-	//process top-left matrix
-	for( int i = 1 ; i <= block_width ; i++){
-		dimGrid.x = i;
-		dimGrid.y = 1;
-		needle_cuda_shared_1<<<dimGrid, dimBlock>>>(referrence_cuda, matrix_cuda
-		                                      ,max_cols, penalty, i, block_width); 
-	}
-	printf("Processing bottom-right matrix\n");
-    //process bottom-right matrix
-	for( int i = block_width - 1  ; i >= 1 ; i--){
-		dimGrid.x = i;
-		dimGrid.y = 1;
-		needle_cuda_shared_2<<<dimGrid, dimBlock>>>(referrence_cuda, matrix_cuda
-		                                      ,max_cols, penalty, i, block_width); 
-	}
-
-
-    cudaMemcpy(output_itemsets, matrix_cuda, sizeof(int) * size, cudaMemcpyDeviceToHost);
-	
-//#define TRACEBACK
-#ifdef TRACEBACK
-	
-	FILE *fpo = fopen("result.txt","w");
-	fprintf(fpo, "print traceback value GPU:\n");
-    
-	for (int i = max_rows - 2,  j = max_rows - 2; i>=0, j>=0;){
-		int nw, n, w, traceback;
-		if ( i == max_rows - 2 && j == max_rows - 2 )
-			fprintf(fpo, "%d ", output_itemsets[ i * max_cols + j]); //print the first element
-		if ( i == 0 && j == 0 )
-           break;
-		if ( i > 0 && j > 0 ){
-			nw = output_itemsets[(i - 1) * max_cols + j - 1];
-		    w  = output_itemsets[ i * max_cols + j - 1 ];
-            n  = output_itemsets[(i - 1) * max_cols + j];
-		}
-		else if ( i == 0 ){
-		    nw = n = LIMIT;
-		    w  = output_itemsets[ i * max_cols + j - 1 ];
-		}
-		else if ( j == 0 ){
-		    nw = w = LIMIT;
-            n  = output_itemsets[(i - 1) * max_cols + j];
-		}
-		else{
-		}
-
-		//traceback = maximum(nw, w, n);
-		int new_nw, new_w, new_n;
-		new_nw = nw + referrence[i * max_cols + j];
-		new_w = w - penalty;
-		new_n = n - penalty;
-		
-		traceback = maximum(new_nw, new_w, new_n);
-		if(traceback == new_nw)
-			traceback = nw;
-		if(traceback == new_w)
-			traceback = w;
-		if(traceback == new_n)
-            traceback = n;
-			
-		fprintf(fpo, "%d ", traceback);
-
-		if(traceback == nw )
-		{i--; j--; continue;}
-
-        else if(traceback == w )
-		{j--; continue;}
-
-        else if(traceback == n )
-		{i--; continue;}
-
-		else
-		;
-	}
-	
-	fclose(fpo);
-
-#endif
-
-	cudaFree(referrence_cuda);
-	cudaFree(matrix_cuda);
-
-	free(referrence);
-	free(input_itemsets);
-	free(output_itemsets);
-	
-}
-
+#define LIMIT -999
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include "needle.h"
+#include <cuda.h>
+#include <sys/time.h>
+
+// includes, kernels
+#include "needle_kernel.cu"
+
+#ifdef TIMING
+#include "timing.h"
+
+struct timeval tv;
+struct timeval tv_total_start, tv_total_end;
+struct timeval tv_h2d_start, tv_h2d_end;
+struct timeval tv_d2h_start, tv_d2h_end;
+struct timeval tv_kernel_start, tv_kernel_end;
+struct timeval tv_mem_alloc_start, tv_mem_alloc_end;
+struct timeval tv_close_start, tv_close_end;
+float init_time = 0, mem_alloc_time = 0, h2d_time = 0, kernel_time = 0,
+      d2h_time = 0, close_time = 0, total_time = 0;
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// declaration, forward
+void runTest( int argc, char** argv);
+
+
+int blosum62[24][24] = {
+{ 4, -1, -2, -2,  0, -1, -1,  0, -2, -1, -1, -1, -1, -2, -1,  1,  0, -3, -2,  0, -2, -1,  0, -4},
+{-1,  5,  0, -2, -3,  1,  0, -2,  0, -3, -2,  2, -1, -3, -2, -1, -1, -3, -2, -3, -1,  0, -1, -4},
+{-2,  0,  6,  1, -3,  0,  0,  0,  1, -3, -3,  0, -2, -3, -2,  1,  0, -4, -2, -3,  3,  0, -1, -4},
+{-2, -2,  1,  6, -3,  0,  2, -1, -1, -3, -4, -1, -3, -3, -1,  0, -1, -4, -3, -3,  4,  1, -1, -4},
+{ 0, -3, -3, -3,  9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1, -3, -3, -2, -4},
+{-1,  1,  0,  0, -3,  5,  2, -2,  0, -3, -2,  1,  0, -3, -1,  0, -1, -2, -1, -2,  0,  3, -1, -4},
+{-1,  0,  0,  2, -4,  2,  5, -2,  0, -3, -3,  1, -2, -3, -1,  0, -1, -3, -2, -2,  1,  4, -1, -4},
+{ 0, -2,  0, -1, -3, -2, -2,  6, -2, -4, -4, -2, -3, -3, -2,  0, -2, -2, -3, -3, -1, -2, -1, -4},
+{-2,  0,  1, -1, -3,  0,  0, -2,  8, -3, -3, -1, -2, -1, -2, -1, -2, -2,  2, -3,  0,  0, -1, -4},
+{-1, -3, -3, -3, -1, -3, -3, -4, -3,  4,  2, -3,  1,  0, -3, -2, -1, -3, -1,  3, -3, -3, -1, -4},
+{-1, -2, -3, -4, -1, -2, -3, -4, -3,  2,  4, -2,  2,  0, -3, -2, -1, -2, -1,  1, -4, -3, -1, -4},
+{-1,  2,  0, -1, -3,  1,  1, -2, -1, -3, -2,  5, -1, -3, -1,  0, -1, -3, -2, -2,  0,  1, -1, -4},
+{-1, -1, -2, -3, -1,  0, -2, -3, -2,  1,  2, -1,  5,  0, -2, -1, -1, -1, -1,  1, -3, -1, -1, -4},
+{-2, -3, -3, -3, -2, -3, -3, -3, -1,  0,  0, -3,  0,  6, -4, -2, -2,  1,  3, -1, -3, -3, -1, -4},
+{-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4,  7, -1, -1, -4, -3, -2, -2, -1, -2, -4},
+{ 1, -1,  1,  0, -1,  0,  0,  0, -1, -2, -2,  0, -1, -2, -1,  4,  1, -3, -2, -2,  0,  0,  0, -4},
+{ 0, -1,  0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1,  1,  5, -2, -2,  0, -1, -1,  0, -4},
+{-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1,  1, -4, -3, -2, 11,  2, -3, -4, -3, -2, -4},
+{-2, -2, -2, -3, -2, -1, -2, -3,  2, -1, -1, -2, -1,  3, -3, -2, -2,  2,  7, -1, -3, -2, -1, -4},
+{ 0, -3, -3, -3, -1, -2, -2, -3, -3,  3,  1, -2,  1, -1, -2, -2,  0, -3, -1,  4, -3, -2, -1, -4},
+{-2, -1,  3,  4, -3,  0,  1, -1,  0, -3, -4,  0, -3, -3, -2,  0, -1, -4, -3, -3,  4,  1, -1, -4},
+{-1,  0,  0,  1, -3,  3,  4, -2,  0, -3, -3,  1, -1, -3, -1,  0, -1, -3, -2, -2,  1,  4, -1, -4},
+{ 0, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2,  0,  0, -2, -1, -1, -1, -1, -1, -4},
+{-4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,  1}
+};
+
+double gettime() {
+  struct timeval t;
+  gettimeofday(&t,NULL);
+  return t.tv_sec+t.tv_usec*1e-6;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Program main
+////////////////////////////////////////////////////////////////////////////////
+int
+main( int argc, char** argv) 
+{
+
+  printf("WG size of kernel = %d \n", BLOCK_SIZE);
+
+    runTest( argc, argv);
+
+    return EXIT_SUCCESS;
+}
+
+void usage(int argc, char **argv)
+{
+	fprintf(stderr, "Usage: %s <max_rows/max_cols> <penalty> \n", argv[0]);
+	fprintf(stderr, "\t<dimension>  - x and y dimensions\n");
+	fprintf(stderr, "\t<penalty> - penalty(positive integer)\n");
+	exit(1);
+}
+
+void runTest( int argc, char** argv) 
+{
+    int max_rows, max_cols, penalty;
+    int *input_itemsets, *output_itemsets, *referrence;
+	int *matrix_cuda,  *referrence_cuda;
+	int size;
+	
+    
+    // the lengths of the two sequences should be able to divided by 16.
+	// And at current stage  max_rows needs to equal max_cols
+	if (argc == 3)
+	{
+		max_rows = atoi(argv[1]);
+		max_cols = atoi(argv[1]);
+		penalty = atoi(argv[2]);
+	}
+    else{
+	usage(argc, argv);
+    }
+	
+	if(atoi(argv[1])%16!=0){
+	fprintf(stderr,"The dimension values must be a multiple of 16\n");
+	exit(1);
+	}
+	
+
+	max_rows = max_rows + 1;
+	max_cols = max_cols + 1;
+	referrence = (int *)malloc( max_rows * max_cols * sizeof(int) );
+    input_itemsets = (int *)malloc( max_rows * max_cols * sizeof(int) );
+	output_itemsets = (int *)malloc( max_rows * max_cols * sizeof(int) );
+	
+
+	if (!input_itemsets)
+		fprintf(stderr, "error: can not allocate memory");
+
+    srand ( 7 );
+	
+	
+    for (int i = 0 ; i < max_cols; i++){
+		for (int j = 0 ; j < max_rows; j++){
+			input_itemsets[i*max_cols+j] = 0;
+		}
+	}
+	
+	printf("Start Needleman-Wunsch\n");
+	
+	for( int i=1; i< max_rows ; i++){    //please define your own sequence. 
+       input_itemsets[i*max_cols] = rand() % 10 + 1;
+	}
+    for( int j=1; j< max_cols ; j++){    //please define your own sequence.
+       input_itemsets[j] = rand() % 10 + 1;
+	}
+
+
+	for (int i = 1 ; i < max_cols; i++){
+		for (int j = 1 ; j < max_rows; j++){
+		referrence[i*max_cols+j] = blosum62[input_itemsets[i*max_cols]][input_itemsets[j]];
+		}
+	}
+
+    for( int i = 1; i< max_rows ; i++)
+       input_itemsets[i*max_cols] = -i * penalty;
+	for( int j = 1; j< max_cols ; j++)
+       input_itemsets[j] = -j * penalty;
+
+
+    size = max_cols * max_rows;
+	cudaMalloc((void**)& referrence_cuda, sizeof(int)*size);
+	cudaMalloc((void**)& matrix_cuda, sizeof(int)*size);
+	
+	cudaMemcpy(referrence_cuda, referrence, sizeof(int) * size, cudaMemcpyHostToDevice);
+	cudaMemcpy(matrix_cuda, input_itemsets, sizeof(int) * size, cudaMemcpyHostToDevice);
+
+    dim3 dimGrid;
+	dim3 dimBlock(BLOCK_SIZE, 1);
+	int block_width = ( max_cols - 1 )/BLOCK_SIZE;
+
+#ifdef  TIMING
+  gettimeofday(&tv_kernel_start, NULL);
+#endif
+
+	printf("Processing top-left matrix\n");
+	//process top-left matrix
+	for( int i = 1 ; i <= block_width ; i++){
+		dimGrid.x = i;
+		dimGrid.y = 1;
+		needle_cuda_shared_1<<<dimGrid, dimBlock>>>(referrence_cuda, matrix_cuda
+		                                      ,max_cols, penalty, i, block_width); 
+	}
+	printf("Processing bottom-right matrix\n");
+    //process bottom-right matrix
+	for( int i = block_width - 1  ; i >= 1 ; i--){
+		dimGrid.x = i;
+		dimGrid.y = 1;
+		needle_cuda_shared_2<<<dimGrid, dimBlock>>>(referrence_cuda, matrix_cuda
+		                                      ,max_cols, penalty, i, block_width); 
+	}
+
+#ifdef  TIMING
+    gettimeofday(&tv_kernel_end, NULL);
+    tvsub(&tv_kernel_end, &tv_kernel_start, &tv);
+    kernel_time += tv.tv_sec * 1000.0 + (float) tv.tv_usec / 1000.0;
+#endif
+
+    cudaMemcpy(output_itemsets, matrix_cuda, sizeof(int) * size, cudaMemcpyDeviceToHost);
+	
+//#define TRACEBACK
+#ifdef TRACEBACK
+	
+	FILE *fpo = fopen("result.txt","w");
+	fprintf(fpo, "print traceback value GPU:\n");
+    
+	for (int i = max_rows - 2,  j = max_rows - 2; i>=0, j>=0;){
+		int nw, n, w, traceback;
+		if ( i == max_rows - 2 && j == max_rows - 2 )
+			fprintf(fpo, "%d ", output_itemsets[ i * max_cols + j]); //print the first element
+		if ( i == 0 && j == 0 )
+           break;
+		if ( i > 0 && j > 0 ){
+			nw = output_itemsets[(i - 1) * max_cols + j - 1];
+		    w  = output_itemsets[ i * max_cols + j - 1 ];
+            n  = output_itemsets[(i - 1) * max_cols + j];
+		}
+		else if ( i == 0 ){
+		    nw = n = LIMIT;
+		    w  = output_itemsets[ i * max_cols + j - 1 ];
+		}
+		else if ( j == 0 ){
+		    nw = w = LIMIT;
+            n  = output_itemsets[(i - 1) * max_cols + j];
+		}
+		else{
+		}
+
+		//traceback = maximum(nw, w, n);
+		int new_nw, new_w, new_n;
+		new_nw = nw + referrence[i * max_cols + j];
+		new_w = w - penalty;
+		new_n = n - penalty;
+		
+		traceback = maximum(new_nw, new_w, new_n);
+		if(traceback == new_nw)
+			traceback = nw;
+		if(traceback == new_w)
+			traceback = w;
+		if(traceback == new_n)
+            traceback = n;
+			
+		fprintf(fpo, "%d ", traceback);
+
+		if(traceback == nw )
+		{i--; j--; continue;}
+
+        else if(traceback == w )
+		{j--; continue;}
+
+        else if(traceback == n )
+		{i--; continue;}
+
+		else
+		;
+	}
+	
+	fclose(fpo);
+
+#endif
+
+	cudaFree(referrence_cuda);
+	cudaFree(matrix_cuda);
+
+	free(referrence);
+	free(input_itemsets);
+	free(output_itemsets);
+
+#ifdef  TIMING
+    printf("Exec: %f\n", kernel_time);
+#endif
+}
+
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/nw/README gpu-rodinia_new/cuda/nw/README
--- gpu-rodinia/cuda/nw/README	2015-12-11 08:46:09.000000000 -0700
+++ gpu-rodinia_new/cuda/nw/README	2023-06-06 14:22:22.808702934 -0600
@@ -1,8 +1,7 @@
 Note: This program generate two sequences randomly. Please specify your own sequences for different uses.
       At the current stage, the program only supports two sequences with the same lengh, which can be divided by 16. 
-Usage: needle 32 32 10  
-	  32 //the length of the 1st sequence
-	  32 //the length of the 2nd sequence
+Usage: needle 32 10 
+	  32 //the length of both sequences
 	  10 //penalty value
 
 ******Adjustable work group size*****
@@ -10,4 +9,4 @@
 
 USAGE:
 make clean
-make KERNEL_DIM="-DRD_WG_SIZE_0=16"
\ No newline at end of file
+make KERNEL_DIM="-DRD_WG_SIZE_0=16"
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/srad/run gpu-rodinia_new/cuda/srad/run
--- gpu-rodinia/cuda/srad/run	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/srad/run	2023-06-06 14:22:22.812702858 -0600
@@ -0,0 +1,3 @@
+cd srad_v1; ./srad 100 0.5 502 458
+cd -
+cd srad_v2;./srad 2048 2048 0 127 0 127 0.5 2
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/srad/srad_v1/makefile gpu-rodinia_new/cuda/srad/srad_v1/makefile
--- gpu-rodinia/cuda/srad/srad_v1/makefile	2015-12-11 08:46:15.000000000 -0700
+++ gpu-rodinia_new/cuda/srad/srad_v1/makefile	1969-12-31 17:00:00.000000000 -0700
@@ -1,38 +0,0 @@
-include ../../../common/make.config
-
-CC := $(CUDA_DIR)/bin/nvcc
-
-INCLUDE := $(CUDA_DIR)/include
-
-# Example
-# target: dependencies
-	# command 1
-	# command 2
-          # .
-          # .
-          # .
-	# command n
-
-# link objects(binaries) together
-a.out:		main.o
-	$(CC)	main.o \
-				-I$(INCLUDE) \
-				-L$(CUDA_LIB_DIR)  \
-				-lm -lcuda -lcudart -o srad
-
-# compile main function file into object (binary)
-main.o: 	main.cu \
-				define.c \
-				graphics.c \
-				extract_kernel.cu \
-				prepare_kernel.cu \
-				reduce_kernel.cu \
-				srad_kernel.cu \
-				srad2_kernel.cu \
-				compress_kernel.cu
-	nvcc	main.cu \
-				-c -O3 -arch sm_35
-
-# delete all object files
-clean:
-	rm *.o srad
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/srad/srad_v1/Makefile gpu-rodinia_new/cuda/srad/srad_v1/Makefile
--- gpu-rodinia/cuda/srad/srad_v1/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/srad/srad_v1/Makefile	2023-06-06 15:51:02.655762288 -0600
@@ -0,0 +1,41 @@
+include ../../../common/make.config
+
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
+
+INCLUDE := $(CUDA_DIR)/include
+
+# Example
+# target: dependencies
+	# command 1
+	# command 2
+          # .
+          # .
+          # .
+	# command n
+
+# link objects(binaries) together
+a.out:		main.o
+	$(CC)	main.o \
+				-I$(INCLUDE) \
+				-L$(CUDA_LIB_DIR)  \
+				-lm -lcuda -lcudart -o srad
+
+# compile main function file into object (binary)
+main.o: 	main.cu \
+				define.c \
+				graphics.c \
+				extract_kernel.cu \
+				prepare_kernel.cu \
+				reduce_kernel.cu \
+				srad_kernel.cu \
+				srad2_kernel.cu \
+				compress_kernel.cu
+	$(CC)	main.cu \
+				-c -O3
+#	nvcc	main.cu \
+				-c -O3 -arch sm_35
+
+
+# delete all object files
+clean:
+	rm -f *.o srad
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/srad/srad_v2/Makefile gpu-rodinia_new/cuda/srad/srad_v2/Makefile
--- gpu-rodinia/cuda/srad/srad_v2/Makefile	2015-12-11 08:46:16.000000000 -0700
+++ gpu-rodinia_new/cuda/srad/srad_v2/Makefile	2023-06-06 14:22:22.812702858 -0600
@@ -1,6 +1,6 @@
 include ../../../common/make.config
 
-CC := $(CUDA_DIR)/bin/nvcc
+CC := $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 
 INCLUDE := $(CUDA_DIR)/include
 
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/streamcluster/Makefile gpu-rodinia_new/cuda/streamcluster/Makefile
--- gpu-rodinia/cuda/streamcluster/Makefile	2015-12-11 08:46:09.000000000 -0700
+++ gpu-rodinia_new/cuda/streamcluster/Makefile	2023-06-06 14:22:22.812702858 -0600
@@ -1,6 +1,6 @@
 include ../../common/make.config
 
-NVCC = $(CUDA_DIR)/bin/nvcc
+NVCC = $(CUDA_DIR)/bin/nvcc $(CUDA_FLAG)
 
 NVCC_FLAGS = -I$(CUDA_DIR)/include
 
@@ -20,9 +20,9 @@
 endif
 
 # make dp=1 compiles the CUDA kernels with double-precision support
-ifeq ($(dp),1)
-	NVCC_FLAGS += --gpu-name sm_13
-endif
+#ifeq ($(dp),1)
+#	NVCC_FLAGS += --gpu-name sm_13
+#endif
 
 
 $(TARGET_G): streamcluster_cuda_cpu.cpp streamcluster_cuda.cu streamcluster_header.cu
diff -ruN '--exclude=*.txt' '--exclude=*.out' '--exclude=*.pgm' '--exclude=*cleanref*' gpu-rodinia/cuda/util/timing.h gpu-rodinia_new/cuda/util/timing.h
--- gpu-rodinia/cuda/util/timing.h	1969-12-31 17:00:00.000000000 -0700
+++ gpu-rodinia_new/cuda/util/timing.h	2023-06-06 14:22:22.816702781 -0600
@@ -0,0 +1,22 @@
+#ifndef __TIMING_H__
+#define __TIMING_H__
+
+#include <sys/time.h>
+
+void time_measure_start(struct timeval *tv);
+void time_measure_end(struct timeval *tv);
+
+/* tvsub: ret = x - y. */
+static inline void tvsub(struct timeval *x,
+						 struct timeval *y,
+						 struct timeval *ret)
+{
+	ret->tv_sec = x->tv_sec - y->tv_sec;
+	ret->tv_usec = x->tv_usec - y->tv_usec;
+	if (ret->tv_usec < 0) {
+		ret->tv_sec--;
+		ret->tv_usec += 1000000;
+	}
+}
+
+#endif
