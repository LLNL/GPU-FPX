--- ./record_reg_vals/inject_funcs.cu	2024-12-12 14:29:26.000000000 -0700
+++ ./GPU-FPX/detector/inject_funcs.cu	2024-12-17 12:35:08.979056207 -0700
@@ -1,37 +1,38 @@
-/*
- * SPDX-FileCopyrightText: Copyright (c) 2019 NVIDIA CORPORATION & AFFILIATES.
- * All rights reserved.
- * SPDX-License-Identifier: BSD-3-Clause
+/* Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  * Neither the name of NVIDIA CORPORATION nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
  *
- * 1. Redistributions of source code must retain the above copyright notice, this
- * list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#define __STDC_FORMAT_MACROS 1
+#include <inttypes.h>
+
 #include <stdint.h>
 #include <stdio.h>
 #include <cstdarg>
+#include "nvbit_reg_rw.h"
+
 
 #include "utils/utils.h"
 
@@ -39,11 +40,262 @@
 #include "utils/channel.hpp"
 
 /* contains definition of the mem_access_t structure */
-#include "common.h"
+#include "../utility/common.h"
+
+__device__
+static 
+__forceinline__ 
+uint32_t _FPC_FP32_IS_INF(uint32_t reg_val) {
+    uint32_t exponent, mantissa; 
+    exponent = reg_val << 1;
+    exponent = exponent >> 24; 
+    mantissa = reg_val << 9; 
+    mantissa = mantissa >> 9;
+    if(exponent == (uint32_t)(255) && mantissa == (uint32_t)(0)){
+        return E_INF;
+    }
+    return 0; 
+}
+
+__device__
+static 
+__forceinline__ 
+uint32_t _FPC_FP32_IS_NAN(uint32_t reg_val) {
+    uint32_t exponent, mantissa; 
+    exponent = reg_val << 1;
+    exponent = exponent >> 24; 
+    mantissa = reg_val << 9; 
+    mantissa = mantissa >> 9;
+    if(exponent == (uint32_t)(255) && mantissa != (uint32_t)(0)){
+        return E_NAN;
+    }
+    return 0; 
+}
+
+__device__
+static 
+__forceinline__ 
+uint32_t _FPC_FP32_IS_SUBNORMAL(uint32_t reg_val) {
+    uint32_t exponent, mantissa; 
+    exponent = reg_val << 1;
+    exponent = exponent >> 24; 
+    mantissa = reg_val << 9; 
+    mantissa = mantissa >> 9;
+    if(exponent == (uint32_t)(0) && mantissa != (uint32_t)(0)){
+        return E_SUB;
+    }
+    return 0; 
+}
+
+__device__
+static 
+__forceinline__ 
+uint32_t _FPC_FP32_IS_0(uint32_t reg_val) {
+    if(_FPC_FP32_IS_INF(reg_val)!=0||_FPC_FP32_IS_NAN(reg_val)!=0){
+        return E_DIV0;
+    }
+    return 0;
+
+}
+
+__device__
+static 
+__forceinline__ 
+uint32_t _FPC_FP64_IS_NAN(uint64_t reg_val) {
+    uint64_t exponent, mantissa; 
+    exponent = reg_val << 1;
+    exponent = exponent >> 53; 
+    mantissa = reg_val << 12; 
+    mantissa = mantissa >> 12;
+    if(exponent == (uint64_t)(2047) && mantissa != (uint64_t)(0)){
+        return E_NAN;
+    }
+    return 0; 
+}
+
+
+__device__
+static 
+__forceinline__ 
+uint32_t _FPC_FP64_IS_INF(uint64_t reg_val) {
+    uint64_t exponent, mantissa; 
+    exponent = reg_val << 1;
+    exponent = exponent >> 53; 
+    mantissa = reg_val << 12; 
+    mantissa = mantissa >> 12;
+    if(exponent == (uint64_t)(2047) && mantissa == (uint64_t)(0)){
+        return E_INF;
+    }
+    return 0; 
+}
+
+__device__
+static 
+__forceinline__ 
+uint32_t _FPC_FP64_IS_SUBNORMAL(uint64_t reg_val) {
+    uint64_t exponent, mantissa; 
+    exponent = reg_val << 1;
+    exponent = exponent >> 53; 
+    mantissa = reg_val << 12; 
+    mantissa = mantissa >> 12;
+    if(exponent == (uint64_t)(0) && mantissa != (uint64_t)(0)){
+        return E_SUB;
+    }
+    return 0; 
+}
+
+__device__
+static 
+__forceinline__ 
+uint32_t _FPC_FP64_IS_0(uint64_t reg_val) {
+    if(_FPC_FP64_IS_INF(reg_val)!=0||_FPC_FP64_IS_NAN(reg_val)!=0){
+        return E_DIV0;
+    }
+    return 0;
+
+}
+
+__device__
+static
+__forceinline__
+uint32_t encode_index(uint32_t mem_index, uint32_t exec) {
+    exec = exec -1;
+    uint32_t final_index = mem_index | exec; 
+    return final_index;
+}
+
+// __device__
+// static
+// __forceinline__
+// void send_info(int active_mask, int exec, uint32_t mem_index, const int laneid, const int first_laneid, reg_info_t &ri){
+        
+//     warp_info_t wi;
+        
+//     for (int tid = 0; tid < 32; tid++) {
+//         //TODO: only shfl to tid=0
+//             wi.exce_type[tid] = __shfl_sync(active_mask, exce, tid);
+//             wi.mem_index_ar[tid] = __shfl_sync(active_mask, mem_index, tid);
+//             //printf("exce[i] is %d\n",ri.exce_type[tid]);
+//     }
+
+//     /* first active lane pushes information on the channel */
+//     if (first_laneid == laneid) {
+//         for(int i =0; i< 32; i++){
+//             if(wi.exce_type[i]>0){
+//                 uint32_t e = wi.exce_type[i] -1;
+//                 uint32_t final_index = mem_index | e; 
+//                 return final_index;
+//                 uint32_t table_index = encode_index(wi.mem_index_ar[i], wi.exce_type[i]);
+//                 //uint32_t index_info = device_table[table_index];
+//                 //printf("table index is %u\n", table_index);
+//                 uint32_t index_info = atomicAdd((unsigned int*)&device_table[table_index], 1);
+//                 if(index_info == 0) {
+//                     //atomicAdd((unsigned int*)&device_table[table_index], 1);
+//                     ri.warp_exec_info[i] = table_index;
+//                     ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+//                     channel_dev->push(&ri, sizeof(reg_info_t));
+//                 }   
+//                 // ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+//                 // channel_dev->push(&ri, sizeof(reg_info_t));
+//                 // break;
+//             }
+//         }
+//     }
+// }
+
+extern "C" __device__ __noinline__ void record_reg_val_32_stand(int pred, int opcode_id,int kernel_id,
+                                                    //uint64_t location,
+                                                    //int loc_id,
+                                                    //ushort k_loc_id,
+                                                    //int32_t inst_type,
+                                                    uint64_t pdevice_table,
+                                                    uint32_t mem_index,
+                                                    uint64_t pchannel_dev,
+                                                    uint32_t low_add, 
+                                                    uint32_t high_add
+                                                    ) {
+    
+    if (!pred) {
+        return;
+    }
+
+    int active_mask = __ballot_sync(__activemask(), 1);
+    const int laneid = get_laneid();
+    const int first_laneid = __ffs(active_mask) - 1;
+
+    reg_info_t ri;
+
+    int4 cta = get_ctaid();
+    ri.cta_id_x = cta.x;
+    ri.cta_id_y = cta.y;
+    ri.cta_id_z = cta.z;
+    ri.warp_id = get_warpid();
+    //ri.location = (char*)location;
+    ri.opcode_id = opcode_id;
+    ri.kernel_id = kernel_id;
+    //ri.loc_id = loc_id;
+    //ri.inst_type = inst_type;
+    ri.mem_index = mem_index;
+    uint32_t val_low = low_add;
+    uint32_t val_hi = high_add;
+    // uint32_t *device_table = (uint32_t *)pdevice_table;
+    uint32_t exce = 0;
+
+
+    
+    // for(int tid =0; tid<32; tid++){
+    //     ri.reg_vals[tid][0] = __shfl_sync(active_mask, val_low, tid);
+    //     ri.reg_vals[tid][1] = __shfl_sync(active_mask, val_hi, tid);
+    // }
+
+
+    exce = _FPC_FP32_IS_NAN(val_low);
+    exce = exce+_FPC_FP32_IS_INF(val_low);
+    exce = exce+_FPC_FP32_IS_SUBNORMAL(val_low);
+        //printf("exce is %d\n",exce);
+    for (int tid = 0; tid < 32; tid++) {
+        //TODO: only shfl to tid=0
+            ri.exce_type[tid] = __shfl_sync(active_mask, exce, tid);
+            ri.mem_index_ar[tid] = __shfl_sync(active_mask, mem_index, tid);
+            //printf("exce[i] is %d\n",ri.exce_type[tid]);
+    }
+
+    /* first active lane pushes information on the channel */
+    if (first_laneid == laneid) {
+        for(int i =0; i< 32; i++){
+            if(ri.exce_type[i]>0){
+                uint32_t table_index = encode_index(ri.mem_index_ar[i], ri.exce_type[i]);
+                //uint32_t index_info = device_table[table_index];
+                //printf("table index is %u\n", table_index);
+                uint32_t *device_table = (uint32_t *)pdevice_table;
+                uint32_t index_info = atomicAdd((unsigned int*)&device_table[table_index], 1);
+                if(index_info == 0) {
+                   // atomicAdd((unsigned int*)&device_table[table_index], 1);
+                    ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+                    channel_dev->push(&ri, sizeof(reg_info_t));
+                    break;
+                }   
+                // ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+                // channel_dev->push(&ri, sizeof(reg_info_t));
+                // break;
+            }
+        }
+    }
+}
 
-extern "C" __device__ __noinline__ void record_reg_val(int pred, int opcode_id,
-                                                       uint64_t pchannel_dev,
-                                                       int32_t num_regs...) {
+                                
+extern "C" __device__ __noinline__ void record_reg_val_32_div0(int pred, int opcode_id,int kernel_id,
+                                                    //uint64_t location,
+                                                    //int loc_id,
+                                                    //ushort k_loc_id,
+                                                    //int32_t inst_type,
+                                                    uint64_t pdevice_table,
+                                                    uint32_t mem_index,
+                                                    uint64_t pchannel_dev,
+                                                    uint32_t low_add, 
+                                                    uint32_t high_add
+                                                    ) {
+    
     if (!pred) {
         return;
     }
@@ -60,26 +312,202 @@
     ri.cta_id_z = cta.z;
     ri.warp_id = get_warpid();
     ri.opcode_id = opcode_id;
-    ri.num_regs = num_regs;
+    ri.kernel_id = kernel_id;
+    //ri.loc_id = loc_id;
+    //ri.inst_type = inst_type;
+    ri.mem_index = mem_index;
+    uint32_t val_low = low_add;
+    uint32_t val_hi = high_add;
+    uint32_t exce = 0;
+    // uint32_t *device_table = (uint32_t *)pdevice_table;
+
+
+    
+    // for(int tid =0; tid<32; tid++){
+    //     ri.reg_vals[tid][0] = __shfl_sync(active_mask, val_low, tid);
+    //     ri.reg_vals[tid][1] = __shfl_sync(active_mask, val_hi, tid);
+    // }
+
+    exce = _FPC_FP32_IS_0(val_low);
+    //printf("val_low = %f\n",(float *)val_hi);
+    for (int tid = 0; tid < 32; tid++) {
+            ri.exce_type[tid] = __shfl_sync(active_mask, exce, tid);
+            ri.mem_index_ar[tid] = __shfl_sync(active_mask, mem_index, tid);
 
-    if (num_regs) {
-        va_list vl;
-        va_start(vl, num_regs);
-
-        for (int i = 0; i < num_regs; i++) {
-            uint32_t val = va_arg(vl, uint32_t);
-
-            /* collect register values from other threads */
-            for (int tid = 0; tid < 32; tid++) {
-                ri.reg_vals[tid][i] = __shfl_sync(active_mask, val, tid);
+    }
+    /* first active lane pushes information on the channel */
+    if (first_laneid == laneid) {
+        //only transfer if there's an excpeionts
+        // int sum = 0;
+        //printf("Checking opcode_id = %d\n",opcode_id);
+        for(int i =0; i< 32; i++){
+            if(ri.exce_type[i]>0){
+                uint32_t table_index = encode_index(ri.mem_index_ar[i], ri.exce_type[i]);
+                //uint32_t index_info = device_table[table_index];
+                uint32_t *device_table = (uint32_t *)pdevice_table;
+                uint32_t index_info = atomicAdd((unsigned int*)&device_table[table_index], 1);
+                if(index_info == 0) {
+                   // atomicAdd((unsigned int*)&device_table[table_index], 1);
+                    ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+                    channel_dev->push(&ri, sizeof(reg_info_t));
+                    break;                    
+                }   
+                // ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+                // channel_dev->push(&ri, sizeof(reg_info_t));
+                // break;
             }
         }
-        va_end(vl);
     }
+}
+
+extern "C" __device__ __noinline__ void record_reg_val_64_stand(int pred, int opcode_id,int kernel_id,
+                                                    //uint64_t location,
+                                                    //int loc_id,
+                                                    //ushort k_loc_id,
+                                                    //int32_t inst_type,
+                                                    uint64_t pdevice_table,
+                                                    uint32_t mem_index,
+                                                    uint64_t pchannel_dev,
+                                                    uint32_t low_add, 
+                                                    uint32_t high_add
+                                                    ) {
+    
+    if (!pred) {
+        return;
+    }
+
+    int active_mask = __ballot_sync(__activemask(), 1);
+    const int laneid = get_laneid();
+    const int first_laneid = __ffs(active_mask) - 1;
+
+    reg_info_t ri;
+
+    int4 cta = get_ctaid();
+    ri.cta_id_x = cta.x;
+    ri.cta_id_y = cta.y;
+    ri.cta_id_z = cta.z;
+    ri.warp_id = get_warpid();
+
+    //ri.location = (char*)location;
+    ri.opcode_id = opcode_id;
+    ri.kernel_id = kernel_id;
+    //ri.loc_id = loc_id;
+    //ri.inst_type = inst_type;
+    ri.mem_index = mem_index;
+    uint32_t val_low = low_add;
+    uint32_t val_hi = high_add;
+    uint32_t exce = 0;
+    // uint32_t *device_table = (uint32_t *)pdevice_table;
+
+
+
+    
+    // for(int tid =0; tid<32; tid++){
+    //     ri.reg_vals[tid][0] = __shfl_sync(active_mask, val_low, tid);
+    //     ri.reg_vals[tid][1] = __shfl_sync(active_mask, val_hi, tid);
+    // }
+  
+    uint64_t fp64_val = (uint64_t) val_hi << 32 | val_low;
+
+    exce = _FPC_FP64_IS_NAN(fp64_val);
+    exce = exce+_FPC_FP64_IS_INF(fp64_val);
+    exce = exce+_FPC_FP64_IS_SUBNORMAL(fp64_val);
+    for (int tid = 0; tid < 32; tid++) {
+            ri.exce_type[tid] = __shfl_sync(active_mask, exce, tid);
+            ri.mem_index_ar[tid] = __shfl_sync(active_mask, mem_index, tid);
+    }
+
 
     /* first active lane pushes information on the channel */
     if (first_laneid == laneid) {
-        ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
-        channel_dev->push(&ri, sizeof(reg_info_t));
+        for(int i =0; i< 32; i++){
+            if(ri.exce_type[i]>0){
+                uint32_t table_index = encode_index(ri.mem_index_ar[i], ri.exce_type[i]);
+                //atomicAdd((unsigned int*)&device_table[table_index], 1);
+                //uint32_t index_info = device_table[table_index]; 
+                uint32_t *device_table = (uint32_t *)pdevice_table;
+                uint32_t index_info = atomicAdd((unsigned int*)&device_table[table_index], 1);
+                if(index_info == 0) {
+                   // atomicAdd((unsigned int*)&device_table[table_index], 1);
+                    ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+                    channel_dev->push(&ri, sizeof(reg_info_t));
+                    break; 
+                }   
+                //printf("index info is %u\n", index_info);            
+                
+                //break;
+            }
+        }
+    }
+}
+
+extern "C" __device__ __noinline__ void record_reg_val_64_div0(int pred, int opcode_id,int kernel_id,
+                                                    //uint64_t location,
+                                                    //int loc_id,
+                                                    //ushort k_loc_id,
+                                                    //int32_t inst_type,
+                                                    uint64_t pdevice_table,
+                                                    uint32_t mem_index,
+                                                    uint64_t pchannel_dev,
+                                                    uint32_t low_add, 
+                                                    uint32_t high_add
+                                                    ) {
+    
+    if (!pred) {
+        return;
+    }
+
+    int active_mask = __ballot_sync(__activemask(), 1);
+    const int laneid = get_laneid();
+    const int first_laneid = __ffs(active_mask) - 1;
+
+    reg_info_t ri;
+
+    int4 cta = get_ctaid();
+    ri.cta_id_x = cta.x;
+    ri.cta_id_y = cta.y;
+    ri.cta_id_z = cta.z;
+    ri.warp_id = get_warpid();
+    ri.opcode_id = opcode_id;
+    ri.kernel_id = kernel_id;
+    //ri.loc_id = loc_id;
+    //ri.location = (char*)location;
+    //ri.inst_type = inst_type;
+    ri.mem_index = mem_index;
+    uint32_t val_low = low_add;
+    uint32_t val_hi = high_add;
+    uint32_t exce = 0;
+    // uint32_t *device_table = (uint32_t *)pdevice_table;
+
+
+    // for(int tid =0; tid<32; tid++){
+    //     ri.reg_vals[tid][0] = __shfl_sync(active_mask, val_low, tid);
+    //     ri.reg_vals[tid][1] = __shfl_sync(active_mask, val_hi, tid);
+    // }
+    uint64_t fp64_val = (uint64_t) val_hi << 32 | val_low;
+    exce = _FPC_FP64_IS_0(fp64_val);
+    for (int tid = 0; tid < 32; tid++) {
+        ri.exce_type[tid] = __shfl_sync(active_mask, exce, tid);
+        ri.mem_index_ar[tid] = __shfl_sync(active_mask, mem_index, tid);
+    }
+    if (first_laneid == laneid) {
+        for(int i =0; i< 32; i++){
+            if(ri.exce_type[i]>0){
+                uint32_t table_index = encode_index(ri.mem_index_ar[i], ri.exce_type[i]);
+                //uint32_t index_info = device_table[table_index];
+                uint32_t *device_table = (uint32_t *)pdevice_table;
+                uint32_t index_info = atomicAdd((unsigned int*)&device_table[table_index], 1);
+                if(index_info == 0) {  
+//		    atomicAdd((unsigned int*)&device_table[table_index], 1);
+                    ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+                    channel_dev->push(&ri, sizeof(reg_info_t));
+                    break; 
+                }   
+                // ChannelDev *channel_dev = (ChannelDev *)pchannel_dev;
+                // channel_dev->push(&ri, sizeof(reg_info_t));
+                // break;
+            }
+        }
     }
 }
+
